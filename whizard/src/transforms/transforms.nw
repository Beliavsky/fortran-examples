% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*-
% WHIZARD event transforms and event API
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Event Implementation}
\includemodulegraph{transforms}

With a process object and the associated methods at hand, we can
generate events for elementary processes and, by subsequent
transformation, for complete physical processes.

We have the following modules:
\begin{description}
\item[event\_transforms]
  Abstract base type for transforming a physical process with process
  instance and included evaluators, etc., into a new
  object.  The following modules extend this base type.
\item[resonance\_insertion]
  Insert a resonance history into an event record, based on
  kinematical and matrix-element information.
\item[recoil\_kinematics]
  Common kinematics routines for the ISR and EPA handlers.
\item[isr\_photon\_handler]
  Transform collinear kinematics, as it results from applying ISR
  radiation, to non-collinear kinematics with a reasonable
  transverse-momentum distribution of the radiated photons, and also
  of the recoiling partonic event.
\item[epa\_beam\_handler]
  For photon-initiated processes where the effective photon
  approximation is used in integration, to add in beam-particle
  recoil.  Analogous to the ISR handler.
\item[decays]
  Combine the elementary process with elementary decay processes and
  thus transform the elementary event into a decayed event, still at
  the parton level.
\item[showers]
  Create QED/QCD showers out of the partons that are emitted by
  elementary processes.  This should be interleaved with showering of
  radiated particles (structure functions) and multiple interactions.
\item[hadrons]
  (not implemented yet) Apply hadronization to the partonic events,
  interleaved with hadron decays.  (The current setup relies on
  hadronizing partonic events externally.)
\item[tau\_decays]
  (not implemented yet) Let $\tau$ leptons decay taking full spin
  correlations into account.
\item[evt\_nlo]
  Handler for fixed-order NLO events.
\item[events]
  Combine all pieces to generate full events.
\item[eio\_raw]
  Raw I/O for complete events.
\end{description}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Event Transforms}
<<[[event_transforms.f90]]>>=
<<File header>>

module event_transforms

<<Use kinds>>
<<Use strings>>
  use quantum_numbers, only: quantum_numbers_t
  use interactions
  use particles
  use model_data
  use rng_base
  use process, only: process_t
  use instances, only: process_instance_t
  use process_stacks

<<Standard module head>>

<<Event transforms: public>>

<<Event transforms: types>>

<<Event transforms: interfaces>>

  interface
<<Event transforms: sub interfaces>>
  end interface

end module event_transforms

@ %def event_transforms
@
<<[[event_transforms_sub.f90]]>>=
<<File header>>

submodule (event_transforms) event_transforms_s

  use io_units
  use format_utils, only: write_separator
  use diagnostics
  use subevents

  implicit none

contains

<<Event transforms: procedures>>

end submodule event_transforms_s

@ %def event_transforms_s
@
\subsection{Abstract base type}
Essentially, all methods are abstract, but some get minimal base
versions.  We know that there will be a random-number generator at top
level, and that we will relate to an elementary process.

The model is stored separately.  It may contain modified settings that differ
from the model instance stored in the process object.

Each event transform contains a particle set that it can fill for
further use.  There is a flag that indicates this.

We will collect event transforms in a list, therefore we include
[[previous]] and [[next]] pointers.
<<Event transforms: public>>=
  public :: evt_t
<<Event transforms: types>>=
  type, abstract :: evt_t
     type(process_t), pointer :: process => null ()
     type(process_instance_t), pointer :: process_instance => null ()
     class(model_data_t), pointer :: model => null ()
     class(rng_t), allocatable :: rng
     integer :: rejection_count = 0
     logical :: particle_set_exists = .false.
     type(particle_set_t) :: particle_set
     class(evt_t), pointer :: previous => null ()
     class(evt_t), pointer :: next => null ()
     logical :: only_weighted_events = .false.
   contains
   <<Event transforms: evt: TBP>>
  end type evt_t

@ %def evt_t
@ Finalizer.  In any case, we finalize the r.n.g.  The process
instance is a pointer and should not be finalized here.
<<Event transforms: evt: TBP>>=
  procedure :: final => evt_final
  procedure :: base_final => evt_final
<<Event transforms: sub interfaces>>=
    module subroutine evt_final (evt)
      class(evt_t), intent(inout) :: evt
    end subroutine evt_final
<<Event transforms: procedures>>=
  module subroutine evt_final (evt)
    class(evt_t), intent(inout) :: evt
    if (allocated (evt%rng))  call evt%rng%final ()
    if (evt%particle_set_exists) &
         call evt%particle_set%final ()
  end subroutine evt_final

@ %def evt_final
@ Print out the type of the [[evt]].
<<Event transforms: evt: TBP>>=
  procedure (evt_write_name), deferred :: write_name
<<Event transforms: interfaces>>=
  abstract interface
     subroutine evt_write_name (evt, unit)
       import
       class(evt_t), intent(in) :: evt
       integer, intent(in), optional :: unit
     end subroutine evt_write_name
  end interface

@ %def evt_write_name
@
<<Event transforms: evt: TBP>>=
  procedure (evt_write), deferred :: write
<<Event transforms: interfaces>>=
  abstract interface
     subroutine evt_write (evt, unit, verbose, more_verbose, testflag)
       import
       class(evt_t), intent(in) :: evt
       integer, intent(in), optional :: unit
       logical, intent(in), optional :: verbose, more_verbose, testflag
     end subroutine evt_write
  end interface

@ %def evt_write
@ Output.  We can print r.n.g. info.
<<Event transforms: evt: TBP>>=
  procedure :: base_write => evt_base_write
<<Event transforms: sub interfaces>>=
    module subroutine evt_base_write (evt, unit, testflag, show_set)
      class(evt_t), intent(in) :: evt
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: testflag, show_set
    end subroutine evt_base_write
<<Event transforms: procedures>>=
  module subroutine evt_base_write (evt, unit, testflag, show_set)
    class(evt_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag, show_set
    integer :: u
    logical :: show
    u = given_output_unit (unit)
    show = .true.;  if (present (show_set))  show = show_set
    if (associated (evt%process)) then
       write (u, "(3x,A,A,A)")   "Associated process: '", &
            char (evt%process%get_id ()), "'"
    end if
    if (allocated (evt%rng)) then
       call evt%rng%write (u, 1)
       write (u, "(3x,A,I0)")  "Number of tries = ", evt%rejection_count
    end if
    if (show) then
       if (evt%particle_set_exists) then
          call write_separator (u)
          call evt%particle_set%write (u, testflag = testflag)
       end if
    end if
  end subroutine evt_base_write

@ %def evt_base_write
@ Connect the transform with a process instance (and thus with the
associated process).  Use this to allocate the master random-number
generator.

This is not an initializer; we may initialize the transform by
implementation-specific methods.
<<Event transforms: evt: TBP>>=
  procedure :: connect => evt_connect
  procedure :: base_connect => evt_connect
<<Event transforms: sub interfaces>>=
    module subroutine evt_connect (evt, process_instance, model, process_stack)
      class(evt_t), intent(inout), target :: evt
      type(process_instance_t), intent(in), target :: process_instance
      class(model_data_t), intent(in), target :: model
      type(process_stack_t), intent(in), optional :: process_stack
    end subroutine evt_connect
<<Event transforms: procedures>>=
  module subroutine evt_connect (evt, process_instance, model, process_stack)
    class(evt_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    evt%process => process_instance%process
    evt%process_instance => process_instance
    evt%model => model
    call evt%process%make_rng (evt%rng)
  end subroutine evt_connect

@ %def evt_connect
@ Reset internal state.
<<Event transforms: evt: TBP>>=
  procedure :: reset => evt_reset
  procedure :: base_reset => evt_reset
<<Event transforms: sub interfaces>>=
    module subroutine evt_reset (evt)
      class(evt_t), intent(inout) :: evt
    end subroutine evt_reset
<<Event transforms: procedures>>=
  module subroutine evt_reset (evt)
    class(evt_t), intent(inout) :: evt
    evt%rejection_count = 0
    call evt%particle_set%final ()
    evt%particle_set_exists = .false.
  end subroutine evt_reset

@ %def evt_reset
@ Prepare for a new event: reset internal state, if necessary.  We
provide MCI and term index of the parent process.
<<Event transforms: evt: TBP>>=
  procedure (evt_prepare_new_event), deferred :: prepare_new_event
<<Event transforms: interfaces>>=
  interface
     subroutine evt_prepare_new_event (evt, i_mci, i_term)
       import
       class(evt_t), intent(inout) :: evt
       integer, intent(in) :: i_mci, i_term
     end subroutine evt_prepare_new_event
  end interface

@ %def evt_prepare_new_event
@ Generate a weighted event, using a valid initiator event in the
process instance, and the random-number generator.  The returned event
probability should be a number between zero and one that we can use for
rejection.
<<Event transforms: evt: TBP>>=
  procedure (evt_generate_weighted), deferred :: generate_weighted
<<Event transforms: interfaces>>=
  abstract interface
     subroutine evt_generate_weighted (evt, probability)
       import
       class(evt_t), intent(inout) :: evt
       real(default), intent(inout) :: probability
     end subroutine evt_generate_weighted
  end interface

@ %def evt_generate_weighted
@ The unweighted event generation routine is actually implemented.  It
uses the random-number generator for simple rejection.  Of course, the
implementation may override this and implement a different way of
generating an unweighted event.
<<Event transforms: evt: TBP>>=
  procedure :: generate_unweighted => evt_generate_unweighted
  procedure :: base_generate_unweighted => evt_generate_unweighted
<<Event transforms: sub interfaces>>=
    module subroutine evt_generate_unweighted (evt)
      class(evt_t), intent(inout) :: evt
    end subroutine evt_generate_unweighted
<<Event transforms: procedures>>=
  module subroutine evt_generate_unweighted (evt)
    class(evt_t), intent(inout) :: evt
    real(default) :: p, x
    evt%rejection_count = 0
    REJECTION: do
       evt%rejection_count = evt%rejection_count + 1
       call evt%generate_weighted (p)
       if (signal_is_pending ())  return
       call evt%rng%generate (x)
       if (x < p)  exit REJECTION
    end do REJECTION
  end subroutine evt_generate_unweighted

@ %def evt_generate_unweighted
@ Make a particle set.  This should take the most recent evaluator (or
whatever stores the event), factorize the density matrix if necessary,
and store as a particle set.

If applicable, the factorization should make use of the
[[factorization_mode]] and [[keep_correlations]] settings.

The values [[r]], if set, should control the factorization in more
detail, e.g., bypassing the random-number generator.
<<Event transforms: evt: TBP>>=
  procedure (evt_make_particle_set), deferred :: make_particle_set
<<Event transforms: interfaces>>=
  interface
     subroutine evt_make_particle_set &
          (evt, factorization_mode, keep_correlations, r)
       import
       class(evt_t), intent(inout) :: evt
       integer, intent(in) :: factorization_mode
       logical, intent(in) :: keep_correlations
       real(default), dimension(:), intent(in), optional :: r
     end subroutine evt_make_particle_set
  end interface

@ %def evt_make_particle_set
@ Copy an existing particle set into the event record.  This bypasses
all methods to evaluate the internal state, but may be sufficient for
further processing.
<<Event transforms: evt: TBP>>=
  procedure :: set_particle_set => evt_set_particle_set
<<Event transforms: sub interfaces>>=
    module subroutine evt_set_particle_set (evt, particle_set, i_mci, i_term)
      class(evt_t), intent(inout) :: evt
      type(particle_set_t), intent(in) :: particle_set
      integer, intent(in) :: i_term, i_mci
    end subroutine evt_set_particle_set
<<Event transforms: procedures>>=
  module subroutine evt_set_particle_set (evt, particle_set, i_mci, i_term)
    class(evt_t), intent(inout) :: evt
    type(particle_set_t), intent(in) :: particle_set
    integer, intent(in) :: i_term, i_mci
    call evt%prepare_new_event (i_mci, i_term)
    evt%particle_set = particle_set
    evt%particle_set_exists = .true.
  end subroutine evt_set_particle_set

@ %def evt_set_particle_set
@ This procedure can help in the previous task, if the particles are
available in the form of an interaction object.
We need two interactions, one with color summed over, the [[int_matrix]],
and one with the probability distributed among flows, the [[int_flows]].

We use the two values from the random number generator saved in [[r]]
for factorizing the state.
For testing purposes, we can provide those numbers explicitly.

The optional [[qn_select]] allows to limit the number of quantum numbers to
choose from when factorizing. If only a single set of quantum numbers is given,
it effectively dictates the quantum numbers chosen for the event.
<<Event transforms: evt: TBP>>=
  procedure :: factorize_interactions => evt_factorize_interactions
<<Event transforms: sub interfaces>>=
    module subroutine evt_factorize_interactions &
         (evt, int_matrix, int_flows, factorization_mode, &
         keep_correlations, r, qn_select)
      class(evt_t), intent(inout) :: evt
      type(interaction_t), intent(in), target :: int_matrix, int_flows
      integer, intent(in) :: factorization_mode
      logical, intent(in) :: keep_correlations
      real(default), dimension(:), intent(in), optional :: r
      type(quantum_numbers_t), dimension(:), intent(in), optional :: qn_select
    end subroutine evt_factorize_interactions
<<Event transforms: procedures>>=
  module subroutine evt_factorize_interactions &
       (evt, int_matrix, int_flows, factorization_mode, &
       keep_correlations, r, qn_select)
    class(evt_t), intent(inout) :: evt
    type(interaction_t), intent(in), target :: int_matrix, int_flows
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    type(quantum_numbers_t), dimension(:), intent(in), optional :: qn_select
    real(default), dimension(2) :: x
    if (present (r)) then
       if (size (r) == 2) then
          x = r
       else
          call msg_bug ("event factorization: size of r array must be 2")
       end if
    else
       call evt%rng%generate (x)
    end if
    call evt%particle_set%init (evt%particle_set_exists, &
         int_matrix, int_flows, factorization_mode, x, &
         keep_correlations, keep_virtual=.true., qn_select = qn_select)
    evt%particle_set_exists = .true.
  end subroutine evt_factorize_interactions

@ %def evt_factorize_interactions
@
<<Event transforms: public>>=
  public :: make_factorized_particle_set
<<Event transforms: sub interfaces>>=
    module subroutine make_factorized_particle_set (evt, factorization_mode, &
           keep_correlations, r, ii_term, qn_select)
      class(evt_t), intent(inout) :: evt
      integer, intent(in) :: factorization_mode
      logical, intent(in) :: keep_correlations
      real(default), dimension(:), intent(in), optional :: r
      integer, intent(in), optional :: ii_term
      type(quantum_numbers_t), dimension(:), intent(in), optional :: qn_select
    end subroutine make_factorized_particle_set
<<Event transforms: procedures>>=
  module subroutine make_factorized_particle_set (evt, factorization_mode, &
         keep_correlations, r, ii_term, qn_select)
    class(evt_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    integer, intent(in), optional :: ii_term
    type(quantum_numbers_t), dimension(:), intent(in), optional :: qn_select
    integer :: i_term
    type(interaction_t), pointer :: int_matrix, int_flows
    if (evt%process_instance%is_complete_event ()) then
       if (present (ii_term)) then
          i_term = ii_term
       else
          i_term = evt%process_instance%select_i_term ()
       end if
       int_matrix => evt%process_instance%get_matrix_int_ptr (i_term)
       int_flows  => evt%process_instance%get_flows_int_ptr (i_term)
       call evt%factorize_interactions (int_matrix, int_flows, &
            factorization_mode, keep_correlations, r, qn_select)
       call evt%tag_incoming ()
    else
       call msg_bug ("Event factorization: event is incomplete")
    end if
  end subroutine make_factorized_particle_set

@ %def make_factorized_particle_set
@ Mark the incoming particles as incoming in the particle set.  This
is necessary because in the interaction objects they are usually
marked as virtual.

In the inquiry functions we set the term index to one; the indices of
beams and incoming particles should be identical for all process
terms.

We use the initial elementary process for obtaining the indices.
Thus, we implicitly assume that the beam and incoming indices stay the
same across event transforms.  If this is not true for a transform
(say, MPI), it should override this method.
<<Event transforms: evt: TBP>>=
  procedure :: tag_incoming => evt_tag_incoming
<<Event transforms: sub interfaces>>=
    module subroutine evt_tag_incoming (evt)
      class(evt_t), intent(inout) :: evt
    end subroutine evt_tag_incoming
<<Event transforms: procedures>>=
  module subroutine evt_tag_incoming (evt)
    class(evt_t), intent(inout) :: evt
    integer :: i_term, n_in
    integer, dimension(:), allocatable :: beam_index, in_index
    n_in = evt%process%get_n_in ()
    i_term = 1
    allocate (beam_index (n_in))
    call evt%process_instance%get_beam_index (i_term, beam_index)
    call evt%particle_set%reset_status (beam_index, PRT_BEAM)
    allocate (in_index (n_in))
    call evt%process_instance%get_in_index (i_term, in_index)
    call evt%particle_set%reset_status (in_index, PRT_INCOMING)
  end subroutine evt_tag_incoming

@ %def evt_tag_incoming
@
\subsection{Implementation: Trivial transform}
This transform contains just a pointer to process and process
instance.  The [[generate]] methods do nothing.
<<Event transforms: public>>=
  public :: evt_trivial_t
<<Event transforms: types>>=
  type, extends (evt_t) :: evt_trivial_t
   contains
   <<Event transforms: evt trivial: TBP>>
  end type evt_trivial_t

@ %def evt_trivial_t
@
<<Event transforms: evt trivial: TBP>>=
  procedure :: write_name => evt_trivial_write_name
<<Event transforms: sub interfaces>>=
    module subroutine evt_trivial_write_name (evt, unit)
      class(evt_trivial_t), intent(in) :: evt
      integer, intent(in), optional :: unit
    end subroutine evt_trivial_write_name
<<Event transforms: procedures>>=
  module subroutine evt_trivial_write_name (evt, unit)
    class(evt_trivial_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Event transform: trivial (hard process)"
  end subroutine evt_trivial_write_name

@ %def evt_trivial_write_name
@ The finalizer is trivial.  Some output:
<<Event transforms: evt trivial: TBP>>=
  procedure :: write => evt_trivial_write
<<Event transforms: sub interfaces>>=
    module subroutine evt_trivial_write &
         (evt, unit, verbose, more_verbose, testflag)
      class(evt_trivial_t), intent(in) :: evt
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: verbose, more_verbose, testflag
    end subroutine evt_trivial_write
<<Event transforms: procedures>>=
  module subroutine evt_trivial_write &
       (evt, unit, verbose, more_verbose, testflag)
    class(evt_trivial_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    call evt%write_name (u)
    call write_separator (u)
    call evt%base_write (u, testflag = testflag)
!!! More readable but wider output; in line with evt_resonance_write
!     if (verbose .and. evt%particle_set_exists) then
!        call evt%particle_set%write &
!             (u, summary = .true., compressed = .true., testflag = testflag)
!        call write_separator (u)
!     end if
  end subroutine evt_trivial_write

@ %def evt_trivial_write
@ Nothing to do here:
<<Event transforms: evt trivial: TBP>>=
  procedure :: prepare_new_event => evt_trivial_prepare_new_event
<<Event transforms: sub interfaces>>=
    module subroutine evt_trivial_prepare_new_event (evt, i_mci, i_term)
      class(evt_trivial_t), intent(inout) :: evt
      integer, intent(in) :: i_mci, i_term
    end subroutine evt_trivial_prepare_new_event
<<Event transforms: procedures>>=
  module subroutine evt_trivial_prepare_new_event (evt, i_mci, i_term)
    class(evt_trivial_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
  end subroutine evt_trivial_prepare_new_event

@ %def evt_trivial_prepare_new_event
@ The weighted generator is, surprisingly, trivial.
<<Event transforms: evt trivial: TBP>>=
  procedure :: generate_weighted => evt_trivial_generate_weighted
<<Event transforms: sub interfaces>>=
    module subroutine evt_trivial_generate_weighted (evt, probability)
      class(evt_trivial_t), intent(inout) :: evt
      real(default), intent(inout) :: probability
    end subroutine evt_trivial_generate_weighted
<<Event transforms: procedures>>=
  module subroutine evt_trivial_generate_weighted (evt, probability)
    class(evt_trivial_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    probability = 1
  end subroutine evt_trivial_generate_weighted

@ %def evt_trivial_generate_weighted
@ This routine makes a particle set, using the associated process
instance as-is. Note that it is a potential risk to tolerate a
non-existent particle set at this point. We should remove it once the
flavors are determined correctly in all cases. It is currently
neccessary if we are keeping failed events [[?keep_failed_events = .true.]].
For these events, we do not compute the matrix elements, so the
factorization fails trying to determine the quantum
numbers. Additionally, it is necessary for the trivial event
transformation preceeding the event transformations required for
POWHEG matching.
<<Event transforms: evt trivial: TBP>>=
  procedure :: make_particle_set => evt_trivial_make_particle_set
<<Event transforms: sub interfaces>>=
    module subroutine evt_trivial_make_particle_set &
         (evt, factorization_mode, keep_correlations, r)
      class(evt_trivial_t), intent(inout) :: evt
      integer, intent(in) :: factorization_mode
      logical, intent(in) :: keep_correlations
      real(default), dimension(:), intent(in), optional :: r
    end subroutine evt_trivial_make_particle_set
<<Event transforms: procedures>>=
  module subroutine evt_trivial_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_trivial_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    call make_factorized_particle_set (evt, factorization_mode, &
         keep_correlations, r)
    evt%particle_set_exists = .true.
  end subroutine evt_trivial_make_particle_set

@ %def event_trivial_make_particle_set
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[event_transforms_ut.f90]]>>=
<<File header>>

module event_transforms_ut
  use unit_tests
  use event_transforms_uti

<<Standard module head>>

<<Event transforms: public test>>

contains

<<Event transforms: test driver>>

end module event_transforms_ut
@ %def event_transforms_ut
@
<<[[event_transforms_uti.f90]]>>=
<<File header>>

module event_transforms_uti

<<Use kinds>>
<<Use strings>>
  use format_utils, only: write_separator
  use os_interface
  use sm_qcd
  use models
  use state_matrices, only: FM_IGNORE_HELICITY
  use interactions, only: reset_interaction_counter
  use process_libraries
  use rng_base
  use mci_base
  use mci_midpoint
  use phs_base
  use phs_single
  use prc_core
  use prc_test, only: prc_test_create_library

  use process, only: process_t
  use instances, only: process_instance_t

  use event_transforms

  use rng_base_ut, only: rng_test_factory_t

<<Standard module head>>

<<Event transforms: test declarations>>

contains

<<Event transforms: tests>>

<<Event transforms: test auxiliary>>

end module event_transforms_uti

@ %def event_transforms_uti
@ API: driver for the unit tests below.
<<Event transforms: public test>>=
  public :: event_transforms_test
<<Event transforms: test driver>>=
  subroutine event_transforms_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Event transforms: execute tests>>
  end subroutine event_transforms_test

@ %def event_transforms_test
@
\subsubsection{Test trivial event transform}
The trivial transform, as an instance of the abstract transform, does
nothing but to trigger event generation for an elementary process.
<<Event transforms: execute tests>>=
  call test (event_transforms_1, "event_transforms_1", &
       "trivial event transform", &
       u, results)
<<Event transforms: test declarations>>=
  public :: event_transforms_1
<<Event transforms: tests>>=
  subroutine event_transforms_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_t), target :: model
    type(process_library_t), target :: lib
    type(string_t) :: libname, procname1
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    class(evt_t), allocatable :: evt
    integer :: factorization_mode
    logical :: keep_correlations

    write (u, "(A)")  "* Test output: event_transforms_1"
    write (u, "(A)")  "*   Purpose: handle trivial transform"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and parent process"
    write (u, "(A)")

    call os_data%init ()

    libname = "event_transforms_1_lib"
    procname1 = "event_transforms_1_p"

    call prc_test_create_library (libname, lib, &
         scattering = .true., procname1 = procname1)
    call reset_interaction_counter ()

    call model%init_test ()

    allocate (process)
    call process%init (procname1, lib, os_data, model)
    call process%setup_test_cores ()

    allocate (phs_single_config_t :: phs_config_template)
    call process%init_components (phs_config_template)

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts, i_core = 1)
    call process%configure_phs ()
    call process%setup_mci (dispatch_mci_test_midpoint)
    call process%setup_terms ()

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%integrate (1, n_it=1, n_calls=100)
    call process%final_integration (1)
    call process_instance%final ()
    deallocate (process_instance)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    write (u, "(A)")  "* Initialize trivial event transform"
    write (u, "(A)")

    allocate (evt_trivial_t :: evt)
    call evt%connect (process_instance, process%get_model_ptr ())

    write (u, "(A)")  "* Generate event and subsequent transform"
    write (u, "(A)")

    call process_instance%generate_unweighted_event (1)
    call process_instance%evaluate_event_data ()

    call evt%prepare_new_event (1, 1)
    call evt%generate_unweighted ()

    call write_separator (u, 2)
    call evt%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Obtain particle set"
    write (u, "(A)")

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.

    call evt%make_particle_set (factorization_mode, keep_correlations)

    call write_separator (u, 2)
    call evt%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt%final ()
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: event_transforms_1"

  end subroutine event_transforms_1

@ %def event_transforms_1
@ MCI record prepared for midpoint integrator.
<<Event transforms: test auxiliary>>=
  subroutine dispatch_mci_test_midpoint (mci, var_list, process_id, is_nlo)
    use variables, only: var_list_t
    class(mci_t), allocatable, intent(out) :: mci
    type(var_list_t), intent(in) :: var_list
    type(string_t), intent(in) :: process_id
    logical, intent(in), optional :: is_nlo
    allocate (mci_midpoint_t :: mci)
  end subroutine dispatch_mci_test_midpoint

@ %def dispatch_mci_test_midpoint
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Hadronization interface}
<<[[hadrons.f90]]>>=
<<File header>>

module hadrons

<<Use kinds with double>>
<<Use strings>>
  use event_transforms
  use lorentz
  use model_data
  use models
  use particles
  use physics_defs
  use process, only: process_t
  use instances, only: process_instance_t
  use process_stacks
  use whizard_lha
  use pythia8
  use rng_base, only: rng_t
  use shower_base
  use shower_pythia6
  use sm_qcd
  use variables

<<Standard module head>>

<<Hadrons: public>>

<<Hadrons: parameters>>

<<Hadrons: types>>

<<Hadrons: interfaces>>

  interface
<<Hadrons: sub interfaces>>
  end interface

end module hadrons
@ %def hadrons
@
<<[[hadrons_sub.f90]]>>=
<<File header>>

submodule (hadrons) hadrons_s

<<Use debug>>
  use constants
  use diagnostics
  use format_utils, only: write_separator
  use helicities
  use hep_common
  use io_units
  use numeric_utils, only: vanishes
  use subevents

  implicit none

contains

<<Hadrons: procedures>>

end submodule hadrons_s

@ %def hadrons_s
@
\subsection{Hadronization implementations}
<<Hadrons: public>>=
  public :: HADRONS_UNDEFINED, HADRONS_WHIZARD, HADRONS_PYTHIA6, HADRONS_PYTHIA8
<<Hadrons: parameters>>=
  integer, parameter :: HADRONS_UNDEFINED = 0
  integer, parameter :: HADRONS_WHIZARD = 1
  integer, parameter :: HADRONS_PYTHIA6 = 2
  integer, parameter :: HADRONS_PYTHIA8 = 3
@ %def HADRONS_UNDEFINED HADRONS_WHIZARD HADRONS_PYTHIA6 HADRONS_PYTHIA8
@ A dictionary
<<Hadrons: public>>=
  public :: hadrons_method
<<Hadrons: interfaces>>=
  interface hadrons_method
     module procedure hadrons_method_of_string
     module procedure hadrons_method_to_string
  end interface
<<Hadrons: sub interfaces>>=
    elemental module function hadrons_method_of_string (string) result (i)
      integer :: i
      type(string_t), intent(in) :: string
    end function hadrons_method_of_string
    elemental module function hadrons_method_to_string (i) result (string)
      type(string_t) :: string
      integer, intent(in) :: i
    end function hadrons_method_to_string
<<Hadrons: procedures>>=
  elemental module function hadrons_method_of_string (string) result (i)
    integer :: i
    type(string_t), intent(in) :: string
    select case (char(string))
    case ("WHIZARD")
       i = HADRONS_WHIZARD
    case ("PYTHIA6")
       i = HADRONS_PYTHIA6
    case ("PYTHIA8")
       i = HADRONS_PYTHIA8
    case default
       i = HADRONS_UNDEFINED
    end select
  end function hadrons_method_of_string

  elemental module function hadrons_method_to_string (i) result (string)
    type(string_t) :: string
    integer, intent(in) :: i
    select case (i)
    case (HADRONS_WHIZARD)
       string = "WHIZARD"
    case (HADRONS_PYTHIA6)
       string = "PYTHIA6"
    case (HADRONS_PYTHIA8)
       string = "PYTHIA8"
    case default
       string = "UNDEFINED"
    end select
  end function hadrons_method_to_string

@ %def hadrons_method
@
\subsection{Hadronization settings}
These are the general settings and parameters for the different shower
methods.
<<Hadrons: public>>=
  public :: hadron_settings_t
<<Hadrons: types>>=
  type :: hadron_settings_t
     logical :: active = .false.
     integer :: method = HADRONS_UNDEFINED
     real(default) :: enhanced_fraction = 0
     real(default) :: enhanced_width = 0
   contains
   <<Hadrons: hadron settings: TBP>>
  end type hadron_settings_t

@ %def hadron_settings_t
@ Read in the hadronization settings.
<<Hadrons: hadron settings: TBP>>=
  procedure :: init => hadron_settings_init
<<Hadrons: sub interfaces>>=
    module subroutine hadron_settings_init (hadron_settings, var_list)
      class(hadron_settings_t), intent(out) :: hadron_settings
      type(var_list_t), intent(in) :: var_list
    end subroutine hadron_settings_init
<<Hadrons: procedures>>=
  module subroutine hadron_settings_init (hadron_settings, var_list)
    class(hadron_settings_t), intent(out) :: hadron_settings
    type(var_list_t), intent(in) :: var_list
    hadron_settings%active = &
         var_list%get_lval (var_str ("?hadronization_active"))
    hadron_settings%method = hadrons_method_of_string ( &
         var_list%get_sval (var_str ("$hadronization_method")))
    hadron_settings%enhanced_fraction = &
         var_list%get_rval (var_str ("hadron_enhanced_fraction"))
    hadron_settings%enhanced_width = &
         var_list%get_rval (var_str ("hadron_enhanced_width"))
  end subroutine hadron_settings_init

@ %def hadron_settings_init
@
<<Hadrons: hadron settings: TBP>>=
  procedure :: write => hadron_settings_write
<<Hadrons: sub interfaces>>=
    module subroutine hadron_settings_write (settings, unit)
      class(hadron_settings_t), intent(in) :: settings
      integer, intent(in), optional :: unit
    end subroutine hadron_settings_write
<<Hadrons: procedures>>=
  module subroutine hadron_settings_write (settings, unit)
    class(hadron_settings_t), intent(in) :: settings
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)")  "Hadronization settings:"
    call write_separator (u)
    write (u, "(1x,A)")  "Master switches:"
    write (u, "(3x,A,1x,L1)") &
         "active                = ", settings%active
    write (u, "(1x,A)")  "General settings:"
    if (settings%active) then
       write (u, "(3x,A)") &
            "hadron_method         =  " // &
            char (hadrons_method_to_string (settings%method))
    else
       write (u, "(3x,A)") " [Hadronization off]"
    end if
    write (u, "(1x,A)")  "pT generation parameters"
    write (u, "(3x,A,1x,ES19.12)") &
         "enhanced_fraction     = ", settings%enhanced_fraction
    write (u, "(3x,A,1x,ES19.12)") &
         "enhanced_width        = ", settings%enhanced_width
  end subroutine hadron_settings_write

@ %def hadron_settings_write
@
\subsection{Abstract Hadronization Type}
The [[model]] is the fallback model including all hadrons
<<Hadrons: types>>=
  type, abstract :: hadrons_t
     class(rng_t), allocatable :: rng
     type(shower_settings_t) :: shower_settings
     type(hadron_settings_t) :: hadron_settings
     type(model_t), pointer :: model => null()
   contains
   <<Hadrons: hadrons: TBP>>
  end type hadrons_t

@ %def hadrons_t
@
<<Hadrons: hadrons: TBP>>=
  procedure (hadrons_init), deferred :: init
<<Hadrons: interfaces>>=
  abstract interface
    subroutine hadrons_init &
         (hadrons, shower_settings, hadron_settings, model_hadrons)
      import
      class(hadrons_t), intent(out) :: hadrons
      type(shower_settings_t), intent(in) :: shower_settings
      type(hadron_settings_t), intent(in) :: hadron_settings
      type(model_t), target, intent(in) :: model_hadrons
    end subroutine hadrons_init
   end interface

@ %def hadrons_init
@
<<Hadrons: hadrons: TBP>>=
  procedure (hadrons_hadronize), deferred :: hadronize
<<Hadrons: interfaces>>=
  abstract interface
     subroutine hadrons_hadronize (hadrons, particle_set, valid)
       import
       class(hadrons_t), intent(inout) :: hadrons
       type(particle_set_t), intent(in) :: particle_set
       logical, intent(out) :: valid
     end subroutine hadrons_hadronize
  end interface
@ %def hadrons_hadronize
@
<<Hadrons: hadrons: TBP>>=
  procedure (hadrons_make_particle_set), deferred :: make_particle_set
<<Hadrons: interfaces>>=
  abstract interface
     subroutine hadrons_make_particle_set (hadrons, particle_set, &
          model, valid)
       import
       class(hadrons_t), intent(in) :: hadrons
       type(particle_set_t), intent(inout) :: particle_set
       class(model_data_t), intent(in), target :: model
       logical, intent(out) :: valid
     end subroutine hadrons_make_particle_set
  end interface

@ %def hadrons_make_particle_set
@
<<Hadrons: hadrons: TBP>>=
  procedure :: import_rng => hadrons_import_rng
<<Hadrons: sub interfaces>>=
    pure module subroutine hadrons_import_rng (hadrons, rng)
      class(hadrons_t), intent(inout) :: hadrons
      class(rng_t), intent(inout), allocatable :: rng
    end subroutine hadrons_import_rng
<<Hadrons: procedures>>=
  pure module subroutine hadrons_import_rng (hadrons, rng)
    class(hadrons_t), intent(inout) :: hadrons
    class(rng_t), intent(inout), allocatable :: rng
    call move_alloc (from = rng, to = hadrons%rng)
  end subroutine hadrons_import_rng

@ %def hadrons_import_rng
@
\subsection{[[WHIZARD]] Hadronization Type}
Hadronization can be (incompletely) performed through \whizard's internal
routine.
<<Hadrons: public>>=
  public :: hadrons_hadrons_t
<<Hadrons: types>>=
  type, extends (hadrons_t) :: hadrons_hadrons_t
     contains
       <<Hadrons: hadrons hadrons: TBP>>
    end type hadrons_hadrons_t

@ %def hadrons_hadrons_t
@
<<Hadrons: hadrons hadrons: TBP>>=
  procedure :: init => hadrons_hadrons_init
<<Hadrons: sub interfaces>>=
    module subroutine hadrons_hadrons_init &
         (hadrons, shower_settings, hadron_settings, model_hadrons)
      class(hadrons_hadrons_t), intent(out) :: hadrons
      type(shower_settings_t), intent(in) :: shower_settings
      type(hadron_settings_t), intent(in) :: hadron_settings
      type(model_t), intent(in), target :: model_hadrons
    end subroutine hadrons_hadrons_init
<<Hadrons: procedures>>=
  module subroutine hadrons_hadrons_init &
       (hadrons, shower_settings, hadron_settings, model_hadrons)
    class(hadrons_hadrons_t), intent(out) :: hadrons
    type(shower_settings_t), intent(in) :: shower_settings
    type(hadron_settings_t), intent(in) :: hadron_settings
    type(model_t), intent(in), target :: model_hadrons
    hadrons%model => model_hadrons
    hadrons%shower_settings = shower_settings
    hadrons%hadron_settings = hadron_settings
    call msg_message &
         ("Hadronization: WHIZARD model for hadronization and decays")
  end subroutine hadrons_hadrons_init

@ %def hadrons_hadrons_init
@
<<Hadrons: hadrons hadrons: TBP>>=
  procedure :: hadronize => hadrons_hadrons_hadronize
<<Hadrons: sub interfaces>>=
    module subroutine hadrons_hadrons_hadronize (hadrons, particle_set, valid)
      class(hadrons_hadrons_t), intent(inout) :: hadrons
      type(particle_set_t), intent(in) :: particle_set
      logical, intent(out) :: valid
    end subroutine hadrons_hadrons_hadronize
<<Hadrons: procedures>>=
  module subroutine hadrons_hadrons_hadronize (hadrons, particle_set, valid)
    class(hadrons_hadrons_t), intent(inout) :: hadrons
    type(particle_set_t), intent(in) :: particle_set
    logical, intent(out) :: valid
    integer, dimension(:), allocatable :: cols, acols, octs
    integer :: n
    if (signal_is_pending ()) return
    if (debug_on) call msg_debug (D_TRANSFORMS, "hadrons_hadrons_hadronize")
    call particle_set%write (6, compressed=.true.)
    n = particle_set%get_n_tot ()
    allocate (cols (n), acols (n), octs (n))
    call extract_color_systems (particle_set, cols, acols, octs)
    print *, "size(cols)  = ", size (cols)
    if (size(cols) > 0) then
       print *, "cols  = ", cols
    end if
    print *, "size(acols) = ", size(acols)
    if (size(acols) > 0) then
       print *, "acols = ", acols
    end if
    print *, "size(octs)  = ", size(octs)
    if (size (octs) > 0) then
       print *, "octs  = ", octs
    end if
    !!! if all arrays are empty, i.e. zero particles found, nothing to do
  end subroutine hadrons_hadrons_hadronize

@ %def hadrons_hadrons_hadronize
@ This type contains a flavor selector for the creation of hadrons,
including parameters for the special handling of baryons.
<<Hadrons: public>>=
  public :: had_flav_t
<<Hadrons: types>>=
  type had_flav_t
  end type had_flav_t

@ %def had_flav_t
@ This is the type for the ends of Lund strings.
<<Hadrons: public>>=
  public :: lund_end
<<Hadrons: types>>=
  type lund_end
     logical :: from_pos
     integer :: i_end
     integer :: i_max
     integer :: id_had
     integer :: i_pos_old
     integer :: i_neg_old
     integer :: i_pos_new
     integer :: i_neg_new
     real(default) :: px_old
     real(default) :: py_old
     real(default) :: px_new
     real(default) :: py_new
     real(default) :: px_had
     real(default) :: py_had
     real(default) :: m_had
     real(default) :: mT2_had
     real(default) :: z_had
     real(default) :: gamma_old
     real(default) :: gamma_new
     real(default) :: x_pos_old
     real(default) :: x_pos_new
     real(default) :: x_pos_had
     real(default) :: x_neg_old
     real(default) :: x_neg_new
     real(default) :: x_neg_had
     type(had_flav_t) :: old_flav
     type(had_flav_t) :: new_flav
     type(vector4_t) :: p_had
     type(vector4_t) :: p_pre
  end type lund_end

@ %def lund_end
@ Generator for transverse momentum for the fragmentation.
<<Hadrons: public>>=
  public :: lund_pt_t
<<Hadrons: types>>=
  type lund_pt_t
     real(default) :: sigma_min
     real(default) :: sigma_q
     real(default) :: enhanced_frac
     real(default) :: enhanced_width
     real(default) :: sigma_to_had
     class(rng_t), allocatable :: rng
   contains
   <<Hadrons: lund pT: TBP>>
  end type lund_pt_t

@ %def lund_pt
<<Hadrons: lund pT: TBP>>=
  procedure :: init => lund_pt_init
<<Hadrons: sub interfaces>>=
    module subroutine lund_pt_init (lund_pt, settings)
      class (lund_pt_t), intent(out) :: lund_pt
      type(hadron_settings_t), intent(in) :: settings
    end subroutine lund_pt_init
<<Hadrons: procedures>>=
  module subroutine lund_pt_init (lund_pt, settings)
    class (lund_pt_t), intent(out) :: lund_pt
    type(hadron_settings_t), intent(in) :: settings
  end subroutine lund_pt_init

@ %def lund_pt_init
@
<<Hadrons: hadrons hadrons: TBP>>=
  procedure :: make_particle_set => hadrons_hadrons_make_particle_set
<<Hadrons: sub interfaces>>=
    module subroutine hadrons_hadrons_make_particle_set &
           (hadrons, particle_set, model, valid)
      class(hadrons_hadrons_t), intent(in) :: hadrons
      type(particle_set_t), intent(inout) :: particle_set
      class(model_data_t), intent(in), target :: model
      logical, intent(out) :: valid
    end subroutine hadrons_hadrons_make_particle_set
<<Hadrons: procedures>>=
  module subroutine hadrons_hadrons_make_particle_set &
         (hadrons, particle_set, model, valid)
    class(hadrons_hadrons_t), intent(in) :: hadrons
    type(particle_set_t), intent(inout) :: particle_set
    class(model_data_t), intent(in), target :: model
    logical, intent(out) :: valid
    if (signal_is_pending ()) return
    valid = .false.
    if (valid) then
    else
       call msg_fatal ("WHIZARD hadronization not yet implemented")
    end if
  end subroutine hadrons_hadrons_make_particle_set

@ %def hadrons_hadrons_make_particle_set
@
<<Hadrons: procedures>>=
  subroutine extract_color_systems (p_set, cols, acols, octs)
    type(particle_set_t), intent(in) :: p_set
    integer, dimension(:), allocatable, intent(out) :: cols, acols, octs
    logical, dimension(:), allocatable :: mask
    integer :: i, n, n_cols, n_acols, n_octs
    n = p_set%get_n_tot ()
    allocate (mask (n))
    do i = 1, n
       mask(i) = p_set%prt(i)%col%get_col () /= 0 .and. &
            p_set%prt(i)%col%get_acl () == 0 .and. &
            p_set%prt(i)%get_status () == PRT_OUTGOING
    end do
    n_cols = count (mask)
    allocate (cols (n_cols))
    cols = p_set%get_indices (mask)
    do i = 1, n
       mask(i) = p_set%prt(i)%col%get_col () == 0 .and. &
            p_set%prt(i)%col%get_acl () /= 0 .and. &
            p_set%prt(i)%get_status () == PRT_OUTGOING
    end do
    n_acols = count (mask)
    allocate (acols (n_acols))
    acols = p_set%get_indices (mask)
    do i = 1, n
       mask(i) = p_set%prt(i)%col%get_col () /= 0 .and. &
            p_set%prt(i)%col%get_acl () /= 0 .and. &
            p_set%prt(i)%get_status () == PRT_OUTGOING
    end do
    n_octs = count (mask)
    allocate (octs (n_octs))
    octs = p_set%get_indices (mask)
  end subroutine extract_color_systems

@ %def extract_color_systems
@
\subsection{[[PYTHIA6]] Hadronization Type}
Hadronization via [[PYTHIA6]] is at another option for
hadronization within \whizard.
<<Hadrons: public>>=
  public :: hadrons_pythia6_t
<<Hadrons: types>>=
  type, extends (hadrons_t) :: hadrons_pythia6_t
   contains
   <<Hadrons: hadrons pythia6: TBP>>
  end type hadrons_pythia6_t

@ %def hadrons_pythia6_t
<<Hadrons: hadrons pythia6: TBP>>=
  procedure :: init => hadrons_pythia6_init
<<Hadrons: sub interfaces>>=
    module subroutine hadrons_pythia6_init &
         (hadrons, shower_settings, hadron_settings, model_hadrons)
      class(hadrons_pythia6_t), intent(out) :: hadrons
      type(shower_settings_t), intent(in) :: shower_settings
      type(hadron_settings_t), intent(in) :: hadron_settings
      type(model_t), intent(in), target :: model_hadrons
    end subroutine hadrons_pythia6_init
<<Hadrons: procedures>>=
  module subroutine hadrons_pythia6_init &
       (hadrons, shower_settings, hadron_settings, model_hadrons)
    class(hadrons_pythia6_t), intent(out) :: hadrons
    type(shower_settings_t), intent(in) :: shower_settings
    type(hadron_settings_t), intent(in) :: hadron_settings
    type(model_t), intent(in), target :: model_hadrons
    logical :: pygive_not_set_by_shower
    hadrons%model => model_hadrons
    hadrons%shower_settings = shower_settings
    hadrons%hadron_settings = hadron_settings
    pygive_not_set_by_shower = .not. (shower_settings%method == PS_PYTHIA6 &
         .and. (shower_settings%isr_active .or. shower_settings%fsr_active))
    if (pygive_not_set_by_shower) then
       call pythia6_set_verbose (shower_settings%verbose)
       call pythia6_set_config (shower_settings%pythia6_pygive)
    end if
    call msg_message &
         ("Hadronization: Using PYTHIA6 interface for hadronization and decays")
  end subroutine hadrons_pythia6_init

@ %def hadrons_pythia6_init
@ Assume that the event record is still in the PYTHIA COMMON BLOCKS
transferred there by the WHIZARD or PYTHIA6 shower routines.
<<Hadrons: hadrons pythia6: TBP>>=
  procedure :: hadronize => hadrons_pythia6_hadronize
<<Hadrons: sub interfaces>>=
    module subroutine hadrons_pythia6_hadronize (hadrons, particle_set, valid)
      class(hadrons_pythia6_t), intent(inout) :: hadrons
      type(particle_set_t), intent(in) :: particle_set
      logical, intent(out) :: valid
    end subroutine hadrons_pythia6_hadronize
<<Hadrons: procedures>>=
  module subroutine hadrons_pythia6_hadronize (hadrons, particle_set, valid)
    class(hadrons_pythia6_t), intent(inout) :: hadrons
    type(particle_set_t), intent(in) :: particle_set
    logical, intent(out) :: valid
    integer :: N, NPAD, K
    real(double) :: P, V
    common /PYJETS/ N, NPAD, K(4000,5), P(4000,5), V(4000,5)
    save /PYJETS/
    if (signal_is_pending ()) return
    if (debug_on) call msg_debug (D_TRANSFORMS, "hadrons_pythia6_hadronize")
    call pygive ("MSTP(111)=1")    !!! Switch on hadronization and decays
    call pygive ("MSTJ(1)=1")      !!! String fragmentation
    call pygive ("MSTJ(21)=2")     !!! String fragmentation keeping resonance momentum
    call pygive ("MSTJ(28)=0")     !!! Switch off tau decays
    if (debug_active (D_TRANSFORMS)) then
       call msg_debug (D_TRANSFORMS, "N", N)
       call pylist(2)
       print *, ' line 7 : ', k(7,1:5), p(7,1:5)
    end if
    call pyedit (12)
    call pythia6_set_last_treated_line (N)
    call pyexec ()
    call pyedit (12)
    valid = .true.
  end subroutine hadrons_pythia6_hadronize

@ %def hadrons_pythia6_hadronize
@
<<Hadrons: hadrons pythia6: TBP>>=
  procedure :: make_particle_set => hadrons_pythia6_make_particle_set
<<Hadrons: sub interfaces>>=
    module subroutine hadrons_pythia6_make_particle_set &
         (hadrons, particle_set, model, valid)
      class(hadrons_pythia6_t), intent(in) :: hadrons
      type(particle_set_t), intent(inout) :: particle_set
      class(model_data_t), intent(in), target :: model
      logical, intent(out) :: valid
    end subroutine hadrons_pythia6_make_particle_set
<<Hadrons: procedures>>=
  module subroutine hadrons_pythia6_make_particle_set &
       (hadrons, particle_set, model, valid)
    class(hadrons_pythia6_t), intent(in) :: hadrons
    type(particle_set_t), intent(inout) :: particle_set
    class(model_data_t), intent(in), target :: model
    logical, intent(out) :: valid
    if (signal_is_pending ()) return
    valid = pythia6_handle_errors ()
    if (valid) then
       call pythia6_combine_with_particle_set &
            (particle_set, model, hadrons%model, hadrons%shower_settings)
    end if
  end subroutine hadrons_pythia6_make_particle_set

@ %def hadrons_pythia6_make_particle_set
@
\subsection{[[PYTHIA8]] Hadronization}
@
<<Hadrons: public>>=
  public :: hadrons_pythia8_t
<<Hadrons: types>>=
  type, extends (hadrons_t) :: hadrons_pythia8_t
     type(pythia8_t) :: pythia
     type(whizard_lha_t) :: lhaup
     logical :: user_process_set = .false.
     logical :: pythia_initialized = .false., &
          lhaup_initialized = .false.
  contains
   <<Hadrons: hadrons pythia8: TBP>>
  end type hadrons_pythia8_t

@ %def hadrons_pythia8_t
@
<<Hadrons: hadrons pythia8: TBP>>=
  procedure :: init => hadrons_pythia8_init
<<Hadrons: sub interfaces>>=
    module subroutine hadrons_pythia8_init &
         (hadrons, shower_settings, hadron_settings, model_hadrons)
      class(hadrons_pythia8_t), intent(out) :: hadrons
      type(shower_settings_t), intent(in) :: shower_settings
      type(hadron_settings_t), intent(in) :: hadron_settings
      type(model_t), intent(in), target :: model_hadrons
    end subroutine hadrons_pythia8_init
<<Hadrons: procedures>>=
  module subroutine hadrons_pythia8_init &
       (hadrons, shower_settings, hadron_settings, model_hadrons)
    class(hadrons_pythia8_t), intent(out) :: hadrons
    type(shower_settings_t), intent(in) :: shower_settings
    type(hadron_settings_t), intent(in) :: hadron_settings
    type(model_t), intent(in), target :: model_hadrons
    hadrons%model => model_hadrons
    hadrons%shower_settings = shower_settings
    hadrons%hadron_settings = hadron_settings
    call msg_message ("Hadronization: Using PYTHIA8 interface " // &
         "for hadronization and decays.")
    ! TODO sbrass which verbose?
    call hadrons%pythia%init (verbose = shower_settings%verbose)
    call hadrons%lhaup%init ()
  end subroutine hadrons_pythia8_init

@ %def hadrons_pythia8_init
@ Transfer hadron settings to [[PYTHIA8]].
<<Hadrons: hadrons pythia8: TBP>>=
  procedure, private :: transfer_settings => hadrons_pythia8_transfer_settings
<<Hadrons: sub interfaces>>=
    module subroutine hadrons_pythia8_transfer_settings (hadrons)
      class(hadrons_pythia8_t), intent(inout), target :: hadrons
    end subroutine hadrons_pythia8_transfer_settings
<<Hadrons: procedures>>=
  module subroutine hadrons_pythia8_transfer_settings (hadrons)
    class(hadrons_pythia8_t), intent(inout), target :: hadrons
    real(default) :: r
    if (debug_on)  call msg_debug &
         (D_TRANSFORMS, "hadrons_pythia8_transfer_settings")
    if (debug_on)  call msg_debug2 &
         (D_TRANSFORMS, "pythia_initialized", hadrons%pythia_initialized)
    if (hadrons%pythia_initialized) return
    call hadrons%pythia%import_rng (hadrons%rng)
    call hadrons%pythia%parse_and_set_config &
         (hadrons%shower_settings%pythia8_config)
    if (len (hadrons%shower_settings%pythia8_config_file) > 0) &
         call hadrons%pythia%read_file &
         (hadrons%shower_settings%pythia8_config_file)
    call hadrons%pythia%read_string (var_str ("Beams:frameType = 5"))
    call hadrons%pythia%read_string (var_str ("ProcessLevel:all = off"))
    if (.not. hadrons%shower_settings%verbose) then
       call hadrons%pythia%read_string (var_str ("Print:quiet = on"))
    end if
    call hadrons%pythia%set_lhaup_ptr (hadrons%lhaup)
    call hadrons%pythia%init_pythia ()
    hadrons%pythia_initialized = .true.
  end subroutine hadrons_pythia8_transfer_settings

@ %def hadrons_pythia8_transfer_settings
@ Set user process for the LHA interface.
<<Hadrons: hadrons pythia8: TBP>>=
  procedure, private :: set_user_process => hadrons_pythia8_set_user_process
<<Hadrons: sub interfaces>>=
    module subroutine hadrons_pythia8_set_user_process (hadrons, pset)
      class(hadrons_pythia8_t), intent(inout) :: hadrons
      type(particle_set_t), intent(in) :: pset
    end subroutine hadrons_pythia8_set_user_process
<<Hadrons: procedures>>=
  module subroutine hadrons_pythia8_set_user_process (hadrons, pset)
    class(hadrons_pythia8_t), intent(inout) :: hadrons
    type(particle_set_t), intent(in) :: pset
    integer, dimension(2) :: beam_pdg
    real(default), dimension(2) :: beam_energy
    integer, parameter :: process_id = 0, n_processes = 0
    if (debug_on)  call msg_debug &
         (D_TRANSFORMS, "hadrons_pythia8_set_user_process")
    beam_pdg = [pset%prt(1)%get_pdg (), pset%prt(2)%get_pdg ()]
    beam_energy = [energy(pset%prt(1)%p), energy(pset%prt(2)%p)]
    call hadrons%lhaup%set_init (beam_pdg, beam_energy, &
         n_processes, unweighted = .false., negative_weights = .false.)
    call hadrons%lhaup%set_process_parameters (process_id = process_id, &
         cross_section = one, error = one)
  end subroutine hadrons_pythia8_set_user_process

@ %def hadrons_pythia8_set_user_process
@ Import particle set.
<<Hadrons: hadrons pythia8: TBP>>=
  procedure, private :: import_particle_set => &
       hadrons_pythia8_import_particle_set
<<Hadrons: sub interfaces>>=
    module subroutine hadrons_pythia8_import_particle_set &
         (hadrons, particle_set)
      class(hadrons_pythia8_t), target, intent(inout) :: hadrons
      type(particle_set_t), intent(in) :: particle_set
    end subroutine hadrons_pythia8_import_particle_set
<<Hadrons: procedures>>=
  module subroutine hadrons_pythia8_import_particle_set (hadrons, particle_set)
    class(hadrons_pythia8_t), target, intent(inout) :: hadrons
    type(particle_set_t), intent(in) :: particle_set
    integer, parameter :: PROCESS_ID = 1
    if (debug_on)  call msg_debug &
         (D_TRANSFORMS, "hadrons_pythia8_import_particle_set")
    if (.not. hadrons%user_process_set) then
       call hadrons%set_user_process (particle_set)
       hadrons%user_process_set = .true.
    end if
    call hadrons%lhaup%set_event_process (process_id = PROCESS_ID, &
         scale = -one, alpha_qcd = -one, alpha_qed = -one, weight = -one)
    call hadrons%lhaup%set_event (process_id = PROCESS_ID, &
         particle_set = particle_set, polarization = .true.)
    if (debug_active (D_TRANSFORMS)) then
       call hadrons%lhaup%list_init ()
    end if
  end subroutine hadrons_pythia8_import_particle_set

@ %def hadrons_pythia8_import_particle_set
@
<<Hadrons: hadrons pythia8: TBP>>=
  procedure :: hadronize => hadrons_pythia8_hadronize
<<Hadrons: sub interfaces>>=
    module subroutine hadrons_pythia8_hadronize (hadrons, particle_set, valid)
      class(hadrons_pythia8_t), intent(inout) :: hadrons
      type(particle_set_t), intent(in) :: particle_set
      logical, intent(out) :: valid
    end subroutine hadrons_pythia8_hadronize
<<Hadrons: procedures>>=
  module subroutine hadrons_pythia8_hadronize (hadrons, particle_set, valid)
    class(hadrons_pythia8_t), intent(inout) :: hadrons
    type(particle_set_t), intent(in) :: particle_set
    logical, intent(out) :: valid
    if (signal_is_pending ()) return
    call hadrons%import_particle_set (particle_set)
    if (.not. hadrons%pythia_initialized) &
         call hadrons%transfer_settings ()
    call hadrons%pythia%next (valid)
    if (debug_active (D_TRANSFORMS)) then
       call hadrons%pythia%list_event ()
       call particle_set%write (summary=.true., compressed=.true.)
    end if
  end subroutine hadrons_pythia8_hadronize

@ %def hadrons_pythia8_hadronize
@
<<Hadrons: hadrons pythia8: TBP>>=
  procedure :: make_particle_set => hadrons_pythia8_make_particle_set
<<Hadrons: sub interfaces>>=
    module subroutine hadrons_pythia8_make_particle_set &
           (hadrons, particle_set, model, valid)
      class(hadrons_pythia8_t), intent(in) :: hadrons
      type(particle_set_t), intent(inout) :: particle_set
      class(model_data_t), intent(in), target :: model
      logical, intent(out) :: valid
    end subroutine hadrons_pythia8_make_particle_set
<<Hadrons: procedures>>=
  module subroutine hadrons_pythia8_make_particle_set &
         (hadrons, particle_set, model, valid)
    class(hadrons_pythia8_t), intent(in) :: hadrons
    type(particle_set_t), intent(inout) :: particle_set
    class(model_data_t), intent(in), target :: model
    logical, intent(out) :: valid
    type(particle_t), dimension(:), allocatable :: beam
    if (debug_on)  call msg_debug &
         (D_TRANSFORMS, "hadrons_pythia8_make_particle_set")
    if (signal_is_pending ()) return
    associate (settings => hadrons%shower_settings)
      if (debug_active (D_TRANSFORMS)) then
         call msg_debug (D_TRANSFORMS, 'Combine PYTHIA8 with particle set')
         call msg_debug (D_TRANSFORMS, 'Particle set before replacing')
         call particle_set%write (summary=.true., compressed=.true.)
         call hadrons%pythia%list_event ()
         call msg_debug (D_TRANSFORMS, string = "settings%hadron_collision", &
              value = settings%hadron_collision)
      end if
      call hadrons%pythia%get_hadron_particles (&
           model, hadrons%model, particle_set, &
           helicity = PRT_DEFINITE_HELICITY)
    end associate
    if (debug_active (D_TRANSFORMS)) then
       print *, 'Particle set after replacing'
       call particle_set%write (summary=.true., compressed=.true.)
    end if
    valid = .true.
  end subroutine hadrons_pythia8_make_particle_set

@ %def hadrons_pythia8_make_particle_set
@
\subsection{Hadronization Event Transform}
This is the type for the hadronization event transform.  It does not
depend on the specific hadronization implementation of
[[hadrons_t]].
<<Hadrons: public>>=
  public :: evt_hadrons_t
<<Hadrons: types>>=
  type, extends (evt_t) :: evt_hadrons_t
     class(hadrons_t), allocatable :: hadrons
     type(model_t), pointer :: model_hadrons => null()
     type(qcd_t) :: qcd
     logical :: is_first_event
   contains
   <<Hadrons: evt hadrons: TBP>>
  end type evt_hadrons_t

@ %def evt_hadrons_t
@ Initialize the parameters.  The [[model_hadrons]] is supposed to be
the SM variant that contains all hadrons that may be generated in the
shower.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: init => evt_hadrons_init
<<Hadrons: sub interfaces>>=
    module subroutine evt_hadrons_init (evt, model_hadrons)
      class(evt_hadrons_t), intent(out) :: evt
      type(model_t), intent(in), target :: model_hadrons
    end subroutine evt_hadrons_init
<<Hadrons: procedures>>=
  module subroutine evt_hadrons_init (evt, model_hadrons)
    class(evt_hadrons_t), intent(out) :: evt
    type(model_t), intent(in), target :: model_hadrons
    evt%model_hadrons => model_hadrons
    evt%is_first_event = .true.
  end subroutine evt_hadrons_init

@ %def evt_hadrons_init
@
<<Hadrons: evt hadrons: TBP>>=
  procedure :: write_name => evt_hadrons_write_name
<<Hadrons: sub interfaces>>=
    module subroutine evt_hadrons_write_name (evt, unit)
      class(evt_hadrons_t), intent(in) :: evt
      integer, intent(in), optional :: unit
    end subroutine evt_hadrons_write_name
<<Hadrons: procedures>>=
  module subroutine evt_hadrons_write_name (evt, unit)
    class(evt_hadrons_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Event transform: hadronization"
  end subroutine evt_hadrons_write_name

@ %def evt_hadrons_write_name
@ Output.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: write => evt_hadrons_write
<<Hadrons: sub interfaces>>=
    module subroutine evt_hadrons_write &
         (evt, unit, verbose, more_verbose, testflag)
      class(evt_hadrons_t), intent(in) :: evt
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: verbose, more_verbose, testflag
    end subroutine evt_hadrons_write
<<Hadrons: procedures>>=
  module subroutine evt_hadrons_write &
       (evt, unit, verbose, more_verbose, testflag)
    class(evt_hadrons_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    call evt%write_name (u)
    call write_separator (u)
    call evt%base_write (u, testflag = testflag, show_set = .false.)
    if (evt%particle_set_exists)  &
         call evt%particle_set%write &
         (u, summary = .true., compressed = .true., testflag = testflag)
    call write_separator (u)
    call evt%hadrons%shower_settings%write (u)
    call write_separator (u)
    call evt%hadrons%hadron_settings%write (u)
  end subroutine evt_hadrons_write

@ %def evt_hadrons_write
@
<<Hadrons: evt hadrons: TBP>>=
  procedure :: first_event => evt_hadrons_first_event
<<Hadrons: sub interfaces>>=
    module subroutine evt_hadrons_first_event (evt)
      class(evt_hadrons_t), intent(inout) :: evt
    end subroutine evt_hadrons_first_event
<<Hadrons: procedures>>=
  module subroutine evt_hadrons_first_event (evt)
    class(evt_hadrons_t), intent(inout) :: evt
    if (debug_on) call msg_debug (D_TRANSFORMS, "evt_hadrons_first_event")
    associate (settings => evt%hadrons%shower_settings)
       settings%hadron_collision = .false.
       if (all (evt%particle_set%prt(1:2)%flv%get_pdg_abs () <= 39)) then
          settings%hadron_collision = .false.
       else if (all (evt%particle_set%prt(1:2)%flv%get_pdg_abs () >= 100)) then
          settings%hadron_collision = .true.
       else
          call msg_fatal ("evt_hadrons didn't recognize beams setup")
       end if
       if (debug_on)  call msg_debug &
            (D_TRANSFORMS, "hadron_collision", settings%hadron_collision)
       if (.not. (settings%isr_active .or. settings%fsr_active)) then
          call msg_fatal ("Hadronization without shower is not supported")
       end if
    end associate
    evt%is_first_event = .false.
  end subroutine evt_hadrons_first_event

@ %def evt_hadrons_first_event
@ Here we take the particle set from the previous event transform and
apply the hadronization.  The result is stored in the [[evt%hadrons]]
object.  We always return a probability of unity as we don't have the
analytic weight of the hadronization.  Invalid events have to be
discarded by the caller which is why we mark the particle set as
invalid.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: generate_weighted => evt_hadrons_generate_weighted
<<Hadrons: sub interfaces>>=
    module subroutine evt_hadrons_generate_weighted (evt, probability)
      class(evt_hadrons_t), intent(inout) :: evt
      real(default), intent(inout) :: probability
    end subroutine evt_hadrons_generate_weighted
<<Hadrons: procedures>>=
  module subroutine evt_hadrons_generate_weighted (evt, probability)
    class(evt_hadrons_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    logical :: valid
    if (signal_is_pending ())  return
    evt%particle_set = evt%previous%particle_set
    if (evt%is_first_event) then
       call evt%first_event ()
    end if
    call evt%hadrons%hadronize (evt%particle_set, valid)
    probability = 1
    evt%particle_set_exists = valid
  end subroutine evt_hadrons_generate_weighted

@ %def evt_hadrons_generate_weighted
@ The factorization parameters are irrelevant.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: make_particle_set => evt_hadrons_make_particle_set
<<Hadrons: sub interfaces>>=
    module subroutine evt_hadrons_make_particle_set &
         (evt, factorization_mode, keep_correlations, r)
      class(evt_hadrons_t), intent(inout) :: evt
      integer, intent(in) :: factorization_mode
      logical, intent(in) :: keep_correlations
      real(default), dimension(:), intent(in), optional :: r
    end subroutine evt_hadrons_make_particle_set
<<Hadrons: procedures>>=
  module subroutine evt_hadrons_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_hadrons_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    logical :: valid
    call evt%hadrons%make_particle_set (evt%particle_set, evt%model, valid)
    evt%particle_set_exists = evt%particle_set_exists .and. valid
  end subroutine evt_hadrons_make_particle_set

@ %def event_hadrons_make_particle_set
@ Connect the process with the hadrons object.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: connect => evt_hadrons_connect
<<Hadrons: sub interfaces>>=
    module subroutine evt_hadrons_connect &
         (evt, process_instance, model, process_stack)
      class(evt_hadrons_t), intent(inout), target :: evt
      type(process_instance_t), intent(in), target :: process_instance
      class(model_data_t), intent(in), target :: model
      type(process_stack_t), intent(in), optional :: process_stack
    end subroutine evt_hadrons_connect  
<<Hadrons: procedures>>=
  module subroutine evt_hadrons_connect &
       (evt, process_instance, model, process_stack)
    class(evt_hadrons_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    call evt%base_connect (process_instance, model, process_stack)
    call evt%make_rng (evt%process)
  end subroutine evt_hadrons_connect

@ %def evt_hadrons_connect
@ Create RNG instances, spawned by the process object.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: make_rng => evt_hadrons_make_rng
<<Hadrons: sub interfaces>>=
    module subroutine evt_hadrons_make_rng (evt, process)
      class(evt_hadrons_t), intent(inout) :: evt
      type(process_t), intent(inout) :: process
      class(rng_t), allocatable :: rng
    end subroutine evt_hadrons_make_rng
<<Hadrons: procedures>>=
  module subroutine evt_hadrons_make_rng (evt, process)
    class(evt_hadrons_t), intent(inout) :: evt
    type(process_t), intent(inout) :: process
    class(rng_t), allocatable :: rng
    call process%make_rng (rng)
    call evt%hadrons%import_rng (rng)
  end subroutine evt_hadrons_make_rng

@ %def evt_hadrons_make_rng
@
<<Hadrons: evt hadrons: TBP>>=
  procedure :: prepare_new_event => evt_hadrons_prepare_new_event
<<Hadrons: sub interfaces>>=
    module subroutine evt_hadrons_prepare_new_event (evt, i_mci, i_term)
      class(evt_hadrons_t), intent(inout) :: evt
      integer, intent(in) :: i_mci, i_term
    end subroutine evt_hadrons_prepare_new_event
<<Hadrons: procedures>>=
  module subroutine evt_hadrons_prepare_new_event (evt, i_mci, i_term)
    class(evt_hadrons_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
  end subroutine evt_hadrons_prepare_new_event

@ %def evt_hadrons_prepare_new_event
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resonance Insertion}
<<[[resonance_insertion.f90]]>>=
<<File header>>

module resonance_insertion

<<Use kinds>>
<<Use strings>>
  use rng_base, only: rng_t
  use selectors, only: selector_t
  use particles, only: particle_t, particle_set_t
  use resonances, only: resonance_history_set_t
  use resonances, only: resonance_tree_t
  use instances, only: process_instance_ptr_t
  use event_transforms

<<Standard module head>>

<<Resonance insertion: public>>

<<Resonance insertion: types>>

  interface
<<Resonance insertion: sub interfaces>>
  end interface

end module resonance_insertion
@ %def resonance_insertion
@
<<[[resonance_insertion_sub.f90]]>>=
<<File header>>

submodule (resonance_insertion) resonance_insertion_s

  use io_units
  use format_utils, only: write_separator
  use format_defs, only: FMT_12
  use interactions, only: interaction_t
  use subevents, only: PRT_RESONANT

  implicit none

contains

<<Resonance insertion: procedures>>

end submodule resonance_insertion_s

@ %def resonance_insertion_s
@
\subsection{Resonance-Insertion Event Transform}
This is the type for the event transform that applies resonance insertion.
The resonance history set describe the resonance histories that we may
consider.  There is a process library with process objects that correspond to
the resonance histories.  Library creation, compilation etc.\ is done outside
the scope of this module.
<<Resonance insertion: public>>=
  public :: evt_resonance_t
<<Resonance insertion: types>>=
  type, extends (evt_t) :: evt_resonance_t
     type(resonance_history_set_t), dimension(:), allocatable :: res_history_set
     integer, dimension(:), allocatable :: index_offset
     integer :: selected_component = 0
     type(string_t) :: libname
     type(string_t), dimension(:), allocatable :: proc_id
     real(default) :: on_shell_limit = 0
     real(default) :: on_shell_turnoff = 0
     real(default) :: background_factor = 1
     logical :: selector_active = .false.
     type(selector_t) :: selector
     integer :: selected_history = 0
     type(process_instance_ptr_t), dimension(:), allocatable :: instance
   contains
   <<Resonance insertion: evt resonance: TBP>>
  end type evt_resonance_t

@ %def evt_resonance_t
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: write_name => evt_resonance_write_name
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_write_name (evt, unit)
      class(evt_resonance_t), intent(in) :: evt
      integer, intent(in), optional :: unit
    end subroutine evt_resonance_write_name
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_write_name (evt, unit)
    class(evt_resonance_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Event transform: resonance insertion"
  end subroutine evt_resonance_write_name

@ %def evt_resonance_write_name
@ Output.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: write => evt_resonance_write
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_write &
         (evt, unit, verbose, more_verbose, testflag)
      class(evt_resonance_t), intent(in) :: evt
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: verbose, more_verbose, testflag
    end subroutine evt_resonance_write
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_write &
       (evt, unit, verbose, more_verbose, testflag)
    class(evt_resonance_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    integer :: u, i
    u = given_output_unit (unit)
    call write_separator (u, 2)
    call evt%write_name (u)
    call write_separator (u, 2)
    write (u, "(1x,A,A,A)")  "Process library = '", char (evt%libname), "'"
    if (allocated (evt%res_history_set)) then
       do i = 1, size (evt%res_history_set)
          if (i == evt%selected_component) then
             write (u, "(1x,A,I0,A)")  "Component #", i, ": *"
          else
             write (u, "(1x,A,I0,A)")  "Component #", i, ":"
          end if
          call evt%res_history_set(i)%write (u, indent=1)
       end do
    end if
    call write_separator (u)
    if (allocated (evt%instance)) then
       write (u, "(1x,A)")  "Subprocess instances: allocated"
    else
       write (u, "(1x,A)")  "Subprocess instances: not allocated"
    end if
    if (evt%particle_set_exists) then
       if (evt%selected_history > 0) then
          write (u, "(1x,A,I0)")  "Selected: resonance history #", &
               evt%selected_history
       else
          write (u, "(1x,A)")  "Selected: no resonance history"
       end if
    else
       write (u, "(1x,A)")  "Selected: [none]"
    end if
    write (u, "(1x,A,1x," // FMT_12 // ")")  &
         "On-shell limit    =", evt%on_shell_limit
    write (u, "(1x,A,1x," // FMT_12 // ")")  &
         "On-shell turnoff  =", evt%on_shell_turnoff
    write (u, "(1x,A,1x," // FMT_12 // ")")  &
         "Background factor =", evt%background_factor
    call write_separator (u)
    if (evt%selector_active) then
       write (u, "(2x)", advance="no")
       call evt%selector%write (u, testflag=testflag)
       call write_separator (u)
    end if
    call evt%base_write (u, testflag = testflag, show_set = .false.)
    call write_separator (u)
    if (evt%particle_set_exists) then
       call evt%particle_set%write &
            (u, summary = .true., compressed = .true., testflag = testflag)
       call write_separator (u)
    end if
  end subroutine evt_resonance_write

@ %def evt_resonance_write
@
\subsection{Set contained data}
Insert the resonance data, in form of a pre-generated resonance
history set.  Accumulate the number of histories for each set, to
initialize an array of index offsets for lookup.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: set_resonance_data => evt_resonance_set_resonance_data
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_set_resonance_data (evt, res_history_set)
      class(evt_resonance_t), intent(inout) :: evt
      type(resonance_history_set_t), dimension(:), intent(in) :: res_history_set
    end subroutine evt_resonance_set_resonance_data
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_set_resonance_data (evt, res_history_set)
    class(evt_resonance_t), intent(inout) :: evt
    type(resonance_history_set_t), dimension(:), intent(in) :: res_history_set
    integer :: i
    evt%res_history_set = res_history_set
    allocate (evt%index_offset (size (evt%res_history_set)), source = 0)
    do i = 2, size (evt%res_history_set)
       evt%index_offset(i) = &
            evt%index_offset(i-1) + evt%res_history_set(i-1)%get_n_history ()
    end do
  end subroutine evt_resonance_set_resonance_data

@ %def evt_resonance_set_resonance_data
@ Set the library that contains the resonant subprocesses.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: set_library => evt_resonance_set_library
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_set_library (evt, libname)
      class(evt_resonance_t), intent(inout) :: evt
      type(string_t), intent(in) :: libname
    end subroutine evt_resonance_set_library
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_set_library (evt, libname)
    class(evt_resonance_t), intent(inout) :: evt
    type(string_t), intent(in) :: libname
    evt%libname = libname
  end subroutine evt_resonance_set_library

@ %def evt_resonance_set_library
@ Assign pointers to subprocess instances.  Once a subprocess has been
selected, the instance is used for generating the particle set with
valid quantum-number assignments, ready for resonance insertion.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: set_subprocess_instances &
       => evt_resonance_set_subprocess_instances
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_set_subprocess_instances (evt, instance)
      class(evt_resonance_t), intent(inout) :: evt
      type(process_instance_ptr_t), dimension(:), intent(in) :: instance
    end subroutine evt_resonance_set_subprocess_instances
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_set_subprocess_instances (evt, instance)
    class(evt_resonance_t), intent(inout) :: evt
    type(process_instance_ptr_t), dimension(:), intent(in) :: instance
    evt%instance = instance
  end subroutine evt_resonance_set_subprocess_instances

@ %def evt_resonance_set_subprocess_instances
@ Set the on-shell limit, the relative distance from a resonance that
is still considered to be on-shell.  The probability for being
considered on-shell can be reduced by the turnoff parameter below.
For details, see the [[resonances]] module.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: set_on_shell_limit => evt_resonance_set_on_shell_limit
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_set_on_shell_limit (evt, on_shell_limit)
      class(evt_resonance_t), intent(inout) :: evt
      real(default), intent(in) :: on_shell_limit
    end subroutine evt_resonance_set_on_shell_limit
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_set_on_shell_limit (evt, on_shell_limit)
    class(evt_resonance_t), intent(inout) :: evt
    real(default), intent(in) :: on_shell_limit
    evt%on_shell_limit = on_shell_limit
  end subroutine evt_resonance_set_on_shell_limit

@ %def evt_resonance_set_on_shell_limit
@ Set the Gaussian on-shell turnoff parameter, the width of the
weighting factor for the resonance squared matrix element.  If the
resonance is off shell, this factor reduces the weight of the matrix
element in the selector, such that the probability for considered
resonant is reduced.  The factor is applied only if the offshellness
is less than the [[on_shell_limit]] above.  For details, see the
[[resonances]] module.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: set_on_shell_turnoff => evt_resonance_set_on_shell_turnoff
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_set_on_shell_turnoff (evt, on_shell_turnoff)
      class(evt_resonance_t), intent(inout) :: evt
      real(default), intent(in) :: on_shell_turnoff
    end subroutine evt_resonance_set_on_shell_turnoff
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_set_on_shell_turnoff (evt, on_shell_turnoff)
    class(evt_resonance_t), intent(inout) :: evt
    real(default), intent(in) :: on_shell_turnoff
    evt%on_shell_turnoff = on_shell_turnoff
  end subroutine evt_resonance_set_on_shell_turnoff

@ %def evt_resonance_set_on_shell_turnoff
@ Reweight (suppress) the background contribution if there is a resonance
history that applies.  The event will be registered as background if there is
no applicable resonance history, or if the background configuration has been
selected based on (reweighted) squared matrix elements.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: set_background_factor => evt_resonance_set_background_factor
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_set_background_factor &
         (evt, background_factor)
      class(evt_resonance_t), intent(inout) :: evt
      real(default), intent(in) :: background_factor
    end subroutine evt_resonance_set_background_factor
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_set_background_factor (evt, background_factor)
    class(evt_resonance_t), intent(inout) :: evt
    real(default), intent(in) :: background_factor
    evt%background_factor = background_factor
  end subroutine evt_resonance_set_background_factor

@ %def evt_resonance_set_background_factor
@
\subsection{Selector}
Manually import a random-number generator object.  This should be
done only for testing purposes.  The standard procedure is to
[[connect]] a process to an event transform; this will create an
appropriate [[rng]] from the RNG factory in the process object.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: import_rng => evt_resonance_import_rng
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_import_rng (evt, rng)
      class(evt_resonance_t), intent(inout) :: evt
      class(rng_t), allocatable, intent(inout) :: rng
    end subroutine evt_resonance_import_rng
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_import_rng (evt, rng)
    class(evt_resonance_t), intent(inout) :: evt
    class(rng_t), allocatable, intent(inout) :: rng
    call move_alloc (from = rng, to = evt%rng)
  end subroutine evt_resonance_import_rng

@ %def evt_resonance_import_rng
@
We use a standard selector object to choose from the available resonance
histories.  If the selector is inactive, we do not insert resonances.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: write_selector => evt_resonance_write_selector
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_write_selector (evt, unit, testflag)
      class(evt_resonance_t), intent(in) :: evt
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: testflag
    end subroutine evt_resonance_write_selector
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_write_selector (evt, unit, testflag)
    class(evt_resonance_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (evt%selector_active) then
       call evt%selector%write (u, testflag)
    else
       write (u, "(1x,A)")  "Selector: [inactive]"
    end if
  end subroutine evt_resonance_write_selector

@ %def evt_resonance_write_selector
@
The selector is initialized with relative weights of
histories which need not be normalized.  Channels with weight zero are
ignored.

The [[offset]] will normally be $-1$, so we count from zero, and zero
is a valid result from the selector.  Selecting the zero entry implies
no resonance insertion.  However, this behavior is not hard-coded
here (without offset, no resonance is not possible as a result).
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: init_selector => evt_resonance_init_selector
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_init_selector (evt, weight, offset)
      class(evt_resonance_t), intent(inout) :: evt
      real(default), dimension(:), intent(in) :: weight
      integer, intent(in), optional :: offset
    end subroutine evt_resonance_init_selector
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_init_selector (evt, weight, offset)
    class(evt_resonance_t), intent(inout) :: evt
    real(default), dimension(:), intent(in) :: weight
    integer, intent(in), optional :: offset
    if (any (weight > 0)) then
       call evt%selector%init (weight, offset = offset)
       evt%selector_active = .true.
    else
       evt%selector_active = .false.
    end if
  end subroutine evt_resonance_init_selector

@ %def evt_resonance_init_selector
@ Return all selector weights, for inspection.  Note that the index
counts from zero.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: get_selector_weights => evt_resonance_get_selector_weights
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_get_selector_weights (evt, weight)
      class(evt_resonance_t), intent(in) :: evt
      real(default), dimension(0:), intent(out) :: weight
    end subroutine evt_resonance_get_selector_weights
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_get_selector_weights (evt, weight)
    class(evt_resonance_t), intent(in) :: evt
    real(default), dimension(0:), intent(out) :: weight
    integer :: i
    do i = 0, ubound (weight,1)
       weight(i) = evt%selector%get_weight (i)
    end do
  end subroutine evt_resonance_get_selector_weights

@ %def evt_resonance_get_selector_weights
@
\subsection{Runtime calculations}
Use the associated master process instance and the subprocess
instances to distribute the current momentum set, then compute the
squared matrix elements weights for all subprocesses.

NOTE: Procedures in this subsection are not covered by unit tests
in this module, but by unit tests of the [[restricted_subprocesses]]
module.

Fill the particle set, so the momentum configuration can be used by
the subprocess instances.  The standard workflow is to copy from the
previous particle set.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: fill_momenta => evt_resonance_fill_momenta
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_fill_momenta (evt)
      class(evt_resonance_t), intent(inout) :: evt
    end subroutine evt_resonance_fill_momenta
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_fill_momenta (evt)
    class(evt_resonance_t), intent(inout) :: evt
    integer :: i, n
    if (associated (evt%previous)) then
       evt%particle_set = evt%previous%particle_set
    else if (associated (evt%process_instance)) then
       ! this branch only for unit test
       call evt%process_instance%get_trace &
            (evt%particle_set, i_term=1, n_incoming=evt%process%get_n_in ())
    end if
  end subroutine evt_resonance_fill_momenta

@ %def evt_resonance_fill_momenta
@
Return the indices of those subprocesses which can be considered
on-shell.  The result depends on the stored particle set (outgoing
momenta) and on the on-shell limit value.

The index [[evt%selected_component]] identifies the particular history set that
corresponds to the given process component.  Recall that process
components may have different external particles, so they have
distinct history sets.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: determine_on_shell_histories &
       => evt_resonance_determine_on_shell_histories
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_determine_on_shell_histories &
         (evt, index_array)
      class(evt_resonance_t), intent(in) :: evt
      integer, dimension(:), allocatable, intent(out) :: index_array
    end subroutine evt_resonance_determine_on_shell_histories
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_determine_on_shell_histories &
       (evt, index_array)
    class(evt_resonance_t), intent(in) :: evt
    integer, dimension(:), allocatable, intent(out) :: index_array
    integer :: i
    i = evt%selected_component
    call evt%res_history_set(i)%determine_on_shell_histories &
         (evt%particle_set%get_outgoing_momenta (), &
         evt%on_shell_limit, &
         index_array)
  end subroutine evt_resonance_determine_on_shell_histories

@ %def evt_resonance_determine_on_shell_histories
@ Evaluate selected subprocesses.  (In actual operation, the ones that
have been tagged as on-shell.)

We assume that the MCI, term, and channel indices for the subprocesses
can all be set to 1.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: evaluate_subprocess => evt_resonance_evaluate_subprocess
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_evaluate_subprocess (evt, index_array)
      class(evt_resonance_t), intent(inout) :: evt
      integer, dimension(:), intent(in) :: index_array
    end subroutine evt_resonance_evaluate_subprocess
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_evaluate_subprocess (evt, index_array)
    class(evt_resonance_t), intent(inout) :: evt
    integer, dimension(:), intent(in) :: index_array
    integer :: k, i
    if (allocated (evt%instance)) then
       do k = 1, size (index_array)
          i = index_array(k)
          associate (instance => evt%instance(i)%p)
            call instance%choose_mci (1)
            call instance%set_trace (evt%particle_set, 1, check_match=.false.)
            call instance%recover (channel = 1, i_term = 1, &
                 update_sqme = .true., recover_phs = .false.)
          end associate
       end do
    end if
  end subroutine evt_resonance_evaluate_subprocess

@ %def evt_resonance_evaluate_subprocess
@ Return the current squared matrix-element value of the master
process, and of the selected resonant subprocesses, respectively.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: get_master_sqme => evt_resonance_get_master_sqme
  procedure :: get_subprocess_sqme => evt_resonance_get_subprocess_sqme
<<Resonance insertion: sub interfaces>>=
    module function evt_resonance_get_master_sqme (evt) result (sqme)
      class(evt_resonance_t), intent(in) :: evt
      real(default) :: sqme
    end function evt_resonance_get_master_sqme
    module subroutine evt_resonance_get_subprocess_sqme (evt, sqme, index_array)
      class(evt_resonance_t), intent(in) :: evt
      real(default), dimension(:), intent(out) :: sqme
      integer, dimension(:), intent(in), optional :: index_array
    end subroutine evt_resonance_get_subprocess_sqme
<<Resonance insertion: procedures>>=
  module function evt_resonance_get_master_sqme (evt) result (sqme)
    class(evt_resonance_t), intent(in) :: evt
    real(default) :: sqme
    sqme = evt%process_instance%get_sqme ()
  end function evt_resonance_get_master_sqme

  module subroutine evt_resonance_get_subprocess_sqme (evt, sqme, index_array)
    class(evt_resonance_t), intent(in) :: evt
    real(default), dimension(:), intent(out) :: sqme
    integer, dimension(:), intent(in), optional :: index_array
    integer :: k, i
    if (present (index_array)) then
       sqme = 0
       do k = 1, size (index_array)
          call get_sqme (index_array(k))
       end do
    else
       do i = 1, size (evt%instance)
          call get_sqme (i)
       end do
    end if
  contains
    subroutine get_sqme (i)
      integer, intent(in) :: i
      associate (instance => evt%instance(i)%p)
        sqme(i) = instance%get_sqme ()
      end associate
    end subroutine get_sqme
  end subroutine evt_resonance_get_subprocess_sqme

@ %def evt_resonance_get_master_sqme
@ %def evt_resonance_get_subprocess_sqme
@ Apply a turnoff factor for off-shell kinematics to the [[sqme]]
values.  The [[sqme]] array indices are offset from the resonance
history set entries.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: apply_turnoff_factor => evt_resonance_apply_turnoff_factor
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_apply_turnoff_factor &
         (evt, sqme, index_array)
      class(evt_resonance_t), intent(in) :: evt
      real(default), dimension(:), intent(inout) :: sqme
      integer, dimension(:), intent(in) :: index_array
    end subroutine evt_resonance_apply_turnoff_factor
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_apply_turnoff_factor (evt, sqme, index_array)
    class(evt_resonance_t), intent(in) :: evt
    real(default), dimension(:), intent(inout) :: sqme
    integer, dimension(:), intent(in) :: index_array
    integer :: k, i_res, i_prc
    do k = 1, size (index_array)
       i_res = evt%selected_component
       i_prc = index_array(k) + evt%index_offset(i_res)
       sqme(i_prc) = sqme(i_prc) &
            * evt%res_history_set(i_res)%evaluate_gaussian &
            &   (evt%particle_set%get_outgoing_momenta (), &
            &    evt%on_shell_turnoff, index_array(k))
    end do
  end subroutine evt_resonance_apply_turnoff_factor

@ %def evt_resonance_apply_turnoff_factor
@ We use the calculations of resonant matrix elements to determine
probabilities for all applicable resonance configurations.  This method combines
the steps implemented above.

First, we determine the selected process component.

TODO: the version below selects the first component which is found
active.  This make sense only for standard LO process components,
where exactly one component corresponds to a MCI set.

For the selected process component, we query the kinematics and
determine the applicable resonance histories.  We collect squared
matrix elements for those resonance histories and compare them to the
master-process squared matrix element.

The result is the probability for each resonance history
together with the probability for non-resonant background (zeroth
entry).  The latter is defined as the difference between the complete
process result and the sum of the resonances, ignoring the possibility
for interference.  If the complete process result is actually
undershooting the sum of resonances, we nevertheless count the
background with positive probability.

When looking up the subprocess sqme, we must add the [[index_offset]]
to the resulting array, since the indices returned by the individual
history set all count from one, while the subprocess instances that
belong to process components are collected in one flat array.

After determining matrix elements and background, we may reduce the
weight of the matrix elements in the selector by applying a turnoff
factor.

The factor [[background_factor]] indicates whether to include the background
contribution at all, as long as there is a nonvanishing resonance
contribution.  Note that instead of setting background to zero, we just
multiply it by a very small number.  This ensures that indices are assigned
correctly, and that background will eventually be selected if smooth turnoff
is chosen.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: compute_probabilities => evt_resonance_compute_probabilities
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_compute_probabilities (evt)
      class(evt_resonance_t), intent(inout) :: evt
    end subroutine evt_resonance_compute_probabilities
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_compute_probabilities (evt)
    class(evt_resonance_t), intent(inout) :: evt
    integer, dimension(:), allocatable :: index_array
    real(default) :: sqme_master, sqme_sum, sqme_bg
    real(default), dimension(:), allocatable :: sqme_res
    integer :: n, ic
    if (.not. associated (evt%process_instance))  return
    n = size (evt%instance)
    call evt%select_component (0)
    FIND_ACTIVE_COMPONENT: do ic = 1, evt%process%get_n_components ()
       if (evt%process%component_is_selected (ic)) then
          call evt%select_component (ic)
          exit FIND_ACTIVE_COMPONENT
       end if
    end do FIND_ACTIVE_COMPONENT
    if (evt%selected_component > 0) then
       call evt%determine_on_shell_histories (index_array)
    else
       allocate (index_array (0))
    end if
    call evt%evaluate_subprocess &
         (index_array + evt%index_offset(evt%selected_component))
    allocate (sqme_res (n), source = 0._default)
    call evt%get_subprocess_sqme &
         (sqme_res, index_array + evt%index_offset(evt%selected_component))
    sqme_master = evt%get_master_sqme ()
    sqme_sum = sum (sqme_res)
    sqme_bg = abs (sqme_master - sqme_sum)
    if (evt%on_shell_turnoff > 0) then
       call evt%apply_turnoff_factor (sqme_res, index_array)
    end if
    if (any (sqme_res > 0)) then
       sqme_bg = sqme_bg * evt%background_factor
    end if
    call evt%init_selector ([sqme_bg, sqme_res], offset = -1)
  end subroutine evt_resonance_compute_probabilities

@ %def evt_resonance_compute_probabilities
@ Set the selected component (unit tests).
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: select_component => evt_resonance_select_component
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_select_component (evt, i_component)
      class(evt_resonance_t), intent(inout) :: evt
      integer, intent(in) :: i_component
    end subroutine evt_resonance_select_component
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_select_component (evt, i_component)
    class(evt_resonance_t), intent(inout) :: evt
    integer, intent(in) :: i_component
    evt%selected_component = i_component
  end subroutine evt_resonance_select_component

@ %def evt_resonance_select_component
@
\subsection{Sanity check}
Check the color assignment, which may be wrong for the inserted resonances.
Delegated to the particle-set component.  Return offending particle
indices and, optionally, particles as arrays.

This is done in a unit test.  The current algorithm, i.e., selecting
the color assignment from the resonant-subprocess instance, should not
generate invalid color assignments.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: find_prt_invalid_color => evt_resonance_find_prt_invalid_color
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_find_prt_invalid_color (evt, index, prt)
      class(evt_resonance_t), intent(in) :: evt
      integer, dimension(:), allocatable, intent(out) :: index
      type(particle_t), dimension(:), allocatable, intent(out), optional :: prt
    end subroutine evt_resonance_find_prt_invalid_color
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_find_prt_invalid_color (evt, index, prt)
    class(evt_resonance_t), intent(in) :: evt
    integer, dimension(:), allocatable, intent(out) :: index
    type(particle_t), dimension(:), allocatable, intent(out), optional :: prt
    if (evt%particle_set_exists) then
       call evt%particle_set%find_prt_invalid_color (index, prt)
    else
       allocate (prt (0))
    end if
  end subroutine evt_resonance_find_prt_invalid_color

@ %def evt_resonance_find_prt_invalid_color
@
\subsection{API implementation}
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: prepare_new_event => evt_resonance_prepare_new_event
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_prepare_new_event (evt, i_mci, i_term)
      class(evt_resonance_t), intent(inout) :: evt
      integer, intent(in) :: i_mci, i_term
    end subroutine evt_resonance_prepare_new_event
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_prepare_new_event (evt, i_mci, i_term)
    class(evt_resonance_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
  end subroutine evt_resonance_prepare_new_event

@ %def evt_resonance_prepare_new_event
@ Select one of the histories, based on the momentum array from the
current particle set.  Compute the probabilities for all resonant
subprocesses and initialize the selector accordingly.  Then select one
resonance history, or none.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: generate_weighted => evt_resonance_generate_weighted
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_generate_weighted (evt, probability)
      class(evt_resonance_t), intent(inout) :: evt
      real(default), intent(inout) :: probability
    end subroutine evt_resonance_generate_weighted
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_generate_weighted (evt, probability)
    class(evt_resonance_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    integer :: i_term
    call evt%fill_momenta ()
    call evt%compute_probabilities ()
    if (associated (evt%process_instance)) then
       i_term = evt%process_instance%get_first_active_i_term ()
       if (evt%process_instance%term(i_term)%passed) then
          call evt%selector%generate (evt%rng, evt%selected_history)
       end if
    else
       call evt%selector%generate (evt%rng, evt%selected_history)
    end if
    probability = 1
  end subroutine evt_resonance_generate_weighted

@ %def evt_resonance_generate_weighted
@ Here take the current particle set and insert resonance intermediate
states if applicable.  The resonance history has already been chosen
by the generator above.  If no resonance history applies, just retain
the particle set.

If a resonance history applies, we factorize the exclusive interaction
of the selected (resonance-process) process instance.  With a
temporary particle set [[prt_set]] as workspace, we the insert the
resonances, reinstate parent-child relations and set colors and
momenta for the resonances.  The temporary is then copied back.

Taking the event data from the resonant subprocess instead of the
master process, guarantees that all flavor, helicity, and color
assignments are valid for the selected resonance history.  Note that
the transform may thus choose a quantum-number combination that is
different from the one chosen by the master process.

The [[i_term]] value for the selected subprocess instance is always
1.  We support only LO process.  For those, the master process may
have several terms (= components) that correspond to different
external states.  The subprocesses are distinct, each one corresponds
to a definite master component, and by itself it consists of a single
component/term.

However, if the selector chooses resonance history \#0, i.e., no
resonance, we just copy the particle set from the previous (i.e.,
trivial) event transform and ignore all subprocess data.
<<Resonance insertion: evt resonance: TBP>>=
  procedure :: make_particle_set => evt_resonance_make_particle_set
<<Resonance insertion: sub interfaces>>=
    module subroutine evt_resonance_make_particle_set &
         (evt, factorization_mode, keep_correlations, r)
      class(evt_resonance_t), intent(inout) :: evt
      integer, intent(in) :: factorization_mode
      logical, intent(in) :: keep_correlations
      real(default), dimension(:), intent(in), optional :: r
    end subroutine evt_resonance_make_particle_set
<<Resonance insertion: procedures>>=
  module subroutine evt_resonance_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_resonance_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    type(particle_set_t), target :: prt_set
    type(particle_t), dimension(:), allocatable :: prt
    integer :: n_beam, n_in, n_vir, n_res, n_out, i, i_res, i_term, i_tree
    type(interaction_t), pointer :: int_matrix, int_flows
    integer, dimension(:), allocatable :: map
    type(resonance_tree_t) :: res_tree
    if (associated (evt%previous)) then
       if (evt%previous%particle_set_exists) then
          if (evt%selected_history > 0) then
             if (allocated (evt%instance)) then
                associate (instance => evt%instance(evt%selected_history)%p)
                  call instance%evaluate_event_data (weight = 1._default)
                  i_term = 1
                  int_matrix => instance%get_matrix_int_ptr (i_term)
                  int_flows  => instance%get_flows_int_ptr (i_term)
                  call evt%factorize_interactions (int_matrix, int_flows, &
                       factorization_mode, keep_correlations, r)
                  call evt%tag_incoming ()
                end associate
             else  ! this branch only for unit test
                evt%particle_set = evt%previous%particle_set
             end if
             i_tree = evt%selected_history &
                  - evt%index_offset(evt%selected_component)
             call evt%res_history_set(evt%selected_component)%get_tree &
                  (i_tree, res_tree)
             n_beam = evt%particle_set%get_n_beam ()
             n_in = evt%particle_set%get_n_in ()
             n_vir = evt%particle_set%get_n_vir ()
             n_out = evt%particle_set%get_n_out ()
             n_res = res_tree%get_n_resonances ()
             allocate (map (n_beam + n_in + n_vir + n_out))
             map(1:n_beam+n_in+n_vir) &
                  = [(i, i = 1, n_beam+n_in+n_vir)]
             map(n_beam+n_in+n_vir+1:n_beam+n_in+n_vir+n_out) &
                  = [(i + n_res, &
                  &   i = n_beam+n_in+n_vir+1, &
                  &       n_beam+n_in+n_vir+n_out)]
             call prt_set%transfer (evt%particle_set, n_res, map)
             do i = 1, n_res
                i_res = n_beam + n_in + n_vir + i
                call prt_set%insert (i_res, &
                     PRT_RESONANT, &
                     res_tree%get_flv (i), &
                     res_tree%get_children (i, &
                     &   n_beam+n_in+n_vir, n_beam+n_in+n_vir+n_res))
             end do
             do i = n_res, 1, -1
                i_res = n_beam + n_in + n_vir + i
                call prt_set%recover_color (i_res)
             end do
             call prt_set%set_momentum &
                  (map(:), evt%particle_set%get_momenta (), on_shell = .true.)
             do i = n_res, 1, -1
                i_res = n_beam + n_in + n_vir + i
                call prt_set%recover_momentum (i_res)
             end do
             call evt%particle_set%final ()
             evt%particle_set = prt_set
             call prt_set%final ()
             evt%particle_set_exists = .true.
          else  ! retain particle set, as copied from previous evt
             evt%particle_set_exists = .true.
          end if
       else
          evt%particle_set_exists = .false.
       end if
    else
       evt%particle_set_exists = .false.
    end if
  end subroutine evt_resonance_make_particle_set

@ %def event_resonance_make_particle_set
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[resonance_insertion_ut.f90]]>>=
<<File header>>

module resonance_insertion_ut
  use unit_tests
  use resonance_insertion_uti

<<Standard module head>>

<<Resonance insertion: public test>>

contains

<<Resonance insertion: test driver>>

end module resonance_insertion_ut
@ %def resonance_insertion_ut
@
<<[[resonance_insertion_uti.f90]]>>=
<<File header>>

module resonance_insertion_uti

<<Use kinds>>
<<Use strings>>
  use format_utils, only: write_separator
  use os_interface
  use lorentz
  use rng_base, only: rng_t
  use flavors, only: flavor_t
  use colors, only: color_t
  use models, only: syntax_model_file_init, syntax_model_file_final
  use models, only: model_list_t, model_t
  use particles, only: particle_t, particle_set_t

  use resonances, only: resonance_info_t
  use resonances, only: resonance_history_t
  use resonances, only: resonance_history_set_t

  use event_transforms
  use resonance_insertion

  use rng_base_ut, only: rng_test_t

<<Standard module head>>

<<Resonance insertion: test declarations>>

contains

<<Resonance insertion: tests>>

end module resonance_insertion_uti

@ %def resonance_insertion_uti
@ API: driver for the unit tests below.
<<Resonance insertion: public test>>=
  public :: resonance_insertion_test
<<Resonance insertion: test driver>>=
  subroutine resonance_insertion_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Resonance insertion: execute tests>>
  end subroutine resonance_insertion_test

@ %def resonance_insertion_test
@
\subsubsection{Test resonance insertion as event transform}
Insert a resonance (W boson) into an event with momentum assignment.
<<Resonance insertion: execute tests>>=
  call test (resonance_insertion_1, "resonance_insertion_1", &
       "simple resonance insertion", &
       u, results)
<<Resonance insertion: test declarations>>=
  public :: resonance_insertion_1
<<Resonance insertion: tests>>=
  subroutine resonance_insertion_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(particle_set_t) :: pset
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(resonance_info_t) :: res_info
    type(resonance_history_t) :: res_history
    type(resonance_history_set_t), dimension(1) :: res_history_set
    type(evt_trivial_t), target :: evt_trivial
    type(evt_resonance_t), target :: evt_resonance
    type(flavor_t) :: fw
    type(color_t) :: col
    real(default) :: mw, ew, pw
    type(vector4_t), dimension(5) :: p
    class(rng_t), allocatable :: rng
    real(default) :: probability
    integer, dimension(:), allocatable :: i_invalid
    type(particle_t), dimension(:), allocatable :: prt_invalid
    integer :: i

    write (u, "(A)")  "* Test output: resonance_insertion_1"
    write (u, "(A)")  "*   Purpose: apply simple resonance insertion"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)
    ! reset slightly in order to avoid a rounding ambiguity
    call model%set_real (var_str ("mW"), 80.418_default)

    write (u, "(A)")  "* Initialize particle set"
    write (u, "(A)")

    call pset%init_direct (n_beam = 0, n_in = 2, n_rem = 0, n_vir = 0, n_out = 3, &
         pdg = [1, -1, 1, -2, 24], model = model)

    call fw%init (24, model)

    mw = fw%get_mass ()
    ew = 200._default
    pw = sqrt (ew**2 - mw**2)

    p(1) = vector4_moving (ew, ew, 3)
    p(2) = vector4_moving (ew,-ew, 3)
    p(3) = vector4_moving (ew/2, vector3_moving ([pw/2, mw/2, 0._default]))
    p(4) = vector4_moving (ew/2, vector3_moving ([pw/2,-mw/2, 0._default]))
    p(5) = vector4_moving (ew, vector3_moving ([-pw, 0._default, 0._default]))

    call pset%set_momentum (p, on_shell = .true.)

    call col%init_col_acl (1,0)
    call pset%set_color (1, col)

    call col%init_col_acl (0,1)
    call pset%set_color (2, col)

    call col%init_col_acl (2,0)
    call pset%set_color (3, col)

    call col%init_col_acl (0,2)
    call pset%set_color (4, col)

    call col%init_col_acl (0,0)
    call pset%set_color (5, col)

    write (u, "(A)")  "* Fill trivial event transform"
    write (u, "(A)")

    call evt_trivial%reset ()
    call evt_trivial%set_particle_set (pset, 1, 1)
    call evt_trivial%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Prepare resonance history set"
    write (u, "(A)")

    call res_history_set(1)%init ()

    call res_info%init (3, -24, model, 2)
    call res_history%add_resonance (res_info)
    call res_history_set(1)%enter (res_history)
    call res_history%clear ()

    call res_history_set(1)%freeze ()

    write (u, "(A)")  "* Initialize resonance insertion transform"
    write (u, "(A)")

    evt_trivial%next => evt_resonance
    evt_resonance%previous => evt_trivial

    allocate (rng_test_t :: rng)
    call evt_resonance%import_rng (rng)

    call evt_resonance%set_resonance_data (res_history_set)
    call evt_resonance%select_component (1)
    call evt_resonance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Fill resonance insertion transform"
    write (u, "(A)")

    call evt_resonance%prepare_new_event (1, 1)
    call evt_resonance%init_selector ([1._default])
    call evt_resonance%generate_weighted (probability)
    call evt_resonance%make_particle_set (0, .false.)

    call evt_resonance%write (u)

    write (u, "(A)")
    write (u, "(A,1x,F8.5)")  "Event probability =", probability

    write (u, "(A)")
    call evt_resonance%find_prt_invalid_color (i_invalid, prt_invalid)
    write (u, "(A)")  "Particles with invalid color:"
    select case (size (prt_invalid))
    case (0)
       write (u, "(2x,A)")  "[none]"
    case default
       do i = 1, size (prt_invalid)
          write (u, "(1x,A,1x,I0)", advance="no")  "Particle", i_invalid(i)
          call prt_invalid(i)%write (u)
       end do
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_resonance%final ()
    call evt_trivial%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: resonance_insertion_1"

  end subroutine resonance_insertion_1

@ %def resonance_insertion_1
@
\subsubsection{Resonance insertion with color mismatch}
Same as previous test (but no momenta); resonance insertion should fail
because of color mismatch: W boson is color-neutral.
<<Resonance insertion: execute tests>>=
  call test (resonance_insertion_2, "resonance_insertion_2", &
       "resonance color mismatch", &
       u, results)
<<Resonance insertion: test declarations>>=
  public :: resonance_insertion_2
<<Resonance insertion: tests>>=
  subroutine resonance_insertion_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(particle_set_t) :: pset
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(resonance_info_t) :: res_info
    type(resonance_history_t) :: res_history
    type(resonance_history_set_t), dimension(1) :: res_history_set
    type(evt_trivial_t), target :: evt_trivial
    type(evt_resonance_t), target :: evt_resonance
    type(color_t) :: col
    class(rng_t), allocatable :: rng
    real(default) :: probability
    type(particle_t), dimension(:), allocatable :: prt_invalid
    integer, dimension(:), allocatable :: i_invalid
    integer :: i

    write (u, "(A)")  "* Test output: resonance_insertion_2"
    write (u, "(A)")  "*   Purpose: resonance insertion with color mismatch"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, "(A)")  "* Initialize particle set"
    write (u, "(A)")

    call pset%init_direct (n_beam = 0, n_in = 2, n_rem = 0, n_vir = 0, n_out = 3, &
         pdg = [1, -1, 1, -2, 24], model = model)

    call col%init_col_acl (1,0)
    call pset%set_color (1, col)

    call col%init_col_acl (0,2)
    call pset%set_color (2, col)

    call col%init_col_acl (1,0)
    call pset%set_color (3, col)

    call col%init_col_acl (0,2)
    call pset%set_color (4, col)

    call col%init_col_acl (0,0)
    call pset%set_color (5, col)

    write (u, "(A)")  "* Fill trivial event transform"
    write (u, "(A)")

    call evt_trivial%reset ()
    call evt_trivial%set_particle_set (pset, 1, 1)
    call evt_trivial%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Prepare resonance history set"
    write (u, "(A)")

    call res_history_set(1)%init ()

    call res_info%init (3, -24, model, 2)
    call res_history%add_resonance (res_info)
    call res_history_set(1)%enter (res_history)
    call res_history%clear ()

    call res_history_set(1)%freeze ()

    write (u, "(A)")  "* Initialize resonance insertion transform"
    write (u, "(A)")

    evt_trivial%next => evt_resonance
    evt_resonance%previous => evt_trivial

    allocate (rng_test_t :: rng)
    call evt_resonance%import_rng (rng)

    call evt_resonance%set_resonance_data (res_history_set)
    call evt_resonance%select_component (1)
    call evt_resonance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Fill resonance insertion transform"
    write (u, "(A)")

    call evt_resonance%prepare_new_event (1, 1)
    call evt_resonance%init_selector ([1._default])
    call evt_resonance%generate_weighted (probability)
    call evt_resonance%make_particle_set (0, .false.)

    call evt_resonance%write (u)

    write (u, "(A)")
    write (u, "(A,1x,F8.5)")  "Event probability =", probability

    write (u, "(A)")
    call evt_resonance%find_prt_invalid_color (i_invalid, prt_invalid)
    write (u, "(A)")  "Particles with invalid color:"
    select case (size (prt_invalid))
    case (0)
       write (u, "(2x,A)")  "[none]"
    case default
       do i = 1, size (prt_invalid)
          write (u, "(1x,A,1x,I0)", advance="no")  "Particle", i_invalid(i)
          call prt_invalid(i)%write (u)
       end do
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_resonance%final ()
    call evt_trivial%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: resonance_insertion_2"

  end subroutine resonance_insertion_2

@ %def resonance_insertion_2
@
\subsubsection{Complex resonance history}
This is the resonance history $u\bar u \to (t\to W^+ b) + (\bar t\to
(h \to b\bar b) + (\bar t^\ast \to W^-\bar b))$.
<<Resonance insertion: execute tests>>=
  call test (resonance_insertion_3, "resonance_insertion_3", &
       "complex resonance history", &
       u, results)
<<Resonance insertion: test declarations>>=
  public :: resonance_insertion_3
<<Resonance insertion: tests>>=
  subroutine resonance_insertion_3 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(particle_set_t) :: pset
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(resonance_info_t) :: res_info
    type(resonance_history_t) :: res_history
    type(resonance_history_set_t), dimension(1) :: res_history_set
    type(evt_trivial_t), target :: evt_trivial
    type(evt_resonance_t), target :: evt_resonance
    type(color_t) :: col
    class(rng_t), allocatable :: rng
    real(default) :: probability
    type(particle_t), dimension(:), allocatable :: prt_invalid
    integer, dimension(:), allocatable :: i_invalid
    integer :: i

    write (u, "(A)")  "* Test output: resonance_insertion_3"
    write (u, "(A)")  "*   Purpose: resonance insertion with color mismatch"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, "(A)")  "* Initialize particle set"
    write (u, "(A)")

    call pset%init_direct (n_beam = 0, n_in = 2, n_rem = 0, n_vir = 0, n_out = 6, &
         pdg = [2, -2, 24, 5, 5, -5, -24, -5], model = model)

    call col%init_col_acl (1,0)
    call pset%set_color (1, col)

    call col%init_col_acl (0,2)
    call pset%set_color (2, col)

    call col%init_col_acl (0,0)
    call pset%set_color (3, col)

    call col%init_col_acl (1,0)
    call pset%set_color (4, col)

    call col%init_col_acl (3,0)
    call pset%set_color (5, col)

    call col%init_col_acl (0,3)
    call pset%set_color (6, col)

    call col%init_col_acl (0,0)
    call pset%set_color (7, col)

    call col%init_col_acl (0,2)
    call pset%set_color (8, col)

    write (u, "(A)")  "* Fill trivial event transform"
    write (u, "(A)")

    call evt_trivial%reset ()
    call evt_trivial%set_particle_set (pset, 1, 1)
    call evt_trivial%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Prepare resonance history set"
    write (u, "(A)")

    call res_history_set(1)%init ()

    call res_info%init (3, 6, model, 6)
    call res_history%add_resonance (res_info)
    call res_info%init (12, 25, model, 6)
    call res_history%add_resonance (res_info)
    call res_info%init (60, -6, model, 6)
    call res_history%add_resonance (res_info)
    call res_history_set(1)%enter (res_history)
    call res_history%clear ()

    call res_history_set(1)%freeze ()

    write (u, "(A)")  "* Initialize resonance insertion transform"
    write (u, "(A)")

    evt_trivial%next => evt_resonance
    evt_resonance%previous => evt_trivial

    allocate (rng_test_t :: rng)
    call evt_resonance%import_rng (rng)

    call evt_resonance%set_resonance_data (res_history_set)
    call evt_resonance%select_component (1)
    call evt_resonance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Fill resonance insertion transform"
    write (u, "(A)")

    call evt_resonance%prepare_new_event (1, 1)
    call evt_resonance%init_selector ([1._default])
    call evt_resonance%generate_weighted (probability)
    call evt_resonance%make_particle_set (0, .false.)

    call evt_resonance%write (u)

    write (u, "(A)")
    call evt_resonance%find_prt_invalid_color (i_invalid, prt_invalid)
    write (u, "(A)")  "Particles with invalid color:"
    select case (size (prt_invalid))
    case (0)
       write (u, "(2x,A)")  "[none]"
    case default
       do i = 1, size (prt_invalid)
          write (u, "(1x,A,1x,I0)", advance="no")  "Particle", i_invalid(i)
          call prt_invalid(i)%write (u)
       end do
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_resonance%final ()
    call evt_trivial%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: resonance_insertion_3"

  end subroutine resonance_insertion_3

@ %def resonance_insertion_3
@
\subsubsection{Resonance history selection}
Another test with zero momenta: select one of several resonant channels
using the selector component.
<<Resonance insertion: execute tests>>=
  call test (resonance_insertion_4, "resonance_insertion_4", &
       "resonance history selection", &
       u, results)
<<Resonance insertion: test declarations>>=
  public :: resonance_insertion_4
<<Resonance insertion: tests>>=
  subroutine resonance_insertion_4 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(particle_set_t) :: pset
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(resonance_info_t) :: res_info
    type(resonance_history_t) :: res_history
    type(resonance_history_set_t), dimension(1) :: res_history_set
    type(evt_trivial_t), target :: evt_trivial
    type(evt_resonance_t), target :: evt_resonance
    type(color_t) :: col
    class(rng_t), allocatable :: rng
    real(default) :: probability
    integer :: i

    write (u, "(A)")  "* Test output: resonance_insertion_4"
    write (u, "(A)")  "*   Purpose: resonance history selection"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, "(A)")  "* Initialize particle set"
    write (u, "(A)")

    call pset%init_direct (n_beam = 0, n_in = 2, n_rem = 0, n_vir = 0, n_out = 4, &
         pdg = [1, -1, 1, -2, -3, 4], model = model)

    write (u, "(A)")  "* Fill trivial event transform"
    write (u, "(A)")

    call evt_trivial%reset ()
    call evt_trivial%set_particle_set (pset, 1, 1)
    call evt_trivial%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Prepare resonance history set"
    write (u, "(A)")

    call res_history_set(1)%init ()

    call res_info%init (3, -24, model, 4)
    call res_history%add_resonance (res_info)
    call res_history_set(1)%enter (res_history)
    call res_history%clear ()

    call res_info%init (12, 24, model, 4)
    call res_history%add_resonance (res_info)
    call res_history_set(1)%enter (res_history)
    call res_history%clear ()

    call res_info%init (12, 24, model, 4)
    call res_history%add_resonance (res_info)
    call res_info%init (15, 25, model, 4)
    call res_history%add_resonance (res_info)
    call res_history_set(1)%enter (res_history)
    call res_history%clear ()

    call res_history_set(1)%freeze ()

    write (u, "(A)")  "* Initialize resonance insertion transform"
    write (u, "(A)")

    evt_trivial%next => evt_resonance
    evt_resonance%previous => evt_trivial

    allocate (rng_test_t :: rng)
    call evt_resonance%import_rng (rng)

    call evt_resonance%set_resonance_data (res_history_set)
    call evt_resonance%select_component (1)
    call evt_resonance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Fill resonance insertion transform"
    write (u, "(A)")

    do i = 1, 6
       write (u, "(A,1x,I0)")  "* Event #", i
       write (u, "(A)")

       call evt_resonance%prepare_new_event (1, 1)
       call evt_resonance%init_selector ([1._default, 2._default, 1._default])
       call evt_resonance%generate_weighted (probability)
       call evt_resonance%make_particle_set (0, .false.)

       call evt_resonance%write (u)
       write (u, "(A)")
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_resonance%final ()
    call evt_trivial%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: resonance_insertion_4"

  end subroutine resonance_insertion_4

@ %def resonance_insertion_4
@
\subsubsection{Resonance history selection}
Another test with zero momenta: select either a resonant channel or no
resonance.
<<Resonance insertion: execute tests>>=
  call test (resonance_insertion_5, "resonance_insertion_5", &
       "resonance history on/off", &
       u, results)
<<Resonance insertion: test declarations>>=
  public :: resonance_insertion_5
<<Resonance insertion: tests>>=
  subroutine resonance_insertion_5 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(particle_set_t) :: pset
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(resonance_info_t) :: res_info
    type(resonance_history_t) :: res_history
    type(resonance_history_set_t), dimension(1) :: res_history_set
    type(evt_trivial_t), target :: evt_trivial
    type(evt_resonance_t), target :: evt_resonance
    type(color_t) :: col
    class(rng_t), allocatable :: rng
    real(default) :: probability
    integer :: i

    write (u, "(A)")  "* Test output: resonance_insertion_5"
    write (u, "(A)")  "*   Purpose: resonance history selection including no resonance"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, "(A)")  "* Initialize particle set"
    write (u, "(A)")

    call pset%init_direct (n_beam = 0, n_in = 2, n_rem = 0, n_vir = 0, n_out = 4, &
         pdg = [1, -1, 1, -2, -3, 4], model = model)

    write (u, "(A)")  "* Fill trivial event transform"
    write (u, "(A)")

    call evt_trivial%reset ()
    call evt_trivial%set_particle_set (pset, 1, 1)

    write (u, "(A)")  "* Prepare resonance history set"
    write (u, "(A)")

    call res_history_set(1)%init ()

    call res_info%init (3, -24, model, 4)
    call res_history%add_resonance (res_info)
    call res_history_set(1)%enter (res_history)
    call res_history%clear ()

    call res_history_set(1)%freeze ()

    write (u, "(A)")  "* Initialize resonance insertion transform"
    write (u, "(A)")

    evt_trivial%next => evt_resonance
    evt_resonance%previous => evt_trivial

    allocate (rng_test_t :: rng)
    call evt_resonance%import_rng (rng)

    call evt_resonance%set_resonance_data (res_history_set)
    call evt_resonance%select_component (1)

    write (u, "(A)")  "* Fill resonance insertion transform"
    write (u, "(A)")

    do i = 1, 2
       write (u, "(A,1x,I0)")  "* Event #", i
       write (u, "(A)")

       call evt_resonance%prepare_new_event (1, 1)
       call evt_resonance%init_selector ([1._default, 3._default], offset = -1)
       call evt_resonance%generate_weighted (probability)
       call evt_resonance%make_particle_set (0, .false.)

       call evt_resonance%write (u)
       write (u, "(A)")
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_resonance%final ()
    call evt_trivial%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: resonance_insertion_5"

  end subroutine resonance_insertion_5

@ %def resonance_insertion_5
@
\subsubsection{Resonance insertion with structured beams}
Insert a resonance (W boson) into an event with beam and virtual
particles.
<<Resonance insertion: execute tests>>=
  call test (resonance_insertion_6, "resonance_insertion_6", &
       "resonance insertion with beam structure", &
       u, results)
<<Resonance insertion: test declarations>>=
  public :: resonance_insertion_6
<<Resonance insertion: tests>>=
  subroutine resonance_insertion_6 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(particle_set_t) :: pset
    type(model_t), pointer :: model
    type(resonance_info_t) :: res_info
    type(resonance_history_t) :: res_history
    type(resonance_history_set_t), dimension(1) :: res_history_set
    type(evt_trivial_t), target :: evt_trivial
    type(evt_resonance_t), target :: evt_resonance
    class(rng_t), allocatable :: rng
    real(default) :: probability

    write (u, "(A)")  "* Test output: resonance_insertion_6"
    write (u, "(A)")  "*   Purpose: resonance insertion with structured beams"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, "(A)")  "* Initialize particle set"
    write (u, "(A)")

    call pset%init_direct (n_beam = 2, n_in = 2, n_rem = 2, n_vir = 0, n_out = 2, &
         pdg = [11, -11, 11, -11, 22, 22, 13, -13], model = model)

    write (u, "(A)")  "* Fill trivial event transform"
    write (u, "(A)")

    call evt_trivial%reset ()
    call evt_trivial%set_particle_set (pset, 1, 1)
    call evt_trivial%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Prepare resonance history set"
    write (u, "(A)")

    call res_history_set(1)%init ()

    call res_info%init (3, 23, model, 2)
    call res_history%add_resonance (res_info)
    call res_history_set(1)%enter (res_history)
    call res_history%clear ()

    call res_history_set(1)%freeze ()

    write (u, "(A)")  "* Initialize resonance insertion transform"
    write (u, "(A)")

    evt_trivial%next => evt_resonance
    evt_resonance%previous => evt_trivial

    allocate (rng_test_t :: rng)
    call evt_resonance%import_rng (rng)

    call evt_resonance%set_resonance_data (res_history_set)
    call evt_resonance%select_component (1)
    call evt_resonance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Fill resonance insertion transform"
    write (u, "(A)")

    call evt_resonance%prepare_new_event (1, 1)
    call evt_resonance%init_selector ([1._default])
    call evt_resonance%generate_weighted (probability)
    call evt_resonance%make_particle_set (0, .false.)

    call evt_resonance%write (u)

    write (u, "(A)")
    write (u, "(A,1x,F8.5)")  "Event probability =", probability

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_resonance%final ()
    call evt_trivial%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: resonance_insertion_6"

  end subroutine resonance_insertion_6

@ %def resonance_insertion_6
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Recoil kinematics}
<<[[recoil_kinematics.f90]]>>=
<<File header>>

module recoil_kinematics

<<Use kinds>>
  use lorentz, only: vector4_t
  use lorentz, only: vector4_null
  use lorentz, only: vector4_moving
  use lorentz, only: vector3_moving
  use lorentz, only: transverse_part
  use lorentz, only: lorentz_transformation_t
  use lorentz, only: inverse
  use lorentz, only: boost
  use lorentz, only: transformation
  use lorentz, only: operator(+)
  use lorentz, only: operator(-)
  use lorentz, only: operator(*)
  use lorentz, only: operator(**)
  use lorentz, only: lambda

<<Standard module head>>

<<Recoil kinematics: public>>

<<Recoil kinematics: parameters>>

<<Recoil kinematics: types>>

  interface
<<Recoil kinematics: sub interfaces>>
  end interface

end module recoil_kinematics
@ %def recoil_kinematics
@
<<[[recoil_kinematics_sub.f90]]>>=
<<File header>>

submodule (recoil_kinematics) recoil_kinematics_s

  use constants, only: twopi

  implicit none

contains

<<Recoil kinematics: procedures>>

end submodule recoil_kinematics_s

@ %def recoil_kinematics_s
@
\subsection{$\phi$ sampler}
This is trivial.  Generate an azimuthal angle, given a $(0,1)$ RNG parameter.
<<Recoil kinematics: procedures>>=
  elemental subroutine generate_phi_recoil (r, phi)
    real(default), intent(in) :: r
    real(default), intent(out) :: phi

    phi = r * twopi

  end subroutine generate_phi_recoil

@ %def generate_phi_recoil
@
\subsection{$Q^2$ sampler}
The dynamics of factorization suggests to generate a flat $Q^2$
distribution from a (random) number, event by event.

At the lowest momentum transfer values, the particle (electron) mass
sets a smooth cutoff.  The formula can produce $Q$ values below the
electron mass, down to zero, but with a power distribution that
eventually evolves into the expected logarithmic distribution for $Q^2 >
m^2$.

We are talking about the absolute value here, so all $Q^2$
values are positive.  For the actual momentum transfer, $q^2=-Q^2$.
<<Recoil kinematics: public>>=
  public :: generate_q2_recoil
<<Recoil kinematics: sub interfaces>>=
    elemental module subroutine generate_q2_recoil (s, x_bar, q2_max, m2, r, q2)
      real(default), intent(in) :: s
      real(default), intent(in) :: q2_max
      real(default), intent(in) :: x_bar
      real(default), intent(in) :: m2
      real(default), intent(in) :: r
      real(default), intent(out) :: q2
    end subroutine generate_q2_recoil
<<Recoil kinematics: procedures>>=
  elemental module subroutine generate_q2_recoil (s, x_bar, q2_max, m2, r, q2)
    real(default), intent(in) :: s
    real(default), intent(in) :: q2_max
    real(default), intent(in) :: x_bar
    real(default), intent(in) :: m2
    real(default), intent(in) :: r
    real(default), intent(out) :: q2

    real(default) :: q2_max_evt

    q2_max_evt = q2_max_event (s, x_bar, q2_max)

    q2 = m2 * (exp (r * log (1 + (q2_max_evt / m2))) - 1)

  end subroutine generate_q2_recoil

@ %def generate_q_recoil
@
The $Q$ distribution is cut off from above by the kinematic limit,
which depends on the energy that is available for the radiated photon,
or by a user-defined cutoff -- whichever is less.  The kinematic limit
fits the formulas for recoil momenta (see below), and it also
implicitly enters the ISR collinear structure function, so the
normalization of the distribution should be correct.
<<Recoil kinematics: procedures>>=
  elemental function q2_max_event (s, x_bar, q2_max) result (q2)
    real(default), intent(in) :: s
    real(default), intent(in) :: x_bar
    real(default), intent(in) :: q2_max
    real(default) :: q2

    q2 = min (x_bar * s, q2_max)

  end function q2_max_event

@ %def q2_max_event
@
\subsection{Kinematics functions}
Given values for energies, $Q_{1,2}^2$, azimuthal angle, compute the
matching polar angle of the radiating particle.  The subroutine
returns $\sin\theta$ and $\cos\theta$.
<<Recoil kinematics: procedures>>=
  subroutine polar_angles (s, xb, rho, ee, q2, sin_th, cos_th, ok)
    real(default), intent(in) :: s
    real(default), intent(in) :: xb
    real(default), intent(in) :: rho
    real(default), dimension(2), intent(in) :: ee
    real(default), dimension(2), intent(in) :: q2
    real(default), dimension(2), intent(out) :: sin_th
    real(default), dimension(2), intent(out) :: cos_th
    logical, intent(out) :: ok

    real(default), dimension(2) :: sin2_th_2

    sin2_th_2 = q2 / (ee * rho * xb * s)

    if (all (sin2_th_2 <= 1)) then
       sin_th = 2 * sqrt (sin2_th_2 * (1 - sin2_th_2))
       cos_th = 1 - 2 * sin2_th_2
       ok = .true.
    else
       sin_th = 0
       cos_th = 1
       ok = .false.
    end if

  end subroutine polar_angles

@ %def polar_angles
@
Compute the acollinearity parameter $\lambda$ from azimuthal and polar
angles.  The result is a number between $0$ and $1$.
<<Recoil kinematics: procedures>>=
  function lambda_factor (sin_th, cos_th, cphi) result (lambda)
    real(default), dimension(2), intent(in) :: sin_th
    real(default), dimension(2), intent(in) :: cos_th
    real(default), intent(in) :: cphi
    real(default) :: lambda

    lambda = (1 - cos_th(1) * cos_th(2) - cphi * sin_th(1) * sin_th(2)) / 2

  end function lambda_factor

@ %def lambda_factor
@
Compute the factor that rescales photon energies, such that the
radiation angles match the kinematics parameters.

For small values of $\bar x/\cosh\eta$, we have to use the Taylor
expansion if we do not want to lose precision.  The optional argument
allows for a unit test that compares exact and approximate.
<<Recoil kinematics: procedures>>=
  function scale_factor (che, lambda, xb0, approximate) result (rho)
    real(default), intent(in) :: che
    real(default), intent(in) :: lambda
    real(default), intent(in) :: xb0
    logical, intent(in), optional :: approximate
    real(default) :: rho

    real(default), parameter :: &
         e0 = (100 * epsilon (1._default)) ** (0.3_default)
    logical :: approx

    if (present (approximate)) then
       approx = approximate
    else
       approx = (xb0/che) < e0
    end if

    if (approx) then
       rho = 1 - lambda * (xb0/(2*che)) * (1 + (1-lambda) * (xb0/che))
    else
       rho =  (che / ((1-lambda)*xb0)) &
         * (1 - sqrt (1 - 2 * (1-lambda) * (xb0/che) &
         &    + (1-lambda) * (xb0 / che)**2))
    end if

  end function scale_factor

@ %def scale_factor
@ The code snippet below is not used anywhere, but may be manually
inserted in a unit test to numerically verify the approximation above.
<<Recoil kinematics: extra test code>>=
    write (u, "(A)")
    write (u, "(A)") "*** Table: scale factor calculation"
    write (u, "(A)")

    lambda = 0.25_default
    write (u, FMT1)  "lambda =", lambda

    che = 4._default
    write (u, FMT1)  "che    =", che

    write (u, "(A)")  "   x0    rho(exact)   rho(approx)   rho(chosen)"
    xb0 = 1._default
    do i = 1, 30
       xb0 = xb0 / 10
       write (u, FMT4)   xb0, &
            scale_factor (che, lambda, xb0, approximate=.false.), &
            scale_factor (che, lambda, xb0, approximate=.true.), &
            scale_factor (che, lambda, xb0)
    end do
@
Compute the current values for the $x_{1,2}$ parameters, given the
updated scale factor $\rho$ and the collinear parameters.
<<Recoil kinematics: procedures>>=
  subroutine scaled_x (rho, ee, xb0, x, xb)
    real(default), intent(in) :: rho
    real(default), dimension(2), intent(in) :: ee
    real(default), intent(in) :: xb0
    real(default), dimension(2), intent(out) :: x
    real(default), dimension(2), intent(out) :: xb

    xb = rho * ee * xb0
    x = 1 - xb

  end subroutine scaled_x

@ %def scaled_x
@
\subsection{Iterative solution of kinematics constraints}
Find a solution of the kinematics constraints.  We know the parameters
appropriate for collinear kinematics $\sqrt{s}$, $x^c_{1,2}$.  We
have picked values vor the momentum transfer $Q_{1,2}$ and the
azimuthal angles $\phi_{1,2}$.  The solution consists of modified energy
fractions $x_{1,2}$ and polar angles $\theta_{1,2}$.

If the computation fails, which can happen for large momentum
transfer, the flag [[ok]] will indicate this.
<<Recoil kinematics: public>>=
  public :: solve_recoil
<<Recoil kinematics: sub interfaces>>=
    module subroutine solve_recoil &
         (sqrts, xc, xcb, phi, q2, x, xb, cos_th, sin_th, ok)
      real(default), intent(in) :: sqrts
      real(default), dimension(2), intent(in) :: xc
      real(default), dimension(2), intent(in) :: xcb
      real(default), dimension(2), intent(in) :: phi
      real(default), dimension(2), intent(in) :: q2
      real(default), dimension(2), intent(out) :: x
      real(default), dimension(2), intent(out) :: xb
      real(default), dimension(2), intent(out) :: cos_th
      real(default), dimension(2), intent(out) :: sin_th
      logical, intent(out) :: ok
    end subroutine solve_recoil
<<Recoil kinematics: procedures>>=
  module subroutine solve_recoil &
       (sqrts, xc, xcb, phi, q2, x, xb, cos_th, sin_th, ok)
    real(default), intent(in) :: sqrts
    real(default), dimension(2), intent(in) :: xc
    real(default), dimension(2), intent(in) :: xcb
    real(default), dimension(2), intent(in) :: phi
    real(default), dimension(2), intent(in) :: q2
    real(default), dimension(2), intent(out) :: x
    real(default), dimension(2), intent(out) :: xb
    real(default), dimension(2), intent(out) :: cos_th
    real(default), dimension(2), intent(out) :: sin_th
    logical, intent(out) :: ok

    real(default) :: s
    real(default), dimension(2) :: ee
    real(default), dimension(2) :: th
    real(default) :: xb0, cphi
    real(default) :: che, lambda
    real(default) :: rho_new, rho, rho_old
    real(default) :: dr_old, dr_new
    real(default), parameter :: dr_limit = 100 * epsilon (1._default)
    integer, parameter :: n_it_max = 20
    integer :: i

    ok = .true.

    s = sqrts**2
    ee = sqrt ([xcb(1)/xcb(2), xcb(2)/xcb(1)])
    che = sum (ee) / 2
    xb0 = sqrt (xcb(1) * xcb(2))
    cphi = cos (phi(1) - phi(2))

    rho_old = 10
    rho = 1
    th = 0
    sin_th = sin (th)
    cos_th = cos (th)
    lambda = lambda_factor (sin_th, cos_th, cphi)
    call scaled_x (rho, ee, xb0, x, xb)

    iterate_loop: do i = 1, n_it_max

       call polar_angles (s, xb0, rho, ee, q2, sin_th, cos_th, ok)
       if (.not. ok)  return
       th = atan2 (sin_th, cos_th)

       lambda = lambda_factor (sin_th, cos_th, cphi)
       rho_new = scale_factor (che, lambda, xb0)
       call scaled_x (rho_new, ee, xb0, x, xb)

       dr_old = abs (rho - rho_old)
       dr_new = abs (rho_new - rho)

       rho_old = rho
       rho = rho_new

       if (dr_new < dr_limit .or. dr_new >= dr_old)  exit iterate_loop

    end do iterate_loop

  end subroutine solve_recoil

@ %def solve_recoil
@
With all kinematics parameters known, construct actual four-vectors
for the recoil momenta, the off-shell (spacelike) parton momenta, and
on-shell projected parton momenta.
<<Recoil kinematics: public>>=
  public :: recoil_momenta
<<Recoil kinematics: sub interfaces>>=
    module subroutine recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, mo, &
         km, qm, qo, ok)
      real(default), intent(in) :: sqrts
      real(default), dimension(2), intent(in) :: xc
      real(default), dimension(2), intent(in) :: xb
      real(default), dimension(2), intent(in) :: cos_th
      real(default), dimension(2), intent(in) :: sin_th
      real(default), dimension(2), intent(in) :: phi
      real(default), dimension(2), intent(in) :: mo
      type(vector4_t), dimension(2), intent(out) :: km
      type(vector4_t), dimension(2), intent(out) :: qm
      type(vector4_t), dimension(2), intent(out) :: qo
      logical, intent(out) :: ok
    end subroutine recoil_momenta
<<Recoil kinematics: procedures>>=
  module subroutine recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, mo, &
       km, qm, qo, ok)
    real(default), intent(in) :: sqrts
    real(default), dimension(2), intent(in) :: xc
    real(default), dimension(2), intent(in) :: xb
    real(default), dimension(2), intent(in) :: cos_th
    real(default), dimension(2), intent(in) :: sin_th
    real(default), dimension(2), intent(in) :: phi
    real(default), dimension(2), intent(in) :: mo
    type(vector4_t), dimension(2), intent(out) :: km
    type(vector4_t), dimension(2), intent(out) :: qm
    type(vector4_t), dimension(2), intent(out) :: qo
    logical, intent(out) :: ok

    type(vector4_t), dimension(2) :: pm
    type(lorentz_transformation_t) :: lt
    real(default) :: sqsh
    real(default) :: po4, po2
    real(default), dimension(2) :: p0, p3

    pm(1) = &
         vector4_moving (sqrts/2, &
         vector3_moving ([0._default, 0._default, sqrts/2]))
    pm(2) = &
         vector4_moving (sqrts/2, &
         vector3_moving ([0._default, 0._default,-sqrts/2]))

    km(1) = xb(1) * (sqrts/2) * vector4_moving ( &
         1._default, &
         vector3_moving ([ &
         &     sin_th(1) * cos (phi(1)), &
         &     sin_th(1) * sin (phi(1)), &
         &     cos_th(1)]) &
         )
    km(2) = xb(2) * (sqrts/2) * vector4_moving ( &
         1._default, &
         vector3_moving ([ &
         &    -sin_th(2) * cos (phi(2)), &
         &    -sin_th(2) * sin (phi(2)), &
         &    -cos_th(2)]) &
         )

    qm(1) = pm(1) - km(1)
    qm(2) = pm(2) - km(2)

    sqsh = sqrt (xc(1)*xc(2)) * sqrts
    lt = transformation (3, qm(1), qm(2), sqsh)

    po4 = lambda (sqsh**2, mo(1)**2, mo(2)**2)
    ok = po4 > 0
    if (ok) then
       po2 = sqrt (po4)/4
       p0 = sqrt (po2 + mo**2)
       p3 = [sqrt (po2), -sqrt (po2)]
       qo = lt * vector4_moving (p0, p3, 3)
    else
       qo = vector4_null
    end if

  end subroutine recoil_momenta

@ %def recoil_momenta
@
Compute the Lorentz transformation that we can use to transform any
outgoing momenta into the new c.m.\ system of the incoming partons.
Not relying on the previous calculations, we determine the
transformation that transforms the original collinear partons into
their c.m.\ system, and then transform this to the new c.m.\ system.
<<Recoil kinematics: public>>=
  public :: recoil_transformation
<<Recoil kinematics: sub interfaces>>=
    module subroutine recoil_transformation (sqrts, xc, qo, lt)
      real(default), intent(in) :: sqrts
      real(default), dimension(2), intent(in) :: xc
      type(vector4_t), dimension(2), intent(in) :: qo
      type(lorentz_transformation_t), intent(out) :: lt
    end subroutine recoil_transformation
<<Recoil kinematics: procedures>>=
  module subroutine recoil_transformation (sqrts, xc, qo, lt)
    real(default), intent(in) :: sqrts
    real(default), dimension(2), intent(in) :: xc
    type(vector4_t), dimension(2), intent(in) :: qo
    type(lorentz_transformation_t), intent(out) :: lt

    real(default) :: sqsh
    type(vector4_t), dimension(2) :: qc
    type(lorentz_transformation_t) :: ltc, lto

    qc(1) = xc(1) * vector4_moving (sqrts/2, sqrts/2, 3)
    qc(2) = xc(2) * vector4_moving (sqrts/2,-sqrts/2, 3)

    sqsh = sqrt (xc(1) * xc(2)) * sqrts
    ltc = transformation (3, qc(1), qc(2), sqsh)
    lto = transformation (3, qo(1), qo(2), sqsh)
    lt = lto * inverse (ltc)

  end subroutine recoil_transformation

@ %def recoil_transformation
@
Compute the Lorentz boost that transforms the c.m.\ frame of the
momenta into the lab frame where they are given.  Also return their
common invariant mass, $\sqrt{s}$.

If the initial momenta are not collinear, [[ok]] is set false.
<<Recoil kinematics: public>>=
  public :: initial_transformation
<<Recoil kinematics: sub interfaces>>=
    module subroutine initial_transformation (p, sqrts, lt, ok)
      type(vector4_t), dimension(2), intent(in) :: p
      real(default), intent(out) :: sqrts
      type(lorentz_transformation_t), intent(out) :: lt
      logical, intent(out) :: ok
    end subroutine initial_transformation
<<Recoil kinematics: procedures>>=
  module subroutine initial_transformation (p, sqrts, lt, ok)
    type(vector4_t), dimension(2), intent(in) :: p
    real(default), intent(out) :: sqrts
    type(lorentz_transformation_t), intent(out) :: lt
    logical, intent(out) :: ok

    ok = all (transverse_part (p) == 0)

    sqrts = (p(1) + p(2)) ** 1
    lt = boost (p(1) + p(2), sqrts)

  end subroutine initial_transformation

@ %def initial_transformation
@
\subsection{Generate recoil event}
Combine the above kinematics calculations.  First generate azimuthal
angles and momentum transfer, solve kinematics and compute momenta for
the radiated photons and the on-shell projected, recoiling partons.

The [[mo]] masses are used for the on-shell projection of the partons after
radiation.  They may be equal to [[m]], or set to zero.

If [[ok]] is false, the data point has failed and we should repeat the
procedure for a new set of RNG parameters [[r]].
<<Recoil kinematics: public>>=
  public :: generate_recoil
<<Recoil kinematics: sub interfaces>>=
    module subroutine generate_recoil &
         (sqrts, q_max, m, mo, xc, xcb, r, km, qm, qo, ok)
      real(default), intent(in) :: sqrts
      real(default), intent(in), dimension(2) :: q_max
      real(default), intent(in), dimension(2) :: m
      real(default), intent(in), dimension(2) :: mo
      real(default), intent(in), dimension(2) :: xc
      real(default), intent(in), dimension(2) :: xcb
      real(default), intent(in), dimension(4) :: r
      type(vector4_t), dimension(2), intent(out) :: km
      type(vector4_t), dimension(2), intent(out) :: qm
      type(vector4_t), dimension(2), intent(out) :: qo
      logical, intent(out) :: ok
    end subroutine generate_recoil
<<Recoil kinematics: procedures>>=
  module subroutine generate_recoil &
       (sqrts, q_max, m, mo, xc, xcb, r, km, qm, qo, ok)
    real(default), intent(in) :: sqrts
    real(default), intent(in), dimension(2) :: q_max
    real(default), intent(in), dimension(2) :: m
    real(default), intent(in), dimension(2) :: mo
    real(default), intent(in), dimension(2) :: xc
    real(default), intent(in), dimension(2) :: xcb
    real(default), intent(in), dimension(4) :: r
    type(vector4_t), dimension(2), intent(out) :: km
    type(vector4_t), dimension(2), intent(out) :: qm
    type(vector4_t), dimension(2), intent(out) :: qo
    logical, intent(out) :: ok

    real(default), dimension(2) :: q2
    real(default), dimension(2) :: phi
    real(default), dimension(2) :: x
    real(default), dimension(2) :: xb
    real(default), dimension(2) :: cos_th
    real(default), dimension(2) :: sin_th

    call generate_q2_recoil (sqrts**2, xcb, q_max**2, m**2, r(1:2), q2)
    call generate_phi_recoil (r(3:4), phi)

    call solve_recoil (sqrts, xc, xcb, phi, q2, x, xb, cos_th, sin_th, ok)
    if (ok) then
       call recoil_momenta &
            (sqrts, xc, xb, cos_th, sin_th, phi, mo, km, qm, qo, ok)
    end if

  end subroutine generate_recoil

@ %def generate_recoil
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[recoil_kinematics_ut.f90]]>>=
<<File header>>

module recoil_kinematics_ut
  use unit_tests
  use recoil_kinematics_uti

<<Standard module head>>

<<Recoil kinematics: public test>>

contains

<<Recoil kinematics: test driver>>

end module recoil_kinematics_ut
@ %def recoil_kinematics_ut
@
<<[[recoil_kinematics_uti.f90]]>>=
<<File header>>

module recoil_kinematics_uti

<<Use kinds>>
  use constants, only: twopi
  use constants, only: degree
  use lorentz, only: vector4_t
  use lorentz, only: vector4_moving
  use lorentz, only: lorentz_transformation_t
  use lorentz, only: inverse
  use lorentz, only: operator(+)
  use lorentz, only: operator(*)
  use lorentz, only: operator(**)
  use lorentz, only: pacify

  use recoil_kinematics, only: solve_recoil
  use recoil_kinematics, only: recoil_momenta
  use recoil_kinematics, only: recoil_transformation
  use recoil_kinematics, only: initial_transformation
  use recoil_kinematics, only: generate_q2_recoil
  use recoil_kinematics, only: generate_recoil

<<Standard module head>>

<<Recoil kinematics: test declarations>>

contains

<<Recoil kinematics: tests>>

end module recoil_kinematics_uti

@ %def recoil_kinematics_uti
@ API: driver for the unit tests below.
<<Recoil kinematics: public test>>=
  public :: recoil_kinematics_test
<<Recoil kinematics: test driver>>=
  subroutine recoil_kinematics_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Recoil kinematics: execute tests>>
  end subroutine recoil_kinematics_test

@ %def recoil_kinematics_test
@
\subsubsection{Recoil kinematics}
For a set of input data, solve the kinematics constraints and generate
momenta accordingly.
<<Recoil kinematics: execute tests>>=
  call test (recoil_kinematics_1, "recoil_kinematics_1", &
       "iterative solution of non-collinear kinematics", &
       u, results)
<<Recoil kinematics: test declarations>>=
  public :: recoil_kinematics_1
<<Recoil kinematics: tests>>=
  subroutine recoil_kinematics_1 (u)
    integer, intent(in) :: u

    real(default) :: sqrts
    real(default), dimension(2) :: xc, xcb
    real(default), dimension(2) :: q
    real(default), dimension(2) :: phi
    real(default), dimension(2) :: mo
    real(default), dimension(2) :: cos_th, sin_th
    real(default), dimension(2) :: x
    real(default), dimension(2) :: xb
    type(vector4_t), dimension(2) :: km
    type(vector4_t), dimension(2) :: qm
    type(vector4_t), dimension(2) :: qo
    integer :: i
    logical :: ok

    character(*), parameter :: FMT1 = "(1x,A,9(1x,F15.10))"
    character(*), parameter :: FMT2 = "(1x,A,9(1x,F10.5))"
    character(*), parameter :: FMT4 = "(3x,ES8.1,9(1x,ES19.12))"

    write (u, "(A)")  "* Test output: recoil_kinematics_1"
    write (u, "(A)")  "*   Purpose: compute kinematics for various input data"
    write (u, "(A)")

    sqrts = 100
    write (u, FMT1)  "sqrts =", sqrts

    write (u, "(A)")
    write (u, "(A)") "*** collinear data set"
    write (u, "(A)")

    xc = [0.6_default, 0.9_default]
    xcb = 1 - xc
    phi = [0.1_default, 0.2_default] * twopi
    q = 0
    mo = 0

    call show_data
    call solve_recoil (sqrts, xc, xcb, phi, q**2, x, xb, cos_th, sin_th, ok)
    call show_results

    call recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, mo, km, qm, qo, ok)
    call show_momenta

    write (u, "(A)")
    write (u, "(A)") "*** moderate data set"
    write (u, "(A)")

    xc = [0.6_default, 0.9_default]
    xcb = 1 - xc
    phi = [0.1_default, 0.2_default] * twopi
    q = [0.2_default, 0.05_default] * sqrts

    call show_data
    call solve_recoil (sqrts, xc, xcb, phi, q**2, x, xb, cos_th, sin_th, ok)
    call show_results
    call recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, mo, km, qm, qo, ok)
    call show_momenta

    write (u, "(A)")
    write (u, "(A)") "*** semi-soft data set"
    write (u, "(A)")

    xcb= [0.1_default, 0.0001_default]
    xc = 1 - xcb
    phi = [0.1_default, 0.2_default] * twopi
    q = [0.2_default, 0.00001_default] * sqrts

    call show_data
    call solve_recoil (sqrts, xc, xcb, phi, q**2, x, xb, cos_th, sin_th, ok)
    call show_results

    call recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, mo, km, qm, qo, ok)
    call show_momenta

    write (u, "(A)")
    write (u, "(A)") "*** hard-soft data set"
    write (u, "(A)")

    xcb= [0.1_default, 1.e-30_default]
    xc = 1 - xcb
    phi = [0.1_default, 0.2_default] * twopi
    q = [0.2_default, 1.e-35_default] * sqrts

    call show_data
    call solve_recoil (sqrts, xc, xcb, phi, q**2, x, xb, cos_th, sin_th, ok)
    call show_results

    call recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, mo, km, qm, qo, ok)
    call show_momenta

    write (u, "(A)")
    write (u, "(A)") "*** hard data set"
    write (u, "(A)")

    xc = [0.2_default, 0.4_default]
    xcb = 1 - xc
    phi = [0.1_default, 0.8_default] * twopi
    q = [0.74_default, 0.3_default] * sqrts

    call show_data
    call solve_recoil (sqrts, xc, xcb, phi, q**2, x, xb, cos_th, sin_th, ok)
    call show_results

    call recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, mo, km, qm, qo, ok)
    call show_momenta

    write (u, "(A)")
    write (u, "(A)") "*** failing data set"
    write (u, "(A)")

    xc = [0.2_default, 0.4_default]
    xcb = 1 - xc
    phi = [0.1_default, 0.8_default] * twopi
    q = [0.9_default, 0.3_default] * sqrts

    call show_data
    call solve_recoil (sqrts, xc, xcb, phi, q**2, x, xb, cos_th, sin_th, ok)
    if (.not. ok) then
       write (u, "(A)")
       write (u, "(A)") "Failed as expected."
    end if

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: recoil_kinematics_1"

  contains

    subroutine show_data
      write (u, FMT1) "sqs_h =", sqrt (xc(1) * xc(2)) * sqrts
      write (u, FMT1) "xc    =", xc
      write (u, FMT1) "xcb   =", xcb
      write (u, FMT1) "Q     =", Q
      write (u, FMT1) "phi/D =", phi / degree
    end subroutine show_data

    subroutine show_results
      write (u, "(A)")
      write (u, "(A)") "Result:"
      write (u, FMT1) "th/D  =", atan2 (sin_th, cos_th) / degree
      write (u, FMT1) "x     =", x
      write (u, "(A)")
    end subroutine show_results

    subroutine show_momenta
      type(vector4_t) :: qm0, qo0
      real(default), parameter :: tol = 1.e-7_default
      call pacify (km, tol)
      call pacify (qm, tol)
      call pacify (qo, tol)
      write (u, "(A)") "Momenta: k"
      call km(1)%write (u, testflag=.true.)
      call km(2)%write (u, testflag=.true.)
      write (u, FMT1) "k^2 =", abs (km(1)**2), abs (km(2)**2)
      write (u, "(A)")
      write (u, "(A)") "Momenta: q"
      call qm(1)%write (u, testflag=.true.)
      call qm(2)%write (u, testflag=.true.)
      write (u, "(A)")
      write (u, "(A)") "Momenta: q(os)"
      call qo(1)%write (u, testflag=.true.)
      call qo(2)%write (u, testflag=.true.)
      write (u, "(A)")
      write (u, "(A)") "Check: parton momentum sum: q vs q(os)"
      qm0 = qm(1) + qm(2)
      call qm0%write (u, testflag=.true.)
      qo0 = qo(1) + qo(2)
      call qo0%write (u, testflag=.true.)
      write (u, "(A)")
      write (u, "(A)") "* Check: momentum transfer (off-shell/on-shell)"
      write (u, FMT2) "|q| =", abs (qm(1)**1), abs (qm(2)**1)
      write (u, FMT2) "Q   =", q
      write (u, FMT2) "|qo|=", abs (qo(1)**1), abs (qo(2)**1)
      write (u, "(A)")
      write (u, "(A)") "* Check: sqrts, sqrts_hat"
      write (u, FMT1) "|p| =", (km(1)+km(2)+qm(1)+qm(2))**1, (qm(1)+qm(2))**1
      write (u, FMT1) "sqs =", sqrts, sqrt (product (xc)) * sqrts
      write (u, FMT1) "|po|=", abs ((km(1)+km(2)+qo(1)+qo(2))**1), abs ((qo(1)+qo(2))**1)
    end subroutine show_momenta

  end subroutine recoil_kinematics_1

@ %def recoil_kinematics_1
@
\subsubsection{Recoil $Q$ distribution}
Sample the $Q$ distribution for equidistant bins in the input variable.
<<Recoil kinematics: execute tests>>=
  call test (recoil_kinematics_2, "recoil_kinematics_2", &
       "Q distribution", &
       u, results)
<<Recoil kinematics: test declarations>>=
  public :: recoil_kinematics_2
<<Recoil kinematics: tests>>=
  subroutine recoil_kinematics_2 (u)
    integer, intent(in) :: u

    real(default) :: sqrts
    real(default) :: q_max
    real(default) :: m
    real(default) :: x_bar
    real(default) :: r
    real(default) :: q2, q2_old
    integer :: i
    integer :: n_bin

    character(*), parameter :: FMT1 = "(1x,A,9(1x,F15.10))"
    character(*), parameter :: FMT3 = "(2x,9(1x,F10.5))"

    write (u, "(A)")  "* Test output: recoil_kinematics_2"
    write (u, "(A)")  "*   Purpose: compute Q distribution"
    write (u, "(A)")

    n_bin = 20

    write (u, "(A)") "* No Q cutoff, xbar = 1"
    write (u, "(A)")

    sqrts = 100
    q_max = sqrts
    m = 0.511e-3_default
    x_bar = 1._default
    call show_table

    write (u, "(A)")
    write (u, "(A)") "* With Q cutoff, xbar = 1"
    write (u, "(A)")

    q_max = 10
    call show_table

    write (u, "(A)")
    write (u, "(A)") "* No Q cutoff, xbar = 0.01"
    write (u, "(A)")

    q_max = sqrts
    x_bar = 0.01_default
    call show_table

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: recoil_kinematics_2"

  contains

    subroutine show_table
      write (u, FMT1)  "sqrts =", sqrts
      write (u, FMT1)  "q_max =", q_max
      write (u, FMT1)  "m     =", m
      write (u, FMT1)  "x_bar =", x_bar
      write (u, "(A)")
      write (u, "(1x,A)")  "Table:  r         |Q|    |Q_i/Q_(i-1)|"
      q2_old = 0
      do i = 0, n_bin
         r = real (i, default) / n_bin
         call generate_q2_recoil (sqrts**2, x_bar, q_max**2, m**2, r, q2)
         if (q2_old > 0) then
            write (u, FMT3)  r, sqrt (q2), sqrt (q2 / q2_old)
         else
            write (u, FMT3)  r, sqrt (q2)
         end if
         q2_old = q2
      end do
    end subroutine show_table

  end subroutine recoil_kinematics_2

@ %def recoil_kinematics_2
@
\subsubsection{Generate recoil event}
Combine $Q^2$ sampling with momentum generation.
<<Recoil kinematics: execute tests>>=
  call test (recoil_kinematics_3, "recoil_kinematics_3", &
       "generate recoil event", &
       u, results)
<<Recoil kinematics: test declarations>>=
  public :: recoil_kinematics_3
<<Recoil kinematics: tests>>=
  subroutine recoil_kinematics_3 (u)
    integer, intent(in) :: u

    real(default) :: sqrts
    real(default), dimension(2) :: q_max
    real(default), dimension(2) :: m, mo
    real(default), dimension(2) :: xc, xcb
    real(default), dimension(4) :: r
    type(vector4_t), dimension(2) :: km
    type(vector4_t), dimension(2) :: qm
    type(vector4_t), dimension(2) :: qo
    logical :: ok

    character(*), parameter :: FMT1 = "(1x,A,9(1x,F15.10))"
    character(*), parameter :: FMT2 = "(1x,A,9(1x,F10.5))"

    write (u, "(A)")  "* Test output: recoil_kinematics_3"
    write (u, "(A)")  "*   Purpose: generate momenta from RNG parameters"
    write (u, "(A)")

    write (u, "(A)") "*** collinear data set"
    write (u, "(A)")

    sqrts = 100
    q_max = sqrts
    m     = 0.511e-3_default
    mo    = 0

    xc = [0.6_default, 0.9_default]
    xcb = 1 - xc

    r = [0._default, 0._default, 0._default, 0._default]

    call show_data
    call generate_recoil (sqrts, q_max, m, mo, xc, xcb, r, km, qm, qo, ok)
    call show_momenta

    write (u, "(A)")
    write (u, "(A)") "*** moderate data set"
    write (u, "(A)")

    xc = [0.6_default, 0.9_default]
    xcb = 1 - xc

    r = [0.8_default, 0.2_default, 0.1_default, 0.2_default]

    call show_data
    call generate_recoil (sqrts, q_max, m, mo, xc, xcb, r, km, qm, qo, ok)
    call show_momenta

    write (u, "(A)")
    write (u, "(A)") "*** failing data set"
    write (u, "(A)")

    xc = [0.2_default, 0.4_default]
    xcb = 1 - xc

    r = [0.9999_default, 0.3_default, 0.1_default, 0.8_default]

    call show_data
    call generate_recoil (sqrts, q_max, m, mo, xc, xcb, r, km, qm, qo, ok)
    if (.not. ok) then
       write (u, "(A)")
       write (u, "(A)") "Failed as expected."
    else
       call show_momenta
    end if

  contains

    subroutine show_data
      write (u, FMT1)  "sqrts =", sqrts
      write (u, FMT1)  "q_max =", q_max
      write (u, FMT1)  "m     =", m
      write (u, FMT1)  "xc    =", xc
      write (u, FMT1)  "xcb   =", xcb
      write (u, FMT1)  "r     =", r
    end subroutine show_data

    subroutine show_momenta
      real(default), parameter :: tol = 1.e-7_default
      call pacify (km, tol)
      call pacify (qo, tol)
      write (u, "(A)")
      write (u, "(A)") "* Momenta: k"
      call km(1)%write (u, testflag=.true.)
      call km(2)%write (u, testflag=.true.)
      write (u, FMT1) "k^2 =", abs (km(1)**2), abs (km(2)**2)
      write (u, "(A)")
      write (u, "(A)") "* Momenta: q(os)"
      call qo(1)%write (u, testflag=.true.)
      call qo(2)%write (u, testflag=.true.)
      write (u, FMT1) "q^2 =", abs (qo(1)**2), abs (qo(2)**2)
      write (u, "(A)")
      write (u, "(A)") "* Check: momentum transfer (off-shell/on-shell)"
      write (u, FMT2) "Q   =", q_check (1), q_check (2)
      write (u, FMT2) "|q| =", abs (qm(1)**1), abs (qm(2)**1)
      write (u, "(A)")
      write (u, "(A)") "* Check: sqrts, sqrts_hat"
      write (u, FMT1) "sqs =", sqrts, sqrt (product (xc)) * sqrts
      write (u, FMT1) "|po|=", abs ((km(1)+km(2)+qo(1)+qo(2))**1), abs ((qo(1)+qo(2))**1)
    end subroutine show_momenta

    function q_check (i) result (q)
      integer, intent(in) :: i
      real(default) :: q
      real(default) :: q2
      call generate_q2_recoil (sqrts**2, xcb(i), q_max(i)**2, m(i)**2, r(i), q2)
      q = sqrt (q2)
    end function q_check

  end subroutine recoil_kinematics_3

@ %def recoil_kinematics_3
@
\subsubsection{Transformation after recoil}
Given a solution to recoil kinematics, compute the Lorentz
transformation that transforms the old collinear parton momenta into
the new parton momenta.
<<Recoil kinematics: execute tests>>=
  call test (recoil_kinematics_4, "recoil_kinematics_4", &
       "reference frame", &
       u, results)
<<Recoil kinematics: test declarations>>=
  public :: recoil_kinematics_4
<<Recoil kinematics: tests>>=
  subroutine recoil_kinematics_4 (u)
    integer, intent(in) :: u

    real(default) :: sqrts
    real(default), dimension(2) :: xc, xcb
    real(default), dimension(2) :: q
    real(default), dimension(2) :: phi
    real(default), dimension(2) :: cos_th, sin_th
    real(default), dimension(2) :: mo
    real(default), dimension(2) :: x
    real(default), dimension(2) :: xb
    type(vector4_t), dimension(2) :: km
    type(vector4_t), dimension(2) :: qm
    type(vector4_t), dimension(2) :: qo
    type(lorentz_transformation_t) :: lt
    logical :: ok

    character(*), parameter :: FMT1 = "(1x,A,9(1x,F15.10))"
    character(*), parameter :: FMT2 = "(1x,A,9(1x,F10.5))"

    write (u, "(A)")  "* Test output: recoil_kinematics_4"
    write (u, "(A)")  "*   Purpose: check Lorentz transformation for recoil"
    write (u, "(A)")

    sqrts = 100
    write (u, FMT1)  "sqrts =", sqrts

    write (u, "(A)")
    write (u, "(A)") "*** collinear data set"
    write (u, "(A)")

    xc = [0.6_default, 0.9_default]
    xcb = 1 - xc
    phi = [0.1_default, 0.2_default] * twopi
    q = 0
    mo = 0

    call show_data
    call solve_recoil (sqrts, xc, xcb, phi, q**2, x, xb, cos_th, sin_th, ok)
    call recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, mo, km, qm, qo, ok)
    call recoil_transformation (sqrts, xc, qo, lt)
    call show_transformation

    write (u, "(A)")
    write (u, "(A)") "*** moderate data set"
    write (u, "(A)")

    xc = [0.6_default, 0.9_default]
    xcb = 1 - xc
    phi = [0.1_default, 0.2_default] * twopi
    q = [0.2_default, 0.05_default] * sqrts

    call show_data
    call solve_recoil (sqrts, xc, xcb, phi, q**2, x, xb, cos_th, sin_th, ok)
    call recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, mo, km, qm, qo, ok)
    call recoil_transformation (sqrts, xc, qo, lt)
    call show_transformation

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: recoil_kinematics_4"

  contains

    subroutine show_data
      write (u, FMT1) "sqs_h =", sqrt (xc(1) * xc(2)) * sqrts
      write (u, FMT1) "xc    =", xc
      write (u, FMT1) "xcb   =", xcb
      write (u, FMT1) "Q     =", Q
      write (u, FMT1) "phi/D =", phi / degree
    end subroutine show_data

    subroutine show_transformation
      type(vector4_t), dimension(2) :: qc
      type(vector4_t), dimension(2) :: qct
      real(default), parameter :: tol = 1.e-7_default
      qc(1) = xc(1) * vector4_moving (sqrts/2, sqrts/2, 3)
      qc(2) = xc(2) * vector4_moving (sqrts/2,-sqrts/2, 3)
      qct = lt * qc
      call pacify (qct, tol)
      write (u, "(A)")
      write (u, "(A)") "Momenta: q(os)"
      call qo(1)%write (u, testflag=.true.)
      call qo(2)%write (u, testflag=.true.)
      write (u, "(A)")
      write (u, "(A)") "Momenta: LT * qc"
      call qct(1)%write (u, testflag=.true.)
      call qct(2)%write (u, testflag=.true.)
    end subroutine show_transformation

  end subroutine recoil_kinematics_4

@ %def recoil_kinematics_4
@
\subsubsection{Transformation before recoil}
Given a pair of incoming `beam' partons (i.e., before ISR splitting),
compute the transformation that transforms their common c.m.\ frame
into the lab frame.
<<Recoil kinematics: execute tests>>=
  call test (recoil_kinematics_5, "recoil_kinematics_5", &
       "initial reference frame", &
       u, results)
<<Recoil kinematics: test declarations>>=
  public :: recoil_kinematics_5
<<Recoil kinematics: tests>>=
  subroutine recoil_kinematics_5 (u)
    integer, intent(in) :: u

    real(default) :: sqrts
    real(default) :: sqrtsi
    real(default), dimension(2) :: x
    type(vector4_t), dimension(2) :: p
    type(vector4_t), dimension(2) :: pi
    type(vector4_t), dimension(2) :: p0
    type(lorentz_transformation_t) :: lt
    logical :: ok

    character(*), parameter :: FMT1 = "(1x,A,9(1x,F15.10))"
    character(*), parameter :: FMT2 = "(1x,A,9(1x,F10.5))"

    write (u, "(A)")  "* Test output: recoil_kinematics_5"
    write (u, "(A)")  "*   Purpose: determine initial Lorentz transformation"
    write (u, "(A)")

    sqrts = 100
    write (u, FMT1)  "sqrts =", sqrts

    x = [0.6_default, 0.9_default]

    p(1) = x(1) * vector4_moving (sqrts/2, sqrts/2, 3)
    p(2) = x(2) * vector4_moving (sqrts/2,-sqrts/2, 3)

    call show_data
    call initial_transformation (p, sqrtsi, lt, ok)

    pi(1) = vector4_moving (sqrtsi/2, sqrtsi/2, 3)
    pi(2) = vector4_moving (sqrtsi/2,-sqrtsi/2, 3)

    p0 = inverse (lt) * p

    call show_momenta

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: recoil_kinematics_5"

  contains

    subroutine show_data
      write (u, FMT1) "sqrts =", sqrts
      write (u, FMT1) "x     =", x
    end subroutine show_data


    subroutine show_momenta
      real(default), parameter :: tol = 1.e-7_default
      write (u, "(A)")
      write (u, "(A)") "* Momenta: p_in(c.m.)"
      call pi(1)%write (u, testflag=.true.)
      call pi(2)%write (u, testflag=.true.)
      write (u, "(A)")
      write (u, "(A)") "* Momenta: inv(LT) * p_in(lab)"
      call p0(1)%write (u, testflag=.true.)
      call p0(2)%write (u, testflag=.true.)
    end subroutine show_momenta

  end subroutine recoil_kinematics_5

@ %def recoil_kinematics_5
@
\subsubsection{Transformation after recoil with on-shell momenta}
Given a solution to recoil kinematics, compute the Lorentz
transformation that transforms the old collinear parton momenta into
the new parton momenta.

Compare the results for massless and massive on-shell projection.
<<Recoil kinematics: execute tests>>=
  call test (recoil_kinematics_6, "recoil_kinematics_6", &
       "massless/massive on-shell projection", &
       u, results)
<<Recoil kinematics: test declarations>>=
  public :: recoil_kinematics_6
<<Recoil kinematics: tests>>=
  subroutine recoil_kinematics_6 (u)
    integer, intent(in) :: u

    real(default) :: sqrts
    real(default), dimension(2) :: xc, xcb
    real(default), dimension(2) :: q
    real(default), dimension(2) :: phi
    real(default), dimension(2) :: cos_th, sin_th
    real(default), dimension(2) :: x
    real(default), dimension(2) :: xb
    real(default), dimension(2) :: mo, z
    type(vector4_t), dimension(2) :: km
    type(vector4_t), dimension(2) :: qm
    type(vector4_t), dimension(2) :: qo
    type(lorentz_transformation_t) :: lt
    logical :: ok

    character(*), parameter :: FMT1 = "(1x,A,9(1x,F15.10))"
    character(*), parameter :: FMT2 = "(1x,A,9(1x,F11.6))"

    write (u, "(A)")  "* Test output: recoil_kinematics_6"
    write (u, "(A)")  "*   Purpose: check effect of mass in on-shell projection"
    write (u, "(A)")

    sqrts = 10
    write (u, FMT1)  "sqrts =", sqrts
    z = 0
    mo = 0.511e-3
    write (u, FMT1)  "mass  =", mo

    write (u, "(A)")
    write (u, "(A)") "*** collinear data set"
    write (u, "(A)")

    xc = [0.6_default, 0.9_default]
    xcb = 1 - xc
    phi = [0.1_default, 0.2_default] * twopi
    q = 0

    call show_data
    call solve_recoil (sqrts, xc, xcb, phi, q**2, x, xb, cos_th, sin_th, ok)
    call recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, z, km, qm, qo, ok)
    call recoil_transformation (sqrts, xc, qo, lt)
    write (u, "(A)")
    write (u, "(A)") "Massless projection:"
    call show_momenta

    call recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, mo, km, qm, qo, ok)
    call recoil_transformation (sqrts, xc, qo, lt)
    write (u, "(A)")
    write (u, "(A)") "Massive projection:"
    call show_momenta

    write (u, "(A)")
    write (u, "(A)") "*** moderate data set"
    write (u, "(A)")

    xc = [0.6_default, 0.9_default]
    xcb = 1 - xc
    phi = [0.1_default, 0.2_default] * twopi
    q = [0.2_default, 0.05_default] * sqrts

    call show_data
    call solve_recoil (sqrts, xc, xcb, phi, q**2, x, xb, cos_th, sin_th, ok)
    call recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, z, km, qm, qo, ok)
    call recoil_transformation (sqrts, xc, qo, lt)
    write (u, "(A)")
    write (u, "(A)") "Massless projection:"
    call show_momenta

    call recoil_momenta (sqrts, xc, xb, cos_th, sin_th, phi, mo, km, qm, qo, ok)
    call recoil_transformation (sqrts, xc, qo, lt)
    write (u, "(A)")
    write (u, "(A)") "Massive projection:"
    call show_momenta

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: recoil_kinematics_6"

  contains

    subroutine show_data
      write (u, FMT1) "sqs_h =", sqrt (xc(1) * xc(2)) * sqrts
      write (u, FMT1) "xc    =", xc
      write (u, FMT1) "xcb   =", xcb
      write (u, FMT1) "Q     =", Q
      write (u, FMT1) "phi/D =", phi / degree
    end subroutine show_data

    subroutine show_momenta
      write (u, "(A)") "Momenta: q(os)"
      call qo(1)%write (u, testflag=.true.)
      write (u, FMT2)  "m = ", abs (qo(1)**1)
      call qo(2)%write (u, testflag=.true.)
      write (u, FMT2)  "m = ", abs (qo(2)**1)
    end subroutine show_momenta

  end subroutine recoil_kinematics_6

@ %def recoil_kinematics_6
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Transverse momentum for the ISR and EPA approximations}

The ISR and EPA handler takes an event with a single radiated collinear
particle (photon for ISR, beam particle for EPA) for each beam, respectively,
and inserts transverse momentum for both.  The four-particle kinematics allows
us to generate $Q^2$ and azimuthal angles independently, without violating
energy-momentum conservation.  The $Q^2$ distribution is logarithmic, as
required by the effective particle approximation, and reflected in the
inclusive ISR/EPA structure functions.  We also conserve the invariant mass of
the partonic systm after radiation.  The total transverse-momentum kick is
applied in form of a Lorentz transformation to the elementary process, both
in- and out-particles.  In fact, the incoming partons (beam particle for ISR,
photon for EPA) which would be virtual space-like in the exact kinematics
configuration, are replaced by on-shell incoming partons, such that energy,
momentum, and invariant mass $\sqrt{\hat s}$ are conserved.

Regarding kinematics, we treat all particles as massless.  The beam-particle
mass only appears as the parameter [[isr_mass]] or [[epa_mass]], respectively,
and cuts off the logarithmic distribution.  The upper cutoff is [[isr_q_max]]
([[epa_q_max]]), which defaults to the available energy $\sqrt{s}$.

The only differences between ISR and EPA, in this context, are the particle
types, and an extra $\bar x$ factor in the lower cutoff for EPA, see below.
<<[[isr_epa_handler.f90]]>>=
<<File header>>

module isr_epa_handler

<<Use kinds>>
<<Use strings>>
  use lorentz, only: vector4_t
  use lorentz, only: energy
  use lorentz, only: lorentz_transformation_t
  use lorentz, only: identity
  use lorentz, only: inverse
  use lorentz, only: operator(*)
  use flavors, only: flavor_t
  use particles, only: particle_t
  use rng_base, only: rng_t
  use event_transforms

<<Standard module head>>

<<ISR/EPA handler: public>>

<<ISR/EPA handler: parameters>>

<<ISR/EPA handler: types>>

  interface
<<ISR/EPA handler: sub interfaces>>
  end interface

end module isr_epa_handler
@ %def isr_epa_handler
@
<<[[isr_epa_handler_sub.f90]]>>=
<<File header>>

submodule (isr_epa_handler) isr_epa_handler_s

  use diagnostics, only: msg_fatal
  use diagnostics, only: msg_bug
  use io_units
  use format_defs, only: FMT_12, FMT_19
  use format_utils, only: write_separator
  use format_utils, only: pac_fmt
  use physics_defs, only: PHOTON
  use recoil_kinematics, only: initial_transformation
  use recoil_kinematics, only: generate_recoil
  use recoil_kinematics, only: recoil_transformation

  implicit none

contains

<<ISR/EPA handler: procedures>>

end submodule isr_epa_handler_s

@ %def isr_epa_handler_s
@
\subsection{Event transform type}
Convention: [[beam]] are the incoming partons before ISR -- not
necessarily the actual beams, need not be in c.m.\ frame.  [[radiated]]
are the radiated particles (photon for ISR), and [[parton]] are the
remainders which
initiate the elementary process.  These particles are copied verbatim
from the event record, and must be collinear.

The kinematical parameters are [[sqrts]] = invariant mass of the
[[beam]] particles, [[q_max]] and [[m]] determining the $Q^2$
distribution, and [[xc]]/[[xcb]] as the energy fraction (complement)
of the partons, relative to the beams.

Transformations: [[lti]] is the Lorentz transformation that would
boosts [[pi]] (c.m. frame) back to the original [[beam]] momenta (lab
frame).  [[lto]] is the recoil transformation, transforming the partons
after ISR from the collinear frame to the recoiling frame.  [[lt]] is
the combination of both, which is to be applied to all particles after
the hard interaction.

Momenta: [[pi]] are the beams transformed to their common c.m.\ frame.
[[ki]] and [[qi]] are the photon/parton
momenta in the [[pi]] c.m.\ frame.  [[km]] and [[qm]] are the
photon/parton momenta with the $Q$ distribution applied, and finally
[[qo]] are the partons [[qm]] projected on-shell.
<<ISR/EPA handler: public>>=
  public :: evt_isr_epa_t
<<ISR/EPA handler: types>>=
  type, extends (evt_t) :: evt_isr_epa_t
     private
     integer :: mode = ISR_TRIVIAL_COLLINEAR
     logical :: isr_active = .false.
     logical :: epa_active = .false.
     real(default) :: isr_q_max = 0
     real(default) :: epa_q_max = 0
     real(default) :: isr_mass = 0
     real(default) :: epa_mass = 0
     logical :: isr_keep_mass = .true.
     real(default) :: sqrts = 0
     integer, dimension(2) :: rad_mode = BEAM_RAD_NONE
     real(default), dimension(2) :: q_max = 0
     real(default), dimension(2) :: m = 0
     real(default), dimension(2) :: xc = 0
     real(default), dimension(2) :: xcb = 0
     type(lorentz_transformation_t) :: lti = identity
     type(lorentz_transformation_t) :: lto = identity
     type(lorentz_transformation_t) :: lt  = identity
     integer, dimension(2) :: i_beam = 0
     type(particle_t), dimension(2) :: beam
     type(vector4_t), dimension(2) :: pi
     integer, dimension(2) :: i_radiated = 0
     type(particle_t), dimension(2) :: radiated
     type(vector4_t), dimension(2) :: ki
     type(vector4_t), dimension(2) :: km
     integer, dimension(2) :: i_parton = 0
     type(particle_t), dimension(2) :: parton
     type(vector4_t), dimension(2) :: qi
     type(vector4_t), dimension(2) :: qm
     type(vector4_t), dimension(2) :: qo
   contains
   <<ISR/EPA handler: evt isr: TBP>>
  end type evt_isr_epa_t

@ %def evt_isr_epa_t
@
\subsection{ISR/EPA distinction}
<<ISR/EPA handler: parameters>>=
  integer, parameter, public :: BEAM_RAD_NONE = 0
  integer, parameter, public :: BEAM_RAD_ISR = 1
  integer, parameter, public :: BEAM_RAD_EPA = 2

@ %def BEAM_RAD_NONE
@ %def BEAM_RAD_ISR
@ %def BEAM_RAD_EPA
<<ISR/EPA handler: procedures>>=
  function rad_mode_string (mode) result (string)
    type(string_t) :: string
    integer, intent(in) :: mode
    select case (mode)
    case (BEAM_RAD_NONE);  string = "---"
    case (BEAM_RAD_ISR);   string = "ISR"
    case (BEAM_RAD_EPA);   string = "EPA"
    case default;  string = "???"
    end select
  end function rad_mode_string

@ %def rad_mode_string
@
\subsection{Photon insertion modes}
<<ISR/EPA handler: parameters>>=
  integer, parameter, public :: ISR_TRIVIAL_COLLINEAR = 0
  integer, parameter, public :: ISR_PAIR_RECOIL = 1

@ %def ISR_TRIVIAL_COLLINEAR ISR_PAIR_RECOIL
@
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: get_mode_string => evt_isr_epa_get_mode_string
<<ISR/EPA handler: sub interfaces>>=
    module function evt_isr_epa_get_mode_string (evt) result (string)
      type(string_t) :: string
      class(evt_isr_epa_t), intent(in) :: evt
    end function evt_isr_epa_get_mode_string
<<ISR/EPA handler: procedures>>=
  module function evt_isr_epa_get_mode_string (evt) result (string)
    type(string_t) :: string
    class(evt_isr_epa_t), intent(in) :: evt
    select case (evt%mode)
    case (ISR_TRIVIAL_COLLINEAR)
       string = "trivial, collinear"
    case (ISR_PAIR_RECOIL)
       string = "pair recoil"
    case default
       string = "[undefined]"
    end select
  end function evt_isr_epa_get_mode_string

@ %def evt_isr_epa_get_mode_string
@ Set the numerical mode ID from a user-level string representation.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: set_mode_string => evt_isr_epa_set_mode_string
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_set_mode_string (evt, string)
      class(evt_isr_epa_t), intent(inout) :: evt
      type(string_t), intent(in) :: string
    end subroutine evt_isr_epa_set_mode_string
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_set_mode_string (evt, string)
    class(evt_isr_epa_t), intent(inout) :: evt
    type(string_t), intent(in) :: string
    select case (char (string))
    case ("trivial")
       evt%mode = ISR_TRIVIAL_COLLINEAR
    case ("recoil")
       evt%mode = ISR_PAIR_RECOIL
    case default
       call msg_fatal ("ISR handler: mode '" // char (string) &
            // "' is undefined")
    end select
  end subroutine evt_isr_epa_set_mode_string

@ %def evt_isr_epa_set_mode_string
@
\subsection{Output}
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: write_name => evt_isr_epa_write_name
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_write_name (evt, unit)
      class(evt_isr_epa_t), intent(in) :: evt
      integer, intent(in), optional :: unit
    end subroutine evt_isr_epa_write_name
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_write_name (evt, unit)
    class(evt_isr_epa_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Event transform: ISR/EPA handler"
  end subroutine evt_isr_epa_write_name

@ %def evt_isr_epa_write_name
@ The overall recoil-handling mode.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: write_mode => evt_isr_epa_write_mode
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_write_mode (evt, unit)
      class(evt_isr_epa_t), intent(in) :: evt
      integer, intent(in), optional :: unit
    end subroutine evt_isr_epa_write_mode
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_write_mode (evt, unit)
    class(evt_isr_epa_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A,1x,I0,':',1x,A)")  "Insertion mode =", evt%mode, &
         char (evt%get_mode_string ())
  end subroutine evt_isr_epa_write_mode

@ %def evt_isr_epa_write_mode
@ The input data for ISR and EPA, respectively.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: write_input => evt_isr_epa_write_input
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_write_input (evt, unit, testflag)
      class(evt_isr_epa_t), intent(in) :: evt
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: testflag
    end subroutine evt_isr_epa_write_input
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_write_input (evt, unit, testflag)
    class(evt_isr_epa_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    character(len=7) :: fmt
    integer :: u
    u = given_output_unit (unit)
    call pac_fmt (fmt, FMT_19, FMT_12, testflag)
    if (evt%isr_active) then
       write (u, "(3x,A,1x," // fmt // ")") "ISR: Q_max =", evt%isr_q_max
       write (u, "(3x,A,1x," // fmt // ")") "     m     =", evt%isr_mass
       write (u, "(3x,A,1x,L1)") "     keep m=", evt%isr_keep_mass
    else
       write (u, "(3x,A)") "ISR: [inactive]"
    end if
    if (evt%epa_active) then
       write (u, "(3x,A,1x," // fmt // ")") "EPA: Q_max =", evt%epa_q_max
       write (u, "(3x,A,1x," // fmt // ")") "     m     =", evt%epa_mass
    else
       write (u, "(3x,A)") "EPA: [inactive]"
    end if
  end subroutine evt_isr_epa_write_input

@ %def evt_isr_epa_write_input
@ The trivial mode does not depend on any data, since it does nothing
to the event.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: write_data => evt_isr_epa_write_data
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_write_data (evt, unit, testflag)
      class(evt_isr_epa_t), intent(in) :: evt
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: testflag
    end subroutine evt_isr_epa_write_data
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_write_data (evt, unit, testflag)
    class(evt_isr_epa_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    character(len=7), parameter :: FMTL_19 = "A3,16x"
    character(len=7), parameter :: FMTL_12 = "A3,9x"
    character(len=7) :: fmt, fmtl
    integer :: u
    u = given_output_unit (unit)
    call pac_fmt (fmt, FMT_19, FMT_12, testflag)
    call pac_fmt (fmtl, FMTL_19, FMTL_12, testflag)
    select case (evt%mode)
    case (ISR_PAIR_RECOIL)
       write (u, "(1x,A)")  "Event:"
       write (u, "(3x,A,2(1x," // fmtl // "))") &
            "mode  = ", &
            char (rad_mode_string (evt%rad_mode(1))), &
            char (rad_mode_string (evt%rad_mode(2)))
       write (u, "(3x,A,2(1x," // fmt // "))") "Q_max =", evt%q_max
       write (u, "(3x,A,2(1x," // fmt // "))") "m     =", evt%m
       write (u, "(3x,A,2(1x," // fmt // "))") "x     =", evt%xc
       write (u, "(3x,A,2(1x," // fmt // "))") "xb    =", evt%xcb
       write (u, "(3x,A,1x," // fmt // ")")    "sqrts =", evt%sqrts
       call write_separator (u)
       write (u, "(A)")  "Lorentz boost (partons before radiation &
            &c.m. -> lab) ="
       call evt%lti%write (u, testflag)
       write (u, "(A)")  "Lorentz transformation (collinear partons &
            &-> partons with recoil in c.m.) ="
       call evt%lto%write (u, testflag)
       write (u, "(A)")  "Combined transformation (partons &
            &-> partons with recoil in lab frame) ="
       call evt%lt%write (u, testflag)
    end select
  end subroutine evt_isr_epa_write_data

@ %def evt_isr_epa_write_data
@ Output method.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: write => evt_isr_epa_write
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_write &
         (evt, unit, verbose, more_verbose, testflag)
      class(evt_isr_epa_t), intent(in) :: evt
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: verbose, more_verbose, testflag
    end subroutine evt_isr_epa_write
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_write &
       (evt, unit, verbose, more_verbose, testflag)
    class(evt_isr_epa_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    logical :: show_mass
    integer :: u, i
    u = given_output_unit (unit)
    if (present (testflag)) then
       show_mass = .not. testflag
    else
       show_mass = .true.
    end if
    call write_separator (u, 2)
    call evt%write_name (u)
    call write_separator (u, 2)
    call evt%write_mode (u)
    call evt%write_input (u, testflag=testflag)
    call evt%write_data (u, testflag=testflag)
    call write_separator (u)
    call evt%base_write (u, testflag = testflag, show_set = .false.)
    if (all (evt%i_beam > 0)) then
       call write_separator (u)
       write (u, "(A,2(1x,I0))")  "Partons before radiation:", evt%i_beam
       do i = 1, 2
          call evt%beam(i)%write (u, testflag=testflag)
       end do
       call write_separator (u)
       write (u, "(A)")  "... boosted to c.m.:"
       do i = 1, 2
          call evt%pi(i)%write (u, show_mass=show_mass, testflag=testflag)
       end do
    end if
    if (all (evt%i_radiated > 0)) then
       call write_separator (u)
       write (u, "(A,2(1x,I0))")  "Radiated particles, collinear:", &
            evt%i_radiated
       do i = 1, 2
          call evt%radiated(i)%write (u, testflag=testflag)
       end do
       call write_separator (u)
       write (u, "(A)")  "... boosted to c.m.:"
       do i = 1, 2
          call evt%ki(i)%write (u, show_mass=show_mass, testflag=testflag)
       end do
       call write_separator (u)
       write (u, "(A)")  "... with kT:"
       do i = 1, 2
          call evt%km(i)%write (u, show_mass=show_mass, testflag=testflag)
       end do
    end if
    if (all (evt%i_parton > 0)) then
       call write_separator (u)
       write (u, "(A,2(1x,I0))")  "Partons after radiation, collinear:", &
            evt%i_parton
       do i = 1, 2
          call evt%parton(i)%write (u, testflag=testflag)
       end do
       call write_separator (u)
       write (u, "(A)")  "... boosted to c.m.:"
       do i = 1, 2
          call evt%qi(i)%write (u, show_mass=show_mass, testflag=testflag)
       end do
       call write_separator (u)
       write (u, "(A)")  "... with qT, off-shell:"
       do i = 1, 2
          call evt%qm(i)%write (u, show_mass=show_mass, testflag=testflag)
       end do
       call write_separator (u)
       write (u, "(A)")  "... projected on-shell:"
       do i = 1, 2
          call evt%qo(i)%write (u, show_mass=show_mass, testflag=testflag)
       end do
       call write_separator (u)
    end if
    if (evt%particle_set_exists)  &
         call evt%particle_set%write &
         (u, summary = .true., compressed = .true., testflag = testflag)
    call write_separator (u)
  end subroutine evt_isr_epa_write

@ %def evt_isr_epa_write
@
\subsection{Initialization}
Manually import a random-number generator object.  This should be
done only for testing purposes.  The standard procedure is to
[[connect]] a process to an event transform; this will create an
appropriate [[rng]] from the RNG factory in the process object.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: import_rng => evt_isr_epa_import_rng
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_import_rng (evt, rng)
      class(evt_isr_epa_t), intent(inout) :: evt
      class(rng_t), allocatable, intent(inout) :: rng
    end subroutine evt_isr_epa_import_rng
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_import_rng (evt, rng)
    class(evt_isr_epa_t), intent(inout) :: evt
    class(rng_t), allocatable, intent(inout) :: rng
    call move_alloc (from = rng, to = evt%rng)
  end subroutine evt_isr_epa_import_rng

@ %def evt_isr_epa_import_rng
@ Set constant kinematics limits and initialize for ISR.  Note that [[sqrts]]
is used only as the fallback value for [[q_max]].  The actual [[sqrts]] value
for the transform object is inferred from the incoming particles, event by
event.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: set_data_isr => evt_isr_epa_set_data_isr
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_set_data_isr (evt, sqrts, q_max, m, keep_mass)
      class(evt_isr_epa_t), intent(inout) :: evt
      real(default), intent(in) :: sqrts
      real(default), intent(in) :: q_max
      real(default), intent(in) :: m
      logical, intent(in) :: keep_mass
    end subroutine evt_isr_epa_set_data_isr
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_set_data_isr (evt, sqrts, q_max, m, keep_mass)
    class(evt_isr_epa_t), intent(inout) :: evt
    real(default), intent(in) :: sqrts
    real(default), intent(in) :: q_max
    real(default), intent(in) :: m
    logical, intent(in) :: keep_mass
    if (sqrts <= 0) then
       call msg_fatal ("ISR handler: sqrts value must be positive")
    end if
    if (q_max <= 0 .or. q_max > sqrts) then
       evt%isr_q_max = sqrts
    else
       evt%isr_q_max = q_max
    end if
    if (m > 0) then
       evt%isr_mass = m
    else
       call msg_fatal ("ISR handler: ISR_mass value must be positive")
    end if
    evt%isr_active = .true.
    evt%isr_keep_mass = keep_mass
  end subroutine evt_isr_epa_set_data_isr

@ %def evt_isr_epa_set_data_isr
@ Set constant kinematics limits and initialize for EPA.  Note that [[sqrts]] is
used only as the fallback value for [[q_max]].  The actual [[sqrts]]
value for the transform object is inferred from the incoming
particles, event by event.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: set_data_epa => evt_isr_epa_set_data_epa
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_set_data_epa (evt, sqrts, q_max, m)
      class(evt_isr_epa_t), intent(inout) :: evt
      real(default), intent(in) :: sqrts
      real(default), intent(in) :: q_max
      real(default), intent(in) :: m
    end subroutine evt_isr_epa_set_data_epa
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_set_data_epa (evt, sqrts, q_max, m)
    class(evt_isr_epa_t), intent(inout) :: evt
    real(default), intent(in) :: sqrts
    real(default), intent(in) :: q_max
    real(default), intent(in) :: m
    if (sqrts <= 0) then
       call msg_fatal ("EPA handler: sqrts value must be positive")
    end if
    if (q_max <= 0 .or. q_max > sqrts) then
       evt%epa_q_max = sqrts
    else
       evt%epa_q_max = q_max
    end if
    if (m > 0) then
       evt%epa_mass = m
    else
       call msg_fatal ("EPA handler: EPA_mass value must be positive")
    end if
    evt%epa_active = .true.
  end subroutine evt_isr_epa_set_data_epa

@ %def evt_isr_epa_set_data_epa
@
\subsection{Fetch event data}
Identify the radiated particles and the recoil momenta in the
particle set.  Without much sophistication, start from the end and
find particles with the ``remnant'' status.  Their parents should point to
the recoiling parton.  If successful, set the particle indices in the
[[evt]] object, for further processing.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure, private :: identify_radiated
<<ISR/EPA handler: sub interfaces>>=
    module subroutine identify_radiated (evt)
      class(evt_isr_epa_t), intent(inout) :: evt
    end subroutine identify_radiated
<<ISR/EPA handler: procedures>>=
  module subroutine identify_radiated (evt)
    class(evt_isr_epa_t), intent(inout) :: evt
    integer :: i, k
    k = 2
    FIND_LAST_RADIATED: do i = evt%particle_set%get_n_tot (), 1, -1
       associate (prt => evt%particle_set%prt(i))
         if (prt%is_beam_remnant ()) then
            evt%i_radiated(k) = i
            evt%radiated(k) = prt
            k = k - 1
            if (k == 0)  exit FIND_LAST_RADIATED
         end if
       end associate
    end do FIND_LAST_RADIATED
    if (k /= 0)  call err_count
  contains
    subroutine err_count
      call evt%particle_set%write ()
      call msg_fatal ("ISR/EPA handler: &
           &event does not contain two radiated particles")
    end subroutine err_count
  end subroutine identify_radiated

@ %def identify_radiated
@ When the radiated particles are known, we can fetch their parent
particles and ask for the other child, the incoming parton.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure, private :: identify_partons
<<ISR/EPA handler: sub interfaces>>=
    module subroutine identify_partons (evt)
      class(evt_isr_epa_t), intent(inout) :: evt
    end subroutine identify_partons
<<ISR/EPA handler: procedures>>=
  module subroutine identify_partons (evt)
    class(evt_isr_epa_t), intent(inout) :: evt
    integer, dimension(:), allocatable :: parent, child
    integer :: i, j
    if (all (evt%i_radiated > 0)) then
       do i = 1, 2
          parent = evt%radiated(i)%get_parents ()
          if (size (parent) /= 1)  call err_mismatch
          evt%i_beam(i) = parent(1)
          evt%beam(i) = evt%particle_set%prt(parent(1))
          associate (prt => evt%beam(i))
            child = prt%get_children ()
            if (size (child) /= 2)  call err_mismatch
            do j = 1, 2
               if (child(j) /= evt%i_radiated(i)) then
                  evt%i_parton(i) = child(j)
                  evt%parton(i) = evt%particle_set%prt(child(j))
               end if
            end do
          end associate
       end do
    end if
  contains
    subroutine err_mismatch
      call evt%particle_set%write ()
      call msg_bug ("ISR/EPA handler: mismatch in parent-child relations")
    end subroutine err_mismatch
  end subroutine identify_partons

@ %def identify_partons
@ Check whether the radiated particle is a photon, or the incoming
parton is a photon.  Then set the ISR/EPA switch appropriately, for
each beam.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: check_radiation => evt_isr_epa_check_radiation
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_check_radiation (evt)
      class(evt_isr_epa_t), intent(inout) :: evt
    end subroutine evt_isr_epa_check_radiation
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_check_radiation (evt)
    class(evt_isr_epa_t), intent(inout) :: evt
    type(flavor_t) :: flv
    integer :: i
    do i = 1, 2
       flv = evt%radiated(i)%get_flv ()
       if (flv%get_pdg () == PHOTON) then
          if (evt%isr_active) then
             evt%rad_mode(i) = BEAM_RAD_ISR
          else
             call err_isr_init
          end if
       else
          flv = evt%parton(i)%get_flv ()
          if (flv%get_pdg () == PHOTON) then
             if (evt%epa_active) then
                evt%rad_mode(i) = BEAM_RAD_EPA
             else
                call err_epa_init
             end if
          else
             call err_no_photon
          end if
       end if
    end do
  contains
    subroutine err_isr_init
      call evt%particle_set%write ()
      call msg_fatal ("ISR/EPA handler: &
           &event contains radiated photon, but ISR is not initialized")
    end subroutine err_isr_init
    subroutine err_epa_init
      call evt%particle_set%write ()
      call msg_fatal ("ISR/EPA handler: &
           &event contains incoming photon, but EPA is not initialized")
    end subroutine err_epa_init
    subroutine err_no_photon
      call evt%particle_set%write ()
      call msg_fatal ("ISR/EPA handler: &
           &event does not appear to be ISR or EPA - missing photon")
    end subroutine err_no_photon
  end subroutine evt_isr_epa_check_radiation

@ %def evt_isr_epa_check_radiation
@ Internally set the appropriate parameters (ISR/EPA) for the two
beams in the recoil mode.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: set_recoil_parameters => evt_isr_epa_set_recoil_parameters
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_set_recoil_parameters (evt)
      class(evt_isr_epa_t), intent(inout) :: evt
    end subroutine evt_isr_epa_set_recoil_parameters
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_set_recoil_parameters (evt)
    class(evt_isr_epa_t), intent(inout) :: evt
    integer :: i
    do i = 1, 2
       select case (evt%rad_mode(i))
       case (BEAM_RAD_ISR)
          evt%q_max(i) = evt%isr_q_max
          evt%m(i) = evt%isr_mass
       case (BEAM_RAD_EPA)
          evt%q_max(i) = evt%epa_q_max
          evt%m(i) = evt%epa_mass
       end select
    end do
  end subroutine evt_isr_epa_set_recoil_parameters

@ %def evt_isr_epa_set_recoil_parameters
@ Boost the particles that participate in ISR to their proper
c.m.\ frame, copying the momenta to [[pi]], [[ki]], [[qi]].  Also
assign [[sqrts]] properly.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure, private :: boost_to_cm
<<ISR/EPA handler: sub interfaces>>=
    module subroutine boost_to_cm (evt)
      class(evt_isr_epa_t), intent(inout) :: evt
    end subroutine boost_to_cm
<<ISR/EPA handler: procedures>>=
  module subroutine boost_to_cm (evt)
    class(evt_isr_epa_t), intent(inout) :: evt
    type(vector4_t), dimension(2) :: p
    type(vector4_t), dimension(2) :: k
    type(vector4_t), dimension(2) :: q
    logical :: ok
    p = evt%beam%get_momentum ()
    k = evt%radiated%get_momentum ()
    q = evt%parton%get_momentum ()
    call initial_transformation (p, evt%sqrts, evt%lti, ok)
    if (.not. ok)  call err_non_collinear
    evt%pi = inverse (evt%lti) * p
    evt%ki = inverse (evt%lti) * k
    evt%qi = inverse (evt%lti) * q
  contains
    subroutine err_non_collinear
      call evt%particle_set%write ()
      call msg_fatal ("ISR/EPA handler: &
           &partons before radiation are not collinear")
    end subroutine err_non_collinear
  end subroutine boost_to_cm

@ %def boost_to_cm
@ We can infer the $x$ and $\bar x$ values of the event by looking at
the energy fractions of the radiated particles and incoming partons,
respectively, relative to their
parents.  Of course, we must assume that they are all collinear, and
that energy is conserved.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure, private :: infer_x
<<ISR/EPA handler: sub interfaces>>=
    module subroutine infer_x (evt)
      class(evt_isr_epa_t), intent(inout) :: evt
    end subroutine infer_x
<<ISR/EPA handler: procedures>>=
  module subroutine infer_x (evt)
    class(evt_isr_epa_t), intent(inout) :: evt
    real(default) :: E_parent, E_radiated, E_parton
    integer :: i
    if (all (evt%i_radiated > 0)) then
       do i = 1, 2
          E_parent = energy (evt%pi(i))
          E_radiated = energy (evt%ki(i))
          E_parton = energy (evt%qi(i))
          if (E_parent > 0) then
             evt%xc(i) = E_parton / E_parent
             evt%xcb(i)= E_radiated / E_parent
          else
             call err_energy
          end if
       end do
    end if
  contains
    subroutine err_energy
      call evt%particle_set%write ()
      call msg_bug ("ISR/EPA handler: non-positive energy in splitting")
    end subroutine err_energy
  end subroutine infer_x

@ %def infer_x
@
\subsection{Two-parton recoil}
For transforming partons into recoil momenta, we make use of the
routines in the [[recoil_kinematics]] module.  In addition to the
collinear momenta, we use the $x$ energy fractions, and four numbers
from the RNG.

There is one subtle difference w.r.t.\ ISR case: the EPA mass
parameter is multiplied by the energy fraction $x$, separately for
each beam.  This is the effective lower $Q$ cutoff.

For certain kinematics, close to the $Q_\text{max}$ endpoint, this may
fail, and [[ok]] is set to false.  In that case, we should generate
new recoil momenta for the same event.  This is handled by the generic
unweighting procedure.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure, private :: generate_recoil => evt_generate_recoil
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_generate_recoil (evt, ok)
      class(evt_isr_epa_t), intent(inout) :: evt
      logical, intent(out) :: ok
    end subroutine evt_generate_recoil
<<ISR/EPA handler: procedures>>=
  module subroutine evt_generate_recoil (evt, ok)
    class(evt_isr_epa_t), intent(inout) :: evt
    logical, intent(out) :: ok
    real(default), dimension(4) :: r
    real(default), dimension(2) :: m, mo
    integer :: i
    call evt%rng%generate (r)
    m = 0
    mo = 0
    do i = 1, 2
       select case (evt%rad_mode(i))
       case (BEAM_RAD_ISR)
          m(i) = evt%m(i)
          if (evt%isr_keep_mass)  mo(i) = m(i)
       case (BEAM_RAD_EPA)
          m(i) = evt%xc(i) * evt%m(i)
       end select
    end do
    call generate_recoil (evt%sqrts, evt%q_max, m, mo, evt%xc, evt%xcb, r, &
         evt%km, evt%qm, evt%qo, ok)
  end subroutine evt_generate_recoil

@ %def evt_generate_recoil
@ Replace the collinear radiated (incoming) parton momenta by the
momenta that we
have generated, respectively.  Recall that the recoil has been applied
in the c.m.\ system of the partons before ISR, so we apply the stored
Lorentz transformation to boost them to the lab frame.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure, private :: replace_radiated
  procedure, private :: replace_partons
<<ISR/EPA handler: sub interfaces>>=
    module subroutine replace_radiated (evt)
      class(evt_isr_epa_t), intent(inout) :: evt
    end subroutine replace_radiated
    module subroutine replace_partons (evt)
      class(evt_isr_epa_t), intent(inout) :: evt
    end subroutine replace_partons
<<ISR/EPA handler: procedures>>=
  module subroutine replace_radiated (evt)
    class(evt_isr_epa_t), intent(inout) :: evt
    integer :: i
    do i = 1, 2
       associate (prt => evt%particle_set%prt(evt%i_radiated(i)))
         call prt%set_momentum (evt%lti * evt%km(i))
       end associate
    end do
  end subroutine replace_radiated

  module subroutine replace_partons (evt)
    class(evt_isr_epa_t), intent(inout) :: evt
    integer :: i
    do i = 1, 2
       associate (prt => evt%particle_set%prt(evt%i_parton(i)))
         call prt%set_momentum (evt%lti * evt%qo(i))
       end associate
    end do
  end subroutine replace_partons

@ %def replace_radiated
@ %def replace_partons
@
\subsection{Transform the event}
Knowing the new incoming partons for the elementary process, we can
make use of another procedure in [[recoil_kinematics]] to determine
the Lorentz transformation that transforms the collinear frame into
the frame with transverse momentum.  We apply this transformation,
recursively, to all particles that originate from those incoming
partons in the original particle set.

We have to allow for the pre-ISR partons being not in their common
c.m.\ frame.  Taking into account non-commutativity, we actually have
to first transform the outgoing particles to that c.m.\ frame, then
apply the recoil transformation, then boost back to the lab frame.

The [[mask]] keep track of particles that we transform, just in case
the parent-child tree is multiply connected.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: transform_outgoing => evt_transform_outgoing
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_transform_outgoing (evt)
      class(evt_isr_epa_t), intent(inout) :: evt
    end subroutine evt_transform_outgoing
<<ISR/EPA handler: procedures>>=
  module subroutine evt_transform_outgoing (evt)
    class(evt_isr_epa_t), intent(inout) :: evt
    logical, dimension(:), allocatable :: mask
    call recoil_transformation (evt%sqrts, evt%xc, evt%qo, evt%lto)
    evt%lt = evt%lti * evt%lto * inverse (evt%lti)
    allocate (mask (evt%particle_set%get_n_tot ()), source=.false.)
    call transform_children (evt%i_parton(1))
  contains
    recursive subroutine transform_children (i)
      integer, intent(in) :: i
      integer :: j, n_child, c
      integer, dimension(:), allocatable :: child
      child = evt%particle_set%prt(i)%get_children ()
      do j = 1, size (child)
         c = child(j)
         if (.not. mask(c)) then
            associate (prt => evt%particle_set%prt(c))
              call prt%set_momentum (evt%lt * prt%get_momentum ())
              mask(c) = .true.
              call transform_children (c)
            end associate
         end if
      end do
    end subroutine transform_children
  end subroutine evt_transform_outgoing

@ %def evt_transform_outgoing
@
\subsection{Implemented methods}
Here we take the particle set from the previous event transform and
copy it, then generate the transverse momentum for the radiated
particles and for
the incoming partons.  If this fails (rarely, for large $p_T$),
return zero for the probability, to trigger another try.

NOTE: The boost for the initial partonic system, if not in the
c.m.\ frame, has not been implemented yet.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: generate_weighted => &
       evt_isr_epa_generate_weighted
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_generate_weighted (evt, probability)
      class(evt_isr_epa_t), intent(inout) :: evt
      real(default), intent(inout) :: probability
    end subroutine evt_isr_epa_generate_weighted
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_generate_weighted (evt, probability)
    class(evt_isr_epa_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    logical :: valid
    call evt%particle_set%final ()
    evt%particle_set = evt%previous%particle_set
    evt%particle_set_exists = .true.
    select case (evt%mode)
    case (ISR_TRIVIAL_COLLINEAR)
       probability = 1
       valid = .true.
    case (ISR_PAIR_RECOIL)
       call evt%identify_radiated ()
       call evt%identify_partons ()
       call evt%check_radiation ()
       call evt%set_recoil_parameters ()
       call evt%boost_to_cm ()
       call evt%infer_x ()
       call evt%generate_recoil (valid)
       if (valid) then
          probability = 1
       else
          probability = 0
       end if
    case default
       call msg_bug ("ISR/EPA handler: generate weighted: unsupported mode")
    end select
    evt%particle_set_exists = .false.
  end subroutine evt_isr_epa_generate_weighted

@ %def evt_isr_epa_generate_weighted
@ Insert the generated radiated particles and incoming partons with
$p_T$ in their respective places.

The factorization parameters are irrelevant.
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: make_particle_set => &
       evt_isr_epa_make_particle_set
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_make_particle_set &
         (evt, factorization_mode, keep_correlations, r)
      class(evt_isr_epa_t), intent(inout) :: evt
      integer, intent(in) :: factorization_mode
      logical, intent(in) :: keep_correlations
      real(default), dimension(:), intent(in), optional :: r
    end subroutine evt_isr_epa_make_particle_set
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_isr_epa_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    select case (evt%mode)
    case (ISR_TRIVIAL_COLLINEAR)
    case (ISR_PAIR_RECOIL)
       call evt%replace_radiated ()
       call evt%replace_partons ()
       call evt%transform_outgoing ()
    case default
       call msg_bug ("ISR/EPA handler: make particle set: unsupported mode")
    end select
    evt%particle_set_exists = .true.
  end subroutine evt_isr_epa_make_particle_set

@ %def event_isr_epa_handler_make_particle_set
@
<<ISR/EPA handler: evt isr: TBP>>=
  procedure :: prepare_new_event => &
       evt_isr_epa_prepare_new_event
<<ISR/EPA handler: sub interfaces>>=
    module subroutine evt_isr_epa_prepare_new_event (evt, i_mci, i_term)
      class(evt_isr_epa_t), intent(inout) :: evt
      integer, intent(in) :: i_mci, i_term
    end subroutine evt_isr_epa_prepare_new_event
<<ISR/EPA handler: procedures>>=
  module subroutine evt_isr_epa_prepare_new_event (evt, i_mci, i_term)
    class(evt_isr_epa_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
  end subroutine evt_isr_epa_prepare_new_event

@ %def evt_isr_epa_prepare_new_event
@
\subsection{Unit tests: ISR}
Test module, followed by the corresponding implementation module.

This test module differs from most of the other test modules, since it
contains two test subroutines: one for ISR and one for EPA below.
<<[[isr_epa_handler_ut.f90]]>>=
<<File header>>

module isr_epa_handler_ut
  use unit_tests
  use isr_epa_handler_uti

<<Standard module head>>

<<ISR/EPA handler: public test>>

contains

<<ISR/EPA handler: test driver>>

end module isr_epa_handler_ut
@ %def isr_epa_handler_ut
@
<<[[isr_epa_handler_uti.f90]]>>=
<<File header>>

module isr_epa_handler_uti

<<Use kinds>>
<<Use strings>>
  use format_utils, only: write_separator
  use os_interface
  use lorentz, only: vector4_t, vector4_moving, operator(*)
  use rng_base, only: rng_t
  use models, only: syntax_model_file_init, syntax_model_file_final
  use models, only: model_list_t, model_t
  use particles, only: particle_set_t, pacify

  use event_transforms
  use isr_epa_handler, only: evt_isr_epa_t

  use rng_base_ut, only: rng_test_t

<<Standard module head>>

<<ISR/EPA handler: test declarations>>

contains

<<ISR/EPA handler: tests>>

end module isr_epa_handler_uti

@ %def isr_epa_handler_uti
@ API: driver for the unit tests below.
<<ISR/EPA handler: public test>>=
  public :: isr_handler_test
<<ISR/EPA handler: test driver>>=
  subroutine isr_handler_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<ISR/EPA handler: execute ISR tests>>
  end subroutine isr_handler_test

@ %def isr_handler_test
@
\subsubsection{Trivial case}
Handle photons resulting from ISR radiation.  This test is for the
trivial case where the event is kept collinear.
<<ISR/EPA handler: execute ISR tests>>=
  call test (isr_handler_1, "isr_handler_1", &
       "collinear case, no modification", &
       u, results)
<<ISR/EPA handler: test declarations>>=
  public :: isr_handler_1
<<ISR/EPA handler: tests>>=
  subroutine isr_handler_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(particle_set_t) :: pset
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(evt_trivial_t), target :: evt_trivial
    type(evt_isr_epa_t), target :: evt_isr_epa
    type(vector4_t), dimension(8) :: p
    real(default) :: sqrts
    real(default), dimension(2) :: x, xb
    real(default) :: probability

    write (u, "(A)")  "* Test output: isr_handler_1"
    write (u, "(A)")  "*   Purpose: apply photon handler trivially (no-op)"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, "(A)")  "* Initialize particle set"
    write (u, "(A)")

    call pset%init_direct (n_beam = 2, n_in = 2, n_rem = 2, n_vir = 0, n_out = 2, &
         pdg = [11, -11, 11, -11, 22, 22, 13, -13], model = model)

    sqrts = 100._default
    x = [0.6_default, 0.9_default]
    xb= 1 - x

    p(1) = vector4_moving (sqrts/2, sqrts/2, 3)
    p(2) = vector4_moving (sqrts/2,-sqrts/2, 3)
    p(3:4) = x * p(1:2)
    p(5:6) = xb  * p(1:2)
    p(7:8) = p(3:4)

    call pset%set_momentum (p, on_shell = .false.)

    write (u, "(A)")  "* Fill trivial event transform"
    write (u, "(A)")

    call evt_trivial%reset ()
    call evt_trivial%set_particle_set (pset, 1, 1)
    call pacify (evt_trivial%particle_set)
    call evt_trivial%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize ISR handler transform"
    write (u, "(A)")

    evt_trivial%next => evt_isr_epa
    evt_isr_epa%previous => evt_trivial

    call evt_isr_epa%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Fill ISR handler transform"
    write (u, "(A)")

    call evt_isr_epa%prepare_new_event (1, 1)
    call evt_isr_epa%generate_weighted (probability)
    call evt_isr_epa%make_particle_set (0, .false.)

    call evt_isr_epa%write (u)

    write (u, "(A)")
    write (u, "(A,1x,F8.5)")  "Event probability =", probability

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_isr_epa%final ()
    call evt_trivial%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: isr_handler_1"

  end subroutine isr_handler_1

@ %def isr_handler_1
@
\subsubsection{Photon pair with recoil}
Handle photons resulting from ISR radiation.  This test invokes the
two-photon recoil mechanism.  Both photons acquire transverse
momentum, the parton momenta recoil, such that total energy-momentum
is conserved, and all outgoing photons and partons are on-shell
(massless).
<<ISR/EPA handler: execute ISR tests>>=
  call test (isr_handler_2, "isr_handler_2", &
       "two-photon recoil", &
       u, results)
<<ISR/EPA handler: test declarations>>=
  public :: isr_handler_2
<<ISR/EPA handler: tests>>=
  subroutine isr_handler_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(particle_set_t) :: pset
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(evt_trivial_t), target :: evt_trivial
    type(evt_isr_epa_t), target :: evt_isr_epa
    type(vector4_t), dimension(8) :: p
    real(default) :: sqrts
    real(default), dimension(2) :: x, xb
    class(rng_t), allocatable :: rng
    real(default) :: probability

    write (u, "(A)")  "* Test output: isr_handler_2"
    write (u, "(A)")  "*   Purpose: apply photon handler with two-photon recoil"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, "(A)")  "* Initialize particle set"
    write (u, "(A)")

    call pset%init_direct (n_beam = 2, n_in = 2, n_rem = 2, n_vir = 0, n_out = 2, &
         pdg = [11, -11, 11, -11, 22, 22, 13, -13], model = model)

    sqrts = 100._default
    x = [0.6_default, 0.9_default]
    xb= 1 - x

    p(1) = vector4_moving (sqrts/2, sqrts/2, 3)
    p(2) = vector4_moving (sqrts/2,-sqrts/2, 3)
    p(3:4) = x * p(1:2)
    p(5:6) = xb  * p(1:2)
    p(7:8) = p(3:4)

    call pset%set_momentum (p, on_shell = .false.)

    write (u, "(A)")  "* Fill trivial event transform"
    write (u, "(A)")

    call evt_trivial%reset ()
    call evt_trivial%set_particle_set (pset, 1, 1)
    call pacify (evt_trivial%particle_set)
    call evt_trivial%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize ISR handler transform"
    write (u, "(A)")

    evt_trivial%next => evt_isr_epa
    evt_isr_epa%previous => evt_trivial

    call evt_isr_epa%set_mode_string (var_str ("recoil"))
    call evt_isr_epa%set_data_isr ( &
         sqrts = sqrts, &
         q_max = sqrts, &
         m = 511.e-3_default, &
         keep_mass = .false. &
         )

    allocate (rng_test_t :: rng)
    call rng%init (3)  ! default would produce pi for azimuthal angle
    call evt_isr_epa%import_rng (rng)

    call evt_isr_epa%write (u, testflag=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Fill ISR handler transform"
    write (u, "(A)")

    call evt_isr_epa%prepare_new_event (1, 1)
    call evt_isr_epa%generate_weighted (probability)
    call evt_isr_epa%make_particle_set (0, .false.)

    call evt_isr_epa%write (u, testflag=.true.)

    write (u, "(A)")
    write (u, "(A,1x,F8.5)")  "Event probability =", probability

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_isr_epa%final ()
    call evt_trivial%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: isr_handler_2"

  end subroutine isr_handler_2

@ %def isr_handler_2
@
\subsubsection{Boosted beams}
Handle photons resulting from ISR radiation.  This test invokes the
two-photon recoil mechanism, in the case that the partons before ISR
are not in their c.m.\ frame (but collinear).
<<ISR/EPA handler: execute ISR tests>>=
  call test (isr_handler_3, "isr_handler_3", &
       "two-photon recoil with boost", &
       u, results)
<<ISR/EPA handler: test declarations>>=
  public :: isr_handler_3
<<ISR/EPA handler: tests>>=
  subroutine isr_handler_3 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(particle_set_t) :: pset
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(evt_trivial_t), target :: evt_trivial
    type(evt_isr_epa_t), target :: evt_isr_epa
    type(vector4_t), dimension(8) :: p
    real(default) :: sqrts
    real(default), dimension(2) :: x0
    real(default), dimension(2) :: x, xb
    class(rng_t), allocatable :: rng
    real(default) :: probability

    write (u, "(A)")  "* Test output: isr_handler_3"
    write (u, "(A)")  "*   Purpose: apply photon handler for boosted beams &
         &and two-photon recoil"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, "(A)")  "* Initialize particle set"
    write (u, "(A)")

    call pset%init_direct (n_beam = 2, n_in = 2, n_rem = 2, n_vir = 0, n_out = 2, &
         pdg = [11, -11, 11, -11, 22, 22, 13, -13], model = model)

    write (u, "(A)")  "* Event data"
    write (u, "(A)")

    sqrts = 100._default
    write (u, "(A,2(1x,F12.7))")  "sqrts   =", sqrts

    x0 = [0.9_default, 0.4_default]
    write (u, "(A,2(1x,F12.7))")  "x0      =", x0

    write (u, "(A)")
    write (u, "(A,2(1x,F12.7))")  "sqs_hat =", sqrts * sqrt (product (x0))

    x = [0.6_default, 0.9_default]
    xb= 1 - x
    write (u, "(A,2(1x,F12.7))")  "x       =", x

    write (u, "(A)")
    write (u, "(A,2(1x,F12.7))")  "x0 * x  =", x0 * x

    p(1) = x0(1) * vector4_moving (sqrts/2, sqrts/2, 3)
    p(2) = x0(2) * vector4_moving (sqrts/2,-sqrts/2, 3)
    p(3:4) = x * p(1:2)
    p(5:6) = xb  * p(1:2)
    p(7:8) = p(3:4)

    call pset%set_momentum (p, on_shell = .false.)

    write (u, "(A)")
    write (u, "(A)")  "* Fill trivial event transform"
    write (u, "(A)")

    call evt_trivial%reset ()
    call evt_trivial%set_particle_set (pset, 1, 1)
    call pacify (evt_trivial%particle_set)
    call evt_trivial%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize ISR handler transform"
    write (u, "(A)")

    evt_trivial%next => evt_isr_epa
    evt_isr_epa%previous => evt_trivial

    call evt_isr_epa%set_mode_string (var_str ("recoil"))
    call evt_isr_epa%set_data_isr ( &
         sqrts = sqrts, &
         q_max = sqrts, &
         m = 511.e-3_default, &
         keep_mass = .false. &
         )

    allocate (rng_test_t :: rng)
    call rng%init (3)  ! default would produce pi for azimuthal angle
    call evt_isr_epa%import_rng (rng)

    call evt_isr_epa%write (u, testflag=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Fill ISR handler transform"
    write (u, "(A)")

    call evt_isr_epa%prepare_new_event (1, 1)
    call evt_isr_epa%generate_weighted (probability)
    call evt_isr_epa%make_particle_set (0, .false.)

    call evt_isr_epa%write (u, testflag=.true.)

    write (u, "(A)")
    write (u, "(A,1x,F8.5)")  "Event probability =", probability

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_isr_epa%final ()
    call evt_trivial%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: isr_handler_3"

  end subroutine isr_handler_3

@ %def isr_handler_3
@
\subsection{Unit tests: EPA}
API: Extra driver for the unit tests below.
<<ISR/EPA handler: public test>>=
  public :: epa_handler_test
<<ISR/EPA handler: test driver>>=
  subroutine epa_handler_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<ISR/EPA handler: execute EPA tests>>
  end subroutine epa_handler_test

@ %def epa_handler_test
@
\subsubsection{Trivial case}
Handle events resulting from the EPA approximation.  This test is for the
trivial case where the event is kept collinear.
<<ISR/EPA handler: execute EPA tests>>=
  call test (epa_handler_1, "epa_handler_1", &
       "collinear case, no modification", &
       u, results)
<<ISR/EPA handler: test declarations>>=
  public :: epa_handler_1
<<ISR/EPA handler: tests>>=
  subroutine epa_handler_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(particle_set_t) :: pset
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(evt_trivial_t), target :: evt_trivial
    type(evt_isr_epa_t), target :: evt_isr_epa
    type(vector4_t), dimension(8) :: p
    real(default) :: sqrts
    real(default), dimension(2) :: x, xb
    real(default) :: probability

    write (u, "(A)")  "* Test output: epa_handler_1"
    write (u, "(A)")  "*   Purpose: apply beam handler trivially (no-op)"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, "(A)")  "* Initialize particle set"
    write (u, "(A)")

    call pset%init_direct &
         (n_beam = 2, n_in = 2, n_rem = 2, n_vir = 0, n_out = 2, &
         pdg = [11, -11, 22, 22, 11, -11, 13, -13], &
         model = model)

    sqrts = 100._default
    x = [0.6_default, 0.9_default]
    xb= 1 - x

    p(1) = vector4_moving (sqrts/2, sqrts/2, 3)
    p(2) = vector4_moving (sqrts/2,-sqrts/2, 3)
    p(3:4) = x * p(1:2)
    p(5:6) = xb  * p(1:2)
    p(7:8) = p(3:4)

    call pset%set_momentum (p, on_shell = .false.)

    write (u, "(A)")  "* Fill trivial event transform"
    write (u, "(A)")

    call evt_trivial%reset ()
    call evt_trivial%set_particle_set (pset, 1, 1)
    call pacify (evt_trivial%particle_set)
    call evt_trivial%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize EPA handler transform"
    write (u, "(A)")

    evt_trivial%next => evt_isr_epa
    evt_isr_epa%previous => evt_trivial

    call evt_isr_epa%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Fill EPA handler transform"
    write (u, "(A)")

    call evt_isr_epa%prepare_new_event (1, 1)
    call evt_isr_epa%generate_weighted (probability)
    call evt_isr_epa%make_particle_set (0, .false.)

    call evt_isr_epa%write (u)

    write (u, "(A)")
    write (u, "(A,1x,F8.5)")  "Event probability =", probability

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_isr_epa%final ()
    call evt_trivial%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: epa_handler_1"

  end subroutine epa_handler_1

@ %def epa_handler_1
@
\subsubsection{Beam pair with recoil}
Handle beams resulting from the EPA approximation.  This test invokes the
two-beam recoil mechanism.  Both beam remnants acquire transverse
momentum, the photon momenta recoil, such that total energy-momentum
is conserved, and all outgoing beam remnants and photons are on-shell
(massless).
<<ISR/EPA handler: execute EPA tests>>=
  call test (epa_handler_2, "epa_handler_2", &
       "two-beam recoil", &
       u, results)
<<ISR/EPA handler: test declarations>>=
  public :: epa_handler_2
<<ISR/EPA handler: tests>>=
  subroutine epa_handler_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(particle_set_t) :: pset
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(evt_trivial_t), target :: evt_trivial
    type(evt_isr_epa_t), target :: evt_isr_epa
    type(vector4_t), dimension(8) :: p
    real(default) :: sqrts
    real(default), dimension(2) :: x, xb
    class(rng_t), allocatable :: rng
    real(default) :: probability

    write (u, "(A)")  "* Test output: epa_handler_2"
    write (u, "(A)")  "*   Purpose: apply beam handler with two-beam recoil"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, "(A)")  "* Initialize particle set"
    write (u, "(A)")

    call pset%init_direct (n_beam = 2, n_in = 2, n_rem = 2, n_vir = 0, n_out = 2, &
         pdg = [11, -11, 22, 22, 11, -11, 13, -13], model = model)

    sqrts = 100._default
    x = [0.6_default, 0.9_default]
    xb= 1 - x

    p(1) = vector4_moving (sqrts/2, sqrts/2, 3)
    p(2) = vector4_moving (sqrts/2,-sqrts/2, 3)
    p(3:4) = x * p(1:2)
    p(5:6) = xb  * p(1:2)
    p(7:8) = p(3:4)

    call pset%set_momentum (p, on_shell = .false.)

    write (u, "(A)")  "* Fill trivial event transform"
    write (u, "(A)")

    call evt_trivial%reset ()
    call evt_trivial%set_particle_set (pset, 1, 1)
    call pacify (evt_trivial%particle_set)
    call evt_trivial%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize EPA handler transform"
    write (u, "(A)")

    evt_trivial%next => evt_isr_epa
    evt_isr_epa%previous => evt_trivial

    call evt_isr_epa%set_mode_string (var_str ("recoil"))
    call evt_isr_epa%set_data_epa ( &
         sqrts = sqrts, &
         q_max = sqrts, &
         m = 511.e-3_default &
         )

    allocate (rng_test_t :: rng)
    call rng%init (3)  ! default would produce pi for azimuthal angle
    call evt_isr_epa%import_rng (rng)

    call evt_isr_epa%write (u, testflag=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Fill EPA handler transform"
    write (u, "(A)")

    call evt_isr_epa%prepare_new_event (1, 1)
    call evt_isr_epa%generate_weighted (probability)
    call evt_isr_epa%make_particle_set (0, .false.)

    call evt_isr_epa%write (u, testflag=.true.)

    write (u, "(A)")
    write (u, "(A,1x,F8.5)")  "Event probability =", probability

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_isr_epa%final ()
    call evt_trivial%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: epa_handler_2"

  end subroutine epa_handler_2

@ %def epa_handler_2
@
\subsubsection{Boosted beams}
Handle radiated beam remnants resulting from EPA radiation.  This test
invokes the two-beam recoil mechanism, in the case that the partons
before EPA are not in their c.m.\ frame (but collinear).
<<ISR/EPA handler: execute EPA tests>>=
  call test (epa_handler_3, "epa_handler_3", &
       "two-beam recoil with boost", &
       u, results)
<<ISR/EPA handler: test declarations>>=
  public :: epa_handler_3
<<ISR/EPA handler: tests>>=
  subroutine epa_handler_3 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(particle_set_t) :: pset
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(evt_trivial_t), target :: evt_trivial
    type(evt_isr_epa_t), target :: evt_isr_epa
    type(vector4_t), dimension(8) :: p
    real(default) :: sqrts
    real(default), dimension(2) :: x0
    real(default), dimension(2) :: x, xb
    class(rng_t), allocatable :: rng
    real(default) :: probability

    write (u, "(A)")  "* Test output: epa_handler_3"
    write (u, "(A)")  "*   Purpose: apply beam handler for boosted beams &
         &and two-beam recoil"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, "(A)")  "* Initialize particle set"
    write (u, "(A)")

    call pset%init_direct (n_beam = 2, n_in = 2, n_rem = 2, n_vir = 0, n_out = 2, &
         pdg = [11, -11, 22, 22, 11, -11, 13, -13], model = model)

    write (u, "(A)")  "* Event data"
    write (u, "(A)")

    sqrts = 100._default
    write (u, "(A,2(1x,F12.7))")  "sqrts   =", sqrts

    x0 = [0.9_default, 0.4_default]
    write (u, "(A,2(1x,F12.7))")  "x0      =", x0

    write (u, "(A)")
    write (u, "(A,2(1x,F12.7))")  "sqs_hat =", sqrts * sqrt (product (x0))

    x = [0.6_default, 0.9_default]
    xb= 1 - x
    write (u, "(A,2(1x,F12.7))")  "x       =", x

    write (u, "(A)")
    write (u, "(A,2(1x,F12.7))")  "x0 * x  =", x0 * x

    p(1) = x0(1) * vector4_moving (sqrts/2, sqrts/2, 3)
    p(2) = x0(2) * vector4_moving (sqrts/2,-sqrts/2, 3)
    p(3:4) = x * p(1:2)
    p(5:6) = xb  * p(1:2)
    p(7:8) = p(3:4)

    call pset%set_momentum (p, on_shell = .false.)

    write (u, "(A)")
    write (u, "(A)")  "* Fill trivial event transform"
    write (u, "(A)")

    call evt_trivial%reset ()
    call evt_trivial%set_particle_set (pset, 1, 1)
    call pacify (evt_trivial%particle_set)
    call evt_trivial%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize EPA handler transform"
    write (u, "(A)")

    evt_trivial%next => evt_isr_epa
    evt_isr_epa%previous => evt_trivial

    call evt_isr_epa%set_mode_string (var_str ("recoil"))
    call evt_isr_epa%set_data_epa ( &
         sqrts = sqrts, &
         q_max = sqrts, &
         m = 511.e-3_default &
         )

    allocate (rng_test_t :: rng)
    call rng%init (3)  ! default would produce pi for azimuthal angle
    call evt_isr_epa%import_rng (rng)

    call evt_isr_epa%write (u, testflag=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Fill EPA handler transform"
    write (u, "(A)")

    call evt_isr_epa%prepare_new_event (1, 1)
    call evt_isr_epa%generate_weighted (probability)
    call evt_isr_epa%make_particle_set (0, .false.)

    call evt_isr_epa%write (u, testflag=.true.)

    write (u, "(A)")
    write (u, "(A,1x,F8.5)")  "Event probability =", probability

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_isr_epa%final ()
    call evt_trivial%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: epa_handler_3"

  end subroutine epa_handler_3

@ %def epa_handler_3
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Decays}
<<[[decays.f90]]>>=
<<File header>>

module decays

<<Use kinds>>
<<Use strings>>
  use diagnostics
  use flavors
  use interactions
  use evaluators
  use variables, only: var_list_t
  use model_data
  use rng_base
  use selectors
  use parton_states
  use process, only: process_t
  use instances, only: process_instance_t, pacify
  use process_stacks
  use event_transforms

<<Standard module head>>

<<Decays: public>>

<<Decays: types>>

<<Decays: interfaces>>

  interface
<<Decays: sub interfaces>>
  end interface

contains

<<Decays: main procedures>>

end module decays

@ %def decays
@
<<[[decays_sub.f90]]>>=
<<File header>>

submodule (decays) decays_s

  use io_units
  use format_utils, only: write_indent, write_separator
  use format_defs, only: FMT_15
  use numeric_utils
  use helicities
  use quantum_numbers

  implicit none

contains

<<Decays: procedures>>

end submodule decays_s

@ %def decays_s
@
\subsection{Final-State Particle Configuration}
A final-state particle may be either stable or unstable.  Here is an
empty abstract type as the parent of both, with holds just the flavor
information.
<<Decays: types>>=
  type, abstract :: any_config_t
     private
   contains
   <<Decays: any config: TBP>>
  end type any_config_t

@ %def any_config_t
@ Finalizer, depends on the implementation.
<<Decays: any config: TBP>>=
  procedure (any_config_final), deferred :: final
<<Decays: interfaces>>=
  interface
     subroutine any_config_final (object)
       import
       class(any_config_t), intent(inout) :: object
     end subroutine any_config_final
  end interface

@ %def any_config_final
@ The output is also deferred:
<<Decays: any config: TBP>>=
  procedure (any_config_write), deferred :: write
<<Decays: interfaces>>=
  interface
     subroutine any_config_write (object, unit, indent, verbose)
       import
       class(any_config_t), intent(in) :: object
       integer, intent(in), optional :: unit, indent
       logical, intent(in), optional :: verbose
     end subroutine any_config_write
  end interface

@ %def any_config_write
@ This is a container for a stable or unstable particle configurator.
We need this wrapper for preparing arrays that mix stable and unstable
particles.
<<Decays: types>>=
  type :: particle_config_t
     private
     class(any_config_t), allocatable :: c
  end type particle_config_t

@ %def particle_config_t
@
\subsection{Final-State Particle}
In theory, for the particle instance we only need to consider the
unstable case.  However, it is more straightforward to treat
configuration and instance on the same footing, and to introduce a
wrapper for particle objects as above.
<<Decays: types>>=
  type, abstract :: any_t
     private
   contains
   <<Decays: any: TBP>>
  end type any_t

@ %def any_t
@ Finalizer, depends on the implementation.
<<Decays: any: TBP>>=
  procedure (any_final), deferred :: final
<<Decays: interfaces>>=
  interface
     subroutine any_final (object)
       import
       class(any_t), intent(inout) :: object
     end subroutine any_final
  end interface

@ %def any_final
@ The output is also deferred:
<<Decays: any: TBP>>=
  procedure (any_write), deferred :: write
<<Decays: interfaces>>=
  interface
     subroutine any_write (object, unit, indent)
       import
       class(any_t), intent(in) :: object
       integer, intent(in), optional :: unit, indent
     end subroutine any_write
  end interface

@ %def any_write
@ This is a container for a stable or unstable outgoing particle.
We need this wrapper for preparing arrays that mix stable and unstable
particles.
<<Decays: types>>=
  type :: particle_out_t
     private
     class(any_t), allocatable :: c
  end type particle_out_t

@ %def particle_config_t
@
\subsection{Decay Term Configuration}
A decay term is a distinct final state, corresponding to a process
term.  Each decay process may give rise to several terms with,
possibly, differing flavor content.
<<Decays: types>>=
  type :: decay_term_config_t
     private
     type(particle_config_t), dimension(:), allocatable :: prt
   contains
   <<Decays: decay term config: TBP>>
  end type decay_term_config_t

@ %def decay_term_config_t
@ Finalizer, recursive.
<<Decays: decay term config: TBP>>=
  procedure :: final => decay_term_config_final
<<Decays: sub interfaces>>=
    recursive module subroutine decay_term_config_final (object)
      class(decay_term_config_t), intent(inout) :: object
    end subroutine decay_term_config_final
<<Decays: procedures>>=
  recursive module subroutine decay_term_config_final (object)
    class(decay_term_config_t), intent(inout) :: object
    integer :: i
    if (allocated (object%prt)) then
       do i = 1, size (object%prt)
          if (allocated (object%prt(i)%c))  call object%prt(i)%c%final ()
       end do
    end if
  end subroutine decay_term_config_final

@ %def decay_term_config_final
@ Output, with optional indentation
<<Decays: decay term config: TBP>>=
  procedure :: write => decay_term_config_write
<<Decays: sub interfaces>>=
    recursive module subroutine decay_term_config_write &
         (object, unit, indent, verbose)
      class(decay_term_config_t), intent(in) :: object
      integer, intent(in), optional :: unit, indent
      logical, intent(in), optional :: verbose
    end subroutine decay_term_config_write
<<Decays: procedures>>=
  recursive module subroutine decay_term_config_write &
       (object, unit, indent, verbose)
    class(decay_term_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: i, j, u, ind
    logical :: verb
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    verb = .true.;  if (present (verbose))  verb = verbose
    call write_indent (u, ind)
    write (u, "(1x,A)", advance="no")  "Final state:"
    do i = 1, size (object%prt)
       select type (prt_config => object%prt(i)%c)
       type is (stable_config_t)
          write (u, "(1x,A)", advance="no") &
               char (prt_config%flv(1)%get_name ())
          do j = 2, size (prt_config%flv)
             write (u, "(':',A)", advance="no") &
                  char (prt_config%flv(j)%get_name ())
          end do
       type is (unstable_config_t)
          write (u, "(1x,A)", advance="no") &
               char (prt_config%flv%get_name ())
       end select
    end do
    write (u, *)
    if (verb) then
       do i = 1, size (object%prt)
          call object%prt(i)%c%write (u, ind)
       end do
    end if
  end subroutine decay_term_config_write

@ %def decay_term_config_write
@ Initialize, given a set of flavors.  For each flavor, we must indicate
whether the particle is stable.  The second index of the flavor array runs
over alternatives for each decay product; alternatives are allowed only if the
decay product is itself stable.
Gfortran 7/8/9 bug, has to remain in the main module:
<<Decays: decay term config: TBP>>=
  procedure :: init => decay_term_config_init
<<Decays: main procedures>>=
  recursive subroutine decay_term_config_init &
       (term, flv, stable, model, process_stack, var_list)
    class(decay_term_config_t), intent(out) :: term
    type(flavor_t), dimension(:,:), intent(in) :: flv
    logical, dimension(:), intent(in) :: stable
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(var_list_t), intent(in), optional :: var_list
    type(string_t), dimension(:), allocatable :: decay
    integer :: i
    allocate (term%prt (size (flv, 1)))
    do i = 1, size (flv, 1)
       associate (prt => term%prt(i))
         if (stable(i)) then
            allocate (stable_config_t :: prt%c)
         else
            allocate (unstable_config_t :: prt%c)
         end if
         select type (prt_config => prt%c)
         type is (stable_config_t)
            call prt_config%init (flv(i,:))
         type is (unstable_config_t)
            if (all (flv(i,:) == flv(i,1))) then
               call prt_config%init (flv(i,1))
               call flv(i,1)%get_decays (decay)
               call prt_config%init_decays &
                    (decay, model, process_stack, var_list)
            else
               call prt_config%write ()
               call msg_fatal ("Decay configuration: &
                    &unstable product must be unique")
            end if
         end select
       end associate
    end do
  end subroutine decay_term_config_init

@ %def decay_term_config_init
@ Recursively compute widths and branching ratios for all unstable particles.
<<Decays: decay term config: TBP>>=
  procedure :: compute => decay_term_config_compute
<<Decays: sub interfaces>>=
    recursive module subroutine decay_term_config_compute (term)
      class(decay_term_config_t), intent(inout) :: term
    end subroutine decay_term_config_compute
<<Decays: procedures>>=
  recursive module subroutine decay_term_config_compute (term)
    class(decay_term_config_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%prt)
       select type (unstable_config => term%prt(i)%c)
       type is (unstable_config_t)
          call unstable_config%compute ()
       end select
    end do
  end subroutine decay_term_config_compute

@ %def decay_term_config_compute
@
\subsection{Decay Term}
A decay term instance is selected when we generate an event for the associated
process instance.  When evaluated, it triggers further decays down the chain.

Only unstable products are allocated as child particles.
<<Decays: types>>=
  type :: decay_term_t
     private
     type(decay_term_config_t), pointer :: config => null ()
     type(particle_out_t), dimension(:), allocatable :: particle_out
   contains
   <<Decays: decay term: TBP>>
  end type decay_term_t

@ %def decay_term_t
@ Finalizer.
<<Decays: decay term: TBP>>=
  procedure :: final => decay_term_final
<<Decays: sub interfaces>>=
    recursive module subroutine decay_term_final (object)
      class(decay_term_t), intent(inout) :: object
    end subroutine decay_term_final
<<Decays: procedures>>=
  recursive module subroutine decay_term_final (object)
    class(decay_term_t), intent(inout) :: object
    integer :: i
    if (allocated (object%particle_out)) then
       do i = 1, size (object%particle_out)
          call object%particle_out(i)%c%final ()
       end do
    end if
  end subroutine decay_term_final

@ %def decay_term_final
@ Output.
<<Decays: decay term: TBP>>=
  procedure :: write => decay_term_write
<<Decays: sub interfaces>>=
    recursive module subroutine decay_term_write (object, unit, indent)
      class(decay_term_t), intent(in) :: object
      integer, intent(in), optional :: unit, indent
    end subroutine decay_term_write
<<Decays: procedures>>=
  recursive module subroutine decay_term_write (object, unit, indent)
    class(decay_term_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: i, u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call object%config%write (u, ind, verbose = .false.)
    do i = 1, size (object%particle_out)
       call object%particle_out(i)%c%write (u, ind)
    end do
  end subroutine decay_term_write

@ %def decay_term_write
@ Recursively write the embedded process instances.
<<Decays: decay term: TBP>>=
  procedure :: write_process_instances => decay_term_write_process_instances
<<Decays: sub interfaces>>=
    recursive module subroutine decay_term_write_process_instances &
         (term, unit, verbose)
      class(decay_term_t), intent(in) :: term
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: verbose
    end subroutine decay_term_write_process_instances
<<Decays: procedures>>=
  recursive module subroutine decay_term_write_process_instances &
       (term, unit, verbose)
    class(decay_term_t), intent(in) :: term
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%write_process_instances (unit, verbose)
       end select
    end do
  end subroutine decay_term_write_process_instances

@ %def decay_term_write_process_instances
@ Initialization, using the configuration object.  We allocate
particle objects in parallel to the particle configuration objects
which we use to initialize them, one at a time.
Gfortran 7/8/9 bug, has to remain in the main module:
<<Decays: decay term: TBP>>=
  procedure :: init => decay_term_init
<<Decays: main procedures>>=
  recursive subroutine decay_term_init (term, config)
    class(decay_term_t), intent(out) :: term
    type(decay_term_config_t), intent(in), target :: config
    integer :: i
    term%config => config
    allocate (term%particle_out (size (config%prt)))
    do i = 1, size (config%prt)
       select type (prt_config => config%prt(i)%c)
       type is (stable_config_t)
          allocate (stable_t :: term%particle_out(i)%c)
          select type (stable => term%particle_out(i)%c)
          type is (stable_t)
             call stable%init (prt_config)
          end select
       type is (unstable_config_t)
          allocate (unstable_t :: term%particle_out(i)%c)
          select type (unstable => term%particle_out(i)%c)
          type is (unstable_t)
             call unstable%init (prt_config)
          end select
       end select
    end do
  end subroutine decay_term_init

@ %def decay_term_init
@ Implement a RNG instance, spawned by the process object.
<<Decays: decay term: TBP>>=
  procedure :: make_rng => decay_term_make_rng
<<Decays: sub interfaces>>=
    module subroutine decay_term_make_rng (term, process)
      class(decay_term_t), intent(inout) :: term
      type(process_t), intent(inout) :: process
      class(rng_t), allocatable :: rng
    end subroutine decay_term_make_rng
<<Decays: procedures>>=
  module subroutine decay_term_make_rng (term, process)
    class(decay_term_t), intent(inout) :: term
    type(process_t), intent(inout) :: process
    class(rng_t), allocatable :: rng
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call process%make_rng (rng)
          call unstable%import_rng (rng)
       end select
    end do
  end subroutine decay_term_make_rng

@ %def decay_term_make_rng
@ Link the interactions for unstable decay products to the
interaction of the parent process.
<<Decays: decay term: TBP>>=
  procedure :: link_interactions => decay_term_link_interactions
<<Decays: sub interfaces>>=
    recursive module subroutine decay_term_link_interactions (term, trace)
      class(decay_term_t), intent(inout) :: term
      type(interaction_t), intent(in), target :: trace
    end subroutine decay_term_link_interactions
<<Decays: procedures>>=
  recursive module subroutine decay_term_link_interactions (term, trace)
    class(decay_term_t), intent(inout) :: term
    type(interaction_t), intent(in), target :: trace
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%link_interactions (i, trace)
       end select
    end do
  end subroutine decay_term_link_interactions

@ %def decay_term_link_interactions
@ Recursively generate a decay chain, for each of the unstable
particles in the final state.
<<Decays: decay term: TBP>>=
  procedure :: select_chain => decay_term_select_chain
<<Decays: sub interfaces>>=
    recursive module subroutine decay_term_select_chain (term)
      class(decay_term_t), intent(inout) :: term
    end subroutine decay_term_select_chain
<<Decays: procedures>>=
  recursive module subroutine decay_term_select_chain (term)
    class(decay_term_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%select_chain ()
       end select
    end do
  end subroutine decay_term_select_chain

@ %def decay_term_select_chain
@ Recursively generate a decay event, for each of the unstable
particles in the final state.
<<Decays: decay term: TBP>>=
  procedure :: generate => decay_term_generate
<<Decays: sub interfaces>>=
    recursive module subroutine decay_term_generate (term)
      class(decay_term_t), intent(inout) :: term
    end subroutine decay_term_generate
<<Decays: procedures>>=
  recursive module subroutine decay_term_generate (term)
    class(decay_term_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%generate ()
       end select
    end do
  end subroutine decay_term_generate

@ %def decay_term_generate
@
\subsection{Decay Root Configuration}
At the root of a decay chain, there is a parent process.  The decay root
stores a pointer to the parent process and the set of decay configurations.
<<Decays: public>>=
  public :: decay_root_config_t
<<Decays: types>>=
  type :: decay_root_config_t
     private
     type(string_t) :: process_id
     type(process_t), pointer :: process => null ()
     class(model_data_t), pointer :: model => null ()
     type(decay_term_config_t), dimension(:), allocatable :: term_config
   contains
   <<Decays: decay root config: TBP>>
  end type decay_root_config_t

@ %def decay_root_config_t
@ The finalizer is recursive since there may be cascade decays.
<<Decays: decay root config: TBP>>=
  procedure :: final => decay_root_config_final
<<Decays: sub interfaces>>=
    recursive module subroutine decay_root_config_final (object)
      class(decay_root_config_t), intent(inout) :: object
    end subroutine decay_root_config_final
<<Decays: procedures>>=
  recursive module subroutine decay_root_config_final (object)
    class(decay_root_config_t), intent(inout) :: object
    integer :: i
    if (allocated (object%term_config)) then
       do i = 1, size (object%term_config)
          call object%term_config(i)%final ()
       end do
    end if
  end subroutine decay_root_config_final

@ %def decay_root_config_final
@ The output routine is also recursive, and it contains an adjustable
indentation.
<<Decays: decay root config: TBP>>=
  procedure :: write => decay_root_config_write
  procedure :: write_header => decay_root_config_write_header
  procedure :: write_terms => decay_root_config_write_terms
<<Decays: sub interfaces>>=
    recursive module subroutine decay_root_config_write &
         (object, unit, indent, verbose)
      class(decay_root_config_t), intent(in) :: object
      integer, intent(in), optional :: unit, indent
      logical, intent(in), optional :: verbose
    end subroutine decay_root_config_write
    module subroutine decay_root_config_write_header (object, unit, indent)
      class(decay_root_config_t), intent(in) :: object
      integer, intent(in), optional :: unit, indent
    end subroutine decay_root_config_write_header
    module recursive subroutine decay_root_config_write_terms &
         (object, unit, indent, verbose)
      class(decay_root_config_t), intent(in) :: object
      integer, intent(in), optional :: unit, indent
      logical, intent(in), optional :: verbose
    end subroutine decay_root_config_write_terms
<<Decays: procedures>>=
  recursive module subroutine decay_root_config_write &
       (object, unit, indent, verbose)
    class(decay_root_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(1x,A)")  "Final-state decay tree:"
    call object%write_header (unit, indent)
    call object%write_terms (unit, indent, verbose)
  end subroutine decay_root_config_write

  module subroutine decay_root_config_write_header (object, unit, indent)
    class(decay_root_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    if (associated (object%process)) then
       write (u, 3)  "process ID      =", char (object%process_id), "*"
    else
       write (u, 3)  "process ID      =", char (object%process_id)
    end if
3   format (3x,A,2(1x,A))
  end subroutine decay_root_config_write_header

  module recursive subroutine decay_root_config_write_terms &
       (object, unit, indent, verbose)
    class(decay_root_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: i, u, ind
    logical :: verb
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    verb = .true.;  if (present (verbose))  verb = verbose
    if (verb .and. allocated (object%term_config)) then
       do i = 1, size (object%term_config)
          call object%term_config(i)%write (u, ind + 1)
       end do
    end if
  end subroutine decay_root_config_write_terms

@ %def decay_root_config_write
@ Initialize for a named process and (optionally) a pre-determined
number of terms.
<<Decays: decay root config: TBP>>=
  procedure :: init => decay_root_config_init
<<Decays: sub interfaces>>=
    module subroutine decay_root_config_init (decay, model, process_id, n_terms)
      class(decay_root_config_t), intent(out) :: decay
      class(model_data_t), intent(in), target :: model
      type(string_t), intent(in) :: process_id
      integer, intent(in), optional :: n_terms
    end subroutine decay_root_config_init
<<Decays: procedures>>=
  module subroutine decay_root_config_init (decay, model, process_id, n_terms)
    class(decay_root_config_t), intent(out) :: decay
    class(model_data_t), intent(in), target :: model
    type(string_t), intent(in) :: process_id
    integer, intent(in), optional :: n_terms
    decay%model => model
    decay%process_id = process_id
    if (present (n_terms)) then
       allocate (decay%term_config (n_terms))
    end if
  end subroutine decay_root_config_init

@ %def decay_root_config_init
@ Declare a decay term, given an array of flavors.
<<Decays: decay root config: TBP>>=
  procedure :: init_term => decay_root_config_init_term
<<Decays: sub interfaces>>=
    recursive module subroutine decay_root_config_init_term &
         (decay, i, flv, stable, model, process_stack, var_list)
      class(decay_root_config_t), intent(inout) :: decay
      integer, intent(in) :: i
      type(flavor_t), dimension(:,:), intent(in) :: flv
      logical, dimension(:), intent(in) :: stable
      class(model_data_t), intent(in), target :: model
      type(process_stack_t), intent(in), optional :: process_stack
      type(var_list_t), intent(in), optional, target :: var_list
    end subroutine decay_root_config_init_term
<<Decays: procedures>>=
  recursive module subroutine decay_root_config_init_term &
       (decay, i, flv, stable, model, process_stack, var_list)
    class(decay_root_config_t), intent(inout) :: decay
    integer, intent(in) :: i
    type(flavor_t), dimension(:,:), intent(in) :: flv
    logical, dimension(:), intent(in) :: stable
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(var_list_t), intent(in), optional, target :: var_list
    call decay%term_config(i)%init (flv, stable, model, process_stack, var_list)
  end subroutine decay_root_config_init_term

@ %def decay_root_config_init_term
@ Connect the decay root configuration with a process object (which should
represent the parent process).  This includes initialization, therefore
intent(out).

The flavor state is retrieved from the process term object.  However, we have
to be careful: the flavor object points to the model instance that is stored
in the process object.  This model instance may not contain the current
setting for unstable particles and decay.  Therefore, we assign the model
directly.

If the [[process_instance]] argument is provided, we use this for the
flavor state.  This applies to the decay root only, where the process
can be entangled with a beam setup, and the latter contains beam
remnants as further outgoing particles.  These must be included in the
set of outgoing flavors, since the decay application is also done on
the connected state.

Infer stability from the particle properties, using the first row in the set
of flavor states.  For unstable particles, we look for decays,
recursively, available from the process stack (if present).

For the unstable particles, we have to check whether their masses
match between the production and the decay.  Fortunately, both
versions are available for comparison.

The optional [[var_list]] argument may override integral/error
values for decay processes.
<<Decays: decay root config: TBP>>=
  procedure :: connect => decay_root_config_connect
<<Decays: sub interfaces>>=
    recursive module subroutine decay_root_config_connect &
         (decay, process, model, process_stack, process_instance, var_list)
      class(decay_root_config_t), intent(out) :: decay
      type(process_t), intent(in), target :: process
      class(model_data_t), intent(in), target :: model
      type(process_stack_t), intent(in), optional :: process_stack
      type(process_instance_t), intent(in), optional, target :: process_instance
      type(var_list_t), intent(in), optional, target :: var_list
    end subroutine decay_root_config_connect
<<Decays: procedures>>=
  recursive module subroutine decay_root_config_connect &
       (decay, process, model, process_stack, process_instance, var_list)
    class(decay_root_config_t), intent(out) :: decay
    type(process_t), intent(in), target :: process
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(process_instance_t), intent(in), optional, target :: process_instance
    type(var_list_t), intent(in), optional, target :: var_list
    type(connected_state_t), pointer :: connected_state
    type(interaction_t), pointer :: int
    type(flavor_t), dimension(:,:), allocatable :: flv
    logical, dimension(:), allocatable :: stable
    real(default), dimension(:), allocatable :: m_prod, m_dec
    integer :: i
    call decay%init (model, process%get_id (), process%get_n_terms ())
    do i = 1, size (decay%term_config)
       if (present (process_instance)) then
          connected_state => process_instance%get_connected_state_ptr (i)
          int => connected_state%get_matrix_int_ptr ()
          call int%get_flv_out (flv)
       else
          call process%get_term_flv_out (i, flv)
       end if
       allocate (m_prod (size (flv(:,1)%get_mass ())))
       m_prod = flv(:,1)%get_mass ()
       call flv%set_model (model)
       allocate (m_dec (size (flv(:,1)%get_mass ())))
       m_dec = flv(:,1)%get_mass ()
       allocate (stable (size (flv, 1)))
       stable = flv(:,1)%is_stable ()
       call check_masses ()
       call decay%init_term (i, flv, stable, model, process_stack, var_list)
       deallocate (flv, stable, m_prod, m_dec)
    end do
    decay%process => process
  contains
    subroutine check_masses ()
      integer :: i
      logical :: ok
      ok = .true.
      do i = 1, size (m_prod)
         if (.not. stable(i)) then
            if (.not. nearly_equal (m_prod(i), m_dec(i))) then
               write (msg_buffer, "(A,A,A)")  "particle '", &
                    char (flv(i,1)%get_name ()), "':"
               call msg_message
               write (msg_buffer, &
                    "(2x,A,1x," // FMT_15 // ",3x,A,1x," // FMT_15 // ")") &
                    "m_prod =", m_prod(i), "m_dec =", m_dec(i)
               call msg_message
               ok = .false.
            end if
         end if
      end do
      if (.not. ok)  call msg_fatal &
           ("Particle mass mismatch between production and decay")
    end subroutine check_masses
  end subroutine decay_root_config_connect

@ %def decay_root_config_connect
@ Recursively compute widths, errors, and branching ratios.
<<Decays: decay root config: TBP>>=
  procedure :: compute => decay_root_config_compute
<<Decays: sub interfaces>>=
    recursive module subroutine decay_root_config_compute (decay)
      class(decay_root_config_t), intent(inout) :: decay
    end subroutine decay_root_config_compute
<<Decays: procedures>>=
  recursive module subroutine decay_root_config_compute (decay)
    class(decay_root_config_t), intent(inout) :: decay
    integer :: i
    do i = 1, size (decay%term_config)
       call decay%term_config(i)%compute ()
    end do
  end subroutine decay_root_config_compute

@ %def decay_root_config_compute
@
\subsection{Decay Root Instance}
This is the common parent type for decay and decay root.  The process instance
points to the parent process.  The model pointer is separate because particle
settings may be updated w.r.t.\ the parent process object.
<<Decays: types>>=
  type, abstract :: decay_gen_t
     private
     type(decay_term_t), dimension(:), allocatable :: term
     type(process_instance_t), pointer :: process_instance => null ()
     integer :: selected_mci = 0
     integer :: selected_term = 0
   contains
   <<Decays: decay gen: TBP>>
  end type decay_gen_t

@ %def decay_gen_t
@
The decay root represents the parent process.  When an event is generated, the
generator selects the term to which the decay chain applies (if possible).

The process instance is just a pointer.
<<Decays: public>>=
  public :: decay_root_t
<<Decays: types>>=
  type, extends (decay_gen_t) :: decay_root_t
     private
     type(decay_root_config_t), pointer :: config => null ()
   contains
   <<Decays: decay root: TBP>>
  end type decay_root_t

@ %def decay_root_t
@ The finalizer has to recursively finalize the terms, but we can skip the
process instance which is not explicitly allocated.
<<Decays: decay gen: TBP>>=
  procedure :: base_final => decay_gen_final
<<Decays: sub interfaces>>=
    recursive module subroutine decay_gen_final (object)
      class(decay_gen_t), intent(inout) :: object
    end subroutine decay_gen_final
<<Decays: procedures>>=
  recursive module subroutine decay_gen_final (object)
    class(decay_gen_t), intent(inout) :: object
    integer :: i
    if (allocated (object%term)) then
       do i = 1, size (object%term)
          call object%term(i)%final ()
       end do
    end if
  end subroutine decay_gen_final

@ %def decay_gen_final
@ No extra finalization for the decay root.
<<Decays: decay root: TBP>>=
  procedure :: final => decay_root_final
<<Decays: sub interfaces>>=
    module subroutine decay_root_final (object)
      class(decay_root_t), intent(inout) :: object
    end subroutine decay_root_final
<<Decays: procedures>>=
  module subroutine decay_root_final (object)
    class(decay_root_t), intent(inout) :: object
    call object%base_final ()
  end subroutine decay_root_final

@ %def decay_gen_final
@ Output.
<<Decays: decay root: TBP>>=
  procedure :: write => decay_root_write
<<Decays: sub interfaces>>=
    module subroutine decay_root_write (object, unit)
      class(decay_root_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine decay_root_write
<<Decays: procedures>>=
  module subroutine decay_root_write (object, unit)
    class(decay_root_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%config)) then
       call object%config%write (unit, verbose = .false.)
    else
       write (u, "(1x,A)")  "Final-state decay tree: [not configured]"
    end if
    if (object%selected_mci > 0) then
       write (u, "(3x,A,I0)")  "Selected MCI    = ", object%selected_mci
    else
       write (u, "(3x,A)")  "Selected MCI    = [undefined]"
    end if
    if (object%selected_term > 0) then
       write (u, "(3x,A,I0)")  "Selected term   = ", object%selected_term
       call object%term(object%selected_term)%write (u, 1)
    else
       write (u, "(3x,A)")  "Selected term   = [undefined]"
    end if
  end subroutine decay_root_write

@ %def decay_root_write
@ Write the process instances, recursively.
<<Decays: decay gen: TBP>>=
  procedure :: write_process_instances => decay_gen_write_process_instances
<<Decays: sub interfaces>>=
    recursive module subroutine decay_gen_write_process_instances &
         (decay, unit, verbose)
      class(decay_gen_t), intent(in) :: decay
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: verbose
    end subroutine decay_gen_write_process_instances
<<Decays: procedures>>=
  recursive module subroutine decay_gen_write_process_instances &
       (decay, unit, verbose)
    class(decay_gen_t), intent(in) :: decay
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    if (associated (decay%process_instance)) then
       if (verb) then
          call decay%process_instance%write (unit)
       else
          call decay%process_instance%write_header (unit)
       end if
    end if
    if (decay%selected_term > 0) then
       call decay%term(decay%selected_term)%write_process_instances (unit, verb)
    end if
  end subroutine decay_gen_write_process_instances

@ %def decay_gen_write_process_instances
@ Generic initializer.  All can be done recursively.
<<Decays: decay gen: TBP>>=
  procedure :: base_init => decay_gen_init
<<Decays: sub interfaces>>=
    recursive module subroutine decay_gen_init (decay, term_config)
      class(decay_gen_t), intent(out) :: decay
      type(decay_term_config_t), dimension(:), intent(in), target :: term_config
    end subroutine decay_gen_init
<<Decays: procedures>>=
  recursive module subroutine decay_gen_init (decay, term_config)
    class(decay_gen_t), intent(out) :: decay
    type(decay_term_config_t), dimension(:), intent(in), target :: term_config
    integer :: i
    allocate (decay%term (size (term_config)))
    do i = 1, size (decay%term)
       call decay%term(i)%init (term_config(i))
    end do
  end subroutine decay_gen_init

@ %def decay_gen_init
@ Specific initializer.  We assign the configuration object, which should
correspond to a completely initialized decay configuration tree.  We
also connect to an existing process instance.  Then, we recursively
link the child interactions to the parent process.
<<Decays: decay root: TBP>>=
  procedure :: init => decay_root_init
<<Decays: sub interfaces>>=
    module subroutine decay_root_init (decay_root, config, process_instance)
      class(decay_root_t), intent(out) :: decay_root
      type(decay_root_config_t), intent(in), target :: config
      type(process_instance_t), intent(in), target :: process_instance
    end subroutine decay_root_init
<<Decays: procedures>>=
  module subroutine decay_root_init (decay_root, config, process_instance)
    class(decay_root_t), intent(out) :: decay_root
    type(decay_root_config_t), intent(in), target :: config
    type(process_instance_t), intent(in), target :: process_instance
    call decay_root%base_init (config%term_config)
    decay_root%config => config
    decay_root%process_instance => process_instance
    call decay_root%make_term_rng (config%process)
    call decay_root%link_term_interactions ()
  end subroutine decay_root_init

@ %def decay_root_init
@ Explicitly set/get mci and term indices.  (Used in unit test.)
<<Decays: decay gen: TBP>>=
  procedure :: set_mci => decay_gen_set_mci
  procedure :: set_term => decay_gen_set_term
  procedure :: get_mci => decay_gen_get_mci
  procedure :: get_term => decay_gen_get_term
<<Decays: sub interfaces>>=
    module subroutine decay_gen_set_mci (decay, i)
      class(decay_gen_t), intent(inout) :: decay
      integer, intent(in) :: i
    end subroutine decay_gen_set_mci
    module subroutine decay_gen_set_term (decay, i)
      class(decay_gen_t), intent(inout) :: decay
      integer, intent(in) :: i
    end subroutine decay_gen_set_term
    module function decay_gen_get_mci (decay) result (i)
      class(decay_gen_t), intent(inout) :: decay
      integer :: i
    end function decay_gen_get_mci
    module function decay_gen_get_term (decay) result (i)
      class(decay_gen_t), intent(inout) :: decay
      integer :: i
    end function decay_gen_get_term
<<Decays: procedures>>=
  module subroutine decay_gen_set_mci (decay, i)
    class(decay_gen_t), intent(inout) :: decay
    integer, intent(in) :: i
    decay%selected_mci = i
  end subroutine decay_gen_set_mci

  module subroutine decay_gen_set_term (decay, i)
    class(decay_gen_t), intent(inout) :: decay
    integer, intent(in) :: i
    decay%selected_term = i
  end subroutine decay_gen_set_term

  module function decay_gen_get_mci (decay) result (i)
    class(decay_gen_t), intent(inout) :: decay
    integer :: i
    i = decay%selected_mci
  end function decay_gen_get_mci

  module function decay_gen_get_term (decay) result (i)
    class(decay_gen_t), intent(inout) :: decay
    integer :: i
    i = decay%selected_term
  end function decay_gen_get_term

@ %def decay_gen_set_mci
@ %def decay_gen_set_term
@ %def decay_gen_get_mci
@ %def decay_gen_get_term
@ Implement random-number generators for unstable decay selection in
all terms.  This is not recursive.

We also make use of the fact that [[process]] is a pointer; the (state
of the RNG factory inside the) target process will be modified by the
rng-spawning method, but not the pointer.
<<Decays: decay gen: TBP>>=
  procedure :: make_term_rng => decay_gen_make_term_rng
<<Decays: sub interfaces>>=
    module subroutine decay_gen_make_term_rng (decay, process)
      class(decay_gen_t), intent(inout) :: decay
      type(process_t), intent(in), pointer :: process
    end subroutine decay_gen_make_term_rng
<<Decays: procedures>>=
  module subroutine decay_gen_make_term_rng (decay, process)
    class(decay_gen_t), intent(inout) :: decay
    type(process_t), intent(in), pointer :: process
    integer :: i
    do i = 1, size (decay%term)
       call decay%term(i)%make_rng (process)
    end do
  end subroutine decay_gen_make_term_rng

@ %def decay_gen_make_term_rng
@ Recursively link interactions of the enclosed decay terms to the
corresponding terms in the current process instance.
<<Decays: decay gen: TBP>>=
  procedure :: link_term_interactions => decay_gen_link_term_interactions
<<Decays: sub interfaces>>=
    recursive module subroutine decay_gen_link_term_interactions (decay)
      class(decay_gen_t), intent(inout) :: decay
    end subroutine decay_gen_link_term_interactions
<<Decays: procedures>>=
  recursive module subroutine decay_gen_link_term_interactions (decay)
    class(decay_gen_t), intent(inout) :: decay
    integer :: i
    type(interaction_t), pointer :: trace
    associate (instance => decay%process_instance)
      do i = 1, size (decay%term)
         trace => instance%get_trace_int_ptr (i)
         call decay%term(i)%link_interactions (trace)
      end do
    end associate
  end subroutine decay_gen_link_term_interactions

@ %def decay_gen_link_term_interactions
@ Select a decay chain: decay modes and process components.
<<Decays: decay root: TBP>>=
  procedure :: select_chain => decay_root_select_chain
<<Decays: sub interfaces>>=
    module subroutine decay_root_select_chain (decay_root)
      class(decay_root_t), intent(inout) :: decay_root
    end subroutine decay_root_select_chain
<<Decays: procedures>>=
  module subroutine decay_root_select_chain (decay_root)
    class(decay_root_t), intent(inout) :: decay_root
    if (decay_root%selected_term > 0) then
       call decay_root%term(decay_root%selected_term)%select_chain ()
    else
       call msg_bug ("Decays: no term selected for parent process")
    end if
  end subroutine decay_root_select_chain

@ %def decay_root_select_chain
@ Generate a decay tree, i.e., for the selected term in the parent
process, recursively generate a decay event for all unstable
particles.

Factor out the trace of the connected state of the parent process.
This trace should not be taken into account for unweighting the decay
chain, since it was already used for unweighting the parent event, or
it determines the overall event weight.
<<Decays: decay root: TBP>>=
  procedure :: generate => decay_root_generate
<<Decays: sub interfaces>>=
    module subroutine decay_root_generate (decay_root)
      class(decay_root_t), intent(inout) :: decay_root
    end subroutine decay_root_generate
<<Decays: procedures>>=
  module subroutine decay_root_generate (decay_root)
    class(decay_root_t), intent(inout) :: decay_root
    type(connected_state_t), pointer :: connected_state
    if (decay_root%selected_term > 0) then
       connected_state => decay_root%process_instance%get_connected_state_ptr &
            (decay_root%selected_term)
       call connected_state%normalize_matrix_by_trace ()
       call decay_root%term(decay_root%selected_term)%generate ()
    else
       call msg_bug ("Decays: no term selected for parent process")
    end if
  end subroutine decay_root_generate

@ %def decay_root_generate
@
\subsection{Decay Configuration}
A decay configuration describes a distinct decay mode of a particle.  Each
decay mode may include several terms, which correspond to the terms in the
associated process.  In addition to the base type, the decay configuration
object contains the integral of the parent process and the selector for the
MCI group inside this process.

The flavor component should be identical to the flavor component of the parent
particle ([[unstable]] object).
<<Decays: types>>=
  type, extends (decay_root_config_t) :: decay_config_t
     private
     type(flavor_t) :: flv
     real(default) :: weight = 0
     real(default) :: integral = 0
     real(default) :: abs_error = 0
     real(default) :: rel_error = 0
     type(selector_t) :: mci_selector
   contains
   <<Decays: decay config: TBP>>
  end type decay_config_t

@ %def decay_config_t
@ The output routine extends the decay-root writer by listing numerical
component values.
<<Decays: decay config: TBP>>=
  procedure :: write => decay_config_write
<<Decays: sub interfaces>>=
    recursive module subroutine decay_config_write &
         (object, unit, indent, verbose)
      class(decay_config_t), intent(in) :: object
      integer, intent(in), optional :: unit, indent
      logical, intent(in), optional :: verbose
    end subroutine decay_config_write
<<Decays: procedures>>=
  recursive module subroutine decay_config_write (object, unit, indent, verbose)
    class(decay_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(1x,A)")  "Decay:"
    call object%write_header (unit, indent)
    call write_indent (u, ind)
    write (u, 2)  "branching ratio =", object%weight * 100
    call write_indent (u, ind)
    write (u, 1)  "partial width   =", object%integral
    call write_indent (u, ind)
    write (u, 1)  "error (abs)     =", object%abs_error
    call write_indent (u, ind)
    write (u, 1)  "error (rel)     =", object%rel_error
1   format (3x,A,ES19.12)
2   format (3x,A,F11.6,1x,'%')
    call object%write_terms (unit, indent, verbose)
  end subroutine decay_config_write

@ %def decay_config_write
@ Connect a decay configuration with a process object (which should
represent the decay).  This includes initialization, therefore
intent(out).  We first connect the process itself, then do initializations
that are specific for this decay.

Infer stability from the particle properties, using the first row in the set
of flavor states.  Once we can deal with predetermined decay chains, they
should be used instead.

If there is an optional [[var_list]], check if the stored values for
the decay partial width and error have been overridden there.
<<Decays: decay config: TBP>>=
  procedure :: connect => decay_config_connect
<<Decays: sub interfaces>>=
    recursive module subroutine decay_config_connect &
         (decay, process, model, process_stack, process_instance, var_list)
      class(decay_config_t), intent(out) :: decay
      type(process_t), intent(in), target :: process
      class(model_data_t), intent(in), target :: model
      type(process_stack_t), intent(in), optional :: process_stack
      type(process_instance_t), intent(in), optional, target :: process_instance
      type(var_list_t), intent(in), optional, target :: var_list
    end subroutine decay_config_connect
<<Decays: procedures>>=
  recursive module subroutine decay_config_connect &
       (decay, process, model, process_stack, process_instance, var_list)
    class(decay_config_t), intent(out) :: decay
    type(process_t), intent(in), target :: process
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(process_instance_t), intent(in), optional, target :: process_instance
    type(var_list_t), intent(in), optional, target :: var_list
    real(default), dimension(:), allocatable :: integral_mci
    type(string_t) :: process_id
    integer :: i, n_mci
    call decay%decay_root_config_t%connect &
         (process, model, process_stack, var_list=var_list)
    process_id = process%get_id ()
    if (process%lab_is_cm ()) then
       call msg_fatal ("Decay process " // char (process_id) &
            // ": unusable because rest frame is fixed.")
    end if
    decay%integral = process%get_integral ()
    decay%abs_error = process%get_error ()
    if (present (var_list)) then
       call update (decay%integral, "integral(" // process_id // ")")
       call update (decay%abs_error, "error(" // process_id // ")")
    end if
    n_mci = process%get_n_mci ()
    allocate (integral_mci (n_mci))
    do i = 1, n_mci
       integral_mci(i) = process%get_integral_mci (i)
    end do
    call decay%mci_selector%init (integral_mci)
  contains
    subroutine update (var, var_name)
      real(default), intent(inout) :: var
      type(string_t), intent(in) :: var_name
      if (var_list%contains (var_name)) then
         var = var_list%get_rval (var_name)
      end if
    end subroutine update
  end subroutine decay_config_connect

@ %def decay_config_connect
@ Set the flavor entry, which repeats the flavor of the parent unstable
particle.
<<Decays: decay config: TBP>>=
  procedure :: set_flv => decay_config_set_flv
<<Decays: sub interfaces>>=
    module subroutine decay_config_set_flv (decay, flv)
      class(decay_config_t), intent(inout) :: decay
      type(flavor_t), intent(in) :: flv
    end subroutine decay_config_set_flv
<<Decays: procedures>>=
  module subroutine decay_config_set_flv (decay, flv)
    class(decay_config_t), intent(inout) :: decay
    type(flavor_t), intent(in) :: flv
    decay%flv = flv
  end subroutine decay_config_set_flv

@ %def decay_config_set_flv
@ Compute embedded branchings and the relative error.  This method does not
apply to the decay root.
<<Decays: decay config: TBP>>=
  procedure :: compute => decay_config_compute
<<Decays: sub interfaces>>=
    recursive module subroutine decay_config_compute (decay)
      class(decay_config_t), intent(inout) :: decay
    end subroutine decay_config_compute
<<Decays: procedures>>=
  recursive module subroutine decay_config_compute (decay)
    class(decay_config_t), intent(inout) :: decay
    call decay%decay_root_config_t%compute ()
    if (.not. vanishes (decay%integral)) then
       decay%rel_error = decay%abs_error / decay%integral
    else
       decay%rel_error = 0
    end if
  end subroutine decay_config_compute

@ %def decay_config_compute
@
\subsection{Decay Instance}
The decay contains a collection of terms.  One of them is selected when the
decay is evaluated.  This is similar to the decay root, but we implement it
independently.

The process instance object is allocated via a pointer, so it automatically
behaves as a target.
<<Decays: types>>=
  type, extends (decay_gen_t) :: decay_t
     private
     type(decay_config_t), pointer :: config => null ()
     class(rng_t), allocatable :: rng
   contains
   <<Decays: decay: TBP>>
  end type decay_t

@ %def decay_t
@ The finalizer is recursive.
<<Decays: decay: TBP>>=
  procedure :: final => decay_final
<<Decays: sub interfaces>>=
    recursive module subroutine decay_final (object)
      class(decay_t), intent(inout) :: object
    end subroutine decay_final
<<Decays: procedures>>=
  recursive module subroutine decay_final (object)
    class(decay_t), intent(inout) :: object
    integer :: i
    call object%base_final ()
    do i = 1, object%config%process%get_n_mci ()
       call object%process_instance%final_simulation (i)
    end do
    call object%process_instance%final ()
    deallocate (object%process_instance)
  end subroutine decay_final

@ %def decay_final
@ Output.
<<Decays: decay: TBP>>=
  procedure :: write => decay_write
<<Decays: sub interfaces>>=
    recursive module subroutine decay_write (object, unit, indent, recursive)
      class(decay_t), intent(in) :: object
      integer, intent(in), optional :: unit, indent, recursive
    end subroutine decay_write
<<Decays: procedures>>=
  recursive module subroutine decay_write (object, unit, indent, recursive)
    class(decay_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent, recursive
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call object%config%write (unit, indent, verbose = .false.)
    if (allocated (object%rng)) then
       call object%rng%write (u, ind + 1)
    end if
    call write_indent (u, ind)
    if (object%selected_mci > 0) then
       write (u, "(3x,A,I0)")  "Selected MCI    = ", object%selected_mci
    else
       write (u, "(3x,A)")  "Selected MCI    = [undefined]"
    end if
    call write_indent (u, ind)
    if (object%selected_term > 0) then
       write (u, "(3x,A,I0)")  "Selected term   = ", object%selected_term
       call object%term(object%selected_term)%write (u, ind + 1)
    else
       write (u, "(3x,A)")  "Selected term   = [undefined]"
    end if
  end subroutine decay_write

@ %def decay_write
@ Initializer.  Base initialization is done recursively.  Then, we
prepare the current process instance and allocate a random-number
generator for term selection.  For all unstable particles, we also
allocate a r.n.g. as spawned by the current process.
<<Decays: decay: TBP>>=
  procedure :: init => decay_init
<<Decays: sub interfaces>>=
    recursive module subroutine decay_init (decay, config)
      class(decay_t), intent(out) :: decay
      type(decay_config_t), intent(in), target :: config
    end subroutine decay_init
<<Decays: procedures>>=
  recursive module subroutine decay_init (decay, config)
    class(decay_t), intent(out) :: decay
    type(decay_config_t), intent(in), target :: config
    integer :: i
    call decay%base_init (config%term_config)
    decay%config => config
    allocate (decay%process_instance)
    call decay%process_instance%init (decay%config%process)
    call decay%process_instance%setup_event_data (decay%config%model)
    do i = 1, decay%config%process%get_n_mci ()
       call decay%process_instance%init_simulation (i)
    end do
    call decay%config%process%make_rng (decay%rng)
    call decay%make_term_rng (decay%config%process)
  end subroutine decay_init

@ %def decay_init
@ Link interactions to the parent process.  [[i_prt]] is the index of
the current outgoing particle in the parent interaction, for which we
take the trace evaluator.  We link it to the beam particle in the beam
interaction of the decay process instance.  Then, repeat the procedure
for the outgoing particles.
<<Decays: decay: TBP>>=
  procedure :: link_interactions => decay_link_interactions
<<Decays: sub interfaces>>=
    recursive module subroutine decay_link_interactions (decay, i_prt, trace)
      class(decay_t), intent(inout) :: decay
      integer, intent(in) :: i_prt
      type(interaction_t), intent(in), target :: trace
    end subroutine decay_link_interactions
<<Decays: procedures>>=
  recursive module subroutine decay_link_interactions (decay, i_prt, trace)
    class(decay_t), intent(inout) :: decay
    integer, intent(in) :: i_prt
    type(interaction_t), intent(in), target :: trace
    type(interaction_t), pointer :: beam_int
    integer :: n_in, n_vir
    beam_int => decay%process_instance%get_beam_int_ptr ()
    n_in = trace%get_n_in ()
    n_vir = trace%get_n_vir ()
    call beam_int%set_source_link (1, trace, &
         n_in + n_vir + i_prt)
    call decay%link_term_interactions ()
  end subroutine decay_link_interactions

@ %def decay_link_interactions
@ Determine a decay chain.  For each unstable particle we select one
of the possible decay modes, and for each decay process we select one
of the possible decay MCI components, calling the random-number
generators.  We do not generate momenta, yet.
<<Decays: decay: TBP>>=
  procedure :: select_chain => decay_select_chain
<<Decays: sub interfaces>>=
    recursive module subroutine decay_select_chain (decay)
      class(decay_t), intent(inout) :: decay
    end subroutine decay_select_chain
<<Decays: procedures>>=
  recursive module subroutine decay_select_chain (decay)
    class(decay_t), intent(inout) :: decay
    real(default) :: x
    integer :: i
    call decay%rng%generate (x)
    decay%selected_mci = decay%config%mci_selector%select (x)
    call decay%process_instance%choose_mci (decay%selected_mci)
    decay%selected_term = decay%process_instance%select_i_term ()
    do i = 1, size (decay%term)
       call decay%term(i)%select_chain ()
    end do
  end subroutine decay_select_chain

@ %def decay_select_chain
@ Generate a decay.  We first receive the beam momenta from the parent
process (assuming that this is properly linked), then call the
associated process object for a new event.

Factor out the trace of the helicity density matrix of the isolated
state (the one that will be used for the decay chain).  The trace is
taken into account for unweighting the individual decay event and
should therefore be ignored for unweighting the correlated decay
chain afterwards.
<<Decays: decay: TBP>>=
  procedure :: generate => decay_generate
<<Decays: sub interfaces>>=
    recursive module subroutine decay_generate (decay)
      class(decay_t), intent(inout) :: decay
    end subroutine decay_generate
<<Decays: procedures>>=
  recursive module subroutine decay_generate (decay)
    class(decay_t), intent(inout) :: decay
    type(isolated_state_t), pointer :: isolated_state
    integer :: i
    call decay%process_instance%receive_beam_momenta ()
    call decay%process_instance%generate_unweighted_event (decay%selected_mci)
    if (signal_is_pending ())  return
    call decay%process_instance%evaluate_event_data ()
    isolated_state => &
         decay%process_instance%get_isolated_state_ptr (decay%selected_term)
    call isolated_state%normalize_matrix_by_trace ()
    do i = 1, size (decay%term)
       call decay%term(i)%generate ()
       if (signal_is_pending ())  return
    end do
  end subroutine decay_generate

@ %def decay_generate
@
\subsection{Stable Particles}
This is a stable particle.  The flavor can be ambiguous (e.g., partons).
<<Decays: types>>=
  type, extends (any_config_t) :: stable_config_t
     private
     type(flavor_t), dimension(:), allocatable :: flv
   contains
   <<Decays: stable config: TBP>>
  end type stable_config_t

@ %def stable_config_t
@ The finalizer is empty:
<<Decays: stable config: TBP>>=
  procedure :: final => stable_config_final
<<Decays: sub interfaces>>=
    module subroutine stable_config_final (object)
      class(stable_config_t), intent(inout) :: object
    end subroutine stable_config_final
<<Decays: procedures>>=
  module subroutine stable_config_final (object)
    class(stable_config_t), intent(inout) :: object
  end subroutine stable_config_final

@ %def stable_config_final
@ Output.
<<Decays: stable config: TBP>>=
  procedure :: write => stable_config_write
<<Decays: sub interfaces>>=
    recursive module subroutine stable_config_write &
         (object, unit, indent, verbose)
      class(stable_config_t), intent(in) :: object
      integer, intent(in), optional :: unit, indent
      logical, intent(in), optional :: verbose
    end subroutine stable_config_write
<<Decays: procedures>>=
  recursive module subroutine stable_config_write &
       (object, unit, indent, verbose)
    class(stable_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(1x,'+',1x,A)", advance = "no")  "Stable:"
    write (u, "(1x,A)", advance = "no")  char (object%flv(1)%get_name ())
    do i = 2, size (object%flv)
       write (u, "(':',A)", advance = "no") &
            char (object%flv(i)%get_name ())
    end do
    write (u, *)
  end subroutine stable_config_write

@ %def stable_config_write
@ Initializer.  We are presented with an array of flavors, but there may be
double entries which we remove, so we store only the distinct flavors.
<<Decays: stable config: TBP>>=
  procedure :: init => stable_config_init
<<Decays: sub interfaces>>=
    module subroutine stable_config_init (config, flv)
      class(stable_config_t), intent(out) :: config
      type(flavor_t), dimension(:), intent(in) :: flv
    end subroutine stable_config_init
<<Decays: procedures>>=
  module subroutine stable_config_init (config, flv)
    class(stable_config_t), intent(out) :: config
    type(flavor_t), dimension(:), intent(in) :: flv
    integer, dimension (size (flv)) :: pdg
    logical, dimension (size (flv)) :: mask
    integer :: i
    pdg = flv%get_pdg ()
    mask(1) = .true.
    forall (i = 2 : size (pdg))
       mask(i) = all (pdg(i) /= pdg(1:i-1))
    end forall
    allocate (config%flv (count (mask)))
    config%flv = pack (flv, mask)
  end subroutine stable_config_init

@ %def stable_config_init
@ Here is the corresponding object instance.  Except for the pointer
to the configuration, there is no content.
<<Decays: types>>=
  type, extends (any_t) :: stable_t
     private
     type(stable_config_t), pointer :: config => null ()
   contains
   <<Decays: stable: TBP>>
  end type stable_t

@ %def stable_t
@ The finalizer does nothing.
<<Decays: stable: TBP>>=
  procedure :: final => stable_final
<<Decays: sub interfaces>>=
    module subroutine stable_final (object)
      class(stable_t), intent(inout) :: object
    end subroutine stable_final
<<Decays: procedures>>=
  module subroutine stable_final (object)
    class(stable_t), intent(inout) :: object
  end subroutine stable_final

@ %def stable_final
@ We can delegate output to the configuration object.
<<Decays: stable: TBP>>=
  procedure :: write => stable_write
<<Decays: sub interfaces>>=
    module subroutine stable_write (object, unit, indent)
      class(stable_t), intent(in) :: object
      integer, intent(in), optional :: unit, indent
    end subroutine stable_write
<<Decays: procedures>>=
  module subroutine stable_write (object, unit, indent)
    class(stable_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    call object%config%write (unit, indent)
  end subroutine stable_write

@ %def stable_write
@ Initializer: just assign the configuration.
<<Decays: stable: TBP>>=
  procedure :: init => stable_init
<<Decays: sub interfaces>>=
    module subroutine stable_init (stable, config)
      class(stable_t), intent(out) :: stable
      type(stable_config_t), intent(in), target :: config
    end subroutine stable_init
<<Decays: procedures>>=
  module subroutine stable_init (stable, config)
    class(stable_t), intent(out) :: stable
    type(stable_config_t), intent(in), target :: config
    stable%config => config
  end subroutine stable_init

@ %def stable_init
@
\subsection{Unstable Particles}
A branching configuration enables us to select among distinct decay
modes of a particle.  We store the particle flavor (with its implicit
link to a model), an array of decay configurations, and a selector object.

The total width, absolute and relative error are stored as
[[integral]], [[abs_error]], and [[rel_error]], respectively.

The flavor must be unique in this case.
<<Decays: public>>=
  public :: unstable_config_t
<<Decays: types>>=
  type, extends (any_config_t) :: unstable_config_t
     private
     type(flavor_t) :: flv
     real(default) :: integral = 0
     real(default) :: abs_error = 0
     real(default) :: rel_error = 0
     type(selector_t) :: selector
     type(decay_config_t), dimension(:), allocatable :: decay_config
   contains
   <<Decays: unstable config: TBP>>
  end type unstable_config_t

@ %def unstable_config_t
@ Finalizer.  The branching configuration can be a recursive structure.
<<Decays: unstable config: TBP>>=
  procedure :: final => unstable_config_final
<<Decays: sub interfaces>>=
    recursive module subroutine unstable_config_final (object)
      class(unstable_config_t), intent(inout) :: object
    end subroutine unstable_config_final
<<Decays: procedures>>=
  recursive module subroutine unstable_config_final (object)
    class(unstable_config_t), intent(inout) :: object
    integer :: i
    if (allocated (object%decay_config)) then
       do i = 1, size (object%decay_config)
          call object%decay_config(i)%final ()
       end do
    end if
  end subroutine unstable_config_final

@ %def unstable_config_final
@ Output.  Since this may be recursive, we include indentation.
<<Decays: unstable config: TBP>>=
  procedure :: write => unstable_config_write
<<Decays: sub interfaces>>=
    recursive module subroutine unstable_config_write &
         (object, unit, indent, verbose)
      class(unstable_config_t), intent(in) :: object
      integer, intent(in), optional :: unit, indent
      logical, intent(in), optional :: verbose
    end subroutine unstable_config_write
<<Decays: procedures>>=
  recursive module subroutine unstable_config_write &
       (object, unit, indent, verbose)
    class(unstable_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, i, ind
    logical :: verb
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    verb = .true.;  if (present (verbose))  verb = verbose
    call write_indent (u, ind)
    write (u, "(1x,'+',1x,A,1x,A)")  "Unstable:", &
         char (object%flv%get_name ())
    call write_indent (u, ind)
    write (u, 1)  "total width =", object%integral
    call write_indent (u, ind)
    write (u, 1)  "error (abs) =", object%abs_error
    call write_indent (u, ind)
    write (u, 1)  "error (rel) =", object%rel_error
1   format (5x,A,ES19.12)
    if (verb .and. allocated (object%decay_config)) then
       do i = 1, size (object%decay_config)
          call object%decay_config(i)%write (u, ind + 1)
       end do
    end if
  end subroutine unstable_config_write

@ %def unstable_config_write
@ Initializer.  For the unstable particle, the flavor is unique.
<<Decays: unstable config: TBP>>=
  procedure :: init => unstable_config_init
<<Decays: sub interfaces>>=
    module subroutine unstable_config_init (unstable, flv, set_decays, model)
      class(unstable_config_t), intent(out) :: unstable
      type(flavor_t), intent(in) :: flv
      logical, intent(in), optional :: set_decays
      class(model_data_t), intent(in), optional, target :: model
    end subroutine unstable_config_init
<<Decays: procedures>>=
  module subroutine unstable_config_init (unstable, flv, set_decays, model)
    class(unstable_config_t), intent(out) :: unstable
    type(flavor_t), intent(in) :: flv
    logical, intent(in), optional :: set_decays
    class(model_data_t), intent(in), optional, target :: model
    type(string_t), dimension(:), allocatable :: decay
    unstable%flv = flv
    if (present (set_decays)) then
       call unstable%flv%get_decays (decay)
       call unstable%init_decays (decay, model)
    end if
  end subroutine unstable_config_init

@ %def unstable_config_init
@ Further initialization: determine the number of decay modes.  We can assume
that the flavor of the particle has been set already.

If the process stack is given, we can delve recursively into actually
assigning decay processes.  Otherwise, we just initialize with decay
process names.
<<Decays: unstable config: TBP>>=
  procedure :: init_decays => unstable_config_init_decays
<<Decays: sub interfaces>>=
    recursive module subroutine unstable_config_init_decays &
         (unstable, decay_id, model, process_stack, var_list)
      class(unstable_config_t), intent(inout) :: unstable
      type(string_t), dimension(:), intent(in) :: decay_id
      class(model_data_t), intent(in), target :: model
      type(process_stack_t), intent(in), optional :: process_stack
      type(var_list_t), intent(in), optional :: var_list
    end subroutine unstable_config_init_decays
<<Decays: procedures>>=
  recursive module subroutine unstable_config_init_decays &
       (unstable, decay_id, model, process_stack, var_list)
    class(unstable_config_t), intent(inout) :: unstable
    type(string_t), dimension(:), intent(in) :: decay_id
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(var_list_t), intent(in), optional :: var_list
    integer :: i
    allocate (unstable%decay_config (size (decay_id)))
    do i = 1, size (decay_id)
       associate (decay => unstable%decay_config(i))
         if (present (process_stack)) then
            call decay%connect (process_stack%get_process_ptr (decay_id(i)), &
                 model, process_stack, var_list=var_list)
         else
            call decay%init (model, decay_id(i))
         end if
         call decay%set_flv (unstable%flv)
       end associate
    end do
  end subroutine unstable_config_init_decays

@ %def unstable_config_init_decays
@ Explicitly connect a specific decay with a process.  This is used only in
unit tests.
<<Decays: unstable config: TBP>>=
  procedure :: connect_decay => unstable_config_connect_decay
<<Decays: sub interfaces>>=
    module subroutine unstable_config_connect_decay &
         (unstable, i, process, model)
      class(unstable_config_t), intent(inout) :: unstable
      integer, intent(in) :: i
      type(process_t), intent(in), target :: process
      class(model_data_t), intent(in), target :: model
    end subroutine unstable_config_connect_decay
<<Decays: procedures>>=
  module subroutine unstable_config_connect_decay (unstable, i, process, model)
    class(unstable_config_t), intent(inout) :: unstable
    integer, intent(in) :: i
    type(process_t), intent(in), target :: process
    class(model_data_t), intent(in), target :: model
    associate (decay => unstable%decay_config(i))
      call decay%connect (process, model)
    end associate
  end subroutine unstable_config_connect_decay

@ %def unstable_config_connect_decay
@ Compute the total width and branching ratios, initializing the decay
selector.
<<Decays: unstable config: TBP>>=
  procedure :: compute => unstable_config_compute
<<Decays: sub interfaces>>=
    recursive module subroutine unstable_config_compute (unstable)
      class(unstable_config_t), intent(inout) :: unstable
    end subroutine unstable_config_compute
<<Decays: procedures>>=
  recursive module subroutine unstable_config_compute (unstable)
    class(unstable_config_t), intent(inout) :: unstable
    integer :: i
    do i = 1, size (unstable%decay_config)
       call unstable%decay_config(i)%compute ()
    end do
    unstable%integral = sum (unstable%decay_config%integral)
    if (unstable%integral <= 0) then
       call unstable%write ()
       call msg_fatal ("Decay configuration: computed total width is zero")
    end if
    unstable%abs_error = sqrt (sum (unstable%decay_config%abs_error ** 2))
    unstable%rel_error = unstable%abs_error / unstable%integral
    call unstable%selector%init (unstable%decay_config%integral)
    do i = 1, size (unstable%decay_config)
       unstable%decay_config(i)%weight &
            = unstable%selector%get_weight (i)
    end do
  end subroutine unstable_config_compute

@ %def unstable_config_compute
@
Now we define the instance of an unstable particle.
<<Decays: public>>=
  public :: unstable_t
<<Decays: types>>=
  type, extends (any_t) :: unstable_t
     private
     type(unstable_config_t), pointer :: config => null ()
     class(rng_t), allocatable :: rng
     integer :: selected_decay = 0
     type(decay_t), dimension(:), allocatable :: decay
   contains
   <<Decays: unstable: TBP>>
  end type unstable_t

@ %def unstable_t
@ Recursive finalizer.
<<Decays: unstable: TBP>>=
  procedure :: final => unstable_final
<<Decays: sub interfaces>>=
    recursive module subroutine unstable_final (object)
      class(unstable_t), intent(inout) :: object
    end subroutine unstable_final
<<Decays: procedures>>=
  recursive module subroutine unstable_final (object)
    class(unstable_t), intent(inout) :: object
    integer :: i
    if (allocated (object%decay)) then
       do i = 1, size (object%decay)
          call object%decay(i)%final ()
       end do
    end if
  end subroutine unstable_final

@ %def unstable_final
@ Output.
<<Decays: unstable: TBP>>=
  procedure :: write => unstable_write
<<Decays: sub interfaces>>=
    recursive module subroutine unstable_write (object, unit, indent)
      class(unstable_t), intent(in) :: object
      integer, intent(in), optional :: unit, indent
    end subroutine unstable_write
<<Decays: procedures>>=
  recursive module subroutine unstable_write (object, unit, indent)
    class(unstable_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call object%config%write (u, ind, verbose=.false.)
    if (allocated (object%rng)) then
       call object%rng%write (u, ind + 2)
    end if
    call write_indent (u, ind)
    if (object%selected_decay > 0) then
       write (u, "(5x,A,I0)") "Sel. decay  = ", object%selected_decay
       call object%decay(object%selected_decay)%write (u, ind + 1)
    else
       write (u, "(5x,A)")  "Sel. decay  = [undefined]"
    end if
  end subroutine unstable_write

@ %def unstable_write
@ Write the embedded process instances.
<<Decays: unstable: TBP>>=
  procedure :: write_process_instances => unstable_write_process_instances
<<Decays: sub interfaces>>=
    recursive module subroutine unstable_write_process_instances &
         (unstable, unit, verbose)
      class(unstable_t), intent(in) :: unstable
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: verbose
    end subroutine unstable_write_process_instances
<<Decays: procedures>>=
  recursive module subroutine unstable_write_process_instances &
       (unstable, unit, verbose)
    class(unstable_t), intent(in) :: unstable
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    if (unstable%selected_decay > 0) then
       call unstable%decay(unstable%selected_decay)% &
            write_process_instances (unit, verbose)
    end if
  end subroutine unstable_write_process_instances

@ %def unstable_write_process_instances
@ Initialization, using the configuration object.
<<Decays: unstable: TBP>>=
  procedure :: init => unstable_init
<<Decays: sub interfaces>>=
    recursive module subroutine unstable_init (unstable, config)
      class(unstable_t), intent(out) :: unstable
      type(unstable_config_t), intent(in), target :: config
    end subroutine unstable_init
<<Decays: procedures>>=
  recursive module subroutine unstable_init (unstable, config)
    class(unstable_t), intent(out) :: unstable
    type(unstable_config_t), intent(in), target :: config
    integer :: i
    unstable%config => config
    allocate (unstable%decay (size (config%decay_config)))
    do i = 1, size (config%decay_config)
       call unstable%decay(i)%init (config%decay_config(i))
    end do
  end subroutine unstable_init

@ %def unstable_init
@ Recursively link interactions to the parent process.  [[i_prt]] is
the index of the current outgoing particle in the parent interaction.
<<Decays: unstable: TBP>>=
  procedure :: link_interactions => unstable_link_interactions
<<Decays: sub interfaces>>=
    recursive module subroutine unstable_link_interactions &
         (unstable, i_prt, trace)
      class(unstable_t), intent(inout) :: unstable
      integer, intent(in) :: i_prt
      type(interaction_t), intent(in), target :: trace
    end subroutine unstable_link_interactions
<<Decays: procedures>>=
  recursive module subroutine unstable_link_interactions &
       (unstable, i_prt, trace)
    class(unstable_t), intent(inout) :: unstable
    integer, intent(in) :: i_prt
    type(interaction_t), intent(in), target :: trace
    integer :: i
    do i = 1, size (unstable%decay)
       call unstable%decay(i)%link_interactions (i_prt, trace)
    end do
  end subroutine unstable_link_interactions

@ %def unstable_link_interactions
@ Import the random-number generator state.
<<Decays: unstable: TBP>>=
  procedure :: import_rng => unstable_import_rng
<<Decays: sub interfaces>>=
    module subroutine unstable_import_rng (unstable, rng)
      class(unstable_t), intent(inout) :: unstable
      class(rng_t), intent(inout), allocatable :: rng
    end subroutine unstable_import_rng
<<Decays: procedures>>=
  module subroutine unstable_import_rng (unstable, rng)
    class(unstable_t), intent(inout) :: unstable
    class(rng_t), intent(inout), allocatable :: rng
    call move_alloc (from = rng, to = unstable%rng)
  end subroutine unstable_import_rng

@ %def unstable_import_rng
@ Generate a decay chain.  First select a decay mode, then call the
[[select_chain]] method of the selected mode.
<<Decays: unstable: TBP>>=
  procedure :: select_chain => unstable_select_chain
<<Decays: sub interfaces>>=
    recursive module subroutine unstable_select_chain (unstable)
      class(unstable_t), intent(inout) :: unstable
    end subroutine unstable_select_chain
<<Decays: procedures>>=
  recursive module subroutine unstable_select_chain (unstable)
    class(unstable_t), intent(inout) :: unstable
    real(default) :: x
    call unstable%rng%generate (x)
    unstable%selected_decay = unstable%config%selector%select (x)
    call unstable%decay(unstable%selected_decay)%select_chain ()
  end subroutine unstable_select_chain

@ %def unstable_select_chain
@ Generate a decay event.
<<Decays: unstable: TBP>>=
  procedure :: generate => unstable_generate
<<Decays: sub interfaces>>=
    recursive module subroutine unstable_generate (unstable)
      class(unstable_t), intent(inout) :: unstable
    end subroutine unstable_generate
<<Decays: procedures>>=
  recursive module subroutine unstable_generate (unstable)
    class(unstable_t), intent(inout) :: unstable
    call unstable%decay(unstable%selected_decay)%generate ()
  end subroutine unstable_generate

@ %def unstable_generate
@
\subsection{Decay Chain}
While the decay configuration tree and the decay tree are static
entities (during a simulation run), the decay chain is dynamically
generated for each event.  The reason is that with the possibility of
several decay modes for each particle, and several terms for each
process, the total number of distinct decay chains is not under control.

Each entry in the decay chain is a connected parton state.  The origin
of the chain is a connected state in the parent process (not part of
the chain itself).  For each decay, mode and term chosen, we convolute
this with the isolated (!) state of the current decay, to generate a
new connected state.  We accumulate this chain by recursively
traversing the allocated decay tree.  Whenever a particle decays, it
becomes virtual and is replaced by its decay product, while all other
particles stay in the parton state as spectators.

Technically, we implement the decay chain as a stack structure and
include information from the associated decay object for easier
debugging.  This is a decay chain entry:
<<Decays: types>>=
  type, extends (connected_state_t) :: decay_chain_entry_t
     private
     integer :: index = 0
     type(decay_config_t), pointer :: config => null ()
     integer :: selected_mci = 0
     integer :: selected_term = 0
     type(decay_chain_entry_t), pointer :: previous => null ()
  end type decay_chain_entry_t

@ %def decay_chain_entry_t
@ This is the complete chain; we need just a pointer to the last
entry.  We also include a pointer to the master process instance,
which serves as the seed for the decay chain.

The evaluator [[correlated_trace]] traces over all quantum numbers
for the final spin-correlated (but color-summed) evaluator of the
decay chain.  This allows us to compute the probability for a momentum
configuration, given that all individual density matrices (of the
initial process and the subsequent decays) have been normalized to one.

Note: This trace is summed over color, so color is treated exactly
when computing spin correlations.  However, we do not keep
non-diagonal color correlations.  When an event is accepted, we
compute probabilities for all color states and can choose one of them.
<<Decays: public>>=
  public :: decay_chain_t
<<Decays: types>>=
  type :: decay_chain_t
     private
     type(process_instance_t), pointer :: process_instance => null ()
     integer :: selected_term = 0
     type(evaluator_t) :: correlated_trace
     type(decay_chain_entry_t), pointer :: last => null ()
   contains
   <<Decays: decay chain: TBP>>
  end type decay_chain_t

@ %def decay_chain_t
@ The finalizer recursively deletes and deallocates the entries.
<<Decays: decay chain: TBP>>=
  procedure :: final => decay_chain_final
<<Decays: sub interfaces>>=
    module subroutine decay_chain_final (object)
      class(decay_chain_t), intent(inout) :: object
    end subroutine decay_chain_final
<<Decays: procedures>>=
  module subroutine decay_chain_final (object)
    class(decay_chain_t), intent(inout) :: object
    type(decay_chain_entry_t), pointer :: entry
    do while (associated (object%last))
       entry => object%last
       object%last => entry%previous
       call entry%final ()
       deallocate (entry)
    end do
    call object%correlated_trace%final ()
  end subroutine decay_chain_final

@ %def decay_chain_final
@ Doing output recursively allows us to display the chain in
chronological order.
<<Decays: decay chain: TBP>>=
  procedure :: write => decay_chain_write
<<Decays: sub interfaces>>=
    module subroutine decay_chain_write (object, unit)
      class(decay_chain_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine decay_chain_write
<<Decays: procedures>>=
  module subroutine decay_chain_write (object, unit)
    class(decay_chain_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Decay chain:"
    call write_entries (object%last)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Evaluator (correlated trace of the decay chain):"
    call write_separator (u)
    call object%correlated_trace%write (u)
    call write_separator (u, 2)
  contains
    recursive subroutine write_entries (entry)
      type(decay_chain_entry_t), intent(in), pointer :: entry
      if (associated (entry)) then
         call write_entries (entry%previous)
         call write_separator (u, 2)
         write (u, "(1x,A,I0)")  "Decay #", entry%index
         call entry%config%write_header (u)
         write (u, "(3x,A,I0)")  "Selected MCI    = ", entry%selected_mci
         write (u, "(3x,A,I0)")  "Selected term   = ", entry%selected_term
         call entry%config%term_config(entry%selected_term)%write (u, indent=1)
         call entry%write (u)
      end if
    end subroutine write_entries
  end subroutine decay_chain_write

@ %def decay_chain_write
@
Build a decay chain, recursively following the selected decays and
terms in a decay tree.  Before start, we finalize the chain, deleting
any previous contents.
<<Decays: decay chain: TBP>>=
  procedure :: build => decay_chain_build
<<Decays: sub interfaces>>=
    module subroutine decay_chain_build (chain, decay_root)
      class(decay_chain_t), intent(inout), target :: chain
      type(decay_root_t), intent(in) :: decay_root
    end subroutine decay_chain_build
<<Decays: procedures>>=
  module subroutine decay_chain_build (chain, decay_root)
    class(decay_chain_t), intent(inout), target :: chain
    type(decay_root_t), intent(in) :: decay_root
    type(quantum_numbers_mask_t), dimension(:), allocatable :: qn_mask
    type(interaction_t), pointer :: int_last_decay
    call chain%final ()
    if (decay_root%selected_term > 0) then
       chain%process_instance => decay_root%process_instance
       chain%selected_term = decay_root%selected_term
       call chain%build_term_entries (decay_root%term(decay_root%selected_term))
    end if
    int_last_decay => chain%last%get_matrix_int_ptr ()
    allocate (qn_mask (int_last_decay%get_n_tot ()))
    call qn_mask%init (mask_f = .true., mask_c = .true., mask_h = .true.)
    call chain%correlated_trace%init_qn_sum (int_last_decay, qn_mask)
  end subroutine decay_chain_build

@ %def decay_chain_build
@ Build the entries that correspond to a decay term.  We have to scan
all unstable particles.
<<Decays: decay chain: TBP>>=
  procedure :: build_term_entries => decay_chain_build_term_entries
<<Decays: sub interfaces>>=
    recursive module subroutine decay_chain_build_term_entries (chain, term)
      class(decay_chain_t), intent(inout) :: chain
      type(decay_term_t), intent(in) :: term
    end subroutine decay_chain_build_term_entries
<<Decays: procedures>>=
  recursive module subroutine decay_chain_build_term_entries (chain, term)
    class(decay_chain_t), intent(inout) :: chain
    type(decay_term_t), intent(in) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          if (unstable%selected_decay > 0) then
             call chain%build_decay_entries &
                  (unstable%decay(unstable%selected_decay))
          end if
       end select
    end do
  end subroutine decay_chain_build_term_entries

@ %def decay_chain_build_term_entries
@ Build the entries that correspond to a specific decay.  The
decay term should have been determined, so we allocate a decay chain
entry and fill it, then proceed to child decays.

For the first entry, we convolute the connected state of the parent process
instance with the isolated state of the current
decay (which does not contain an extra beam entry for the parent).
For subsequent entries, we take the previous entry as first factor.

In principle, each chain entry (as a parton state) is capable of
holding a subevent object and associated expressions.  We currently do
not make use of that feature.

Before generating the decays, factor out the trace of the helicity
density matrix of the parent parton state.  This trace has
been used for unweighting the original event (unweighted case) or it
determines the overall weight, so it should not be taken into account
in the decay chain generation.
<<Decays: decay chain: TBP>>=
  procedure :: build_decay_entries => decay_chain_build_decay_entries
<<Decays: sub interfaces>>=
    recursive module subroutine decay_chain_build_decay_entries (chain, decay)
      class(decay_chain_t), intent(inout) :: chain
      type(decay_t), intent(in) :: decay
    end subroutine decay_chain_build_decay_entries
<<Decays: procedures>>=
  recursive module subroutine decay_chain_build_decay_entries (chain, decay)
    class(decay_chain_t), intent(inout) :: chain
    type(decay_t), intent(in) :: decay
    type(decay_chain_entry_t), pointer :: entry
    type(connected_state_t), pointer :: previous_state
    type(isolated_state_t), pointer :: current_decay
    type(helicity_t) :: hel
    type(quantum_numbers_t) :: qn_filter_conn
    allocate (entry)
    if (associated (chain%last)) then
       entry%previous => chain%last
       entry%index = entry%previous%index + 1
       previous_state => entry%previous%connected_state_t
    else
       entry%index = 1
       previous_state => &
            chain%process_instance%get_connected_state_ptr (chain%selected_term)
    end if
    entry%config => decay%config
    entry%selected_mci = decay%selected_mci
    entry%selected_term = decay%selected_term
    current_decay => decay%process_instance%get_isolated_state_ptr &
         (decay%selected_term)
    call entry%setup_connected_trace &
         (current_decay, previous_state%get_trace_int_ptr (), resonant=.true.)
    if (entry%config%flv%has_decay_helicity ()) then
       call hel%init (entry%config%flv%get_decay_helicity ())
       call qn_filter_conn%init (hel)
       call entry%setup_connected_matrix &
            (current_decay, previous_state%get_matrix_int_ptr (), &
            resonant=.true., qn_filter_conn = qn_filter_conn)
       call entry%setup_connected_flows &
            (current_decay, previous_state%get_flows_int_ptr (), &
            resonant=.true., qn_filter_conn = qn_filter_conn)
    else
       call entry%setup_connected_matrix &
            (current_decay, previous_state%get_matrix_int_ptr (), &
            resonant=.true.)
       call entry%setup_connected_flows &
            (current_decay, previous_state%get_flows_int_ptr (), &
            resonant=.true.)
    end if
    chain%last => entry
    call chain%build_term_entries (decay%term(decay%selected_term))
  end subroutine decay_chain_build_decay_entries

@ %def decay_chain_build_decay_entries
@ Recursively fill the decay chain with momenta and evaluate the
matrix elements.  Since all evaluators should have correct source
entries at this point, momenta are automatically retrieved from the
appropriate process instance.


Like we did above for the parent process, factor out the trace for
each subsequent decay (the helicity density matrix in the isolated
state, which is taken for the convolution).
<<Decays: decay chain: TBP>>=
  procedure :: evaluate => decay_chain_evaluate
<<Decays: sub interfaces>>=
    module subroutine decay_chain_evaluate (chain)
      class(decay_chain_t), intent(inout) :: chain
    end subroutine decay_chain_evaluate
<<Decays: procedures>>=
  module subroutine decay_chain_evaluate (chain)
    class(decay_chain_t), intent(inout) :: chain
    call evaluate (chain%last)
    call chain%correlated_trace%receive_momenta ()
    call chain%correlated_trace%evaluate ()
  contains
    recursive subroutine evaluate (entry)
      type(decay_chain_entry_t), intent(inout), pointer :: entry
      if (associated (entry)) then
         call evaluate (entry%previous)
         call entry%receive_kinematics ()
         call entry%evaluate_trace ()
         call entry%evaluate_event_data ()
      end if
    end subroutine evaluate
  end subroutine decay_chain_evaluate

@ %def decay_chain_evaluate
@ Return the probability of a decay chain.  This is given as the trace
of the density matrix with intermediate helicity correlations,
normalized by the product of the uncorrelated density matrix traces.  This
works only if an event has been evaluated and the [[correlated_trace]]
evaluator is filled.  By definition, this evaluator has only one
matrix element, and this must be real.
<<Decays: decay chain: TBP>>=
  procedure :: get_probability => decay_chain_get_probability
<<Decays: sub interfaces>>=
    module function decay_chain_get_probability (chain) result (x)
      class(decay_chain_t), intent(in) :: chain
      real(default) :: x
    end function decay_chain_get_probability
<<Decays: procedures>>=
  module function decay_chain_get_probability (chain) result (x)
    class(decay_chain_t), intent(in) :: chain
    real(default) :: x
    x = real (chain%correlated_trace%get_matrix_element (1))
  end function decay_chain_get_probability

@ %def decay_chain_get_probability
@
\subsection{Decay as Event Transform}
The [[evt_decay]] object combines decay configuration, decay tree, and
chain in a single object, as an implementation of the [[evt]] (event
transform) abstract type.

The [[var_list]] may be a pointer to the user variable list, which
could contain overridden parameters for the decay processes.
<<Decays: public>>=
  public :: evt_decay_t
<<Decays: types>>=
  type, extends (evt_t) :: evt_decay_t
     private
     type(decay_root_config_t) :: decay_root_config
     type(decay_root_t) :: decay_root
     type(decay_chain_t) :: decay_chain
     type(var_list_t), pointer :: var_list => null ()
   contains
   <<Decays: evt decay: TBP>>
  end type evt_decay_t

@ %def evt_decay_t
@
<<Decays: evt decay: TBP>>=
  procedure :: write_name => evt_decay_write_name
<<Decays: sub interfaces>>=
    module subroutine evt_decay_write_name (evt, unit)
      class(evt_decay_t), intent(in) :: evt
      integer, intent(in), optional :: unit
    end subroutine evt_decay_write_name
<<Decays: procedures>>=
  module subroutine evt_decay_write_name (evt, unit)
    class(evt_decay_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Event transform: partonic decays"
  end subroutine evt_decay_write_name

@ %def evt_decay_write_name
@ Output.  We display the currently selected decay tree, which
includes configuration data, and the decay chain, i.e., the evaluators.
<<Decays: evt decay: TBP>>=
  procedure :: write => evt_decay_write
<<Decays: sub interfaces>>=
    module subroutine evt_decay_write &
         (evt, unit, verbose, more_verbose, testflag)
      class(evt_decay_t), intent(in) :: evt
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: verbose, more_verbose, testflag
    end subroutine evt_decay_write
<<Decays: procedures>>=
  module subroutine evt_decay_write (evt, unit, verbose, more_verbose, testflag)
    class(evt_decay_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    logical :: verb, verb2
    integer :: u
    u = given_output_unit (unit)
    verb = .true.;  if (present (verbose))  verb = verbose
    verb2 = .false.;  if (present (more_verbose))  verb2 = more_verbose
    call write_separator (u, 2)
    call evt%write_name (u)
    call write_separator (u, 2)
    call evt%base_write (u, testflag = testflag)
    if (associated (evt%var_list)) then
       call write_separator (u)
       write (u, "(1x,A)")  "Variable list for simulation: &
            &[associated, not shown]"
    end if
    if (verb) then
       call write_separator (u)
       call evt%decay_root%write (u)
       if (verb2) then
          call evt%decay_chain%write (u)
          call evt%decay_root%write_process_instances (u, verb)
       end if
    else
       call write_separator (u, 2)
    end if
  end subroutine evt_decay_write

@ %def evt_decay_write
@ Set the pointer to a user variable list.
<<Decays: evt decay: TBP>>=
  procedure :: set_var_list => evt_decay_set_var_list
<<Decays: sub interfaces>>=
    module subroutine evt_decay_set_var_list (evt, var_list)
      class(evt_decay_t), intent(inout) :: evt
      type(var_list_t), intent(in), target :: var_list
    end subroutine evt_decay_set_var_list
<<Decays: procedures>>=
  module subroutine evt_decay_set_var_list (evt, var_list)
    class(evt_decay_t), intent(inout) :: evt
    type(var_list_t), intent(in), target :: var_list
    evt%var_list => var_list
  end subroutine evt_decay_set_var_list

@ %def evt_decay_set_var_list
@ Connect with a process instance and process.  This initializes the
decay configuration.  The process stack is used to look for process
objects that implement daughter decays.

When all processes are assigned, configure the decay tree instance, using the
decay tree configuration.  First obtain the branching ratios, then allocate
the decay tree.  This is done once for all events.
<<Decays: evt decay: TBP>>=
  procedure :: connect => evt_decay_connect
<<Decays: sub interfaces>>=
    module subroutine evt_decay_connect &
         (evt, process_instance, model, process_stack)
      class(evt_decay_t), intent(inout), target :: evt
      type(process_instance_t), intent(in), target :: process_instance
      class(model_data_t), intent(in), target :: model
      type(process_stack_t), intent(in), optional :: process_stack
    end subroutine evt_decay_connect
<<Decays: procedures>>=
  module subroutine evt_decay_connect &
       (evt, process_instance, model, process_stack)
    class(evt_decay_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    call evt%base_connect (process_instance, model)
    if (associated (evt%var_list)) then
       call evt%decay_root_config%connect (process_instance%process, &
            model, process_stack, process_instance, evt%var_list)
    else
       call evt%decay_root_config%connect (process_instance%process, &
            model, process_stack, process_instance)
    end if
    call evt%decay_root_config%compute ()
    call evt%decay_root%init (evt%decay_root_config, evt%process_instance)
  end subroutine evt_decay_connect

@ %def evt_decay_connect
@ Prepare a new event: Select a decay chain and build the corresponding chain
object.
<<Decays: evt decay: TBP>>=
  procedure :: prepare_new_event => evt_decay_prepare_new_event
<<Decays: sub interfaces>>=
    module subroutine evt_decay_prepare_new_event (evt, i_mci, i_term)
      class(evt_decay_t), intent(inout) :: evt
      integer, intent(in) :: i_mci, i_term
    end subroutine evt_decay_prepare_new_event
<<Decays: procedures>>=
  module subroutine evt_decay_prepare_new_event (evt, i_mci, i_term)
    class(evt_decay_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
    evt%decay_root%selected_mci = i_mci
    evt%decay_root%selected_term = i_term
    call evt%decay_root%select_chain ()
    call evt%decay_chain%build (evt%decay_root)
  end subroutine evt_decay_prepare_new_event

@ %def evt_decay_prepare_new_event
@ Generate a weighted event and assign the resulting weight
(probability).  We use a chain initialized by the preceding
subroutine, fill it with momenta and evaluate.
<<Decays: evt decay: TBP>>=
  procedure :: generate_weighted => evt_decay_generate_weighted
<<Decays: sub interfaces>>=
    module subroutine evt_decay_generate_weighted (evt, probability)
      class(evt_decay_t), intent(inout) :: evt
      real(default), intent(inout) :: probability
    end subroutine evt_decay_generate_weighted
<<Decays: procedures>>=
  module subroutine evt_decay_generate_weighted (evt, probability)
    class(evt_decay_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    call evt%decay_root%generate ()
    if (signal_is_pending ())  return
    call evt%decay_chain%evaluate ()
    probability = evt%decay_chain%get_probability ()
  end subroutine evt_decay_generate_weighted

@ %def evt_decay_generate_weighted
@ To create a usable event, we have to transform the interaction into a
particle set; this requires factorization for the correlated density matrix,
according to the factorization mode.
<<Decays: evt decay: TBP>>=
  procedure :: make_particle_set => evt_decay_make_particle_set
<<Decays: sub interfaces>>=
    module subroutine evt_decay_make_particle_set &
         (evt, factorization_mode, keep_correlations, r)
      class(evt_decay_t), intent(inout) :: evt
      integer, intent(in) :: factorization_mode
      logical, intent(in) :: keep_correlations
      real(default), dimension(:), intent(in), optional :: r
    end subroutine evt_decay_make_particle_set
<<Decays: procedures>>=
  module subroutine evt_decay_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_decay_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    type(interaction_t), pointer :: int_matrix, int_flows
    type(decay_chain_entry_t), pointer :: last_entry
    last_entry => evt%decay_chain%last
    int_matrix => last_entry%get_matrix_int_ptr ()
    int_flows  => last_entry%get_flows_int_ptr ()
    call evt%factorize_interactions (int_matrix, int_flows, &
         factorization_mode, keep_correlations, r)
    call evt%tag_incoming ()
  end subroutine evt_decay_make_particle_set

@ %def event_decay_make_particle_set
@
\subsubsection{Auxiliary}
Eliminate numerical noise for the associated process instances.
<<Decays: public>>=
  public :: pacify
<<Decays: interfaces>>=
  interface pacify
     module procedure pacify_decay
     module procedure pacify_decay_gen
     module procedure pacify_term
     module procedure pacify_unstable
  end interface pacify
<<Decays: sub interfaces>>=
    module subroutine pacify_decay (evt)
      class(evt_decay_t), intent(inout) :: evt
    end subroutine pacify_decay
    recursive module subroutine pacify_decay_gen (decay)
      class(decay_gen_t), intent(inout) :: decay
    end subroutine pacify_decay_gen
    recursive module subroutine pacify_term (term)
      class(decay_term_t), intent(inout) :: term
    end subroutine pacify_term
    recursive module subroutine pacify_unstable (unstable)
      class(unstable_t), intent(inout) :: unstable
    end subroutine pacify_unstable
<<Decays: procedures>>=
  module subroutine pacify_decay (evt)
    class(evt_decay_t), intent(inout) :: evt
    call pacify_decay_gen (evt%decay_root)
  end subroutine pacify_decay

  recursive module subroutine pacify_decay_gen (decay)
    class(decay_gen_t), intent(inout) :: decay
    if (associated (decay%process_instance)) then
       call pacify (decay%process_instance)
    end if
    if (decay%selected_term > 0) then
       call pacify_term (decay%term(decay%selected_term))
    end if
  end subroutine pacify_decay_gen

  recursive module subroutine pacify_term (term)
    class(decay_term_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t);  call pacify_unstable (unstable)
       end select
    end do
  end subroutine pacify_term

  recursive module subroutine pacify_unstable (unstable)
    class(unstable_t), intent(inout) :: unstable
    if (unstable%selected_decay > 0) then
       call pacify_decay_gen (unstable%decay(unstable%selected_decay))
    end if
  end subroutine pacify_unstable

@ %def pacify
@ Prepare specific configurations for use in unit tests.
<<Decays: unstable config: TBP>>=
  procedure :: init_test_case1
  procedure :: init_test_case2
<<Decays: sub interfaces>>=
    module subroutine init_test_case1 &
         (unstable, i, flv, integral, relerr, model)
      class(unstable_config_t), intent(inout) :: unstable
      integer, intent(in) :: i
      type(flavor_t), dimension(:,:), intent(in) :: flv
      real(default), intent(in) :: integral
      real(default), intent(in) :: relerr
      class(model_data_t), intent(in), target :: model
    end subroutine init_test_case1
    module subroutine init_test_case2 (unstable, flv1, flv21, flv22, model)
      class(unstable_config_t), intent(inout) :: unstable
      type(flavor_t), dimension(:,:), intent(in) :: flv1, flv21, flv22
      class(model_data_t), intent(in), target :: model
    end subroutine init_test_case2
<<Decays: procedures>>=
  module subroutine init_test_case1 (unstable, i, flv, integral, relerr, model)
    class(unstable_config_t), intent(inout) :: unstable
    integer, intent(in) :: i
    type(flavor_t), dimension(:,:), intent(in) :: flv
    real(default), intent(in) :: integral
    real(default), intent(in) :: relerr
    class(model_data_t), intent(in), target :: model
    associate (decay => unstable%decay_config(i))
      allocate (decay%term_config (1))
      call decay%init_term (1, flv, stable = [.true., .true.], model=model)
      decay%integral = integral
      decay%abs_error = integral * relerr
    end associate
  end subroutine init_test_case1

  module subroutine init_test_case2 (unstable, flv1, flv21, flv22, model)
    class(unstable_config_t), intent(inout) :: unstable
    type(flavor_t), dimension(:,:), intent(in) :: flv1, flv21, flv22
    class(model_data_t), intent(in), target :: model
    associate (decay => unstable%decay_config(1))
      decay%integral = 1.e-3_default
      decay%abs_error = decay%integral * .01_default

      allocate (decay%term_config (1))
      call decay%init_term (1, flv1, stable = [.false., .true.], model=model)

      select type (w => decay%term_config(1)%prt(1)%c)
      type is (unstable_config_t)

         associate (w_decay => w%decay_config(1))
           w_decay%integral = 2._default
           allocate (w_decay%term_config (1))
           call w_decay%init_term (1, flv21, stable = [.true., .true.], &
                model=model)
         end associate
         associate (w_decay => w%decay_config(2))
           w_decay%integral = 1._default
           allocate (w_decay%term_config (1))
           call w_decay%init_term (1, flv22, stable = [.true., .true.], &
                model=model)
         end associate
         call w%compute ()

      end select
    end associate
  end subroutine init_test_case2

@ %def init_test_case1
@ %def init_test_case2
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[decays_ut.f90]]>>=
<<File header>>

module decays_ut
  use unit_tests
  use decays_uti

<<Standard module head>>

<<Decays: public test>>

<<Decays: public test auxiliary>>

contains

<<Decays: test driver>>

end module decays_ut
@ %def decays_ut
@
<<[[decays_uti.f90]]>>=
<<File header>>

module decays_uti

<<Use kinds>>
<<Use strings>>
  use os_interface
  use sm_qcd
  use model_data
  use models
  use state_matrices, only: FM_IGNORE_HELICITY
  use interactions, only: reset_interaction_counter
  use flavors
  use process_libraries
  use rng_base
  use mci_base
  use mci_midpoint
  use phs_base
  use phs_single
  use prc_core
  use prc_test, only: prc_test_create_library
  use process, only: process_t
  use instances, only: process_instance_t
  use process_stacks

  use decays

  use rng_base_ut, only: rng_test_t, rng_test_factory_t

<<Standard module head>>

<<Decays: public test auxiliary>>

<<Decays: test declarations>>

contains

<<Decays: tests>>

<<Decays: test auxiliary>>

end module decays_uti

@ %def decays_uti
@ API: driver for the unit tests below.
<<Decays: public test>>=
  public :: decays_test
<<Decays: test driver>>=
  subroutine decays_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Decays: execute tests>>
  end subroutine decays_test

@ %def decays_test
@
\subsubsection{Testbed}
As a variation of the [[prepare_test_process]] routine used elsewhere, we
define here a routine that creates two processes (scattering $ss\to ss$ and
decay $s\to f\bar f$), compiles and integrates them and prepares for event
generation.
<<Decays: public test auxiliary>>=
  public :: prepare_testbed
<<Decays: test auxiliary>>=
  subroutine prepare_testbed &
       (lib, process_stack, prefix, os_data, &
        scattering, decay, decay_rest_frame)
    type(process_library_t), intent(out), target :: lib
    type(process_stack_t), intent(out) :: process_stack
    type(string_t), intent(in) :: prefix
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: scattering, decay
    logical, intent(in), optional :: decay_rest_frame

    type(model_t), target :: model
    type(model_t), target :: model_copy
    type(string_t) :: libname, procname1, procname2
    type(process_entry_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance
    class(phs_config_t), allocatable :: phs_config_template
    type(field_data_t), pointer :: field_data
    real(default) :: sqrts

    libname = prefix // "_lib"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"

    call model%init_test ()
    call model%set_par (var_str ("ff"), 0.4_default)
    call model%set_par (var_str ("mf"), &
         model%get_real (var_str ("ff")) * model%get_real (var_str ("ms")))

    if (scattering .and. decay) then
       field_data => model%get_field_ptr (25)
       call field_data%set (p_is_stable = .false.)
    end if

    call prc_test_create_library (libname, lib, &
         scattering = .true., decay = .true., &
         procname1 = procname1, procname2 = procname2)

    call reset_interaction_counter ()

    allocate (phs_single_config_t :: phs_config_template)

    if (scattering) then

       call model_copy%init (model%get_name (), &
            model%get_n_real (), &
            model%get_n_complex (), &
            model%get_n_field (), &
            model%get_n_vtx ())
       call model_copy%copy_from (model)

       allocate (process)
       call process%init (procname1, lib, os_data, model_copy)
       call process%setup_test_cores ()
       call process%init_components (phs_config_template)
       sqrts = 1000
       call process%setup_beams_sqrts (sqrts, i_core = 1)
       call process%configure_phs ()
       call process%setup_mci (dispatch_mci_test_midpoint)
       call process%setup_terms ()

       allocate (process_instance)
       call process_instance%init (process%process_t)
       call process_instance%integrate (1, n_it = 1, n_calls = 100)
       call process%final_integration (1)
       call process_instance%final ()
       deallocate (process_instance)

       call process%prepare_simulation (1)
       call process_stack%push (process)
    end if

    if (decay) then
       call model_copy%init (model%get_name (), &
            model%get_n_real (), &
            model%get_n_complex (), &
            model%get_n_field (), &
            model%get_n_vtx ())
       call model_copy%copy_from (model)

       allocate (process)
       call process%init (procname2, lib, os_data, model_copy)
       call process%setup_test_cores ()
       call process%init_components (phs_config_template)
       if (present (decay_rest_frame)) then
          call process%setup_beams_decay (rest_frame = decay_rest_frame, i_core = 1)
       else
          call process%setup_beams_decay (rest_frame = .not. scattering, i_core = 1)
       end if
       call process%configure_phs ()
       call process%setup_mci (dispatch_mci_test_midpoint)
       call process%setup_terms ()

       allocate (process_instance)
       call process_instance%init (process%process_t)
       call process_instance%integrate (1, n_it=1, n_calls=100)
       call process%final_integration (1)
       call process_instance%final ()
       deallocate (process_instance)

       call process%prepare_simulation (1)
       call process_stack%push (process)
    end if

    call model%final ()
    call model_copy%final ()

  end subroutine prepare_testbed

@ %def prepare_testbed
@ MCI record prepared for midpoint integrator.
<<Decays: test auxiliary>>=
  subroutine dispatch_mci_test_midpoint (mci, var_list, process_id, is_nlo)
    use variables, only: var_list_t
    class(mci_t), allocatable, intent(out) :: mci
    type(var_list_t), intent(in) :: var_list
    type(string_t), intent(in) :: process_id
    logical, intent(in), optional :: is_nlo
    allocate (mci_midpoint_t :: mci)
  end subroutine dispatch_mci_test_midpoint

@ %def dispatch_mci_test_midpoint
@
\subsubsection{Simple decay configuration}
We define a branching configuration with two decay modes.  We set the
integral values by hand, so we do not need to evaluate processes, yet.
<<Decays: execute tests>>=
  call test (decays_1, "decays_1", &
       "branching and decay configuration", &
       u, results)
<<Decays: test declarations>>=
  public :: decays_1
<<Decays: tests>>=
  subroutine decays_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_data_t), target :: model
    type(flavor_t) :: flv_h
    type(flavor_t), dimension(2,1) :: flv_hbb, flv_hgg
    type(unstable_config_t), allocatable :: unstable

    write (u, "(A)")  "* Test output: decays_1"
    write (u, "(A)")  "*   Purpose: Set up branching and decay configuration"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call os_data%init ()
    call model%init_sm_test ()

    call flv_h%init (25, model)
    call flv_hbb(:,1)%init ([5, -5], model)
    call flv_hgg(:,1)%init ([22, 22], model)

    write (u, "(A)")  "* Set up branching and decay"
    write (u, "(A)")

    allocate (unstable)
    call unstable%init (flv_h)
    call unstable%init_decays ([var_str ("h_bb"), var_str ("h_gg")], model)

    call unstable%init_test_case1 &
         (1, flv_hbb, 1.234e-3_default, .02_default, model)

    call unstable%init_test_case1 &
         (2, flv_hgg, 3.085e-4_default, .08_default, model)

    call unstable%compute ()
    call unstable%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call unstable%final ()
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_1"

  end subroutine decays_1

@ %def decays_1
@
\subsubsection{Cascade decay configuration}
We define a branching configuration with one decay, which is followed
by another branching.
<<Decays: execute tests>>=
  call test (decays_2, "decays_2", &
       "cascade decay configuration", &
       u, results)
<<Decays: test declarations>>=
  public :: decays_2
<<Decays: tests>>=
  subroutine decays_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_data_t), target :: model
    type(flavor_t) :: flv_h, flv_wp, flv_wm
    type(flavor_t), dimension(2,1) :: flv_hww, flv_wud, flv_wen
    type(unstable_config_t), allocatable :: unstable

    write (u, "(A)")  "* Test output: decays_2"
    write (u, "(A)")  "*   Purpose: Set up cascade branching"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call os_data%init ()
    call model%init_sm_test ()

    call model%set_unstable (25, [var_str ("h_ww")])
    call model%set_unstable (24, [var_str ("w_ud"), var_str ("w_en")])

    call flv_h%init (25, model)
    call flv_hww(:,1)%init ([24, -24], model)
    call flv_wp%init (24, model)
    call flv_wm%init (-24, model)
    call flv_wud(:,1)%init ([2, -1], model)
    call flv_wen(:,1)%init ([-11, 12], model)


    write (u, "(A)")  "* Set up branching and decay"
    write (u, "(A)")

    allocate (unstable)
    call unstable%init (flv_h, set_decays=.true., model=model)

    call unstable%init_test_case2 (flv_hww, flv_wud, flv_wen, model)

    call unstable%compute ()
    call unstable%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call unstable%final ()
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_2"

  end subroutine decays_2

@ %def decays_2
@
\subsubsection{Decay and Process Object}
We define a branching configuration with one decay and connect this
with an actual process object.
<<Decays: execute tests>>=
  call test (decays_3, "decays_3", &
       "associate process", &
       u, results)
<<Decays: test declarations>>=
  public :: decays_3
<<Decays: tests>>=
  subroutine decays_3 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix
    type(string_t) :: procname2
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(unstable_config_t), allocatable :: unstable
    type(flavor_t) :: flv

    write (u, "(A)")  "* Test output: decays_3"
    write (u, "(A)")  "*   Purpose: Connect a decay configuration &
         &with a process"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and integrate process"
    write (u, "(A)")

    call os_data%init ()

    prefix = "decays_3"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.false., decay=.true., decay_rest_frame=.false.)

    procname2 = prefix // "_d"
    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()
    call process%write (.false., u)

    write (u, "(A)")
    write (u, "(A)")  "* Set up branching and decay"
    write (u, "(A)")

    call flv%init (25, model)

    allocate (unstable)
    call unstable%init (flv)
    call unstable%init_decays ([procname2], model)

    write (u, "(A)")  "* Connect decay with process object"
    write (u, "(A)")

    call unstable%connect_decay (1, process, model)

    call unstable%compute ()
    call unstable%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call unstable%final ()
    call process_stack%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_3"

  end subroutine decays_3

@ %def decays_3
@
\subsubsection{Decay and Process Object}
Building upon the previous test, we set up a decay instance and generate a
decay event.
<<Decays: execute tests>>=
  call test (decays_4, "decays_4", &
       "decay instance", &
       u, results)
<<Decays: test declarations>>=
  public :: decays_4
<<Decays: tests>>=
  subroutine decays_4 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix, procname2
    class(rng_t), allocatable :: rng
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(unstable_config_t), allocatable, target :: unstable
    type(flavor_t) :: flv
    type(unstable_t), allocatable :: instance

    write (u, "(A)")  "* Test output: decays_4"
    write (u, "(A)")  "*   Purpose: Create a decay process and evaluate &
         &an instance"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment, process, &
         &and decay configuration"
    write (u, "(A)")

    call os_data%init ()

    prefix = "decays_4"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.false., decay=.true., decay_rest_frame = .false.)

    procname2 = prefix // "_d"
    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()

    call flv%init (25, model)

    allocate (unstable)
    call unstable%init (flv)
    call unstable%init_decays ([procname2], model)

    call model%set_unstable (25, [procname2])

    call unstable%connect_decay (1, process, model)

    call unstable%compute ()

    allocate (rng_test_t :: rng)

    allocate (instance)
    call instance%init (unstable)
    call instance%import_rng (rng)

    call instance%select_chain ()
    call instance%generate ()
    call instance%write (u)

    write (u, *)
    call instance%write_process_instances (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call instance%final ()
    call process_stack%final ()
    call unstable%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_4"

  end subroutine decays_4

@ %def decays_4
@
\subsubsection{Decay with Parent Process}
We define a scattering process $ss\to ss$ and subsequent decays $s\to f\bar
f$.
<<Decays: execute tests>>=
  call test (decays_5, "decays_5", &
       "parent process and decay", &
       u, results)
<<Decays: test declarations>>=
  public :: decays_5
<<Decays: tests>>=
  subroutine decays_5 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix, procname1, procname2
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(decay_root_config_t), target :: decay_root_config
    type(decay_root_t) :: decay_root
    type(decay_chain_t) :: decay_chain

    write (u, "(A)")  "* Test output: decays_5"
    write (u, "(A)")  "*   Purpose: Handle a process with subsequent decays"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and parent process"
    write (u, "(A)")

    call os_data%init ()

    prefix = "decays_5"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.true., decay=.true.)

    write (u, "(A)")  "* Initialize decay process"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname1)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2])

    write (u, "(A)")  "* Initialize decay tree configuration"
    write (u, "(A)")

    call decay_root_config%connect (process, model, process_stack)
    call decay_root_config%compute ()
    call decay_root_config%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize decay tree"

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    call decay_root%init (decay_root_config, process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Select decay chain"
    write (u, "(A)")

    call decay_root%set_mci (1)
    !!! Not yet implemented; there is only one term anyway:
    ! call process_instance%select_i_term (decay_root%selected_term)
    call decay_root%set_term (1)
    call decay_root%select_chain ()

    call decay_chain%build (decay_root)

    call decay_root%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate event"
    write (u, "(A)")

    call process_instance%generate_unweighted_event (decay_root%get_mci ())
    call process_instance%evaluate_event_data ()

    call decay_root%generate ()

    call pacify (decay_root)

    write (u, "(A)")  "* Process instances"
    write (u, "(A)")

    call decay_root%write_process_instances (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate decay chain"
    write (u, "(A)")

    call decay_chain%evaluate ()
    call decay_chain%write (u)

    write (u, *)
    write (u, "(A,ES19.12)")  "chain probability =", &
         decay_chain%get_probability ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call decay_chain%final ()
    call decay_root%final ()
    call decay_root_config%final ()
    call process_instance%final ()
    deallocate (process_instance)

    call process_stack%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_5"

  end subroutine decays_5

@ %def decays_5
@
\subsubsection{Decay as Event Transform}
Again, we define a scattering process $ss\to ss$ and subsequent decays
$s\to f\bar f$.
<<Decays: execute tests>>=
  call test (decays_6, "decays_6", &
       "evt_decay object", &
       u, results)
<<Decays: test declarations>>=
  public :: decays_6
<<Decays: tests>>=
  subroutine decays_6 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix, procname1, procname2
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(evt_decay_t), target :: evt_decay
    integer :: factorization_mode
    logical :: keep_correlations

    write (u, "(A)")  "* Test output: decays_6"
    write (u, "(A)")  "*   Purpose: Handle a process with subsequent decays"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and parent process"
    write (u, "(A)")

    call os_data%init ()

    prefix = "decays_6"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.true., decay=.true.)

    write (u, "(A)")  "* Initialize decay process"

    process => process_stack%get_process_ptr (procname1)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2])

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize decay object"

    call evt_decay%connect (process_instance, model, process_stack)

    write (u, "(A)")
    write (u, "(A)")  "* Generate scattering event"

    call process_instance%generate_unweighted_event (1)
    call process_instance%evaluate_event_data ()

    write (u, "(A)")
    write (u, "(A)")  "* Select decay chain and generate event"
    write (u, "(A)")

    call evt_decay%prepare_new_event (1, 1)
    call evt_decay%generate_unweighted ()

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    call evt_decay%make_particle_set (factorization_mode, keep_correlations)

    call evt_decay%write (u, verbose = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_decay%final ()
    call process_instance%final ()
    deallocate (process_instance)

    call process_stack%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_6"

  end subroutine decays_6

@ %def decays_6
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tau decays}
<<[[tau_decays.f90]]>>=
<<File header>>

module tau_decays

<<Use kinds>>
  use sm_qcd
  use model_data
  use models
  use event_transforms

<<Standard module head>>

<<Tau decays: public>>

<<Tau decays: types>>

  interface
<<Tau decays: sub interfaces>>
  end interface

end module tau_decays
@
<<[[tau_decays_sub.f90]]>>=
<<File header>>

submodule (tau_decays) tau_decays_s

  use io_units
  use format_utils, only: write_separator

  implicit none

contains

<<Tau decays: procedures>>

end submodule tau_decays_s

@ %def tau_decays_s
@
@ %def tau_decays
\subsection{Tau Decays Event Transform}
This is the type for the tau decay event transform.
<<Tau decays: public>>=
  public :: evt_tau_decays_t
<<Tau decays: types>>=
  type, extends (evt_t) :: evt_tau_decays_t
     type(model_t), pointer :: model_hadrons => null()
     type(qcd_t) :: qcd
   contains
   <<Tau decays: evt tau decays: TBP>>
  end type evt_tau_decays_t

@ %def evt_tau_decays_t
<<Tau decays: evt tau decays: TBP>>=
  procedure :: write_name => evt_tau_decays_write_name
<<Tau decays: sub interfaces>>=
    module subroutine evt_tau_decays_write_name (evt, unit)
      class(evt_tau_decays_t), intent(in) :: evt
      integer, intent(in), optional :: unit
    end subroutine evt_tau_decays_write_name
<<Tau decays: procedures>>=
  module subroutine evt_tau_decays_write_name (evt, unit)
    class(evt_tau_decays_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Event transform: tau decays"
  end subroutine evt_tau_decays_write_name

@ %def evt_tau_decays_write_name
@ Output.
<<Tau decays: evt tau decays: TBP>>=
  procedure :: write => evt_tau_decays_write
<<Tau decays: sub interfaces>>=
    module subroutine evt_tau_decays_write &
         (evt, unit, verbose, more_verbose, testflag)
      class(evt_tau_decays_t), intent(in) :: evt
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: verbose, more_verbose, testflag
    end subroutine evt_tau_decays_write
<<Tau decays: procedures>>=
  module subroutine evt_tau_decays_write &
       (evt, unit, verbose, more_verbose, testflag)
    class(evt_tau_decays_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    call evt%write_name (u)
    call write_separator (u)
    call evt%base_write (u, testflag = testflag, show_set = .false.)
    if (evt%particle_set_exists)  &
         call evt%particle_set%write &
         (u, summary = .true., compressed = .true., testflag = testflag)
    call write_separator (u)
  end subroutine evt_tau_decays_write

@ %def evt_tau_decays_write
@ Here we take the particle set from the previous event transform and
apply the tau decays. What probability should be given back, the
product of branching ratios of the corresponding tau decays?
<<Tau decays: evt tau decays: TBP>>=
  procedure :: generate_weighted => evt_tau_decays_generate_weighted
<<Tau decays: sub interfaces>>=
    module subroutine evt_tau_decays_generate_weighted (evt, probability)
      class(evt_tau_decays_t), intent(inout) :: evt
      real(default), intent(inout) :: probability
    end subroutine evt_tau_decays_generate_weighted
<<Tau decays: procedures>>=
  module subroutine evt_tau_decays_generate_weighted (evt, probability)
    class(evt_tau_decays_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    logical :: valid
    evt%particle_set = evt%previous%particle_set
    !!! To be checked or expanded
    probability = 1
    valid = .true.
    evt%particle_set_exists = valid
  end subroutine evt_tau_decays_generate_weighted

@ %def evt_tau_decays_generate_weighted
@ The factorization parameters are irrelevant.
<<Tau decays: evt tau decays: TBP>>=
  procedure :: make_particle_set => evt_tau_decays_make_particle_set
<<Tau decays: sub interfaces>>=
    module subroutine evt_tau_decays_make_particle_set &
         (evt, factorization_mode, keep_correlations, r)
      class(evt_tau_decays_t), intent(inout) :: evt
      integer, intent(in) :: factorization_mode
      logical, intent(in) :: keep_correlations
      real(default), dimension(:), intent(in), optional :: r
    end subroutine evt_tau_decays_make_particle_set
<<Tau decays: procedures>>=
  module subroutine evt_tau_decays_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_tau_decays_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    logical :: valid
    !!! to be checked and expanded
    valid = .true.
    evt%particle_set_exists = evt%particle_set_exists .and. valid
  end subroutine evt_tau_decays_make_particle_set

@ %def event_tau_decays_make_particle_set
@
<<Tau decays: evt tau decays: TBP>>=
  procedure :: prepare_new_event => evt_tau_decays_prepare_new_event
<<Tau decays: sub interfaces>>=
    module subroutine evt_tau_decays_prepare_new_event (evt, i_mci, i_term)
      class(evt_tau_decays_t), intent(inout) :: evt
      integer, intent(in) :: i_mci, i_term
    end subroutine evt_tau_decays_prepare_new_event
<<Tau decays: procedures>>=
  module subroutine evt_tau_decays_prepare_new_event (evt, i_mci, i_term)
    class(evt_tau_decays_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
  end subroutine evt_tau_decays_prepare_new_event

@ %def evt_tau_decays_prepare_new_event
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Shower}
We might use matrix elements of LO and NLO to increase the accuracy of
the shower in the sense of matching as well as merging.
<<[[shower.f90]]>>=
<<File header>>

module shower

<<Use kinds>>
<<Use strings>>
  use os_interface
  use pdf

  use shower_base
  use matching_base

  use sm_qcd
  use model_data

  use event_transforms
  use models
  use process, only: process_t
  use instances, only: process_instance_t
  use process_stacks

<<Standard module head>>

<<Shower: public>>

<<Shower: parameters>>

<<Shower: types>>

  interface
<<Shower: sub interfaces>>
  end interface

end module shower
@ %def shower
@
<<[[shower_sub.f90]]>>=
<<File header>>

submodule (shower) shower_s

<<Use debug>>
  use io_units
  use format_utils, only: write_separator
  use system_defs, only: LF
  use diagnostics
  use lorentz
  use subevents, only: PRT_BEAM_REMNANT, PRT_INCOMING, PRT_OUTGOING
  use powheg_matching, only: powheg_matching_t
  use rng_base
  use hep_common

  implicit none

contains

<<Shower: procedures>>

end submodule shower_s

@ %def shower_s
@
\subsection{Configuration Parameters}
[[POWHEG_TESTING]] allows to disable the parton shower for validation
and testing of the POWHEG procedure.
<<Shower: parameters>>=
  logical, parameter :: POWHEG_TESTING = .true.

@ %def POWHEG_TESTING
@
\subsection{Event Transform}
The event transforms can do more than mere showering.  Especially, it
may reweight showered events to fixed-order matrix elements.  The
[[model_hadrons]] is supposed to be the SM variant that contains all
hadrons that can be generated in the shower.
<<Shower: public>>=
  public :: evt_shower_t
<<Shower: types>>=
  type, extends (evt_t) :: evt_shower_t
     class(shower_base_t), allocatable :: shower
     class(matching_t), allocatable :: matching
     type(model_t), pointer :: model_hadrons => null ()
     type(qcd_t) :: qcd
     type(pdf_data_t) :: pdf_data
     type(os_data_t) :: os_data
     logical :: is_first_event
   contains
   <<Shower: evt shower: TBP>>
  end type evt_shower_t

@ %def evt_shower_t
@
<<Shower: evt shower: TBP>>=
  procedure :: write_name => evt_shower_write_name
<<Shower: sub interfaces>>=
    module subroutine evt_shower_write_name (evt, unit)
      class(evt_shower_t), intent(in) :: evt
      integer, intent(in), optional :: unit
    end subroutine evt_shower_write_name
<<Shower: procedures>>=
  module subroutine evt_shower_write_name (evt, unit)
    class(evt_shower_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Event transform: shower"
  end subroutine evt_shower_write_name

@ %def evt_shower_write_name
@ Output.
<<Shower: evt shower: TBP>>=
  procedure :: write => evt_shower_write
<<Shower: sub interfaces>>=
    module subroutine evt_shower_write &
         (evt, unit, verbose, more_verbose, testflag)
      class(evt_shower_t), intent(in) :: evt
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: verbose, more_verbose, testflag
    end subroutine evt_shower_write
<<Shower: procedures>>=
  module subroutine evt_shower_write &
       (evt, unit, verbose, more_verbose, testflag)
    class(evt_shower_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    call evt%write_name (u)
    call write_separator (u)
    call evt%base_write (u, testflag = testflag, show_set = .false.)
    if (evt%particle_set_exists)  call evt%particle_set%write &
         (u, summary = .true., compressed = .true., testflag = testflag)
    call write_separator (u)
    call evt%shower%settings%write (u)
  end subroutine evt_shower_write

@ %def evt_shower_write
<<Shower: evt shower: TBP>>=
  procedure :: connect => evt_shower_connect
<<Shower: sub interfaces>>=
    module subroutine evt_shower_connect &
         (evt, process_instance, model, process_stack)
      class(evt_shower_t), intent(inout), target :: evt
      type(process_instance_t), intent(in), target :: process_instance
      class(model_data_t), intent(in), target :: model
      type(process_stack_t), intent(in), optional :: process_stack
    end subroutine evt_shower_connect
<<Shower: procedures>>=
  module subroutine evt_shower_connect &
       (evt, process_instance, model, process_stack)
    class(evt_shower_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    call evt%base_connect (process_instance, model, process_stack)
    call evt%make_rng (evt%process)
    if (allocated (evt%matching)) then
       call evt%matching%connect (process_instance, model, evt%shower)
    end if
  end subroutine evt_shower_connect

@ %def evt_shower_connect
@ Initialize the event transformation.  This will be executed once
during dispatching.  The [[model_hadrons]] is supposed to be the SM
variant that contains all hadrons that may be generated in the
shower.
<<Shower: evt shower: TBP>>=
  procedure :: init => evt_shower_init
<<Shower: sub interfaces>>=
    module subroutine evt_shower_init (evt, model_hadrons, os_data)
      class(evt_shower_t), intent(out) :: evt
      type(model_t), intent(in), target :: model_hadrons
      type(os_data_t), intent(in) :: os_data
    end subroutine evt_shower_init
<<Shower: procedures>>=
  module subroutine evt_shower_init (evt, model_hadrons, os_data)
    class(evt_shower_t), intent(out) :: evt
    type(model_t), intent(in), target :: model_hadrons
    type(os_data_t), intent(in) :: os_data
    evt%os_data = os_data
    evt%model_hadrons => model_hadrons
    evt%is_first_event = .true.
  end subroutine evt_shower_init

@ %def evt_shower_init
@ Create RNG instances, spawned by the process object.
<<Shower: evt shower: TBP>>=
  procedure :: make_rng => evt_shower_make_rng
<<Shower: sub interfaces>>=
    module subroutine evt_shower_make_rng (evt, process)
      class(evt_shower_t), intent(inout) :: evt
      type(process_t), intent(inout) :: process
    end subroutine evt_shower_make_rng
<<Shower: procedures>>=
  module subroutine evt_shower_make_rng (evt, process)
    class(evt_shower_t), intent(inout) :: evt
    type(process_t), intent(inout) :: process
    class(rng_t), allocatable :: rng
    call process%make_rng (rng)
    call evt%shower%import_rng (rng)
    if (allocated (evt%matching)) then
       call process%make_rng (rng)
       call evt%matching%import_rng (rng)
    end if
  end subroutine evt_shower_make_rng

@ %def evt_shower_make_rng
@ Things we want to do for a new event before the whole event
transformation chain is evaluated.
<<Shower: evt shower: TBP>>=
  procedure :: prepare_new_event => evt_shower_prepare_new_event
<<Shower: sub interfaces>>=
    module subroutine evt_shower_prepare_new_event (evt, i_mci, i_term)
      class(evt_shower_t), intent(inout) :: evt
      integer, intent(in) :: i_mci, i_term
    end subroutine evt_shower_prepare_new_event
<<Shower: procedures>>=
  module subroutine evt_shower_prepare_new_event (evt, i_mci, i_term)
    class(evt_shower_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    real(default) :: fac_scale, alpha_s
    fac_scale = evt%process_instance%get_fac_scale (i_term)
    alpha_s = evt%process_instance%get_alpha_s (i_term)
    call evt%reset ()
    call evt%shower%prepare_new_event (fac_scale, alpha_s)
  end subroutine evt_shower_prepare_new_event

@ %def evt_shower_prepare_new_event
@
<<Shower: evt shower: TBP>>=
  procedure :: first_event => evt_shower_first_event
<<Shower: sub interfaces>>=
    module subroutine evt_shower_first_event (evt)
      class(evt_shower_t), intent(inout) :: evt
    end subroutine evt_shower_first_event
<<Shower: procedures>>=
  module subroutine evt_shower_first_event (evt)
    class(evt_shower_t), intent(inout) :: evt
    double precision :: pdftest
    if (debug_on) call msg_debug (D_TRANSFORMS, "evt_shower_first_event")
    associate (settings => evt%shower%settings)
       settings%hadron_collision = .false.
       !!! !!! !!! Workaround for PGF90 v16.1
       !!! if (all (evt%particle_set%prt(1:2)%flv%get_pdg_abs () <= 39)) then
       if (evt%particle_set%prt(1)%flv%get_pdg_abs () <= 39 .and. &
           evt%particle_set%prt(2)%flv%get_pdg_abs () <= 39) then
          settings%hadron_collision = .false.
       !!! else if (all (evt%particle_set%prt(1:2)%flv%get_pdg_abs () >= 100)) then
       else if (evt%particle_set%prt(1)%flv%get_pdg_abs () >= 100 .and. &
                evt%particle_set%prt(2)%flv%get_pdg_abs () >= 100) then
          settings%hadron_collision = .true.
       else
          call msg_fatal ("evt_shower didn't recognize beams setup")
       end if
       if (debug_on) call msg_debug (D_TRANSFORMS, "hadron_collision", settings%hadron_collision)
       if (allocated (evt%matching)) then
          evt%matching%is_hadron_collision = settings%hadron_collision
          call evt%matching%first_event ()
       end if
       if (.not. settings%hadron_collision .and. settings%isr_active) then
          call msg_fatal ("?ps_isr_active is only intended for hadron-collisions")
       end if
       if (evt%pdf_data%type == STRF_LHAPDF5) then
          if (settings%isr_active .and. settings%hadron_collision) then
             call GetQ2max (0, pdftest)
             if (pdftest < epsilon (pdftest)) then
                call msg_bug ("ISR QCD shower enabled, but LHAPDF not " // &
                     "initialized," // LF // "     aborting simulation")
                return
             end if
          end if
       else if (evt%pdf_data%type == STRF_PDF_BUILTIN .and. &
                settings%method == PS_PYTHIA6) then
          call msg_fatal ("Builtin PDFs cannot be used for PYTHIA showers," &
               // LF // "     aborting simulation")
          return
       end if
    end associate
    evt%is_first_event = .false.
  end subroutine evt_shower_first_event

@ %def evt_shower_first_event
@ Here we take the particle set from the previous event transform
(assuming that there is always one) and apply the shower algorithm.  The
result is stored in the event transform of the current object.  We
always return a probability of unity as we don't have the analytic
weight of the combination of shower, MLM matching and hadronization.  A
subdivision into multiple event transformations is under construction.
Invalid or vetoed events have to be discarded by the caller which is why
we mark the particle set as invalid. This procedure directly takes the
(MLM) matching into account.
<<Shower: evt shower: TBP>>=
  procedure :: generate_weighted => evt_shower_generate_weighted
<<Shower: sub interfaces>>=
    module subroutine evt_shower_generate_weighted (evt, probability)
      class(evt_shower_t), intent(inout) :: evt
      real(default), intent(inout) :: probability
    end subroutine evt_shower_generate_weighted
<<Shower: procedures>>=
  module subroutine evt_shower_generate_weighted (evt, probability)
    class(evt_shower_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    logical :: valid, vetoed, is_powheg_matching
    if (debug_on) call msg_debug (D_TRANSFORMS, "evt_shower_generate_weighted")
    if (signal_is_pending ())  return
    evt%particle_set = evt%previous%particle_set
    valid = .true.;  vetoed = .false.; is_powheg_matching = .false.
    if (evt%is_first_event)  call evt%first_event ()
    call evt%shower%import_particle_set (evt%particle_set)
    if (allocated (evt%matching)) then
       call evt%matching%before_shower (evt%particle_set, vetoed)
       if (msg_level(D_TRANSFORMS) >= DEBUG) then
          if (debug_on)  call msg_debug &
               (D_TRANSFORMS, "Matching before generate emissions")
          call evt%matching%write ()
       end if
    end if
    if (allocated (evt%matching)) then
       select type (matching => evt%matching)
       type is (powheg_matching_t)
          is_powheg_matching = .true.
       end select
    end if
    if (.not. vetoed) then
       if (.not. POWHEG_TESTING .or. .not. is_powheg_matching) then
          if (evt%shower%settings%method == PS_PYTHIA6 .or. &
              evt%shower%settings%hadronization_active) then
             call assure_heprup (evt%particle_set)
          end if
          call evt%shower%generate_emissions (valid)
       end if
    end if
    probability = 1
    evt%particle_set_exists = valid .and. .not. vetoed
  end subroutine evt_shower_generate_weighted

@ %def evt_shower_generate_weighted
@ Here, we fill the particle set with the partons from the shower.
The factorization parameters are irrelevant.
We make a sanity check that the initial energy lands either in the
outgoing particles or add to the beam remnant.
<<Shower: evt shower: TBP>>=
  procedure :: make_particle_set => evt_shower_make_particle_set
<<Shower: sub interfaces>>=
    module subroutine evt_shower_make_particle_set &
         (evt, factorization_mode, keep_correlations, r)
      class(evt_shower_t), intent(inout) :: evt
      integer, intent(in) :: factorization_mode
      logical, intent(in) :: keep_correlations
      real(default), dimension(:), intent(in), optional :: r
    end subroutine evt_shower_make_particle_set
<<Shower: procedures>>=
  module subroutine evt_shower_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_shower_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    type(vector4_t) :: sum_vec_in, sum_vec_out, sum_vec_beamrem, &
         sum_vec_beamrem_before
    logical :: vetoed, sane
    if (evt%particle_set_exists) then
       vetoed = .false.
       sum_vec_beamrem_before = sum (evt%particle_set%prt%p, &
            mask=evt%particle_set%prt%get_status () == PRT_BEAM_REMNANT)
       call evt%shower%make_particle_set (evt%particle_set, &
            evt%model, evt%model_hadrons)
       if (allocated (evt%matching)) then
          call evt%matching%after_shower (evt%particle_set, vetoed)
       end if
       if (debug_active (D_TRANSFORMS)) then
          call msg_debug (D_TRANSFORMS, &
               "Shower: obtained particle set after shower + matching")
          call evt%particle_set%write (summary = .true., compressed = .true.)
       end if
       sum_vec_in = sum (evt%particle_set%prt%p, &
            mask=evt%particle_set%prt%get_status () == PRT_INCOMING)
       sum_vec_out = sum (evt%particle_set%prt%p, &
            mask=evt%particle_set%prt%get_status () == PRT_OUTGOING)
       sum_vec_beamrem = sum (evt%particle_set%prt%p, &
            mask=evt%particle_set%prt%get_status () == PRT_BEAM_REMNANT)
       sum_vec_beamrem = sum_vec_beamrem - sum_vec_beamrem_before
       sane = abs(sum_vec_out%p(0) - sum_vec_in%p(0)) < &
            sum_vec_in%p(0) / 10 .or. &
            abs((sum_vec_out%p(0) + sum_vec_beamrem%p(0)) - sum_vec_in%p(0)) < &
            sum_vec_in%p(0) / 10
       sane = .true.
       evt%particle_set_exists = .not. vetoed .and. sane
    end if
  end subroutine evt_shower_make_particle_set

@ %def event_shower_make_particle_set
@
<<Shower: evt shower: TBP>>=
  procedure :: contains_powheg_matching => evt_shower_contains_powheg_matching
<<Shower: sub interfaces>>=
    module function evt_shower_contains_powheg_matching (evt) result (val)
       logical :: val
       class(evt_shower_t), intent(in) :: evt
    end function evt_shower_contains_powheg_matching
<<Shower: procedures>>=
  module function evt_shower_contains_powheg_matching (evt) result (val)
     logical :: val
     class(evt_shower_t), intent(in) :: evt
     val = .false.
     if (allocated (evt%matching)) &
        val = evt%matching%get_method () == "POWHEG"
  end function evt_shower_contains_powheg_matching

@ %def evt_shower_contains_powheg_matching
@
<<Shower: evt shower: TBP>>=
  procedure :: disable_powheg_matching => evt_shower_disable_powheg_matching
<<Shower: sub interfaces>>=
    module subroutine evt_shower_disable_powheg_matching (evt)
       class(evt_shower_t), intent(inout) :: evt
    end subroutine evt_shower_disable_powheg_matching
<<Shower: procedures>>=
  module subroutine evt_shower_disable_powheg_matching (evt)
     class(evt_shower_t), intent(inout) :: evt
     select type (matching => evt%matching)
     type is (powheg_matching_t)
        matching%active = .false.
     class default
        call msg_fatal ("Trying to disable powheg but " // &
             "no powheg matching is allocated!")
     end select
  end subroutine evt_shower_disable_powheg_matching

@ %def evt_shower_disable_powheg_matching
@
<<Shower: evt shower: TBP>>=
  procedure :: enable_powheg_matching => evt_shower_enable_powheg_matching
<<Shower: sub interfaces>>=
    module subroutine evt_shower_enable_powheg_matching (evt)
       class(evt_shower_t), intent(inout) :: evt
    end subroutine evt_shower_enable_powheg_matching
<<Shower: procedures>>=
  module subroutine evt_shower_enable_powheg_matching (evt)
     class(evt_shower_t), intent(inout) :: evt
     select type (matching => evt%matching)
     type is (powheg_matching_t)
        matching%active = .true.
     class default
        call msg_fatal &
             ("Trying to enable powheg but no powheg matching is allocated!")
     end select
  end subroutine evt_shower_enable_powheg_matching

@ %def evt_shower_enable_powheg_matching
@
<<Shower: evt shower: TBP>>=
  procedure :: final => evt_shower_final
<<Shower: sub interfaces>>=
    module subroutine evt_shower_final (evt)
      class(evt_shower_t), intent(inout) :: evt
    end subroutine evt_shower_final
<<Shower: procedures>>=
  module subroutine evt_shower_final (evt)
    class(evt_shower_t), intent(inout) :: evt
    call evt%base_final ()
    if (allocated (evt%matching))  call evt%matching%final ()
  end subroutine evt_shower_final

@ %def evt_shower_final
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[shower_ut.f90]]>>=
<<File header>>

module shower_ut
  use unit_tests
  use shower_uti

<<Standard module head>>

<<Shower: public test>>

contains

<<Shower: test driver>>

end module shower_ut
@ %def shower_ut
@
<<[[shower_uti.f90]]>>=
<<File header>>

module shower_uti

<<Use kinds>>
<<Use strings>>
  use format_utils, only: write_separator
  use os_interface
  use sm_qcd
  use physics_defs, only: BORN
  use model_data
  use models
  use state_matrices, only: FM_IGNORE_HELICITY
  use process_libraries
  use rng_base
  use rng_tao
  use dispatch_rng, only: dispatch_rng_factory_fallback
  use mci_base
  use mci_midpoint
  use phs_base
  use phs_single
  use prc_core_def, only: prc_core_def_t
  use prc_core
  use prc_omega
  use variables
  use event_transforms
  use tauola_interface !NODEP!

  use process, only: process_t
  use instances, only: process_instance_t

  use pdf
  use shower_base
  use shower_core

  use dispatch_rng_ut, only: dispatch_rng_factory_tao

  use shower

<<Standard module head>>

<<Shower: test declarations>>

contains

<<Shower: tests>>

end module shower_uti

@ %def shower_uti
@ API: driver for the unit tests below.
<<Shower: public test>>=
  public :: shower_test
<<Shower: test driver>>=
  subroutine shower_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Shower: execute tests>>
  end subroutine shower_test

@ %def shower_test
@
\subsubsection{Testbed}
This sequence sets up a two-jet process, ready for generating events.
<<Shower: tests>>=
<<setup testbed>>
@
<<setup testbed>>=
  subroutine setup_testbed &
       (prefix, os_data, lib, model_list, process, process_instance)
    type(string_t), intent(in) :: prefix
    type(os_data_t), intent(out) :: os_data
    type(process_library_t), intent(out), target :: lib
    type(model_list_t), intent(out) :: model_list
    type(model_t), pointer :: model
    type(model_t), pointer :: model_tmp
    type(process_t), target, intent(out) :: process
    type(process_instance_t), target, intent(out) :: process_instance
    type(var_list_t), pointer :: model_vars
    type(string_t) :: model_name, libname, procname
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    class(prc_core_t), allocatable :: core_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts

    model_name = "SM"
    libname = prefix // "_lib"
    procname = prefix // "p"

    call os_data%init ()
    dispatch_rng_factory_fallback => dispatch_rng_factory_tao
    allocate (model_tmp)
    call model_list%read_model (model_name, model_name // ".mdl", &
         os_data, model_tmp)
    model_vars => model_tmp%get_var_list_ptr ()
    call model_vars%set_real (var_str ("me"), 0._default, &
         is_known = .true.)
    model => model_tmp

    call lib%init (libname)

    allocate (prt_in (2), source = [var_str ("e-"), var_str ("e+")])
    allocate (prt_out (2), source = [var_str ("d"), var_str ("dbar")])

    allocate (entry)
    call entry%init (procname, model, n_in = 2, n_components = 1)
    call omega_make_process_component (entry, 1, &
         model_name, prt_in, prt_out, &
         report_progress=.true.)
    call lib%append (entry)

    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true., verbose = .false.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)

    call process%init (procname, lib, os_data, model)

    allocate (prc_omega_t :: core_template)
    allocate (phs_single_config_t :: phs_config_template)

    call process%setup_cores (dispatch_core_omega_test)

    call process%init_components (phs_config_template)

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts, i_core = 1)
    call process%configure_phs ()
    call process%setup_mci (dispatch_mci_test_midpoint)
    call process%setup_terms ()

    call process_instance%init (process)
    call process_instance%integrate (1, 1, 1000)
    call process%final_integration (1)

    call process_instance%setup_event_data (i_core = 1)
    call process_instance%init_simulation (1)
    call process_instance%generate_weighted_event (1)
    call process_instance%evaluate_event_data ()

  end subroutine setup_testbed

@ %def setup_testbed
@ A minimal dispatcher version that allocates the core object for testing.
<<setup testbed>>=
  subroutine dispatch_core_omega_test (core, core_def, model, &
       helicity_selection, qcd, use_color_factors, has_beam_pol)
    class(prc_core_t), allocatable, intent(inout) :: core
    class(prc_core_def_t), intent(in) :: core_def
    class(model_data_t), intent(in), target, optional :: model
    type(helicity_selection_t), intent(in), optional :: helicity_selection
    type(qcd_t), intent(in), optional :: qcd
    logical, intent(in), optional :: use_color_factors
    logical, intent(in), optional :: has_beam_pol
    allocate (prc_omega_t :: core)
    select type (core)
    type is (prc_omega_t)
       call core%set_parameters (model)
    end select
  end subroutine dispatch_core_omega_test

@ %def dispatch_core_omega_test
@ MCI record prepared for midpoint integrator.
<<setup testbed>>=
  subroutine dispatch_mci_test_midpoint (mci, var_list, process_id, is_nlo)
    use variables, only: var_list_t
    class(mci_t), allocatable, intent(out) :: mci
    type(var_list_t), intent(in) :: var_list
    type(string_t), intent(in) :: process_id
    logical, intent(in), optional :: is_nlo
    allocate (mci_midpoint_t :: mci)
  end subroutine dispatch_mci_test_midpoint

@ %def dispatch_mci_test_midpoint
@
\subsubsection{Trivial Test}
We generate a two-jet event and shower it using default settings, i.e.
in disabled mode.
<<Shower: execute tests>>=
  call test (shower_1, "shower_1", &
       "disabled shower", &
       u, results)
<<Shower: test declarations>>=
  public :: shower_1
<<Shower: tests>>=
  subroutine shower_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(process_library_t), target :: lib
    type(model_list_t) :: model_list
    class(model_data_t), pointer :: model
    type(model_t), pointer :: model_hadrons
    type(process_t), target :: process
    type(process_instance_t), target :: process_instance
    type(pdf_data_t) :: pdf_data
    integer :: factorization_mode
    logical :: keep_correlations
    class(evt_t), allocatable, target :: evt_trivial
    class(evt_t), allocatable, target :: evt_shower
    type(shower_settings_t) :: settings
    type(taudec_settings_t) :: taudec_settings

    write (u, "(A)")  "* Test output: shower_1"
    write (u, "(A)")  "*   Purpose: Two-jet event with disabled shower"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"), &
         os_data, model_hadrons)
    call setup_testbed (var_str ("shower_1"), &
         os_data, lib, model_list, process, process_instance)

    write (u, "(A)")  "* Set up trivial transform"
    write (u, "(A)")

    allocate (evt_trivial_t :: evt_trivial)
    model => process%get_model_ptr ()
    call evt_trivial%connect (process_instance, model)
    call evt_trivial%prepare_new_event (1, 1)
    call evt_trivial%generate_unweighted ()

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    call evt_trivial%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_trivial)
    type is (evt_trivial_t)
       call evt_trivial%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Set up shower event transform"
    write (u, "(A)")

    allocate (evt_shower_t :: evt_shower)
    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%init (model_hadrons, os_data)
       allocate (shower_t :: evt_shower%shower)
       call evt_shower%shower%init (settings, taudec_settings, pdf_data, os_data)
       call evt_shower%connect (process_instance, model)
    end select

    evt_trivial%next => evt_shower
    evt_shower%previous => evt_trivial

    call evt_shower%prepare_new_event (1, 1)
    call evt_shower%generate_unweighted ()
    call evt_shower%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_shower%final ()
    call evt_trivial%final ()
    call process_instance%final ()
    call process%final ()
    call lib%final ()
    call model_hadrons%final ()
    deallocate (model_hadrons)
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: shower_1"

  end subroutine shower_1

@ %def shower_1
@
\subsubsection{FSR Shower}
We generate a two-jet event and shower it with the Whizard FSR shower.
<<Shower: execute tests>>=
  call test (shower_2, "shower_2", &
       "final-state shower", &
       u, results)
<<Shower: test declarations>>=
  public :: shower_2
<<Shower: tests>>=
  subroutine shower_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(process_library_t), target :: lib
    type(model_list_t) :: model_list
    type(model_t), pointer :: model_hadrons
    class(model_data_t), pointer :: model
    type(process_t), target :: process
    type(process_instance_t), target :: process_instance
    integer :: factorization_mode
    logical :: keep_correlations
    type(pdf_data_t) :: pdf_data
    class(evt_t), allocatable, target :: evt_trivial
    class(evt_t), allocatable, target :: evt_shower
    type(shower_settings_t) :: settings
    type(taudec_settings_t) :: taudec_settings

    write (u, "(A)")  "* Test output: shower_2"
    write (u, "(A)")  "*   Purpose: Two-jet event with FSR shower"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data%init ()
    call model_list%read_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"), &
         os_data, model_hadrons)
    call setup_testbed (var_str ("shower_2"), &
         os_data, lib, model_list, process, process_instance)
    model => process%get_model_ptr ()

    write (u, "(A)")  "* Set up trivial transform"
    write (u, "(A)")

    allocate (evt_trivial_t :: evt_trivial)
    call evt_trivial%connect (process_instance, model)
    call evt_trivial%prepare_new_event (1, 1)
    call evt_trivial%generate_unweighted ()

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    call evt_trivial%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_trivial)
    type is (evt_trivial_t)
       call evt_trivial%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Set up shower event transform"
    write (u, "(A)")

    settings%fsr_active = .true.

    allocate (evt_shower_t :: evt_shower)
    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%init (model_hadrons, os_data)
       allocate (shower_t :: evt_shower%shower)
       call evt_shower%shower%init (settings, taudec_settings, pdf_data, os_data)
       call evt_shower%connect (process_instance, model)
    end select

    evt_trivial%next => evt_shower
    evt_shower%previous => evt_trivial

    call evt_shower%prepare_new_event (1, 1)
    call evt_shower%generate_unweighted ()
    call evt_shower%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%write (u, testflag = .true.)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_shower%final ()
    call evt_trivial%final ()
    call process_instance%final ()
    call process%final ()
    call lib%final ()
    call model_hadrons%final ()
    deallocate (model_hadrons)
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: shower_2"

  end subroutine shower_2

@ %def shower_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Fixed Order NLO Events}
This section deals with the generation of weighted event samples which
take into account next-to-leading order corrections. An approach
generating unweighted events is not possible here, because negative
weights might occur due to subtraction. Note that the events produced
this way are not physical in the sense that they will not keep
NLO-accuracy when interfaced to a parton shower. They are rather
useful for theoretical consistency checks and a fast estimate of
NLO effects.\\
We generate NLO events in the following way: First, the integration
is carried out using the complete divergence-subtracted NLO matrix
element. In the subsequent simulation, $N$-particle kinematics
are generated using $\mathcal{B}+\mathcal{V}+\mathcal{C}$ as weight.
After that, the program loops over all singular regions and for each
of them generates an event with $N+1$-particle kinematics.
The weight for those events corresponds to the real matrix
element $\mathcal{R}^\alpha$ evaluated at the $\alpha$-region's
emitter's phase space point, multiplied with $S_\alpha$.
This procedure is implemented using the [[evt_nlo]] transform.

<<[[evt_nlo.f90]]>>=
<<File header>>

module evt_nlo

<<Use kinds>>
<<Use strings>>
  use constants
  use phs_points, only: phs_point_t
  use phs_points, only: assignment(=), operator(*), size
  use sm_qcd
  use model_data
  use particles
  use instances, only: process_instance_t
  use process_stacks
  use event_transforms
  use quantum_numbers, only: quantum_numbers_t

  use phs_fks, only: phs_fks_t, phs_fks_generator_t
  use phs_fks, only: phs_identifier_t, phs_point_set_t
  use resonances, only: resonance_contributors_t
  use fks_regions, only: region_data_t

<<Standard module head>>

<<Evt NLO: public>>

<<Evt NLO: public parameters>>

<<Evt NLO: types>>

  interface
<<Evt NLO: sub interfaces>>
  end interface

end module evt_nlo

@ %def evt_nlo
@
<<[[evt_nlo_sub.f90]]>>=
<<File header>>

submodule (evt_nlo) evt_nlo_s

<<Use debug>>
  use io_units, only: given_output_unit
  use diagnostics
  use format_utils, only: write_separator
  use numeric_utils, only: nearly_equal
  use physics_defs, only: BORN, NLO_REAL
  use lorentz
  use interactions, only: interaction_t
  use pcm, only: pcm_nlo_t, pcm_nlo_workspace_t
  use prc_core, only: prc_core_t
  use prc_external, only: prc_external_t
  use phs_fks, only: SQRTS_FIXED, SQRTS_VAR

  implicit none

contains

<<Evt NLO: procedures>>

end submodule evt_nlo_s

@ %def evt_nlo_s
@
<<Evt NLO: types>>=
  type :: nlo_event_deps_t
     logical :: lab_is_cm = .true.
     type(phs_point_set_t) :: p_born_cms
     type(phs_point_set_t) :: p_born_lab
     type(phs_point_set_t) :: p_real_cms
     type(phs_point_set_t) :: p_real_lab
     type(resonance_contributors_t), dimension(:), allocatable :: contributors
     type(phs_identifier_t), dimension(:), allocatable :: phs_identifiers
     integer, dimension(:), allocatable :: alr_to_i_con
     integer :: n_phs = 0
  end type nlo_event_deps_t

@ %def nlo_event_deps_t
@ This event transformation is for the generation of fixed-order NLO
events. It takes an event with Born kinematics and creates $N_\alpha + 1$
modified weighted events. The first one has Born kinematics and its
weight is the sum of Born, virtual, subtraction and, if present, also
DGLAP matrix elements. The other $N_\alpha$ events have a weight which
is equal to the real matrix element, evaluated with the phase space
corresponding to the emitter of the $\alpha$-region.

As the NLO event transforms have different kinematics, they also
differ in their [[particle_set]]s. The NLO [[event_t]] object carries
a single pointer to a [[particle_set]]. To avoid interference between
the different NLO [[particle_set]]s, we save the [[particle_set]] of
the current $\alpha$-region in the array [[particle_set_nlo]].
Otherwise it would be unretrievable if the usual particle set of the
event object was used.
<<Evt NLO: public parameters>>=
  integer, parameter, public :: EVT_NLO_UNDEFINED = 0
  integer, parameter, public :: EVT_NLO_SEPARATE_BORNLIKE = 1
  integer, parameter, public :: EVT_NLO_SEPARATE_REAL = 2
  integer, parameter, public :: EVT_NLO_COMBINED = 3
<<Evt NLO: public>>=
  public :: evt_nlo_t
<<Evt NLO: types>>=
  type, extends (evt_t) :: evt_nlo_t
    type(phs_fks_generator_t) :: phs_fks_generator
    real(default) :: sqme_rad = zero
    integer :: i_evaluation = 0
    type(particle_set_t), dimension(:), allocatable :: particle_set_nlo
    type(qcd_t) :: qcd
    type(nlo_event_deps_t) :: event_deps
    integer :: mode = EVT_NLO_UNDEFINED
    integer, dimension(:), allocatable :: &
       i_evaluation_to_i_phs, i_evaluation_to_emitter, &
       i_evaluation_to_i_term
    logical :: keep_failed_events = .false.
    integer :: selected_i_flv = 0
  contains
  <<Evt NLO: evt nlo: TBP>>
  end type evt_nlo_t

@ %def evt_nlo_t
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: write_name => evt_nlo_write_name
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_write_name (evt, unit)
      class(evt_nlo_t), intent(in) :: evt
      integer, intent(in), optional :: unit
    end subroutine evt_nlo_write_name
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_write_name (evt, unit)
    class(evt_nlo_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)") "Event transform: NLO"
  end subroutine evt_nlo_write_name

@ %def evt_nlo_write_name
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: write => evt_nlo_write
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_write (evt, unit, verbose, more_verbose, testflag)
      class(evt_nlo_t), intent(in) :: evt
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: verbose, more_verbose, testflag
    end subroutine evt_nlo_write
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_write (evt, unit, verbose, more_verbose, testflag)
    class(evt_nlo_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    integer :: u, i
    u = given_output_unit (unit)
    call write_separator (u, 2)
    call evt%write_name (u)
    call write_separator (u)
    call evt%base_write (u, testflag = testflag, show_set = .true.)
    write (u,'(A,ES16.9)')  "sqme_rad = ", evt%sqme_rad
    write (u, "(3x,A,I0)")  "i_evaluation = ", evt%i_evaluation
    call write_separator (u)
    write (u, "(1x,A)")  "Radiated particle sets:"
    do i = 1, size (evt%particle_set_nlo)
       call evt%particle_set_nlo(i)%write (u, testflag = testflag)
       call write_separator (u)
    end do
  end subroutine evt_nlo_write

@ %def evt_nlo_write
@ Connects the event transform to the process. Here also the phase space
is set up by making [[real_kinematics]] point to the corresponding
object in the [[pcm_instance]].
<<Evt NLO: evt nlo: TBP>>=
  procedure :: connect => evt_nlo_connect
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_connect &
         (evt, process_instance, model, process_stack)
      class(evt_nlo_t), intent(inout), target :: evt
      type(process_instance_t), intent(in), target :: process_instance
      class(model_data_t), intent(in), target :: model
      type(process_stack_t), intent(in), optional :: process_stack
    end subroutine evt_nlo_connect
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_connect &
       (evt, process_instance, model, process_stack)
    class(evt_nlo_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    if (debug_on) call msg_debug (D_TRANSFORMS, "evt_nlo_connect")
    call evt%base_connect (process_instance, model, process_stack)
    select type (pcm_work => process_instance%pcm_work)
    class is (pcm_nlo_workspace_t)
       select type (pcm => process_instance%pcm)
       type is (pcm_nlo_t)
          call pcm%setup_phs_generator (pcm_work, evt%phs_fks_generator, &
               process_instance%get_sqrts ())
          call evt%set_i_evaluation_mappings (pcm%region_data, &
               pcm_work%real_kinematics%alr_to_i_phs)
       end select
    end select
    call evt%set_mode (process_instance)
    call evt%setup_general_event_kinematics (process_instance)
    if (evt%mode > EVT_NLO_SEPARATE_BORNLIKE) &
         call evt%setup_real_event_kinematics (process_instance)
    if (debug_on) call msg_debug2 (D_TRANSFORMS, "evt_nlo_connect: success")
  end subroutine evt_nlo_connect

@ %def evt_nlo_connect
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: set_i_evaluation_mappings => evt_nlo_set_i_evaluation_mappings
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_set_i_evaluation_mappings &
         (evt, reg_data, alr_to_i_phs)
      class(evt_nlo_t), intent(inout) :: evt
      type(region_data_t), intent(in) :: reg_data
      integer, intent(in), dimension(:) :: alr_to_i_phs
    end subroutine evt_nlo_set_i_evaluation_mappings
<<Evt NLO: types>>=
  type :: registered_triple_t
    integer, dimension(2) :: phs_em
    type(registered_triple_t), pointer :: next => null ()
  end type registered_triple_t
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_set_i_evaluation_mappings &
       (evt, reg_data, alr_to_i_phs)
    class(evt_nlo_t), intent(inout) :: evt
    type(region_data_t), intent(in) :: reg_data
    integer, intent(in), dimension(:) :: alr_to_i_phs
    integer :: n_phs, alr
    integer :: i_evaluation, i_phs, emitter
    logical :: checked
    type(registered_triple_t), allocatable, target :: check_list
    i_evaluation = 1
    n_phs = reg_data%n_phs
    allocate (evt%i_evaluation_to_i_phs (n_phs), source = 0)
    allocate (evt%i_evaluation_to_emitter (n_phs), source = -1)
    allocate (evt%i_evaluation_to_i_term (0 : n_phs), source = 0)
    do alr = 1, reg_data%n_regions
       i_phs = alr_to_i_phs (alr)
       emitter = reg_data%regions(alr)%emitter
       call search_check_list (checked)
       if (.not. checked) then
          evt%i_evaluation_to_i_phs (i_evaluation) = i_phs
          evt%i_evaluation_to_emitter (i_evaluation) = emitter
          i_evaluation = i_evaluation + 1
       end if
    end do
    call fill_i_evaluation_to_i_term ()
    if (.not. (all (evt%i_evaluation_to_i_phs > 0) &
       .and. all (evt%i_evaluation_to_emitter > -1))) then
       call msg_fatal ("evt_nlo: Inconsistent mappings!")
    else
       if (debug2_active (D_TRANSFORMS)) then
          print *, 'evt_nlo Mappings, i_evaluation -> '
          print *, 'i_phs: ', evt%i_evaluation_to_i_phs
          print *, 'emitter: ', evt%i_evaluation_to_emitter
       end if
    end if
  contains
    subroutine fill_i_evaluation_to_i_term ()
      integer :: i_term, i_evaluation, term_emitter
      !!! First find subtraction component
      i_evaluation = 1
      do i_term = 1, evt%process%get_n_terms ()
         if (evt%process_instance%term(i_term)%nlo_type /= NLO_REAL) cycle
         term_emitter = evt%process_instance%kin(i_term)%emitter
         if (term_emitter < 0) then
            evt%i_evaluation_to_i_term (0) = i_term
         else if (evt%i_evaluation_to_emitter(i_evaluation) == term_emitter) then
            evt%i_evaluation_to_i_term (i_evaluation) = i_term
            i_evaluation = i_evaluation + 1
         end if
      end do
    end subroutine fill_i_evaluation_to_i_term

    subroutine search_check_list (found)
      logical, intent(out) :: found
      type(registered_triple_t), pointer :: current_triple => null ()
      if (allocated (check_list)) then
         current_triple => check_list
         do
            if (all (current_triple%phs_em == [i_phs, emitter])) then
               found = .true.
               exit
            end if
            if (.not. associated (current_triple%next)) then
               allocate (current_triple%next)
               current_triple%next%phs_em = [i_phs, emitter]
               found = .false.
               exit
            else
               current_triple => current_triple%next
            end if
         end do
      else
         allocate (check_list)
         check_list%phs_em = [i_phs, emitter]
         found = .false.
      end if
    end subroutine search_check_list
  end subroutine evt_nlo_set_i_evaluation_mappings

@ %def evt_nlo_set_i_evaluation_mappings
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: get_i_phs => evt_nlo_get_i_phs
<<Evt NLO: sub interfaces>>=
    module function evt_nlo_get_i_phs (evt) result (i_phs)
      integer :: i_phs
      class(evt_nlo_t), intent(in) :: evt
    end function evt_nlo_get_i_phs  
<<Evt NLO: procedures>>=
  module function evt_nlo_get_i_phs (evt) result (i_phs)
    integer :: i_phs
    class(evt_nlo_t), intent(in) :: evt
    i_phs = evt%i_evaluation_to_i_phs (evt%i_evaluation)
  end function evt_nlo_get_i_phs

@ %def evt_nlo_get_i_phs
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: get_emitter => evt_nlo_get_emitter
<<Evt NLO: sub interfaces>>=
    module function evt_nlo_get_emitter (evt) result (emitter)
      integer :: emitter
      class(evt_nlo_t), intent(in) :: evt
    end function evt_nlo_get_emitter
<<Evt NLO: procedures>>=
  module function evt_nlo_get_emitter (evt) result (emitter)
    integer :: emitter
    class(evt_nlo_t), intent(in) :: evt
    emitter = evt%i_evaluation_to_emitter (evt%i_evaluation)
  end function evt_nlo_get_emitter

@ %def evt_nlo_get_emitter
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: get_i_term => evt_nlo_get_i_term
<<Evt NLO: sub interfaces>>=
    module function evt_nlo_get_i_term (evt) result (i_term)
      integer :: i_term
      class(evt_nlo_t), intent(in) :: evt
    end function evt_nlo_get_i_term
<<Evt NLO: procedures>>=
  module function evt_nlo_get_i_term (evt) result (i_term)
    integer :: i_term
    class(evt_nlo_t), intent(in) :: evt
    if (evt%mode >= EVT_NLO_SEPARATE_REAL) then
       i_term = evt%i_evaluation_to_i_term (evt%i_evaluation)
    else
       i_term = evt%process_instance%get_first_active_i_term ()
    end if
  end function evt_nlo_get_i_term

@ %def evt_nlo_get_i_term
@ The event transform has a variable which counts the number of times it
has already been called for one generation point. If this variable,
[[i_evaluation]], is zero, this means that [[evt_nlo_generate_weighted]] is called
for the first time, so that the generation of an $N$-particle event is required.
In all other cases, emission events are generated.

During a separate integration of the real component, the first event of
each event group will become the counterevent. In this case, we return
the sum of all subtraction matrix elements.

During a combined integration, the first event will be a combination of all
Born-like events. To get the sum of their matrix elements, we subtract the
sum of all real emissions from the sum of all matrix elements as the real
contribution is the only non-Born contribution.

Note that the argument named [[probablity]], the use of the routine
[[generate_weighted]] and the procedure we use to generate NLO events via an
event transformation is an abuse of the interface which should be refactored.
<<Evt NLO: evt nlo: TBP>>=
  procedure :: generate_weighted => evt_nlo_generate_weighted
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_generate_weighted (evt, probability)
      class(evt_nlo_t), intent(inout) :: evt
      real(default), intent(inout) :: probability
    end subroutine evt_nlo_generate_weighted
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_generate_weighted (evt, probability)
    class(evt_nlo_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    real(default) :: sqme
    call print_debug_info ()
    sqme = probability
    if (evt%mode > EVT_NLO_SEPARATE_BORNLIKE) then
       if (evt%i_evaluation == 0) then
          call evt%reset_phs_identifiers ()
          call evt%evaluate_real_kinematics ()
          if (evt%mode == EVT_NLO_SEPARATE_REAL) then
             sqme = evt%compute_subtraction_sqmes ()
          else
             sqme = sqme - evt%compute_all_sqme_rad ()
          end if
       else
          call evt%compute_real ()
          sqme = evt%sqme_rad
       end if
    end if
    probability = sqme
    if (debug_on)  call msg_debug &
         (D_TRANSFORMS, "probability (after)", probability)
  contains
    function status_code_to_string (mode) result (smode)
      type(string_t) :: smode
      integer, intent(in) :: mode
      select case (mode)
      case (EVT_NLO_UNDEFINED)
         smode = var_str ("Undefined")
      case (EVT_NLO_SEPARATE_BORNLIKE)
         smode = var_str ("Born-like")
      case (EVT_NLO_SEPARATE_REAL)
         smode = var_str ("Real")
      case (EVT_NLO_COMBINED)
         smode = var_str ("Combined")
      end select
    end function status_code_to_string

    subroutine print_debug_info ()
       if (debug_on)  call msg_debug (D_TRANSFORMS, "evt_nlo_generate_weighted")
       if (debug_on)  call msg_debug &
            (D_TRANSFORMS, char ("mode: " // status_code_to_string (evt%mode)))
       if (debug_on)  call msg_debug &
            (D_TRANSFORMS, "probability (before)", probability)
       if (debug_on)  call msg_debug &
            (D_TRANSFORMS, "evt%i_evaluation", evt%i_evaluation)
       if (debug2_active (D_TRANSFORMS)) then
          if (evt%mode > EVT_NLO_SEPARATE_BORNLIKE) then
             if (evt%i_evaluation == 0) then
                print *, 'Evaluate subtraction component'
             else
                print *, 'Evaluate radiation component'
             end if
          end if
       end if
    end subroutine print_debug_info
  end subroutine evt_nlo_generate_weighted

@ %def evt_nlo_generate_weighted
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: reset_phs_identifiers => evt_nlo_reset_phs_identifiers
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_reset_phs_identifiers (evt)
       class(evt_nlo_t), intent(inout) :: evt
    end subroutine evt_nlo_reset_phs_identifiers
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_reset_phs_identifiers (evt)
     class(evt_nlo_t), intent(inout) :: evt
     evt%event_deps%phs_identifiers%evaluated = .false.
  end subroutine evt_nlo_reset_phs_identifiers

@ %def evt_nlo_reset_phs_identifiers
@ The routine [[make_factorized_particle_set]] will setup the subevent momenta
from the [[connected%matrix]]. Its initial state momenta correspond
to the Born process without IS splitting and thus need to be updated
with the real momenta from the [[int_hard]] to get correct momenta in
the events with real radiation.

Ideally the [[int_hard]] and the [[connected]] would be setup with correct
[[source_link]]s to real momenta so that we would not need to replace
momenta of the [[connected]] here.

The parameter [[n_in]] from the [[int_matrix]] is still $0$ as it has
been shifted to [[n_vir]]. We thus take [[n_in]] from the [[particle_set]].
<<Evt NLO: evt nlo: TBP>>=
  procedure :: connected_set_real_IS_momenta => &
       evt_nlo_connected_set_real_IS_momenta
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_connected_set_real_IS_momenta (evt)
      class(evt_nlo_t), intent(inout) :: evt
    end subroutine evt_nlo_connected_set_real_IS_momenta
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_connected_set_real_IS_momenta (evt)
    class(evt_nlo_t), intent(inout) :: evt
    type(vector4_t) :: p_hard, p_beam, p_remn
    type(interaction_t), pointer :: int_matrix
    integer :: i, i_term, n_in, i_in_beam, i_in_hard, i_in_remn
    i_term = evt%get_i_term ()
    int_matrix => evt%process_instance%get_matrix_int_ptr (i_term)
    n_in = evt%particle_set%get_n_in ()
    do i = 1, n_in
       i_in_beam = i
       i_in_hard = n_in + i
       i_in_remn = 2 * n_in + i
       p_hard = evt%process_instance%term(i_term)%int_hard%get_momentum (i)
       p_beam = int_matrix%get_momentum (i_in_beam)
       p_remn = p_beam - p_hard
       call int_matrix%set_momentum (p_hard , i_in_hard)
       call int_matrix%set_momentum (p_remn , i_in_remn)
    end do
  end subroutine evt_nlo_connected_set_real_IS_momenta

@ %def evt_nlo_connected_set_real_IS_momenta
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: make_particle_set => evt_nlo_make_particle_set
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_make_particle_set &
         (evt, factorization_mode, keep_correlations, r)
      class(evt_nlo_t), intent(inout) :: evt
      integer, intent(in) :: factorization_mode
      logical, intent(in) :: keep_correlations
      real(default), dimension(:), intent(in), optional :: r
    end subroutine evt_nlo_make_particle_set
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_nlo_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    if (evt%mode >= EVT_NLO_SEPARATE_BORNLIKE) then
       call make_factorized_particle_set (evt, factorization_mode, &
            keep_correlations, r, evt%get_i_term (), &
            evt%get_selected_quantum_numbers (evt%selected_i_flv))
    else
       call make_factorized_particle_set (evt, factorization_mode, &
            keep_correlations, r)
    end if
  end subroutine evt_nlo_make_particle_set

@ %def evt_nlo_make_particle_set
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: evaluate_real_kinematics => evt_nlo_evaluate_real_kinematics
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_evaluate_real_kinematics (evt)
      class(evt_nlo_t), intent(inout) :: evt
    end subroutine evt_nlo_evaluate_real_kinematics
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_evaluate_real_kinematics (evt)
    class(evt_nlo_t), intent(inout) :: evt
    integer :: alr, i_phs, i_con, emitter
    real(default), dimension(3) :: x_rad
    logical :: use_contributors
    integer :: n_regions
    integer :: i_term
    type(vector4_t), dimension(:), allocatable :: p_real

    select type (pcm_work => evt%process_instance%pcm_work)
    class is (pcm_nlo_workspace_t)
       x_rad = pcm_work%real_kinematics%x_rad
       associate (event_deps => evt%event_deps)
          i_term = evt%get_i_term ()
          event_deps%p_born_lab%phs_point(1) = &
               evt%process_instance%term(i_term)%p_seed
          event_deps%p_born_cms%phs_point(1) &
               = evt%boost_to_cms (event_deps%p_born_lab%phs_point(1))
          call evt%phs_fks_generator%set_sqrts_hat &
               (event_deps%p_born_cms%get_energy (1, 1))
          use_contributors = allocated (event_deps%contributors)
          select type (pcm => evt%process_instance%pcm)
          type is (pcm_nlo_t)
             n_regions = pcm%region_data%n_regions
          end select
          do alr = 1, n_regions
             i_phs = pcm_work%real_kinematics%alr_to_i_phs(alr)
             if (event_deps%phs_identifiers(i_phs)%evaluated) cycle
             emitter = event_deps%phs_identifiers(i_phs)%emitter
             associate (generator => evt%phs_fks_generator)
                if (emitter <= evt%process%get_n_in ()) then
                   call generator%prepare_generation (x_rad, i_phs, emitter, &
                        event_deps%p_born_cms%phs_point(1)%get (), &
                        event_deps%phs_identifiers)
                   ! TODO wk 19-02-28: intent of p_real (also below)?
                   p_real = event_deps%p_real_lab%phs_point(i_phs)
                   select case (generator%isr_kinematics%isr_mode)
                   case (SQRTS_FIXED)
                      call generator%generate_isr_fixed_beam_energy (i_phs, &
                           event_deps%p_born_cms%phs_point(1)%get (), &
                           p_real)
                   case (SQRTS_VAR)
                      call generator%generate_isr (i_phs, &
                           event_deps%p_born_lab%phs_point(1)%get (), &
                           p_real)
                   end select
                   event_deps%p_real_lab%phs_point(i_phs) = p_real
                   event_deps%p_real_cms%phs_point(i_phs) &
                        = evt%boost_to_cms (event_deps%p_real_lab%phs_point(i_phs))
                else
                   if (use_contributors) then
                      i_con = event_deps%alr_to_i_con(alr)
                      call generator%prepare_generation (x_rad, i_phs, emitter, &
                           event_deps%p_born_cms%phs_point(1)%get (), &
                           event_deps%phs_identifiers, event_deps%contributors, i_con)
                      p_real = event_deps%p_real_cms%phs_point(i_phs)
                      call generator%generate_fsr (emitter, i_phs, i_con, &
                           event_deps%p_born_cms%phs_point(1)%get (), &
                           p_real)
                      event_deps%p_real_cms%phs_point(i_phs) = p_real
                   else
                      call generator%prepare_generation (x_rad, i_phs, emitter, &
                           event_deps%p_born_cms%phs_point(1)%get (), &
                           event_deps%phs_identifiers)
                      p_real = event_deps%p_real_cms%phs_point(i_phs)
                      call generator%generate_fsr (emitter, i_phs, &
                           event_deps%p_born_cms%phs_point(1)%get (), &
                           p_real)
                      event_deps%p_real_cms%phs_point(i_phs) = p_real
                   end if
                   event_deps%p_real_lab%phs_point(i_phs) &
                        = evt%boost_to_lab (event_deps%p_real_cms%phs_point(i_phs))
                end if
             end associate
             call pcm_work%set_momenta &
                  (event_deps%p_born_lab%phs_point(1)%get (), &
                  event_deps%p_real_lab%phs_point(i_phs)%get (), &
                  i_phs)
             call pcm_work%set_momenta &
                  (event_deps%p_born_cms%phs_point(1)%get (), &
                  event_deps%p_real_cms%phs_point(i_phs)%get (), &
                  i_phs, cms = .true.)
             event_deps%phs_identifiers(i_phs)%evaluated = .true.
          end do
       end associate
    end select
  end subroutine evt_nlo_evaluate_real_kinematics

@ %def evt_nlo_evaluate_real_kinematics
@ This routine calls the evaluation of the singular regions only for the
subtraction terms.
<<Evt NLO: evt nlo: TBP>>=
  procedure :: compute_subtraction_sqmes => evt_nlo_compute_subtraction_sqmes
<<Evt NLO: sub interfaces>>=
    module function evt_nlo_compute_subtraction_sqmes (evt) result (sqme)
      class(evt_nlo_t), intent(inout) :: evt
      real(default) :: sqme
    end function evt_nlo_compute_subtraction_sqmes
<<Evt NLO: procedures>>=
  module function evt_nlo_compute_subtraction_sqmes (evt) result (sqme)
    class(evt_nlo_t), intent(inout) :: evt
    real(default) :: sqme
    integer :: i_phs, i_term
    if (debug_on)  call msg_debug &
         (D_TRANSFORMS, "evt_nlo_compute_subtraction_sqmes")
    sqme = zero
    associate (event_deps => evt%event_deps)
      i_phs = 1; i_term = evt%i_evaluation_to_i_term(0)
      call evt%process_instance%compute_sqme_rad &
           (i_term, i_phs, is_subtraction = .true.)
      sqme = sqme + evt%process_instance%get_sqme (i_term)
    end associate
  end function evt_nlo_compute_subtraction_sqmes

@ %def evt_nlo_compute_subtraction_sqmes
@ This routine calls the evaluation of the singular regions only for
emission matrix elements.
<<Evt NLO: evt nlo: TBP>>=
  procedure :: compute_real => evt_nlo_compute_real
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_compute_real (evt)
      class(evt_nlo_t), intent(inout) :: evt
    end subroutine evt_nlo_compute_real
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_compute_real (evt)
    class(evt_nlo_t), intent(inout) :: evt
    integer :: i_phs, i_term
    if (debug_on) call msg_debug (D_TRANSFORMS, "evt_nlo_compute_real")
    i_phs = evt%get_i_phs ()
    i_term = evt%i_evaluation_to_i_term (evt%i_evaluation)
    associate (event_deps => evt%event_deps)
      call evt%process_instance%compute_sqme_rad (i_term, i_phs, &
           is_subtraction = .false.)
      evt%sqme_rad = evt%process_instance%get_sqme (i_term)
    end associate
  end subroutine evt_nlo_compute_real

@ %def evt_nlo_compute_real
@ This routine calls the evaluation of the singular regions only for all
emission matrix elements. This is needed for the combined mode. It returns
the sum of all valid real matrix elements.
<<Evt NLO: evt nlo: TBP>>=
  procedure :: compute_all_sqme_rad => evt_nlo_compute_all_sqme_rad
<<Evt NLO: sub interfaces>>=
    module function evt_nlo_compute_all_sqme_rad (evt) result (sqme)
      class(evt_nlo_t), intent(inout) :: evt
      real(default) :: sqme
    end function evt_nlo_compute_all_sqme_rad
<<Evt NLO: procedures>>=
  module function evt_nlo_compute_all_sqme_rad (evt) result (sqme)
    class(evt_nlo_t), intent(inout) :: evt
    real(default) :: sqme
    integer :: i_phs, i_term
    if (debug_on) call msg_debug (D_TRANSFORMS, "evt_nlo_compute_all_sqme_rad")
    sqme = zero
    do i_term = 1, size (evt%process_instance%term)
       if (evt%is_valid_event (i_term)) then
          associate (term => evt%process_instance%term(i_term))
            if (term%nlo_type == NLO_REAL .and. &
                 .not. term%is_subtraction ()) then
               i_phs = evt%process_instance%kin(i_term)%i_phs
               call evt%process_instance%compute_sqme_rad ( &
                    i_term, i_phs, is_subtraction = .false.)
               sqme = sqme + evt%process_instance%get_sqme (i_term)
            end if
          end associate
       end if
    end do
  end function evt_nlo_compute_all_sqme_rad

@ %def evt_nlo_compute_all_sqme_rad
@ Boosts the given four vector [[p_lab]] to the Born or real CMS
depending on the number of given momenta. Unfortunately, all boosts
available via [[get_boost_to_cms]] are Born-like, so we need to
compute the boost to the real CMS here manually. We cannot rely on
[[i_term]] in order to determine whether to apply a Born-like or a
real boost as we also need a real boost to compute the weights of the
Born-like subevents as implemented in [[evt_nlo_generate_weighted]].
<<Evt NLO: evt nlo: TBP>>=
  procedure :: boost_to_cms => evt_nlo_boost_to_cms
<<Evt NLO: sub interfaces>>=
    module function evt_nlo_boost_to_cms (evt, p_lab) result (p_cms)
      type(phs_point_t), intent(in) :: p_lab
      class(evt_nlo_t), intent(in) :: evt
      type(phs_point_t) :: p_cms
    end function evt_nlo_boost_to_cms
<<Evt NLO: procedures>>=
  module function evt_nlo_boost_to_cms (evt, p_lab) result (p_cms)
    type(phs_point_t), intent(in) :: p_lab
    class(evt_nlo_t), intent(in) :: evt
    type(phs_point_t) :: p_cms
    type(vector4_t) :: p0, p1
    type(lorentz_transformation_t) :: lt_lab_to_cms, lt
    real(default) :: sqrts_hat
    integer :: i_boost, n_legs_born
    if (evt%event_deps%lab_is_cm) then
       lt_lab_to_cms = identity
    else
       n_legs_born = size (evt%event_deps%p_born_lab%phs_point(1))
       if (size (p_lab) == n_legs_born) then
          i_boost = evt%get_i_term ()
          lt_lab_to_cms = evt%process_instance%get_boost_to_cms (i_boost)
       else
          sqrts_hat = (p_lab%select (1) + p_lab%select (2))**1
          p0 = p_lab%select (1) + p_lab%select (2)
          lt = boost (p0, sqrts_hat)
          p1 = inverse(lt) * p_lab%select (1)
          lt_lab_to_cms = inverse (lt * rotation_to_2nd (3, space_part (p1)))
       end if
    end if
    p_cms = lt_lab_to_cms * p_lab
  end function evt_nlo_boost_to_cms

@ %def evt_nlo_boost_to_cms
@ Boosts the given four vector [[p_cms]] from the Born CMS to the lab
system. It should not be called for ISR as in this case, the Born CMS
and the real CMS differ.
<<Evt NLO: evt nlo: TBP>>=
  procedure :: boost_to_lab => evt_nlo_boost_to_lab
<<Evt NLO: sub interfaces>>=
    module function evt_nlo_boost_to_lab (evt, p_cms) result (p_lab)
      type(phs_point_t) :: p_lab
      class(evt_nlo_t), intent(in) :: evt
      type(phs_point_t), intent(in) :: p_cms
    end function evt_nlo_boost_to_lab
<<Evt NLO: procedures>>=
  module function evt_nlo_boost_to_lab (evt, p_cms) result (p_lab)
    type(phs_point_t) :: p_lab
    class(evt_nlo_t), intent(in) :: evt
    type(phs_point_t), intent(in) :: p_cms
    type(lorentz_transformation_t) :: lt_cms_to_lab
    integer :: i_boost
    if (evt%event_deps%lab_is_cm) then
       lt_cms_to_lab = identity
    else
       i_boost = evt%get_i_term ()
       lt_cms_to_lab = evt%process_instance%get_boost_to_lab (i_boost)
    end if
    p_lab = lt_cms_to_lab * p_cms
  end function evt_nlo_boost_to_lab

@ %def evt_nlo_boost_to_lab
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: setup_general_event_kinematics => &
       evt_nlo_setup_general_event_kinematics
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_setup_general_event_kinematics &
         (evt, process_instance)
      class(evt_nlo_t), intent(inout) :: evt
      type(process_instance_t), intent(in) :: process_instance
    end subroutine evt_nlo_setup_general_event_kinematics
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_setup_general_event_kinematics &
       (evt, process_instance)
    class(evt_nlo_t), intent(inout) :: evt
    type(process_instance_t), intent(in) :: process_instance
    integer :: n_born
    associate (event_deps => evt%event_deps)
       event_deps%lab_is_cm = process_instance%lab_is_cm (1)
       select type (pcm => process_instance%pcm)
       type is (pcm_nlo_t)
          n_born = pcm%region_data%n_legs_born
       end select
       call event_deps%p_born_cms%init (n_born, 1)
       call event_deps%p_born_lab%init (n_born, 1)
    end associate
  end subroutine evt_nlo_setup_general_event_kinematics

@ %def evt_nlo_setup_general_event_kinematics
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: setup_real_event_kinematics => &
       evt_nlo_setup_real_event_kinematics
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_setup_real_event_kinematics &
         (evt, process_instance)
      class(evt_nlo_t), intent(inout) :: evt
      type(process_instance_t), intent(in) :: process_instance
    end subroutine evt_nlo_setup_real_event_kinematics
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_setup_real_event_kinematics (evt, process_instance)
    class(evt_nlo_t), intent(inout) :: evt
    type(process_instance_t), intent(in) :: process_instance
    integer :: n_real, n_phs
    integer :: i_real
    associate (event_deps => evt%event_deps)
       select type (pcm => process_instance%pcm)
       class is (pcm_nlo_t)
          n_real = pcm%region_data%n_legs_real
       end select
       i_real = evt%process%get_first_real_term ()
       select type (phs => process_instance%kin(i_real)%phs)
       type is (phs_fks_t)
          event_deps%phs_identifiers = phs%phs_identifiers
       end select
       n_phs = size (event_deps%phs_identifiers)
       call event_deps%p_real_cms%init (n_real, n_phs)
       call event_deps%p_real_lab%init (n_real, n_phs)
       select type (pcm => process_instance%pcm)
       type is (pcm_nlo_t)
          if (allocated (pcm%region_data%alr_contributors)) then
             allocate (event_deps%contributors &
                  (size (pcm%region_data%alr_contributors)))
             event_deps%contributors = pcm%region_data%alr_contributors
          end if
          if (allocated (pcm%region_data%alr_to_i_contributor)) then
             allocate (event_deps%alr_to_i_con &
                  (size (pcm%region_data%alr_to_i_contributor)))
             event_deps%alr_to_i_con = pcm%region_data%alr_to_i_contributor
          end if
       end select
    end associate
  end subroutine evt_nlo_setup_real_event_kinematics

@ %def evt_nlo_setup_real_event_kinematics
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: set_mode => evt_nlo_set_mode
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_set_mode (evt, process_instance)
      class(evt_nlo_t), intent(inout) :: evt
      type(process_instance_t), intent(in) :: process_instance
    end subroutine evt_nlo_set_mode
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_set_mode (evt, process_instance)
    class(evt_nlo_t), intent(inout) :: evt
    type(process_instance_t), intent(in) :: process_instance
    integer :: i_real
    select type (pcm => process_instance%pcm)
    type is (pcm_nlo_t)
       if (pcm%settings%combined_integration) then
          evt%mode = EVT_NLO_COMBINED
       else
          i_real = evt%process%get_first_real_component ()
          if (i_real == evt%process%extract_active_component_mci ()) then
             evt%mode = EVT_NLO_SEPARATE_REAL
          else
             evt%mode = EVT_NLO_SEPARATE_BORNLIKE
          end if
       end if
    end select
  end subroutine evt_nlo_set_mode

@ %def evt_nlo_set_mode
@
<<Evt NLO: evt nlo: TBP>>=
  procedure :: is_valid_event => evt_nlo_is_valid_event
<<Evt NLO: sub interfaces>>=
    module function evt_nlo_is_valid_event (evt, i_term) result (valid)
      logical :: valid
      class(evt_nlo_t), intent(in) :: evt
      integer, intent(in) :: i_term
    end function evt_nlo_is_valid_event
<<Evt NLO: procedures>>=
  module function evt_nlo_is_valid_event (evt, i_term) result (valid)
    logical :: valid
    class(evt_nlo_t), intent(in) :: evt
    integer, intent(in) :: i_term
    valid = evt%process_instance%term(i_term)%passed
  end function evt_nlo_is_valid_event

@ %def evt_nlo_is_valid_event
@ Retrieves the actual quantum numbers chosen in [[evt_nlo_prepare_new_event]].
<<Evt NLO: evt nlo: TBP>>=
  procedure :: get_selected_quantum_numbers => &
       evt_nlo_get_selected_quantum_numbers
<<Evt NLO: sub interfaces>>=
    module function evt_nlo_get_selected_quantum_numbers &
         (evt, i_flv) result (qn_select)
      class(evt_nlo_t), intent(in) :: evt
      integer, intent(in) :: i_flv
      type(quantum_numbers_t), dimension(:), allocatable :: qn_select
    end function evt_nlo_get_selected_quantum_numbers
<<Evt NLO: procedures>>=
  module function evt_nlo_get_selected_quantum_numbers &
       (evt, i_flv) result (qn_select)
    class(evt_nlo_t), intent(in) :: evt
    integer, intent(in) :: i_flv
    type(quantum_numbers_t), dimension(:), allocatable :: qn_select
    integer :: i_term, index
    i_term = evt%get_i_term ()
    associate (term => evt%process_instance%term(i_term))
       index = term%connected%matrix%get_qn_index (i_flv, i_sub = 0)
       qn_select = term%connected%matrix%get_quantum_numbers (index)
    end associate
  end function evt_nlo_get_selected_quantum_numbers

@ %def evt_nlo_get_selected_quantum_numbers
@ Selects a flavor structure for Born subevents, such that each
possible flavor structure is as probable as its portion of the sum of
Born matrix elements over all flavors. For non-Born Born-like
subevents, no Born matrix elements are available. We always choose
[[i_flv = 1]] in this case. If all terms are active, i.e. in a full
NLO calculation, the flavors of Born-like subevents will be
distributed according to the Born matrix elements only, to avoid
issues with matrix elements of different sign and assure a LO flavor
distribution.

Likewise, the real-like event flavors are distributed according to the
real matrix elements. Here, we need to make sure to not mix matrix
elements from different real terms and instead determine the flavor
for each subevent based on just the matrix elements for one of the
terms. The implementation below assumes that in the sequence of NLO
terms, the Born term is immediately followed by all the real terms
which are again followed by the subtraction, the virtual and the DGLAP
term.

Both flavor structures can be determined without correlation as the
flavors will only become important for events to be matched to a
parton shower and in this case we will only generate either a single
Born-like or a single real-like event which are not part of an event
group.

In case all subevents failed the cuts, all [[sqme]]s were set to $0$
so we cannot determine the flavor in this way. In this case, we always
choose the first flavor structure given by the matrix-element
generator with [[i_flv = 1]].

Ideally, having to choose a particle set here would not be necessary
as it is also chosen in [[particle_set_init_interaction]] which in the
current approach is disabled by supplying [[qn_select]] explicitly
based on the flavors chosen here.
<<Evt NLO: evt nlo: TBP>>=
  procedure :: prepare_new_event => evt_nlo_prepare_new_event
<<Evt NLO: sub interfaces>>=
    module subroutine evt_nlo_prepare_new_event (evt, i_mci, i_term)
      class(evt_nlo_t), intent(inout) :: evt
      integer, intent(in) :: i_mci, i_term
    end subroutine evt_nlo_prepare_new_event
<<Evt NLO: procedures>>=
  module subroutine evt_nlo_prepare_new_event (evt, i_mci, i_term)
    class(evt_nlo_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    real(default) :: s, x
    real(default) :: sqme_total
    real(default), dimension(:), allocatable :: sqme_flv
    integer :: i, i_flv, i_core, emitter, n_in
    logical, save :: warn_once = .true.
    class(prc_core_t), pointer :: core => null ()
    call evt%reset ()
    call evt%rng%generate (x)
    do i = 1, size (evt%process_instance%term)
       associate (term => evt%process_instance%term(i))
          if (evt%i_evaluation == 0) then
             if (term%nlo_type == BORN) then
                allocate (sqme_flv (term%config%data%n_flv))
                exit
             end if
          else
             if (term%nlo_type == NLO_REAL .and. .not. term%is_subtraction()) then
                allocate (sqme_flv (term%config%data%n_flv))
                exit
             end if
          end if
       end associate
    end do
    sqme_total = zero
    sqme_flv = zero
    i_core = evt%process%get_i_core (i_term)
    core => evt%process%get_core_ptr (i_core)
    do i = 1, size (evt%process_instance%term)
       associate (term => evt%process_instance%term(i))
          if (i == evt%i_evaluation + 1 .and. (term%nlo_type == BORN .or. &
               (term%nlo_type == NLO_REAL .and. .not. term%is_subtraction())) ) then
             sqme_total = sqme_total + real (sum ( term%connected%matrix%get_matrix_element ()))
             !!! TODO (VR 2020-02-19) figure out why this select type is needed for prc_omega_t
             !!! For NLO and prc_omega_t the connected trace seems to be set up incorrectly!
             !!! (PS 2020-11-05) This leads to real events of processes with structure functions
             !!! having a wrong flavor distribution if computed with O'Mega.
             !!! The flavor distributions are identical with and also without the special case
             !!! for O'Mega and wrong in both cases.
             !!! However, this case it is not critical as long as O'Mega does not provide matrix elements
             !!! exclusive in coupling orders and is thus only rarely used for NLO applications anyways
             select type (core)
             class is (prc_external_t)
                do i_flv = 1, size (sqme_flv)
                   if (allocated (term%passed_array)) then
                      if (term%passed .and. .not. term%passed_array(i_flv)) cycle
                   end if
                   sqme_flv(i_flv) = sqme_flv(i_flv) &
                        + real (term%connected%matrix%get_matrix_element ( &
                        term%connected%matrix%get_qn_index (i_flv, i_sub = 0)))
                end do
             class default
                sqme_flv = sqme_flv &
                     + real (term%connected%matrix%get_matrix_element ())
                emitter = evt%process_instance%kin(i)%emitter
                n_in = evt%process_instance%kin(i)%n_in
                if (warn_once .and. term%nlo_type == NLO_REAL .and. emitter <= n_in) then
                   warn_once = .false.
                   call msg_warning("evt_nlo_prepare_new_event: fNLO flavor&
                        & distributions with O'Mega are wrong.")
                end if
             end select
          end if
       end associate
    end do
    if (debug2_active (D_TRANSFORMS)) then
       if (.not. nearly_equal(sqme_total, sum (sqme_flv))) then
          call msg_warning ("evt_nlo_prepare_new_event: &
          &sum over flavored sqmes does not match total sqme.")
       end if
    end if
    !!! Need absolute values to take into account negative weights
    x = x * abs (sqme_total)
    s = abs (sqme_flv (1))
    evt%selected_i_flv = 1
    if (s < x) then
       do i_flv = 2, size (sqme_flv)
          s = s + abs (sqme_flv (i_flv))
          if (s > x) then
             evt%selected_i_flv = i_flv
             exit
          end if
       end do
    end if
    if (debug2_active (D_TRANSFORMS)) then
       call msg_print_color ("Selected i_flv: ", COL_GREEN)
       print *, evt%selected_i_flv
    end if
  end subroutine evt_nlo_prepare_new_event

@ %def evt_nlo_prepare_new_event
@
\section{Complete Events}
This module combines hard processes with decay chains, shower, and
hadronization (not implemented yet) to complete events.  It also
manages the input and output of event records in various formats.
<<[[events.f90]]>>=
<<File header>>

module events

<<Use kinds>>
<<Use strings>>
  use diagnostics
  use variables
  use expr_base
  use model_data
  use state_matrices, only: FM_IGNORE_HELICITY, &
       FM_SELECT_HELICITY, FM_FACTOR_HELICITY, FM_CORRELATED_HELICITY
  use particles
  use subevt_expr
  use rng_base
  use process, only: process_t
  use instances, only: process_instance_t
  use process_stacks
  use event_base
  use event_transforms

<<Standard module head>>

<<Events: public>>

<<Events: types>>

<<Events: interfaces>>

  interface
<<Events: sub interfaces>>
  end interface

contains

<<Events: main procedures>>

end module events
@ %def events
@
<<[[events_sub.f90]]>>=
<<File header>>

submodule (events) events_s

<<Use debug>>
  use constants, only: one
  use io_units
  use format_utils, only: pac_fmt, write_separator
  use format_defs, only: FMT_12, FMT_19
  use numeric_utils
  use pcm, only: pcm_nlo_workspace_t
  use decays
  use evt_nlo
  use phs_fks, only: SQRTS_FIXED, SQRTS_VAR

  implicit none

contains

<<Events: procedures>>

end submodule events_s

@ %def events_s
@
\subsection{Event configuration}
The parameters govern the transformation of an event to a particle set.

The [[safety_factor]] reduces the acceptance probability for
unweighting.  If greater than one, excess events become less likely,
but the reweighting efficiency also drops.

The [[sigma]] and [[n]] values, if nontrivial, allow for reweighting
the events according to the requested [[norm_mode]].

Various [[parse_node_t]] objects are taken from the SINDARIN input.
They encode expressions that apply to the current event.  The
workspaces for evaluating those expressions are set up in the
[[event_expr_t]] objects.  Note that these are really pointers,
so the actual nodes are not stored inside the event object.
<<Events: types>>=
  type :: event_config_t
     logical :: unweighted = .false.
     integer :: norm_mode = NORM_UNDEFINED
     integer :: factorization_mode = FM_IGNORE_HELICITY
     logical :: keep_correlations = .false.
     logical :: colorize_subevt = .false.
     real(default) :: sigma = 1
     integer :: n = 1
     real(default) :: safety_factor = 1
     class(expr_factory_t), allocatable :: ef_selection
     class(expr_factory_t), allocatable :: ef_reweight
     class(expr_factory_t), allocatable :: ef_analysis
   contains
   <<Events: event config: TBP>>
  end type event_config_t

@ %def event_config_t
@ Output.
<<Events: event config: TBP>>=
  procedure :: write => event_config_write
<<Events: sub interfaces>>=
    module subroutine event_config_write (object, unit, show_expressions)
      class(event_config_t), intent(in) :: object
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: show_expressions
    end subroutine event_config_write
<<Events: procedures>>=
  module subroutine event_config_write (object, unit, show_expressions)
    class(event_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_expressions
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A,L1)")  "Unweighted         = ", object%unweighted
    write (u, "(3x,A,A)")   "Normalization      = ", &
         char (event_normalization_string (object%norm_mode))
    write (u, "(3x,A)", advance="no")  "Helicity handling  = "
    select case (object%factorization_mode)
    case (FM_IGNORE_HELICITY)
       write (u, "(A)")  "drop"
    case (FM_SELECT_HELICITY)
       write (u, "(A)")  "select"
    case (FM_FACTOR_HELICITY)
       write (u, "(A)")  "factorize"
    end select
    write (u, "(3x,A,L1)")  "Keep correlations  = ", object%keep_correlations
    if (object%colorize_subevt) then
       write (u, "(3x,A,L1)")  "Colorize subevent  = ", object%colorize_subevt
    end if
    if (.not. nearly_equal (object%safety_factor, one)) then
       write (u, "(3x,A," // FMT_12 // ")")  &
            "Safety factor      = ", object%safety_factor
    end if
    if (present (show_expressions)) then
       if (show_expressions) then
          if (allocated (object%ef_selection)) then
             call write_separator (u)
             write (u, "(3x,A)") "Event selection expression:"
             call object%ef_selection%write (u)
          end if
          if (allocated (object%ef_reweight)) then
             call write_separator (u)
             write (u, "(3x,A)") "Event reweighting expression:"
             call object%ef_reweight%write (u)
          end if
          if (allocated (object%ef_analysis)) then
             call write_separator (u)
             write (u, "(3x,A)") "Analysis expression:"
             call object%ef_analysis%write (u)
          end if
       end if
    end if
  end subroutine event_config_write

@ %def event_config_write
@
\subsection{The event type}
This is the concrete implementation of the [[generic_event_t]] core
that is defined above in the [[event_base]] module.  The core manages
the main (dressed) particle set pointer and the current values for
weights and sqme.  The implementation adds configuration data,
expressions, process references, and event transforms.

Each event refers to a single elementary process.  This process may be
dressed by a shower, a decay chain etc.  We maintain pointers to a
process instance.

A list of event transforms (class [[evt_t]]) transform the connected
interactions of the process instance into the final particle set.  In
this list, the first transform is always the trivial one, which just
factorizes the process instance.  Subsequent transforms may apply
decays, etc.  The [[particle_set]] pointer identifies the particle set
that we want to be analyzed and returned by the event, usually the
last one.

Squared matrix element and weight values: when reading events from
file, the [[ref]] value is the number in the file, while the [[prc]]
value is the number that we calculate from the momenta in the file,
possibly with different parameters.  When generating events the first
time, or if we do not recalculate, the numbers should coincide.
Furthermore, the array of [[alt]] values is copied from an array of
alternative event records.  These values should represent calculated
values.

The [[sqme]] and [[weight]] values mirror corresponding values in the
[[expr]] subobject.  The idea is that when generating or reading
events, the event record is filled first, then the [[expr]] object
acquires copies.  These copies are used for writing events and as targets
for pointer variables in the analysis expression.

All data that involve user-provided expressions (selection, reweighting,
analysis) are handled by the [[expr]] subobject.  In particular, evaluating
the event-selection expression sets the [[passed]] flag.  Furthermore,
the [[expr]] subobject collects data that can be used in the analysis
and should be written to file, including copies of [[sqme]] and [[weight]].
<<Events: public>>=
  public :: event_t
<<Events: types>>=
  type, extends (generic_event_t) :: event_t
     type(event_config_t) :: config
     type(process_t), pointer :: process => null ()
     type(process_instance_t), pointer :: instance => null ()
     class(rng_t), allocatable :: rng
     integer :: selected_i_mci = 0
     integer :: selected_i_term = 0
     integer :: selected_channel = 0
     logical :: is_complete = .false.
     class(evt_t), pointer :: transform_first => null ()
     class(evt_t), pointer :: transform_last => null ()
     type(event_expr_t) :: expr
     logical :: selection_evaluated = .false.
     logical :: passed = .false.
     real(default), allocatable :: alpha_qcd_forced
     real(default), allocatable :: scale_forced
     real(default) :: reweight = 1
     logical :: analysis_flag = .false.
     integer :: i_event = 0
   contains
   <<Events: event: TBP>>
  end type event_t

@ %def event_t
@
<<Events: event: TBP>>=
  procedure :: clone => event_clone
<<Events: sub interfaces>>=
    module subroutine event_clone (event, event_new)
      class(event_t), intent(in), target :: event
      class(event_t), intent(out), target:: event_new
    end subroutine event_clone
<<Events: procedures>>=
  module subroutine event_clone (event, event_new)
    class(event_t), intent(in), target :: event
    class(event_t), intent(out), target:: event_new
    type(string_t) :: id
    integer :: num_id
    event_new%config = event%config
    event_new%process => event%process
    event_new%instance => event%instance
    if (allocated (event%rng)) &
         allocate(event_new%rng, source=event%rng)
    event_new%selected_i_mci = event%selected_i_mci
    event_new%selected_i_term = event%selected_i_term
    event_new%selected_channel = event%selected_channel
    event_new%is_complete = event%is_complete
    event_new%transform_first => event%transform_first
    event_new%transform_last => event%transform_last
    event_new%selection_evaluated = event%selection_evaluated
    event_new%passed = event%passed
    if (allocated (event%alpha_qcd_forced)) &
         allocate(event_new%alpha_qcd_forced, source=event%alpha_qcd_forced)
    if (allocated (event%scale_forced)) &
         allocate(event_new%scale_forced, source=event%scale_forced)
    event_new%reweight = event%reweight
    event_new%analysis_flag = event%analysis_flag
    event_new%i_event = event%i_event
    id = event_new%process%get_id ()
    if (id /= "")  call event_new%expr%set_process_id (id)
    num_id = event_new%process%get_num_id ()
    if (num_id /= 0)  call event_new%expr%set_process_num_id (num_id)
    call event_new%expr%setup_vars (event_new%process%get_sqrts ())
    call event_new%expr%link_var_list (event_new%process%get_var_list_ptr ())
  end subroutine event_clone

@ %def event_clone
@ Finalizer: the list of event transforms is deleted iteratively.
<<Events: event: TBP>>=
  procedure :: final => event_final
<<Events: sub interfaces>>=
    module subroutine event_final (object)
      class(event_t), intent(inout) :: object
    end subroutine event_final
<<Events: procedures>>=
  module subroutine event_final (object)
    class(event_t), intent(inout) :: object
    class(evt_t), pointer :: evt
    if (allocated (object%rng))  call object%rng%final ()
    call object%expr%final ()
    do while (associated (object%transform_first))
       evt => object%transform_first
       object%transform_first => evt%next
       call evt%final ()
       deallocate (evt)
    end do
  end subroutine event_final

@ %def event_final
@ Output.

The event index is written in the header, it should coincide with the
[[event_index]] variable that can be used in selection and analysis.

Particle set: this is a pointer to one of the event transforms, so it
should suffice to print the latter.
<<Events: event: TBP>>=
  procedure :: write => event_write
<<Events: sub interfaces>>=
    module subroutine event_write (object, unit, show_process, &
         show_transforms, show_decay, verbose, testflag)
      class(event_t), intent(in) :: object
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: show_process, show_transforms, show_decay
      logical, intent(in), optional :: verbose
      logical, intent(in), optional :: testflag
    end subroutine event_write
<<Events: procedures>>=
  module subroutine event_write (object, unit, show_process, &
       show_transforms, show_decay, verbose, testflag)
    class(event_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_process, show_transforms, show_decay
    logical, intent(in), optional :: verbose
    logical, intent(in), optional :: testflag
    logical :: prc, trans, dec, verb
    class(evt_t), pointer :: evt
    character(len=7) :: fmt
    integer :: u, i
    call pac_fmt (fmt, FMT_19, FMT_12, testflag)
    u = given_output_unit (unit)
    prc = .true.;  if (present (show_process))  prc = show_process
    trans = .true.;  if (present (show_transforms))  trans = show_transforms
    dec = .true.;  if (present (show_decay))  dec = show_decay
    verb = .false.;  if (present (verbose))  verb = verbose
    call write_separator (u, 2)
    write (u, "(1x,A)", advance="no")  "Event"
    if (object%has_index ()) then
       write (u, "(1x,'#',I0)", advance="no")  object%get_index ()
    end if
    if (object%is_complete) then
       write (u, *)
    else
       write (u, "(1x,A)")  "[incomplete]"
    end if
    call write_separator (u)
    call object%config%write (u)
    if (object%sqme_ref_is_known () .or. object%weight_ref_is_known ()) then
       call write_separator (u)
    end if
    if (object%sqme_ref_is_known ()) then
       write (u, "(3x,A," // fmt // ")") &
            "Squared matrix el. (ref) = ", object%get_sqme_ref ()
       if (object%sqme_alt_is_known ()) then
          do i = 1, object%get_n_alt ()
             write (u, "(5x,A," // fmt // ",1x,I0)")  &
                  "alternate sqme   = ", object%get_sqme_alt(i), i
          end do
       end if
    end if
    if (object%sqme_prc_is_known ()) &
       write (u, "(3x,A," // fmt // ")") &
            "Squared matrix el. (prc) = ", object%get_sqme_prc ()

    if (object%weight_ref_is_known ()) then
       write (u, "(3x,A," // fmt // ")") &
            "Event weight (ref)       = ", object%get_weight_ref ()
       if (object%weight_alt_is_known ()) then
          do i = 1, object%get_n_alt ()
             write (u, "(5x,A," // fmt // ",1x,I0)")  &
                  "alternate weight       = ", object%get_weight_alt(i), i
          end do
       end if
    end if
    if (object%weight_prc_is_known ()) &
       write (u, "(3x,A," // fmt // ")") &
            "Event weight (prc)       = ", object%get_weight_prc ()

    if (object%selected_i_mci /= 0) then
       call write_separator (u)
       write (u, "(3x,A,I0)")  "Selected MCI group = ", object%selected_i_mci
       write (u, "(3x,A,I0)")  "Selected term      = ", object%selected_i_term
       write (u, "(3x,A,I0)")  "Selected channel   = ", object%selected_channel
    end if
    if (object%selection_evaluated) then
       call write_separator (u)
       write (u, "(3x,A,L1)")  "Passed selection   = ", object%passed
       if (object%passed) then
          write (u, "(3x,A," // fmt // ")") &
               "Reweighting factor = ", object%reweight
          write (u, "(3x,A,L1)") &
               "Analysis flag      = ", object%analysis_flag
       end if
    end if
    if (associated (object%instance)) then
       if (prc) then
          if (verb) then
             call object%instance%write (u, testflag)
          else
             call object%instance%write_header (u)
          end if
       end if
       if (trans) then
          evt => object%transform_first
          do while (associated (evt))
             select type (evt)
             type is (evt_decay_t)
                call evt%write (u, verbose = dec, more_verbose = verb, &
                     testflag = testflag)
             class default
                call evt%write (u, verbose = verb, testflag = testflag)
             end select
             call write_separator (u, 2)
             evt => evt%next
          end do
       else
          call write_separator (u, 2)
       end if
       if (object%expr%subevt_filled) then
          call object%expr%write (u, pacified = testflag)
          call write_separator (u, 2)
       end if
    else
       call write_separator (u, 2)
       write (u, "(1x,A)")  "Process instance: [undefined]"
       call write_separator (u, 2)
    end if
  end subroutine event_write

@ %def event_write
@
\subsection{Initialization}
Initialize: set configuration parameters, using a variable list.  We
do not call this [[init]], because this method name will be used by a type
extension.

The default normalization is [[NORM_SIGMA]], since the default
generation mode is weighted.

For unweighted events, we may want to a apply a safety factor to event
rejection.  (By default, this factor is unity and can be ignored.)

We also allocate the trivial event transform, which is always the
first one.
Gfortran 7/8/9 bug, has to remain in the main module:
<<Events: event: TBP>>=
  procedure :: basic_init => event_init
<<Events: main procedures>>=
  subroutine event_init (event, var_list, n_alt)
    class(event_t), intent(out) :: event
    type(var_list_t), intent(in), optional :: var_list
    integer, intent(in), optional :: n_alt
    type(string_t) :: norm_string, mode_string
    logical :: polarized_events
    if (present (n_alt)) then
       call event%base_init (n_alt)
       call event%expr%init (n_alt)
    else
       call event%base_init (0)
    end if
    if (present (var_list)) then
       event%config%unweighted = var_list%get_lval (&
            var_str ("?unweighted"))
       norm_string = var_list%get_sval (&
            var_str ("$sample_normalization"))
       event%config%norm_mode = &
            event_normalization_mode (norm_string, event%config%unweighted)
       polarized_events = &
            var_list%get_lval (var_str ("?polarized_events"))
       if (polarized_events) then
          mode_string = &
               var_list%get_sval (var_str ("$polarization_mode"))
          select case (char (mode_string))
          case ("ignore")
             event%config%factorization_mode = FM_IGNORE_HELICITY
          case ("helicity")
             event%config%factorization_mode = FM_SELECT_HELICITY
          case ("factorized")
             event%config%factorization_mode = FM_FACTOR_HELICITY
          case ("correlated")
             event%config%factorization_mode = FM_CORRELATED_HELICITY
          case default
             call msg_fatal ("Polarization mode " &
                  // char (mode_string) // " is undefined")
          end select
       else
          event%config%factorization_mode = FM_IGNORE_HELICITY
       end if
       event%config%colorize_subevt = &
            var_list%get_lval (var_str ("?colorize_subevt"))
       if (event%config%unweighted) then
          event%config%safety_factor = var_list%get_rval (&
               var_str ("safety_factor"))
       end if
    else
       event%config%norm_mode = NORM_SIGMA
    end if
    allocate (evt_trivial_t :: event%transform_first)
    event%transform_last => event%transform_first
  end subroutine event_init

@ %def event_init
@ Set the [[sigma]] and [[n]] values in the configuration record that
determine non-standard event normalizations.  If these numbers are not
set explicitly, the default value for both is unity, and event
renormalization has no effect.
<<Events: event: TBP>>=
  procedure :: set_sigma => event_set_sigma
  procedure :: set_n => event_set_n
<<Events: sub interfaces>>=
    elemental module subroutine event_set_sigma (event, sigma)
      class(event_t), intent(inout) :: event
      real(default), intent(in) :: sigma
    end subroutine event_set_sigma
    elemental module subroutine event_set_n (event, n)
      class(event_t), intent(inout) :: event
      integer, intent(in) :: n
    end subroutine event_set_n
<<Events: procedures>>=
  elemental module subroutine event_set_sigma (event, sigma)
    class(event_t), intent(inout) :: event
    real(default), intent(in) :: sigma
    event%config%sigma = sigma
  end subroutine event_set_sigma

  elemental module subroutine event_set_n (event, n)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: n
    event%config%n = n
  end subroutine event_set_n

@ %def event_set_n
@ Append an event transform (decays, etc.).  The transform is not yet
connected to a process.  The transform is then considered to belong to
the event object, and will be finalized together with it.  The
original pointer is removed.

We can assume that the trivial transform is already present in the
event object, at least.
<<Events: event: TBP>>=
  procedure :: import_transform => event_import_transform
<<Events: sub interfaces>>=
    module subroutine event_import_transform (event, evt)
      class(event_t), intent(inout) :: event
      class(evt_t), intent(inout), pointer :: evt
    end subroutine event_import_transform
<<Events: procedures>>=
  module subroutine event_import_transform (event, evt)
    class(event_t), intent(inout) :: event
    class(evt_t), intent(inout), pointer :: evt
    event%transform_last%next => evt
    evt%previous => event%transform_last
    event%transform_last => evt
    evt => null ()
  end subroutine event_import_transform

@ %def event_import_transform
@
We link the event to an existing process instance.  This
includes the variable list, which is linked to the process variable
list.  Note that this is not necessarily identical to the variable
list used for event initialization.

The variable list will contain pointers to [[event]] subobjects, therefore the
[[target]] attribute.

Once we have a process connected, we can use it to obtain an event
generator instance.

The model and process stack may be needed by event transforms.  The
current model setting may be different from the model in the process
(regarding unstable particles, etc.).  The process stack can be used
for assigning extra processes that we need for the event transforms.
<<Events: event: TBP>>=
  procedure :: connect => event_connect
<<Events: sub interfaces>>=
    module subroutine event_connect &
         (event, process_instance, model, process_stack)
      class(event_t), intent(inout), target :: event
      type(process_instance_t), intent(in), target :: process_instance
      class(model_data_t), intent(in), target :: model
      type(process_stack_t), intent(in), optional :: process_stack
    end subroutine event_connect
<<Events: procedures>>=
  module subroutine event_connect &
       (event, process_instance, model, process_stack)
    class(event_t), intent(inout), target :: event
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(string_t) :: id
    integer :: num_id
    class(evt_t), pointer :: evt
    event%process => process_instance%process
    event%instance => process_instance
    id = event%process%get_id ()
    if (id /= "")  call event%expr%set_process_id (id)
    num_id = event%process%get_num_id ()
    if (num_id /= 0)  call event%expr%set_process_num_id (num_id)
    call event%expr%setup_vars (event%process%get_sqrts ())
    call event%expr%link_var_list (event%process%get_var_list_ptr ())
    call event%process%make_rng (event%rng)
    evt => event%transform_first
    do while (associated (evt))
       call evt%connect (process_instance, model, process_stack)
       evt => evt%next
    end do
  end subroutine event_connect

@ %def event_connect
@ Set the parse nodes for the associated expressions, individually.  The
parse-node pointers may be null.
<<Events: event: TBP>>=
  procedure :: set_selection => event_set_selection
  procedure :: set_reweight => event_set_reweight
  procedure :: set_analysis => event_set_analysis
<<Events: sub interfaces>>=
    module subroutine event_set_selection (event, ef_selection)
      class(event_t), intent(inout) :: event
      class(expr_factory_t), intent(in) :: ef_selection
    end subroutine event_set_selection
    module subroutine event_set_reweight (event, ef_reweight)
      class(event_t), intent(inout) :: event
      class(expr_factory_t), intent(in) :: ef_reweight
    end subroutine event_set_reweight
    module subroutine event_set_analysis (event, ef_analysis)
      class(event_t), intent(inout) :: event
      class(expr_factory_t), intent(in) :: ef_analysis
    end subroutine event_set_analysis
<<Events: procedures>>=
  module subroutine event_set_selection (event, ef_selection)
    class(event_t), intent(inout) :: event
    class(expr_factory_t), intent(in) :: ef_selection
    allocate (event%config%ef_selection, source = ef_selection)
  end subroutine event_set_selection

  module subroutine event_set_reweight (event, ef_reweight)
    class(event_t), intent(inout) :: event
    class(expr_factory_t), intent(in) :: ef_reweight
    allocate (event%config%ef_reweight, source = ef_reweight)
  end subroutine event_set_reweight

  module subroutine event_set_analysis (event, ef_analysis)
    class(event_t), intent(inout) :: event
    class(expr_factory_t), intent(in) :: ef_analysis
    allocate (event%config%ef_analysis, source = ef_analysis)
  end subroutine event_set_analysis

@ %def event_set_selection
@ %def event_set_reweight
@ %def event_set_analysis
@ Create evaluation trees from the parse trees.  The [[target]] attribute is
required because the expressions contain pointers to event subobjects.
<<Events: event: TBP>>=
  procedure :: setup_expressions => event_setup_expressions
<<Events: sub interfaces>>=
    module subroutine event_setup_expressions (event)
      class(event_t), intent(inout), target :: event
    end subroutine event_setup_expressions
<<Events: procedures>>=
  module subroutine event_setup_expressions (event)
    class(event_t), intent(inout), target :: event
    call event%expr%setup_selection (event%config%ef_selection)
    call event%expr%setup_analysis (event%config%ef_analysis)
    call event%expr%setup_reweight (event%config%ef_reweight)
    call event%expr%colorize (event%config%colorize_subevt)
  end subroutine event_setup_expressions

@ %def event_setup_expressions
@
\subsection{Evaluation}
To fill the [[particle_set]], i.e., the event record proper, we have
to apply all event transforms in order.  The last transform should
fill its associated particle set, factorizing the state matrix
according to the current settings.  There are several parameters
in the event configuration that control this.

We always fill the particle set for the first transform (the hard
process) and the last transform, if different from the first (the
fully dressed process).

Each event transform is an event generator of its own.  We choose to
generate an \emph{unweighted} event for each of them, even if the master
event is assumed to be weighted.  Thus, the overall event weight is
the one of the hard process only.  (There may be more options in future
extensions.)

We can generate the two random numbers that the factorization needs.
For testing purpose, we allow for providing them explicitly, as an option.
<<Events: event: TBP>>=
  procedure :: evaluate_transforms => event_evaluate_transforms
<<Events: sub interfaces>>=
    module subroutine event_evaluate_transforms (event, r)
      class(event_t), intent(inout) :: event
      real(default), dimension(:), intent(in), optional :: r
    end subroutine event_evaluate_transforms
<<Events: procedures>>=
  module subroutine event_evaluate_transforms (event, r)
    class(event_t), intent(inout) :: event
    real(default), dimension(:), intent(in), optional :: r
    class(evt_t), pointer :: evt
    real(default) :: weight_over_sqme
    integer :: i_term, emitter, n_in
    logical :: failed_but_keep
    failed_but_keep = .false.
    if (debug_on) call msg_debug (D_TRANSFORMS, "event_evaluate_transforms")
    call event%discard_particle_set ()
    call event%check ()
    if (event%instance%is_complete_event ()) then
       i_term = event%instance%select_i_term ()
       event%selected_i_term = i_term
       evt => event%transform_first
       do while (associated (evt))
          call evt%prepare_new_event &
               (event%selected_i_mci, event%selected_i_term)
          evt => evt%next
       end do
       if (debug_on) call msg_debug &
            (D_TRANSFORMS, "Before event transformations")
       if (debug_on) call msg_debug &
            (D_TRANSFORMS, "event%weight_prc", event%weight_prc)
       if (debug_on) call msg_debug &
            (D_TRANSFORMS, "event%sqme_prc", event%sqme_prc)
       evt => event%transform_first
       do while (associated (evt))
          call print_transform_name_if_debug ()
          if (evt%only_weighted_events) then
             select type (evt)
             type is (evt_nlo_t)
                i_term = evt%get_i_term ()
                failed_but_keep = .not. evt%is_valid_event (i_term) &
                     .and. evt%keep_failed_events
                if (.not. any(evt%process_instance%term%passed .and. evt%process_instance%term%active) &
                    .and. .not. evt%keep_failed_events)  return
             end select
             if (abs (event%weight_prc) > 0._default) then
                weight_over_sqme = event%weight_prc / event%sqme_prc
                call evt%generate_weighted (event%sqme_prc)
                event%weight_prc = weight_over_sqme * event%sqme_prc
                select type (evt)
                type is (evt_nlo_t)
                   if (.not. evt%is_valid_event (i_term)) event%weight_prc = 0
                end select
             else
                if (.not. failed_but_keep) exit
             end if
          else
             call evt%generate_unweighted ()
          end if
          if (signal_is_pending ())  return
          select type (evt)
          type is (evt_nlo_t)
             if (evt%i_evaluation > 0) then
                emitter = evt%process_instance%kin(i_term)%emitter
                n_in = evt%process_instance%kin(i_term)%n_in
                select type (pcm_work => evt%process_instance%term(i_term)%pcm_work)
                type is (pcm_nlo_workspace_t)
                   if (emitter <= n_in .and. pcm_work%isr_kinematics%isr_mode == SQRTS_VAR) then
                      call evt%connected_set_real_IS_momenta ()
                   end if
                end select
             end if
          end select
          call evt%make_particle_set (event%config%factorization_mode, &
               event%config%keep_correlations)
          if (signal_is_pending ())  return
          if (.not. evt%particle_set_exists) exit
          evt => evt%next
       end do
       evt => event%transform_last
       if ((associated (evt) .and. evt%particle_set_exists) .or. failed_but_keep) then
          if (event%is_nlo ()) then
             select type (evt)
             type is (evt_nlo_t)
                evt%particle_set_nlo (event%i_event + 1) = evt%particle_set
                evt%i_evaluation = evt%i_evaluation + 1
                call event%link_particle_set &
                     (evt%particle_set_nlo(event%i_event + 1))
             end select
          else
             call event%link_particle_set (evt%particle_set)
          end if
       end if
       if (debug_on) call msg_debug &
            (D_TRANSFORMS, "After event transformations")
       if (debug_on) call msg_debug &
            (D_TRANSFORMS, "event%weight_prc", event%weight_prc)
       if (debug_on) call msg_debug &
            (D_TRANSFORMS, "event%sqme_prc", event%sqme_prc)
       if (debug_on) call msg_debug &
            (D_TRANSFORMS, "evt%particle_set_exists", evt%particle_set_exists)
    end if
  contains
    subroutine print_transform_name_if_debug ()
       if (debug_active (D_TRANSFORMS)) then
          print *, 'Current event transform: '
          call evt%write_name ()
       end if
    end subroutine print_transform_name_if_debug
  end subroutine event_evaluate_transforms

@ %def event_evaluate_transforms
@ Set / increment the event index for the current event.  There is no
condition for this to happen.  The event index is actually stored in
the subevent expression, because this allows us to access it in
subevent expressions as a variable.
<<Events: event: TBP>>=
  procedure :: set_index => event_set_index
  procedure :: increment_index => event_increment_index
<<Events: sub interfaces>>=
    module subroutine event_set_index (event, index)
      class(event_t), intent(inout) :: event
      integer, intent(in) :: index
    end subroutine event_set_index
    module subroutine event_increment_index (event, offset)
      class(event_t), intent(inout) :: event
      integer, intent(in), optional :: offset
    end subroutine event_increment_index
<<Events: procedures>>=
  module subroutine event_set_index (event, index)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: index
    call event%expr%set_event_index (index)
  end subroutine event_set_index

  module subroutine event_increment_index (event, offset)
    class(event_t), intent(inout) :: event
    integer, intent(in), optional :: offset
    call event%expr%increment_event_index (offset)
  end subroutine event_increment_index

@ %def event_set_index
@ %def event_increment_index
@
Evaluate the event-related expressions, given a valid
[[particle_set]].  If [[update_sqme]] is set, we use the process
instance for the [[sqme_prc]] value.  The [[sqme_ref]] value is
always taken from the event record.
<<Events: event: TBP>>=
  procedure :: evaluate_expressions => event_evaluate_expressions
<<Events: sub interfaces>>=
    module subroutine event_evaluate_expressions (event)
      class(event_t), intent(inout) :: event
    end subroutine event_evaluate_expressions
<<Events: procedures>>=
  module subroutine event_evaluate_expressions (event)
    class(event_t), intent(inout) :: event
    if (event%has_valid_particle_set ()) then
       call event%expr%fill_subevt (event%get_particle_set_ptr ())
    end if
    if (event%weight_ref_is_known ()) then
       call event%expr%set (weight_ref = event%get_weight_ref ())
    end if
    if (event%weight_prc_is_known ()) then
       call event%expr%set (weight_prc = event%get_weight_prc ())
    end if
    if (event%excess_prc_is_known ()) then
       call event%expr%set (excess_prc = event%get_excess_prc ())
    end if
    if (event%sqme_ref_is_known ()) then
       call event%expr%set (sqme_ref = event%get_sqme_ref ())
    end if
    if (event%sqme_prc_is_known ()) then
       call event%expr%set (sqme_prc = event%get_sqme_prc ())
    end if
    if (event%has_valid_particle_set ()) then
       call event%expr%evaluate &
            (event%passed, event%reweight, event%analysis_flag)
       event%selection_evaluated = .true.
    end if
  end subroutine event_evaluate_expressions

@ %def event_evaluate_expressions
@ Report the result of the [[selection]] evaluation.
<<Events: event: TBP>>=
  procedure :: passed_selection => event_passed_selection
<<Events: sub interfaces>>=
    module function event_passed_selection (event) result (flag)
      class(event_t), intent(in) :: event
      logical :: flag
    end function event_passed_selection
<<Events: procedures>>=
  module function event_passed_selection (event) result (flag)
    class(event_t), intent(in) :: event
    logical :: flag
    flag = event%passed
  end function event_passed_selection

@ %def event_passed_selection
@ Set alternate sqme and weight arrays.  This should be merged with
the previous routine, if the expressions are allowed to refer to these
values.
<<Events: event: TBP>>=
  procedure :: store_alt_values => event_store_alt_values
<<Events: sub interfaces>>=
    module subroutine event_store_alt_values (event)
      class(event_t), intent(inout) :: event
    end subroutine event_store_alt_values
<<Events: procedures>>=
  module subroutine event_store_alt_values (event)
    class(event_t), intent(inout) :: event
    if (event%weight_alt_is_known ()) then
       call event%expr%set (weight_alt = event%get_weight_alt ())
    end if
    if (event%sqme_alt_is_known ()) then
       call event%expr%set (sqme_alt = event%get_sqme_alt ())
    end if
  end subroutine event_store_alt_values

@ %def event_store_alt_values
@
<<Events: event: TBP>>=
  procedure :: is_nlo => event_is_nlo
<<Events: sub interfaces>>=
    module function event_is_nlo (event) result (is_nlo)
      logical :: is_nlo
      class(event_t), intent(in) :: event
    end function event_is_nlo
<<Events: procedures>>=
  module function event_is_nlo (event) result (is_nlo)
    logical :: is_nlo
    class(event_t), intent(in) :: event
    if (associated (event%instance)) then
       select type (pcm_work => event%instance%pcm_work)
       type is (pcm_nlo_workspace_t)
          is_nlo = pcm_work%is_fixed_order_nlo_events ()
       class default
          is_nlo = .false.
       end select
    else
       is_nlo = .false.
    end if
  end function event_is_nlo

@ %def event_is_nlo
@
\subsection{Reset to empty state}
Applying this, current event contents are marked as incomplete but
are not deleted.  In particular, the initialization is kept.  The
event index is also kept, this can be reset separately.
<<Events: event: TBP>>=
  procedure :: reset_contents => event_reset_contents
  procedure :: reset_index => event_reset_index
<<Events: sub interfaces>>=
    module subroutine event_reset_contents (event)
      class(event_t), intent(inout) :: event
    end subroutine event_reset_contents
    module subroutine event_reset_index (event)
      class(event_t), intent(inout) :: event
    end subroutine event_reset_index
<<Events: procedures>>=
  module subroutine event_reset_contents (event)
    class(event_t), intent(inout) :: event
    class(evt_t), pointer :: evt
    call event%base_reset_contents ()
    event%selected_i_mci = 0
    event%selected_i_term = 0
    event%selected_channel = 0
    event%is_complete = .false.
    call event%expr%reset_contents ()
    event%selection_evaluated = .false.
    event%passed = .false.
    event%analysis_flag = .false.
    if (associated (event%instance)) then
       call event%instance%reset (reset_mci = .true.)
    end if
    if (allocated (event%alpha_qcd_forced))  deallocate (event%alpha_qcd_forced)
    if (allocated (event%scale_forced))  deallocate (event%scale_forced)
    evt => event%transform_first
    do while (associated (evt))
       call evt%reset ()
       evt => evt%next
    end do
  end subroutine event_reset_contents

  module subroutine event_reset_index (event)
    class(event_t), intent(inout) :: event
    call event%expr%reset_event_index ()
  end subroutine event_reset_index

@ %def event_reset_contents
@ %def event_reset_index
@
\subsection{Squared Matrix Element and Weight}
Transfer the result of the process instance calculation to the
event record header.
<<Events: event: TBP>>=
  procedure :: import_instance_results => event_import_instance_results
<<Events: sub interfaces>>=
    module subroutine event_import_instance_results (event)
      class(event_t), intent(inout) :: event
    end subroutine event_import_instance_results
<<Events: procedures>>=
  module subroutine event_import_instance_results (event)
    class(event_t), intent(inout) :: event
    if (associated (event%instance)) then
       if (event%instance%has_evaluated_trace ()) then
          call event%set ( &
               sqme_prc = event%instance%get_sqme (), &
               weight_prc = event%instance%get_weight (), &
               excess_prc = event%instance%get_excess (), &
               n_dropped = event%instance%get_n_dropped () &
               )
       end if
    end if
  end subroutine event_import_instance_results

@ %def event_import_instance_results
@ Duplicate the instance result / the reference result in the event
record.
<<Events: event: TBP>>=
  procedure :: accept_sqme_ref => event_accept_sqme_ref
  procedure :: accept_sqme_prc => event_accept_sqme_prc
  procedure :: accept_weight_ref => event_accept_weight_ref
  procedure :: accept_weight_prc => event_accept_weight_prc
<<Events: sub interfaces>>=
    module subroutine event_accept_sqme_ref (event)
      class(event_t), intent(inout) :: event
    end subroutine event_accept_sqme_ref
    module subroutine event_accept_sqme_prc (event)
      class(event_t), intent(inout) :: event
    end subroutine event_accept_sqme_prc
    module subroutine event_accept_weight_ref (event)
      class(event_t), intent(inout) :: event
    end subroutine event_accept_weight_ref
    module subroutine event_accept_weight_prc (event)
      class(event_t), intent(inout) :: event
    end subroutine event_accept_weight_prc
<<Events: procedures>>=
  module subroutine event_accept_sqme_ref (event)
    class(event_t), intent(inout) :: event
    if (event%sqme_ref_is_known ()) then
       call event%set (sqme_prc = event%get_sqme_ref ())
    end if
  end subroutine event_accept_sqme_ref

  module subroutine event_accept_sqme_prc (event)
    class(event_t), intent(inout) :: event
    if (event%sqme_prc_is_known ()) then
       call event%set (sqme_ref = event%get_sqme_prc ())
    end if
  end subroutine event_accept_sqme_prc

  module subroutine event_accept_weight_ref (event)
    class(event_t), intent(inout) :: event
    if (event%weight_ref_is_known ()) then
       call event%set (weight_prc = event%get_weight_ref ())
    end if
  end subroutine event_accept_weight_ref

  module subroutine event_accept_weight_prc (event)
    class(event_t), intent(inout) :: event
    if (event%weight_prc_is_known ()) then
       call event%set (weight_ref = event%get_weight_prc ())
    end if
  end subroutine event_accept_weight_prc

@ %def event_accept_sqme_ref
@ %def event_accept_sqme_prc
@ %def event_accept_weight_ref
@ %def event_accept_weight_prc
@ Update the weight normalization, just after generation.  Unweighted
and weighted events are generated with a different default
normalization.  The intended normalization is stored in the
configuration record.
<<Events: event: TBP>>=
  procedure :: update_normalization => event_update_normalization
<<Events: sub interfaces>>=
    module subroutine event_update_normalization (event, mode_ref)
      class(event_t), intent(inout) :: event
      integer, intent(in), optional :: mode_ref
    end subroutine event_update_normalization
<<Events: procedures>>=
  module subroutine event_update_normalization (event, mode_ref)
    class(event_t), intent(inout) :: event
    integer, intent(in), optional :: mode_ref
    integer :: mode_old
    real(default) :: weight, excess
    if (present (mode_ref)) then
       mode_old = mode_ref
    else if (event%config%unweighted) then
       mode_old = NORM_UNIT
    else
       mode_old = NORM_SIGMA
    end if
    weight = event%get_weight_prc ()
    call event_normalization_update (weight, &
         event%config%sigma, event%config%n, &
         mode_new = event%config%norm_mode, &
         mode_old = mode_old)
    call event%set_weight_prc (weight)
    excess = event%get_excess_prc ()
    call event_normalization_update (excess, &
         event%config%sigma, event%config%n, &
         mode_new = event%config%norm_mode, &
         mode_old = mode_old)
    call event%set_excess_prc (excess)
  end subroutine event_update_normalization

@ %def event_update_normalization
@
The event is complete if it has a particle set plus valid entries for
the sqme and weight values.
<<Events: event: TBP>>=
  procedure :: check => event_check
<<Events: sub interfaces>>=
    module subroutine event_check (event)
      class(event_t), intent(inout) :: event
    end subroutine event_check
<<Events: procedures>>=
  module subroutine event_check (event)
    class(event_t), intent(inout) :: event
    event%is_complete = event%has_valid_particle_set () &
         .and. event%sqme_ref_is_known () &
         .and. event%sqme_prc_is_known () &
         .and. event%weight_ref_is_known () &
         .and. event%weight_prc_is_known ()
    if (event%get_n_alt () /= 0) then
       event%is_complete = event%is_complete &
            .and. event%sqme_alt_is_known () &
            .and. event%weight_alt_is_known ()
    end if
  end subroutine event_check

@ %def event_check
@
@
\subsection{Generation}
Assuming that we have a valid process associated to the event, we
generate an event.  We complete the event data, then factorize the
spin density matrix and transfer it to the particle set.

When done, we retrieve squared matrix element and weight.  In case of
explicit generation, the reference values coincide with the process
values, so we [[accept]] the latter.

The explicit random number argument [[r]] should be generated by a
random-number generator.  It is taken for the factorization algorithm,
bypassing the event-specific random-number generator.  This is useful
for deterministic testing.
<<Events: event: TBP>>=
  procedure :: generate => event_generate
<<Events: sub interfaces>>=
    module subroutine event_generate (event, i_mci, r, i_nlo)
      class(event_t), intent(inout) :: event
      integer, intent(in) :: i_mci
      real(default), dimension(:), intent(in), optional :: r
      integer, intent(in), optional :: i_nlo
    end subroutine event_generate
<<Events: procedures>>=
  module subroutine event_generate (event, i_mci, r, i_nlo)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: i_mci
    real(default), dimension(:), intent(in), optional :: r
    integer, intent(in), optional :: i_nlo
    logical :: generate_new
    generate_new = .true.
    if (present (i_nlo)) generate_new = (i_nlo == 1)
    if (generate_new) call event%reset_contents ()
    event%selected_i_mci = i_mci
    if (event%config%unweighted) then
       call event%instance%generate_unweighted_event (i_mci)
       if (signal_is_pending ()) return
       call event%instance%evaluate_event_data ()
       call event%instance%normalize_weight ()
    else
       if (generate_new) &
          call event%instance%generate_weighted_event (i_mci)
       if (signal_is_pending ()) return
       call event%instance%evaluate_event_data ()
    end if
    event%selected_channel = event%instance%get_channel ()
    call event%import_instance_results ()
    call event%accept_sqme_prc ()
    call event%update_normalization ()
    call event%accept_weight_prc ()
    call event%evaluate_transforms (r)
    if (signal_is_pending ())  return
    call event%check ()
  end subroutine event_generate

@ %def event_generate
@ Get a copy of the particle set belonging to the hard process.
<<Events: event: TBP>>=
  procedure :: get_hard_particle_set => event_get_hard_particle_set
<<Events: sub interfaces>>=
    module subroutine event_get_hard_particle_set (event, pset)
      class(event_t), intent(in) :: event
      type(particle_set_t), intent(out) :: pset
    end subroutine event_get_hard_particle_set
<<Events: procedures>>=
  module subroutine event_get_hard_particle_set (event, pset)
    class(event_t), intent(in) :: event
    type(particle_set_t), intent(out) :: pset
    class(evt_t), pointer :: evt
    evt => event%transform_first
    pset = evt%particle_set
  end subroutine event_get_hard_particle_set

@ %def event_get_hard_particle_set
@
\subsection{Recovering an event}
Select MC group, term, and integration channel.
<<Events: event: TBP>>=
  procedure :: select => event_select
<<Events: sub interfaces>>=
    module subroutine event_select (event, i_mci, i_term, channel)
      class(event_t), intent(inout) :: event
      integer, intent(in) :: i_mci, i_term, channel
    end subroutine event_select
<<Events: procedures>>=
  module subroutine event_select (event, i_mci, i_term, channel)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: i_mci, i_term, channel
    if (associated (event%instance)) then
       event%selected_i_mci = i_mci
       event%selected_i_term = i_term
       event%selected_channel = channel
    else
       event%selected_i_mci = 0
       event%selected_i_term = 0
       event%selected_channel = 0
    end if
  end subroutine event_select

@ %def event_select
@
Copy a particle set into the event record.

We deliberately use the first (the trivial) transform for this, i.e.,
the hard process.  The event reader may either read in the transformed
event separately, or apply all event
transforms to the hard particle set to (re)generate a fully dressed
event.

Since this makes all subsequent event transforms invalid, we call
[[reset]] on them.
<<Events: event: TBP>>=
  procedure :: set_hard_particle_set => event_set_hard_particle_set
<<Events: sub interfaces>>=
    module subroutine event_set_hard_particle_set (event, particle_set)
      class(event_t), intent(inout) :: event
      type(particle_set_t), intent(in) :: particle_set
    end subroutine event_set_hard_particle_set
<<Events: procedures>>=
  module subroutine event_set_hard_particle_set (event, particle_set)
    class(event_t), intent(inout) :: event
    type(particle_set_t), intent(in) :: particle_set
    class(evt_t), pointer :: evt
    evt => event%transform_first
    call evt%set_particle_set (particle_set, &
         event%selected_i_mci, event%selected_i_term)
    call event%link_particle_set (evt%particle_set)
    evt => evt%next
    do while (associated (evt))
       call evt%reset ()
       evt => evt%next
    end do
  end subroutine event_set_hard_particle_set

@ %def event_set_hard_particle_set
@
Set the $\alpha_s$ value that should be used in a recalculation.  This should
be called only if we explicitly want to override the QCD setting of the
process core.
<<Events: event: TBP>>=
  procedure :: set_alpha_qcd_forced => event_set_alpha_qcd_forced
<<Events: sub interfaces>>=
    module subroutine event_set_alpha_qcd_forced (event, alpha_qcd)
      class(event_t), intent(inout) :: event
      real(default), intent(in) :: alpha_qcd
    end subroutine event_set_alpha_qcd_forced
<<Events: procedures>>=
  module subroutine event_set_alpha_qcd_forced (event, alpha_qcd)
    class(event_t), intent(inout) :: event
    real(default), intent(in) :: alpha_qcd
    if (allocated (event%alpha_qcd_forced)) then
       event%alpha_qcd_forced = alpha_qcd
    else
       allocate (event%alpha_qcd_forced, source = alpha_qcd)
    end if
  end subroutine event_set_alpha_qcd_forced

@ %def event_set_alpha_qcd_forced
@
Analogously, for the common scale.  This forces also renormalization and
factorization scale.
<<Events: event: TBP>>=
  procedure :: set_scale_forced => event_set_scale_forced
<<Events: sub interfaces>>=
    module subroutine event_set_scale_forced (event, scale)
      class(event_t), intent(inout) :: event
      real(default), intent(in) :: scale
    end subroutine event_set_scale_forced
<<Events: procedures>>=
  module subroutine event_set_scale_forced (event, scale)
    class(event_t), intent(inout) :: event
    real(default), intent(in) :: scale
    if (allocated (event%scale_forced)) then
       event%scale_forced = scale
    else
       allocate (event%scale_forced, source = scale)
    end if
  end subroutine event_set_scale_forced

@ %def event_set_scale_forced
@
Here we try to recover an event from the [[particle_set]] subobject
and recalculate the structure functions and matrix elements.  We
have the appropriate [[process]] object and an initialized
[[process_instance]] at hand, so beam and configuration data are
known.  From the [[particle_set]], we get the momenta.

The quantum-number information may be incomplete, e.g., helicity
information may be partial or absent.  We recover the event just from
the momentum configuration.

We do not transfer the matrix element from the process instance to the
event record, as we do when generating an event.  The event record may
contain the matrix element as read from file, and the current
calculation may use different parameters.  We thus can compare old and
new values.

The event [[weight]] may also be known already.  If yes, we pass it to the
[[evaluate_event_data]] procedure.  It should already be normalized.  If we
have a [[weight_factor]] value, we obtain the event weight by multiplying the
computed [[sqme]] by this factor.  Otherwise, we make use of the MCI setup
(which should be valid then) to compute the event weight, and we should
normalize the result just as when generating events.

Evaluating event expressions must also be done separately.

If [[recover_phs]] is set (and false), do not attempt any phase-space
calculation, including MCI evaluation.  Useful if we need only matrix elements.
<<Events: event: TBP>>=
  procedure :: recalculate => event_recalculate
<<Events: sub interfaces>>=
    module subroutine event_recalculate (event, update_sqme, weight_factor, &
         recover_beams, recover_phs, check_match, success)
      class(event_t), intent(inout) :: event
      logical, intent(in) :: update_sqme
      real(default), intent(in), optional :: weight_factor
      logical, intent(in), optional :: recover_beams
      logical, intent(in), optional :: recover_phs
      logical, intent(in), optional :: check_match
      logical, intent(out), optional :: success
    end subroutine event_recalculate
<<Events: procedures>>=
  module subroutine event_recalculate (event, update_sqme, weight_factor, &
       recover_beams, recover_phs, check_match, success)
    class(event_t), intent(inout) :: event
    logical, intent(in) :: update_sqme
    real(default), intent(in), optional :: weight_factor
    logical, intent(in), optional :: recover_beams
    logical, intent(in), optional :: recover_phs
    logical, intent(in), optional :: check_match
    logical, intent(out), optional :: success
    type(particle_set_t), pointer :: particle_set
    integer :: i_mci, i_term, channel
    logical :: rec_phs_mci
    rec_phs_mci = .true.;  if (present (recover_phs))  rec_phs_mci = recover_phs
    if (present (success))  success = .false.
    if (event%has_valid_particle_set ()) then
       particle_set => event%get_particle_set_ptr ()
       i_mci = event%selected_i_mci
       i_term = event%selected_i_term
       channel = event%selected_channel
       if (i_mci == 0 .or. i_term == 0 .or. channel == 0) then
          call msg_bug ("Event: recalculate: undefined selection parameters")
       end if
       call event%instance%choose_mci (i_mci)
       call event%instance%set_trace &
            (particle_set, i_term, recover_beams, check_match, success)
       if (present (success)) then
          if (.not. success)  return
       end if
       if (allocated (event%alpha_qcd_forced)) then
          call event%instance%set_alpha_qcd_forced &
               (i_term, event%alpha_qcd_forced)
       end if
       call event%instance%recover (channel, i_term, &
            update_sqme, rec_phs_mci, event%scale_forced)
       if (signal_is_pending ())  return
       if (update_sqme .and. present (weight_factor)) then
          call event%instance%evaluate_event_data &
               (weight = event%instance%get_sqme () * weight_factor)
       else if (event%weight_ref_is_known ()) then
          call event%instance%evaluate_event_data &
               (weight = event%get_weight_ref ())
       else if (rec_phs_mci) then
          call event%instance%recover_event ()
          if (signal_is_pending ())  return
          call event%instance%evaluate_event_data ()
          if (event%config%unweighted) then
             call event%instance%normalize_weight ()
          end if
       end if
       if (signal_is_pending ())  return
       if (update_sqme) then
          call event%import_instance_results ()
       else
          call event%accept_sqme_ref ()
          call event%accept_weight_ref ()
       end if
    else
       call msg_bug ("Event: can't recalculate, particle set is undefined")
    end if
  end subroutine event_recalculate

@ %def event_recalculate
@
\subsection{Access content}
Pointer to the associated process object (the associated model).
<<Events: event: TBP>>=
  procedure :: get_process_ptr => event_get_process_ptr
  procedure :: get_process_instance_ptr => event_get_process_instance_ptr
  procedure :: get_model_ptr => event_get_model_ptr
<<Events: sub interfaces>>=
    module function event_get_process_ptr (event) result (ptr)
      class(event_t), intent(in) :: event
      type(process_t), pointer :: ptr
    end function event_get_process_ptr
    module function event_get_process_instance_ptr (event) result (ptr)
      class(event_t), intent(in) :: event
      type(process_instance_t), pointer :: ptr
    end function event_get_process_instance_ptr
    module function event_get_model_ptr (event) result (model)
      class(event_t), intent(in) :: event
      class(model_data_t), pointer :: model
    end function event_get_model_ptr
<<Events: procedures>>=
  module function event_get_process_ptr (event) result (ptr)
    class(event_t), intent(in) :: event
    type(process_t), pointer :: ptr
    ptr => event%process
  end function event_get_process_ptr

  module function event_get_process_instance_ptr (event) result (ptr)
    class(event_t), intent(in) :: event
    type(process_instance_t), pointer :: ptr
    ptr => event%instance
  end function event_get_process_instance_ptr

  module function event_get_model_ptr (event) result (model)
    class(event_t), intent(in) :: event
    class(model_data_t), pointer :: model
    if (associated (event%process)) then
       model => event%process%get_model_ptr ()
    else
       model => null ()
    end if
  end function event_get_model_ptr

@ %def event_get_process_ptr
@ %def event_get_process_instance_ptr
@ %def event_get_model_ptr
@ Return the current values of indices: the MCI group of components, the term
index (different terms corresponding, potentially, to different effective
kinematics), and the MC integration channel.  The [[i_mci]] call is delegated
to the current process instance.
<<Events: event: TBP>>=
  procedure :: get_i_mci => event_get_i_mci
  procedure :: get_i_term => event_get_i_term
  procedure :: get_channel => event_get_channel
<<Events: sub interfaces>>=
    module function event_get_i_mci (event) result (i_mci)
      class(event_t), intent(in) :: event
      integer :: i_mci
    end function event_get_i_mci
    module function event_get_i_term (event) result (i_term)
      class(event_t), intent(in) :: event
      integer :: i_term
    end function event_get_i_term
    module function event_get_channel (event) result (channel)
      class(event_t), intent(in) :: event
      integer :: channel
    end function event_get_channel
<<Events: procedures>>=
  module function event_get_i_mci (event) result (i_mci)
    class(event_t), intent(in) :: event
    integer :: i_mci
    i_mci = event%selected_i_mci
  end function event_get_i_mci

  module function event_get_i_term (event) result (i_term)
    class(event_t), intent(in) :: event
    integer :: i_term
    i_term = event%selected_i_term
  end function event_get_i_term

  module function event_get_channel (event) result (channel)
    class(event_t), intent(in) :: event
    integer :: channel
    channel = event%selected_channel
  end function event_get_channel

@ %def event_get_i_mci
@ %def event_get_i_term
@ %def event_get_channel
@ This flag tells us whether the event consists just of a hard process
(i.e., holds at most the first, trivial transform), or is a dressed
events with additional transforms.
<<Events: event: TBP>>=
  procedure :: has_transform => event_has_transform
<<Events: sub interfaces>>=
    module function event_has_transform (event) result (flag)
      class(event_t), intent(in) :: event
      logical :: flag
    end function event_has_transform
<<Events: procedures>>=
  module function event_has_transform (event) result (flag)
    class(event_t), intent(in) :: event
    logical :: flag
    if (associated (event%transform_first)) then
       flag = associated (event%transform_first%next)
    else
       flag = .false.
    end if
  end function event_has_transform

@ %def event_has_transform
@ Return the currently selected normalization mode, or alternate
normalization mode.
<<Events: event: TBP>>=
  procedure :: get_norm_mode => event_get_norm_mode
<<Events: sub interfaces>>=
    elemental module function event_get_norm_mode (event) result (norm_mode)
      class(event_t), intent(in) :: event
      integer :: norm_mode
    end function event_get_norm_mode
<<Events: procedures>>=
  elemental module function event_get_norm_mode (event) result (norm_mode)
    class(event_t), intent(in) :: event
    integer :: norm_mode
    norm_mode = event%config%norm_mode
  end function event_get_norm_mode

@ %def event_get_norm_mode
@ Return the kinematical weight, defined as the ratio of event weight
and squared matrix element.
<<Events: event: TBP>>=
  procedure :: get_kinematical_weight => event_get_kinematical_weight
<<Events: sub interfaces>>=
    module function event_get_kinematical_weight (event) result (f)
      class(event_t), intent(in) :: event
      real(default) :: f
    end function event_get_kinematical_weight
<<Events: procedures>>=
  module function event_get_kinematical_weight (event) result (f)
    class(event_t), intent(in) :: event
    real(default) :: f
    if (event%sqme_ref_is_known () .and. event%weight_ref_is_known () &
         .and. abs (event%get_sqme_ref ()) > 0) then
       f = event%get_weight_ref () / event%get_sqme_ref ()
    else
       f = 0
    end if
  end function event_get_kinematical_weight

@ %def event_get_kinematical_weight
@ Return data used by external event formats.
<<Events: event: TBP>>=
  procedure :: has_index => event_has_index
  procedure :: get_index => event_get_index
  procedure :: get_fac_scale => event_get_fac_scale
  procedure :: get_alpha_s => event_get_alpha_s
  procedure :: get_sqrts => event_get_sqrts
  procedure :: get_polarization => event_get_polarization
  procedure :: get_beam_file => event_get_beam_file
  procedure :: get_process_name => event_get_process_name
<<Events: sub interfaces>>=
    module function event_has_index (event) result (flag)
      class(event_t), intent(in) :: event
      logical :: flag
    end function event_has_index
    module function event_get_index (event) result (index)
      class(event_t), intent(in) :: event
      integer :: index
    end function event_get_index
    module function event_get_fac_scale (event) result (fac_scale)
      class(event_t), intent(in) :: event
      real(default) :: fac_scale
    end function event_get_fac_scale
    module function event_get_alpha_s (event) result (alpha_s)
      class(event_t), intent(in) :: event
      real(default) :: alpha_s
    end function event_get_alpha_s
    module function event_get_sqrts (event) result (sqrts)
      class(event_t), intent(in) :: event
      real(default) :: sqrts
    end function event_get_sqrts
    module function event_get_polarization (event) result (pol)
      class(event_t), intent(in) :: event
      real(default), dimension(:), allocatable :: pol
    end function event_get_polarization
    module function event_get_beam_file (event) result (file)
      class(event_t), intent(in) :: event
      type(string_t) :: file
    end function event_get_beam_file
    module function event_get_process_name (event) result (name)
      class(event_t), intent(in) :: event
      type(string_t) :: name
    end function event_get_process_name
<<Events: procedures>>=
  module function event_has_index (event) result (flag)
    class(event_t), intent(in) :: event
    logical :: flag
    flag = event%expr%has_event_index ()
  end function event_has_index

  module function event_get_index (event) result (index)
    class(event_t), intent(in) :: event
    integer :: index
    index = event%expr%get_event_index ()
  end function event_get_index

  module function event_get_fac_scale (event) result (fac_scale)
    class(event_t), intent(in) :: event
    real(default) :: fac_scale
    fac_scale = event%instance%get_fac_scale (event%selected_i_term)
  end function event_get_fac_scale

  module function event_get_alpha_s (event) result (alpha_s)
    class(event_t), intent(in) :: event
    real(default) :: alpha_s
    alpha_s = event%instance%get_alpha_s (event%selected_i_term)
  end function event_get_alpha_s

  module function event_get_sqrts (event) result (sqrts)
    class(event_t), intent(in) :: event
    real(default) :: sqrts
    sqrts = event%instance%get_sqrts ()
  end function event_get_sqrts

  module function event_get_polarization (event) result (pol)
    class(event_t), intent(in) :: event
    real(default), dimension(:), allocatable :: pol
    pol = event%instance%get_polarization ()
  end function event_get_polarization

  module function event_get_beam_file (event) result (file)
    class(event_t), intent(in) :: event
    type(string_t) :: file
    file = event%instance%get_beam_file ()
  end function event_get_beam_file

  module function event_get_process_name (event) result (name)
    class(event_t), intent(in) :: event
    type(string_t) :: name
    name = event%instance%get_process_name ()
  end function event_get_process_name

@ %def event_get_index
@ %def event_get_fac_scale
@ %def event_get_alpha_s
@ %def event_get_sqrts
@ %def event_get_polarization
@ %def event_get_beam_file
@ %def event_get_process_name
@ Return the actual number of calls, as stored in the process instance.
<<Events: event: TBP>>=
  procedure :: get_actual_calls_total => event_get_actual_calls_total
<<Events: sub interfaces>>=
    elemental module function event_get_actual_calls_total (event) result (n)
      class(event_t), intent(in) :: event
      integer :: n
    end function event_get_actual_calls_total
<<Events: procedures>>=
  elemental module function event_get_actual_calls_total (event) result (n)
    class(event_t), intent(in) :: event
    integer :: n
    if (associated (event%instance)) then
       n = event%instance%get_actual_calls_total ()
    else
       n = 0
    end if
  end function event_get_actual_calls_total

@ %def event_get_actual_calls_total
@
Eliminate numerical noise in the [[subevt]] expression and in the event
transforms (which includes associated process instances).
<<Events: public>>=
  public :: pacify
<<Events: interfaces>>=
  interface pacify
     module procedure pacify_event
  end interface pacify
<<Events: sub interfaces>>=
    module subroutine pacify_event (event)
      class(event_t), intent(inout) :: event
      class(evt_t), pointer :: evt
    end subroutine pacify_event
<<Events: procedures>>=
  module subroutine pacify_event (event)
    class(event_t), intent(inout) :: event
    class(evt_t), pointer :: evt
    call event%pacify_particle_set ()
    if (event%expr%subevt_filled)  call pacify (event%expr)
    evt => event%transform_first
    do while (associated (evt))
       select type (evt)
       type is (evt_decay_t);  call pacify (evt)
       end select
       evt => evt%next
    end do
  end subroutine pacify_event

@ %def pacify
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[events_ut.f90]]>>=
<<File header>>

module events_ut
  use unit_tests
  use events_uti

<<Standard module head>>

<<Events: public test>>

contains

<<Events: test driver>>

end module events_ut
@ %def events_ut
@
<<[[events_uti.f90]]>>=
<<File header>>

module events_uti

<<Use kinds>>
<<Use strings>>
  use os_interface
  use model_data
  use particles
  use process_libraries
  use process_stacks
  use event_transforms
  use decays
  use decays_ut, only: prepare_testbed

  use process, only: process_t
  use instances, only: process_instance_t

  use events

<<Standard module head>>

<<Events: test declarations>>

contains

<<Events: tests>>

end module events_uti

@ %def events_uti
@ API: driver for the unit tests below.
<<Events: public test>>=
  public :: events_test
<<Events: test driver>>=
  subroutine events_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Events: execute tests>>
  end subroutine events_test

@ %def events_test
@
\subsubsection{Empty event record}
<<Events: execute tests>>=
  call test (events_1, "events_1", &
       "empty event record", &
       u, results)
<<Events: test declarations>>=
  public :: events_1
<<Events: tests>>=
  subroutine events_1 (u)
    integer, intent(in) :: u
    type(event_t), target :: event

    write (u, "(A)")  "* Test output: events_1"
    write (u, "(A)")  "*   Purpose: display an empty event object"
    write (u, "(A)")

    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_1"

  end subroutine events_1

@ %def events_1
@
\subsubsection{Simple event}
<<Events: execute tests>>=
  call test (events_2, "events_2", &
       "generate event", &
       u, results)
<<Events: test declarations>>=
  public :: events_2
<<Events: tests>>=
  subroutine events_2 (u)
    use processes_ut, only: prepare_test_process, cleanup_test_process
    integer, intent(in) :: u
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(model_data_t), target :: model

    write (u, "(A)")  "* Test output: events_2"
    write (u, "(A)")  "*   Purpose: generate and display an event"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Generate test process event"

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event object"

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())

    write (u, "(A)")
    write (u, "(A)")  "* Generate test process event"

    call process_instance%generate_weighted_event (1)

    write (u, "(A)")
    write (u, "(A)")  "* Fill event object"
    write (u, "(A)")

    call event%generate (1, [0.4_default, 0.4_default])
    call event%increment_index ()
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_2"

  end subroutine events_2

@ %def events_2
@
\subsubsection{Recovering an event}
Generate an event and store the particle set.  Then reset the event
record, recall the particle set, and recover the event from that.
<<Events: execute tests>>=
  call test (events_4, "events_4", &
       "recover event", &
       u, results)
<<Events: test declarations>>=
  public :: events_4
<<Events: tests>>=
  subroutine events_4 (u)
    use processes_ut, only: prepare_test_process, cleanup_test_process
    integer, intent(in) :: u
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(process_t), allocatable, target :: process2
    type(process_instance_t), allocatable, target :: process2_instance
    type(particle_set_t) :: particle_set
    type(model_data_t), target :: model

    write (u, "(A)")  "* Test output: events_4"
    write (u, "(A)")  "*   Purpose: generate and recover an event"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Generate test process event and save particle set"
    write (u, "(A)")

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())

    call event%generate (1, [0.4_default, 0.4_default])
    call event%increment_index ()
    call event%evaluate_expressions ()
    call event%write (u)

    particle_set = event%get_particle_set_ptr ()
    ! NB: 'particle_set' contains pointers to the model within 'process'

    call event%final ()
    deallocate (event)

    write (u, "(A)")
    write (u, "(A)")  "* Recover event from particle set"
    write (u, "(A)")

    allocate (process2)
    allocate (process2_instance)
    call prepare_test_process (process2, process2_instance, model)
    call process2_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process2_instance, process2%get_model_ptr ())

    call event%select (1, 1, 1)
    call event%set_hard_particle_set (particle_set)
    call event%recalculate (update_sqme = .true.)
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Transfer sqme and evaluate expressions"
    write (u, "(A)")

    call event%accept_sqme_prc ()
    call event%accept_weight_prc ()
    call event%check ()
    call event%set_index (1)
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Reset contents"
    write (u, "(A)")

    call event%reset_contents ()
    call event%reset_index ()
    event%transform_first%particle_set_exists = .false.
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call particle_set%final ()

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process2, process2_instance)
    deallocate (process2_instance)
    deallocate (process2)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_4"

  end subroutine events_4

@ %def events_4
@
\subsubsection{Partially Recovering an event}
Generate an event and store the particle set.  Then reset the event
record, recall the particle set, and recover the event as far as possible
without recomputing the squared matrix element.
<<Events: execute tests>>=
  call test (events_5, "events_5", &
       "partially recover event", &
       u, results)
<<Events: test declarations>>=
  public :: events_5
<<Events: tests>>=
  subroutine events_5 (u)
    use processes_ut, only: prepare_test_process, cleanup_test_process
    integer, intent(in) :: u
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(process_t), allocatable, target :: process2
    type(process_instance_t), allocatable, target :: process2_instance
    type(particle_set_t) :: particle_set
    real(default) :: sqme, weight
    type(model_data_t), target :: model

    write (u, "(A)")  "* Test output: events_5"
    write (u, "(A)")  "*   Purpose: generate and recover an event"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Generate test process event and save particle set"
    write (u, "(A)")

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())

    call event%generate (1, [0.4_default, 0.4_default])
    call event%increment_index ()
    call event%evaluate_expressions ()
    call event%write (u)

    particle_set = event%get_particle_set_ptr ()
    sqme = event%get_sqme_ref ()
    weight = event%get_weight_ref ()

    call event%final ()
    deallocate (event)

    write (u, "(A)")
    write (u, "(A)")  "* Recover event from particle set"
    write (u, "(A)")

    allocate (process2)
    allocate (process2_instance)
    call prepare_test_process (process2, process2_instance, model)
    call process2_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process2_instance, process2%get_model_ptr ())

    call event%select (1, 1, 1)
    call event%set_hard_particle_set (particle_set)
    call event%recalculate (update_sqme = .false.)
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Manually set sqme and evaluate expressions"
    write (u, "(A)")

    call event%set (sqme_ref = sqme, weight_ref = weight)
    call event%accept_sqme_ref ()
    call event%accept_weight_ref ()
    call event%set_index (1)
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call particle_set%final ()

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process2, process2_instance)
    deallocate (process2_instance)
    deallocate (process2)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_5"

  end subroutine events_5

@ %def events_5
@
\subsubsection{Decays}
Generate an event with subsequent decays.
<<Events: execute tests>>=
  call test (events_6, "events_6", &
       "decays", &
       u, results)
<<Events: test declarations>>=
  public :: events_6
<<Events: tests>>=
  subroutine events_6 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(string_t) :: prefix, procname1, procname2
    type(process_library_t), target :: lib
    type(process_stack_t) :: process_stack
    class(evt_t), pointer :: evt_decay
    type(event_t), allocatable, target :: event
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: events_6"
    write (u, "(A)")  "*   Purpose: generate an event with subsequent decays"
    write (u, "(A)")

    write (u, "(A)")  "* Generate test process and decay"
    write (u, "(A)")

    call os_data%init ()

    prefix = "events_6"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.true., decay=.true.)

    write (u, "(A)")  "* Initialize decay process"

    process => process_stack%get_process_ptr (procname1)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2])

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event transform: decay"

    allocate (evt_decay_t :: evt_decay)
    call evt_decay%connect (process_instance, model, process_stack)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event object"
    write (u, "(A)")

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, model)
    call event%import_transform (evt_decay)

    call event%write (u, show_decay = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Generate event"
    write (u, "(A)")

    call event%generate (1, [0.4_default, 0.4_default])
    call event%increment_index ()
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call event%final ()
    deallocate (event)

    call process_instance%final ()
    deallocate (process_instance)

    call process_stack%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_6"

  end subroutine events_6

@ %def events_6
@
\subsubsection{Decays}
Generate a decay event with varying options.
<<Events: execute tests>>=
  call test (events_7, "events_7", &
       "decay options", &
       u, results)
<<Events: test declarations>>=
  public :: events_7
<<Events: tests>>=
  subroutine events_7 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(string_t) :: prefix, procname2
    type(process_library_t), target :: lib
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: events_7"
    write (u, "(A)")  "*   Purpose: check decay options"
    write (u, "(A)")

    write (u, "(A)")  "* Prepare test process"
    write (u, "(A)")

    call os_data%init ()

    prefix = "events_7"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.false., decay=.true.)

    write (u, "(A)")  "* Generate decay event, default options"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2])

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data (model)
    call process_instance%init_simulation (1)

    call process_instance%generate_weighted_event (1)
    call process_instance%write (u)

    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Generate decay event, helicity-diagonal decay"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2], diagonal = .true.)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data (model)
    call process_instance%init_simulation (1)

    call process_instance%generate_weighted_event (1)
    call process_instance%write (u)

    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Generate decay event, isotropic decay, &
         &polarized final state"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2], isotropic = .true.)
    call model%set_polarized (6)
    call model%set_polarized (-6)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data (model)
    call process_instance%init_simulation (1)

    call process_instance%generate_weighted_event (1)
    call process_instance%write (u)

    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call process_stack%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_7"

  end subroutine events_7

@ %def events_7
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Raw Event I/O}
The raw format is for internal use only.  All data are stored
unformatted, so they can be efficiently be re-read on the same
machine, but not necessarily on another machine.

This module explicitly depends on the [[events]] module which provides the
concrete implementation of [[event_base]].  The other I/O formats
access only the methods that are defined in [[event_base]].
<<[[eio_raw.f90]]>>=
<<File header>>

module eio_raw

<<Use kinds>>
<<Use strings>>
  use event_base
  use event_handles, only: event_handle_t
  use eio_data
  use eio_base
  use events

<<Standard module head>>

<<EIO raw: public>>

<<EIO raw: parameters>>

<<EIO raw: types>>

  interface
<<EIO raw: sub interfaces>>
  end interface

end module eio_raw
@ %def eio_raw
@
<<[[eio_raw_sub.f90]]>>=
<<File header>>

submodule (eio_raw) eio_raw_s

  use io_units
  use diagnostics
  use model_data
  use particles

  implicit none

contains

<<EIO raw: procedures>>

end submodule eio_raw_s

@ %def eio_raw_s
@
\subsection{File Format Version}
This is the current default file version.
<<EIO raw: parameters>>=
  integer, parameter :: CURRENT_FILE_VERSION = 2

@ %def CURRENT_FILE_VERSION
@ The user may change this number; this should force some
compatibility mode for reading and writing.  In any case, the file
version stored in a event file that we read has to match the expected
file version.

History of version numbers:
\begin{enumerate}
\item
  Format for WHIZARD 2.2.0 to 2.2.3.  No version number stored in the raw file.
\item
  Format from 2.2.4 on.  File contains version number.  The file
  contains the transformed particle set (if applicable) after the
  hard-process particle set.
\end{enumerate}
@
\subsection{Type}
Note the file version number.  The default may be reset during
initialization, which should enforce some compatibility mode.
<<EIO raw: public>>=
  public :: eio_raw_t
<<EIO raw: types>>=
  type, extends (eio_t) :: eio_raw_t
     logical :: reading = .false.
     logical :: writing = .false.
     integer :: unit = 0
     integer :: norm_mode = NORM_UNDEFINED
     real(default) :: sigma = 1
     integer :: n = 1
     integer :: n_alt = 0
     logical :: check = .false.
     logical :: use_alphas_from_file = .false.
     logical :: use_scale_from_file = .false.
     logical :: fixed_order_nlo = .false.
     integer :: file_version = CURRENT_FILE_VERSION
   contains
   <<EIO raw: eio raw: TBP>>
  end type eio_raw_t

@ %def eio_raw_t
@ Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO raw: eio raw: TBP>>=
  procedure :: write => eio_raw_write
<<EIO raw: sub interfaces>>=
    module subroutine eio_raw_write (object, unit)
      class(eio_raw_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine eio_raw_write
<<EIO raw: procedures>>=
  module subroutine eio_raw_write (object, unit)
    class(eio_raw_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Raw event stream:"
    write (u, "(3x,A,L1)")  "Check MD5 sum     = ", object%check
    if (object%n_alt > 0) then
       write (u, "(3x,A,I0)")  "Alternate weights = ", object%n_alt
    end if
    write (u, "(3x,A,L1)")    "Alpha_s from file = ", &
         object%use_alphas_from_file
    write (u, "(3x,A,L1)")    "Scale from file   = ", &
         object%use_scale_from_file
    write (u, "(3x,A,L1)")    "Events for fNLO   = ", &
         object%fixed_order_nlo
    if (object%reading) then
       write (u, "(3x,A,A)")  "Reading from file = ", char (object%filename)
    else if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
  end subroutine eio_raw_write

@ %def eio_raw_write
@ Finalizer: close any open file.
<<EIO raw: eio raw: TBP>>=
  procedure :: final => eio_raw_final
<<EIO raw: sub interfaces>>=
    module subroutine eio_raw_final (object)
      class(eio_raw_t), intent(inout) :: object
    end subroutine eio_raw_final
<<EIO raw: procedures>>=
  module subroutine eio_raw_final (object)
    class(eio_raw_t), intent(inout) :: object
    if (object%reading .or. object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing raw file '", &
            char (object%filename), "'"
       call msg_message ()
       close (object%unit)
       object%reading = .false.
       object%writing = .false.
    end if
  end subroutine eio_raw_final

@ %def eio_raw_final
@ Set the [[check]] flag which determines whether we compare checksums on input.
<<EIO raw: eio raw: TBP>>=
  procedure :: set_parameters => eio_raw_set_parameters
<<EIO raw: sub interfaces>>=
    module subroutine eio_raw_set_parameters (eio, check, &
         use_alphas_from_file, use_scale_from_file, fixed_order_nlo, &
         version_string, extension)
      class(eio_raw_t), intent(inout) :: eio
      logical, intent(in), optional :: check, use_alphas_from_file, &
           use_scale_from_file, fixed_order_nlo
      type(string_t), intent(in), optional :: version_string
      type(string_t), intent(in), optional :: extension
    end subroutine eio_raw_set_parameters
<<EIO raw: procedures>>=
  module subroutine eio_raw_set_parameters (eio, check, use_alphas_from_file, &
       use_scale_from_file, fixed_order_nlo, version_string, extension)
    class(eio_raw_t), intent(inout) :: eio
    logical, intent(in), optional :: check, use_alphas_from_file, &
         use_scale_from_file, fixed_order_nlo
    type(string_t), intent(in), optional :: version_string
    type(string_t), intent(in), optional :: extension
    if (present (check))  eio%check = check
    if (present (use_alphas_from_file))  eio%use_alphas_from_file = &
         use_alphas_from_file
    if (present (use_scale_from_file))  eio%use_scale_from_file = &
         use_scale_from_file
    if (present (fixed_order_nlo))  eio%fixed_order_nlo = &
         fixed_order_nlo
    if (present (version_string)) then
       select case (char (version_string))
       case ("", "2.2.4")
          eio%file_version = CURRENT_FILE_VERSION
       case ("2.2")
          eio%file_version = 1
       case default
          call msg_fatal ("Raw event I/O: unsupported version '" &
               // char (version_string) // "'")
          eio%file_version = 0
       end select
    end if
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "evx"
    end if
  end subroutine eio_raw_set_parameters

@ %def eio_raw_set_parameters
@ Initialize event writing.
<<EIO raw: eio raw: TBP>>=
  procedure :: init_out => eio_raw_init_out
<<EIO raw: sub interfaces>>=
    module subroutine eio_raw_init_out (eio, sample, data, success, extension)
      class(eio_raw_t), intent(inout) :: eio
      type(string_t), intent(in) :: sample
      type(event_sample_data_t), intent(in), optional :: data
      logical, intent(out), optional :: success
      type(string_t), intent(in), optional :: extension
    end subroutine eio_raw_init_out
<<EIO raw: procedures>>=
  module subroutine eio_raw_init_out (eio, sample, data, success, extension)
    class(eio_raw_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    type(string_t), intent(in), optional :: extension
    character(32) :: md5sum_prc, md5sum_cfg
    character(32), dimension(:), allocatable :: md5sum_alt
    integer :: i
    if (present (extension)) then
       eio%extension  = extension
    else
       eio%extension = "evx"
    end if
    eio%filename = sample // "." // eio%extension
    eio%unit = free_unit ()
    write (msg_buffer, "(A,A,A)")  "Events: writing to raw file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    if (present (data)) then
       md5sum_prc = data%md5sum_prc
       md5sum_cfg = data%md5sum_cfg
       eio%norm_mode = data%norm_mode
       eio%sigma = data%total_cross_section
       eio%n = data%n_evt
       eio%n_alt = data%n_alt
       if (eio%n_alt > 0) then
          !!! !!! !!! Workaround for gfortran 5.0 ICE
          allocate (md5sum_alt (data%n_alt))
          md5sum_alt = data%md5sum_alt
          !!! allocate (md5sum_alt (data%n_alt), source = data%md5sum_alt)
       end if
    else
       md5sum_prc = ""
       md5sum_cfg = ""
    end if
    open (eio%unit, file = char (eio%filename), form = "unformatted", &
         action = "write", status = "replace")
    select case (eio%file_version)
    case (2:);  write (eio%unit)  eio%file_version
    end select
    write (eio%unit)  md5sum_prc
    write (eio%unit)  md5sum_cfg
    write (eio%unit)  eio%norm_mode
    write (eio%unit)  eio%n_alt
    if (allocated (md5sum_alt)) then
       do i = 1, eio%n_alt
          write (eio%unit)  md5sum_alt(i)
       end do
    end if
    if (present (success))  success = .true.
  end subroutine eio_raw_init_out

@ %def eio_raw_init_out
@ Initialize event reading.
<<EIO raw: eio raw: TBP>>=
  procedure :: init_in => eio_raw_init_in
<<EIO raw: sub interfaces>>=
    module subroutine eio_raw_init_in (eio, sample, data, success, extension)
      class(eio_raw_t), intent(inout) :: eio
      type(string_t), intent(in) :: sample
      type(event_sample_data_t), intent(inout), optional :: data
      logical, intent(out), optional :: success
      type(string_t), intent(in), optional :: extension
    end subroutine eio_raw_init_in
<<EIO raw: procedures>>=
  module subroutine eio_raw_init_in (eio, sample, data, success, extension)
    class(eio_raw_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    type(string_t), intent(in), optional :: extension
    character(32) :: md5sum_prc, md5sum_cfg
    character(32), dimension(:), allocatable :: md5sum_alt
    integer :: i, file_version
    if (present (success))  success = .true.
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "evx"
    end if
    eio%filename = sample // "." // eio%extension
    eio%unit = free_unit ()
    if (present (data)) then
       eio%sigma = data%total_cross_section
       eio%n = data%n_evt
    end if
    write (msg_buffer, "(A,A,A)")  "Events: reading from raw file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%reading = .true.
    open (eio%unit, file = char (eio%filename), form = "unformatted", &
         action = "read", status = "old")
    select case (eio%file_version)
    case (2:);  read (eio%unit)  file_version
    case default;  file_version = 1
    end select
    if (file_version /= eio%file_version) then
       call msg_error ("Reading event file: raw-file version mismatch.")
       if (present (success))  success = .false.
       return
    else if (file_version /= CURRENT_FILE_VERSION) then
       call msg_warning ("Reading event file: compatibility mode.")
    end if
    read (eio%unit)  md5sum_prc
    read (eio%unit)  md5sum_cfg
    read (eio%unit)  eio%norm_mode
    read (eio%unit)  eio%n_alt
    if (present (data)) then
       if (eio%n_alt /= data%n_alt) then
          if (present (success))  success = .false.
          return
       end if
    end if
    allocate (md5sum_alt (eio%n_alt))
    do i = 1, eio%n_alt
       read (eio%unit)  md5sum_alt(i)
    end do
    if (present (success)) then
       if (present (data)) then
          if (eio%check) then
             if (data%md5sum_prc /= "") then
                success = success .and. md5sum_prc == data%md5sum_prc
             end if
             if (data%md5sum_cfg /= "") then
                success = success .and. md5sum_cfg == data%md5sum_cfg
             end if
             do i = 1, eio%n_alt
                if (data%md5sum_alt(i) /= "") then
                   success = success .and. md5sum_alt(i) == data%md5sum_alt(i)
                end if
             end do
          else
             call msg_warning ("Reading event file: MD5 sum check disabled")
          end if
       end if
    end if
  end subroutine eio_raw_init_in

@ %def eio_raw_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO raw: eio raw: TBP>>=
  procedure :: switch_inout => eio_raw_switch_inout
<<EIO raw: sub interfaces>>=
    module subroutine eio_raw_switch_inout (eio, success)
      class(eio_raw_t), intent(inout) :: eio
      logical, intent(out), optional :: success
    end subroutine eio_raw_switch_inout
<<EIO raw: procedures>>=
  module subroutine eio_raw_switch_inout (eio, success)
    class(eio_raw_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    write (msg_buffer, "(A,A,A)")  "Events: appending to raw file '", &
         char (eio%filename), "'"
    call msg_message ()
    close (eio%unit, status = "keep")
    eio%reading = .false.
    open (eio%unit, file = char (eio%filename), form = "unformatted", &
         action = "write", position = "append", status = "old")
    eio%writing = .true.
    if (present (success))  success = .true.
  end subroutine eio_raw_switch_inout

@ %def eio_raw_switch_inout
@ Output an event.  Write first the event indices, then weight and
squared matrix element, then the particle set.

We always write the particle set of the hard process.  (Note: this
should be reconsidered.)  We do make a physical copy.

On output, we write the [[prc]] values for weight and sqme, since
these are the values just computed.  On input, we store the values as
[[ref]] values.  The caller can then decide whether to recompute
values and thus obtain distinct [[prc]] values, or just accept them.

The [[passed]] flag is not written.  This allow us to apply different
selection criteria upon rereading.
<<EIO raw: eio raw: TBP>>=
  procedure :: output => eio_raw_output
<<EIO raw: sub interfaces>>=
    module subroutine eio_raw_output &
         (eio, event, i_prc, reading, passed, pacify, event_handle)
      class(eio_raw_t), intent(inout) :: eio
      class(generic_event_t), intent(in), target :: event
      logical, intent(in), optional :: reading, passed, pacify
      class(event_handle_t), intent(inout), optional :: event_handle
      integer, intent(in) :: i_prc
    end subroutine eio_raw_output
<<EIO raw: procedures>>=
  module subroutine eio_raw_output &
       (eio, event, i_prc, reading, passed, pacify, event_handle)
    class(eio_raw_t), intent(inout) :: eio
    class(generic_event_t), intent(in), target :: event
    logical, intent(in), optional :: reading, passed, pacify
    class(event_handle_t), intent(inout), optional :: event_handle
    integer, intent(in) :: i_prc
    type(particle_set_t), pointer :: pset
    integer :: i
    if (eio%writing) then
       if (event%has_valid_particle_set ()) then
          select type (event)
          type is (event_t)
             write (eio%unit)  i_prc
             write (eio%unit)  event%get_index ()
             write (eio%unit)  event%get_i_mci ()
             write (eio%unit)  event%get_i_term ()
             write (eio%unit)  event%get_channel ()
             write (eio%unit)  event%expr%weight_prc
             write (eio%unit)  event%expr%excess_prc
             write (eio%unit)  event%get_n_dropped ()
             write (eio%unit)  event%expr%sqme_prc
             do i = 1, eio%n_alt
                write (eio%unit)  event%expr%weight_alt(i)
                write (eio%unit)  event%expr%sqme_alt(i)
             end do
             allocate (pset)
             call event%get_hard_particle_set (pset)
             call pset%write_raw (eio%unit)
             call pset%final ()
             deallocate (pset)
             select case (eio%file_version)
             case (2:)
                if (event%has_transform ()) then
                   write (eio%unit)  .true.
                   pset => event%get_particle_set_ptr ()
                   call pset%write_raw (eio%unit)
                else
                   write (eio%unit)  .false.
                end if
             end select
          class default
             call msg_bug ("Event: write raw: defined only for full event_t")
          end select
       else
          call msg_bug ("Event: write raw: particle set is undefined")
       end if
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for writing")
    end if
  end subroutine eio_raw_output

@ %def eio_raw_output
@ Input an event.

Note: the particle set is physically copied.  If there is a
performance issue, we might choose to pointer-assign it instead, with
a different version of [[event%set_hard_particle_set]].
<<EIO raw: eio raw: TBP>>=
  procedure :: input_i_prc => eio_raw_input_i_prc
  procedure :: input_event => eio_raw_input_event
<<EIO raw: sub interfaces>>=
    module subroutine eio_raw_input_i_prc (eio, i_prc, iostat)
      class(eio_raw_t), intent(inout) :: eio
      integer, intent(out) :: i_prc
      integer, intent(out) :: iostat
    end subroutine eio_raw_input_i_prc
    module subroutine eio_raw_input_event (eio, event, iostat, event_handle)
      class(eio_raw_t), intent(inout) :: eio
      class(generic_event_t), intent(inout), target :: event
      integer, intent(out) :: iostat
      class(event_handle_t), intent(inout), optional :: event_handle
    end subroutine eio_raw_input_event
<<EIO raw: procedures>>=
  module subroutine eio_raw_input_i_prc (eio, i_prc, iostat)
    class(eio_raw_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    if (eio%reading) then
       read (eio%unit, iostat = iostat)  i_prc
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for reading")
    end if
  end subroutine eio_raw_input_i_prc

  module subroutine eio_raw_input_event (eio, event, iostat, event_handle)
    class(eio_raw_t), intent(inout) :: eio
    class(generic_event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    class(event_handle_t), intent(inout), optional :: event_handle
    integer :: event_index, i_mci, i_term, channel, i
    real(default) :: weight, excess, sqme
    integer :: n_dropped
    real(default), dimension(:), allocatable :: weight_alt, sqme_alt
    logical :: has_transform
    type(particle_set_t), pointer :: pset
    class(model_data_t), pointer :: model
    if (eio%reading) then
       select type (event)
       type is (event_t)
          read (eio%unit, iostat = iostat)  event_index
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  i_mci
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  i_term
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  channel
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  weight
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  excess
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  n_dropped
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  sqme
          if (iostat /= 0)  return
          call event%reset_contents ()
          call event%set_index (event_index)
          call event%select (i_mci, i_term, channel)
          if (eio%norm_mode /= NORM_UNDEFINED) then
             call event_normalization_update (weight, &
                  eio%sigma, eio%n, event%get_norm_mode (), eio%norm_mode)
             call event_normalization_update (excess, &
                  eio%sigma, eio%n, event%get_norm_mode (), eio%norm_mode)
          end if
          call event%set (sqme_ref = sqme, weight_ref = weight, &
               excess_prc = excess, &
               n_dropped = n_dropped)
          if (eio%n_alt /= 0) then
             allocate (sqme_alt (eio%n_alt), weight_alt (eio%n_alt))
             do i = 1, eio%n_alt
                read (eio%unit, iostat = iostat)  weight_alt(i)
                if (iostat /= 0)  return
                read (eio%unit, iostat = iostat)  sqme_alt(i)
                if (iostat /= 0)  return
             end do
             call event%set (sqme_alt = sqme_alt, weight_alt = weight_alt)
          end if
          model => null ()
          if (associated (event%process)) then
             model => event%process%get_model_ptr ()
          end if
          allocate (pset)
          call pset%read_raw (eio%unit, iostat)
          if (iostat /= 0)  return
          if (associated (model))  call pset%set_model (model)
          call event%set_hard_particle_set (pset)
          if (eio%use_alphas_from_file .or. eio%use_scale_from_file) then
             call event%recalculate (update_sqme = .true.)
             if (eio%fixed_order_nlo) then
                if (event%weight_prc /= event%weight_ref .and. &
                     event%weight_prc == 0) then
                   event%weight_prc = event%weight_ref
                end if
             end if
          end if
          call pset%final ()
          deallocate (pset)
          select case (eio%file_version)
          case (2:)
             read (eio%unit, iostat = iostat)  has_transform
             if (iostat /= 0)  return
             if (has_transform) then
                allocate (pset)
                call pset%read_raw (eio%unit, iostat)
                if (iostat /= 0)  return
                if (associated (model)) &
                     call pset%set_model (model)
                call event%link_particle_set (pset)
             end if
          end select
       class default
          call msg_bug ("Event: read raw: defined only for full event_t")
       end select
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for reading")
    end if
  end subroutine eio_raw_input_event

@ %def eio_raw_input_i_prc
@ %def eio_raw_input_event
@
<<EIO raw: eio raw: TBP>>=
  procedure :: skip => eio_raw_skip
<<EIO raw: sub interfaces>>=
    module subroutine eio_raw_skip (eio, iostat)
      class(eio_raw_t), intent(inout) :: eio
      integer, intent(out) :: iostat
    end subroutine eio_raw_skip
<<EIO raw: procedures>>=
  module subroutine eio_raw_skip (eio, iostat)
    class(eio_raw_t), intent(inout) :: eio
    integer, intent(out) :: iostat
    if (eio%reading) then
       read (eio%unit, iostat = iostat)
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for reading")
    end if
  end subroutine eio_raw_skip

@ %def eio_raw_skip
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[eio_raw_ut.f90]]>>=
<<File header>>

module eio_raw_ut
  use unit_tests
  use eio_raw_uti

<<Standard module head>>

<<EIO raw: public test>>

contains

<<EIO raw: test driver>>

end module eio_raw_ut
@ %def eio_raw_ut
@
<<[[eio_raw_uti.f90]]>>=
<<File header>>

module eio_raw_uti

<<Use kinds>>
<<Use strings>>
  use model_data
  use variables
  use events
  use eio_data
  use eio_base

  use eio_raw

  use process, only: process_t
  use instances, only: process_instance_t

<<Standard module head>>

<<EIO raw: test declarations>>

contains

<<EIO raw: tests>>

end module eio_raw_uti

@ %def eio_raw_uti
@ API: driver for the unit tests below.
<<EIO raw: public test>>=
  public :: eio_raw_test
<<EIO raw: test driver>>=
  subroutine eio_raw_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO raw: execute tests>>
  end subroutine eio_raw_test

@ %def eio_raw_test
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO raw: execute tests>>=
  call test (eio_raw_1, "eio_raw_1", &
       "read and write event contents", &
       u, results)
<<EIO raw: test declarations>>=
  public :: eio_raw_1
<<EIO raw: tests>>=
  subroutine eio_raw_1 (u)
    use processes_ut, only: prepare_test_process, cleanup_test_process
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    class(eio_t), allocatable :: eio
    integer :: i_prc, iostat
    type(string_t) :: sample

    write (u, "(A)")  "* Test output: eio_raw_1"
    write (u, "(A)")  "*   Purpose: generate and read/write an event"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"

    call model%init_test ()

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model, &
         run_id = var_str ("run_test"))
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")

    sample = "eio_raw_1"

    allocate (eio_raw_t :: eio)

    call eio%init_out (sample)
    call event%generate (1, [0._default, 0._default])
    call event%increment_index ()
    call event%evaluate_expressions ()
    call event%write (u)
    write (u, "(A)")

    call eio%output (event, i_prc = 42)
    call eio%write (u)
    call eio%final ()

    call event%final ()
    deallocate (event)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event"
    write (u, "(A)")

    call eio%init_in (sample)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())

    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event):", iostat
    call eio%write (u)

    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call event%write (u)
    write (u, "(A)")
    write (u, "(A)")  "* Generate and append another event"
    write (u, "(A)")

    call eio%switch_inout ()
    call event%generate (1, [0._default, 0._default])
    call event%increment_index ()
    call event%evaluate_expressions ()
    call event%write (u)
    write (u, "(A)")

    call eio%output (event, i_prc = 5)
    call eio%write (u)
    call eio%final ()

    call event%final ()
    deallocate (event)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Re-read both events"
    write (u, "(A)")

    call eio%init_in (sample)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())

    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc/1):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event/1):", iostat
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc/2):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event/2):", iostat
    call eio%write (u)

    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()
    deallocate (eio)

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_raw_1"

  end subroutine eio_raw_1

@ %def eio_raw_1
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO raw: execute tests>>=
  call test (eio_raw_2, "eio_raw_2", &
       "handle multiple weights", &
       u, results)
<<EIO raw: test declarations>>=
  public :: eio_raw_2
<<EIO raw: tests>>=
  subroutine eio_raw_2 (u)
    use processes_ut, only: prepare_test_process, cleanup_test_process
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(var_list_t) :: var_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    integer :: i_prc, iostat
    type(string_t) :: sample

    write (u, "(A)")  "* Test output: eio_raw_2"
    write (u, "(A)")  "*   Purpose: generate and read/write an event"
    write (u, "(A)")  "*            with multiple weights"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Initialize test process"

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model, &
         run_id = var_str ("run_test"))
    call process_instance%setup_event_data ()

    call data%init (n_proc = 1, n_alt = 2)

    call var_list%append_log (var_str ("?unweighted"), .false., &
         intrinsic = .true.)
    call var_list%append_string (var_str ("$sample_normalization"), &
         var_str ("auto"), intrinsic = .true.)
    call var_list%append_real (var_str ("safety_factor"), &
         1._default, intrinsic = .true.)

    allocate (event)
    call event%basic_init (var_list, n_alt = 2)
    call event%connect (process_instance, process%get_model_ptr ())

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")

    sample = "eio_raw_2"

    allocate (eio_raw_t :: eio)

    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%increment_index ()
    call event%evaluate_expressions ()
    call event%set (sqme_alt = [2._default, 3._default])
    call event%set (weight_alt = &
         [2 * event%get_weight_ref (), 3 * event%get_weight_ref ()])
    call event%store_alt_values ()
    call event%check ()

    call event%write (u)
    write (u, "(A)")

    call eio%output (event, i_prc = 42)
    call eio%write (u)
    call eio%final ()

    call event%final ()
    deallocate (event)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event"
    write (u, "(A)")

    call eio%init_in (sample, data)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    allocate (event)
    call event%basic_init (var_list, n_alt = 2)
    call event%connect (process_instance, process%get_model_ptr ())

    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event):", iostat
    call eio%write (u)

    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()
    deallocate (eio)

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_raw_2"

  end subroutine eio_raw_2

@ %def eio_raw_2
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dispatch}
An event transform is responsible for dressing a partonic event.
Since event transforms are not mutually exclusive but are
concatenated, we provide individual dispatchers for each of them.

Due to the gfortran 7/8/9 bug that leads to segmentation violation if
polymorphic user-defined derived types are allocated in routines within
submodules, this module remains without submodule until we can switch
to gfortran v10 or newer.
<<[[dispatch_transforms.f90]]>>=
<<File header>>

module dispatch_transforms

<<Use kinds>>
<<Use strings>>
  use process
  use variables
  use system_defs, only: LF
  use system_dependencies, only: LHAPDF6_AVAILABLE
  use sf_lhapdf, only: lhapdf_initialize
  use pdf, only: pdf_data_t
  use diagnostics
  use models
  use os_interface
  use beam_structures
  use resonances, only: resonance_history_set_t
  use instances, only: process_instance_t, process_instance_hook_t

  use event_base, only: event_callback_t, event_callback_nop_t
  use hepmc_interface, only: HEPMC3_MODE_HEPMC2, HEPMC3_MODE_HEPMC3
  use hepmc_interface, only: HEPMC3_MODE_ROOT, HEPMC3_MODE_ROOTTREE
  use hepmc_interface, only: HEPMC3_MODE_HEPEVT
  use eio_base
  use eio_raw
  use eio_checkpoints
  use eio_callback
  use eio_lhef
  use eio_hepmc
  use eio_lcio
  use eio_stdhep
  use eio_ascii
  use eio_weights
  use eio_dump

  use event_transforms
  use resonance_insertion
  use isr_epa_handler
  use decays
  use shower_base
  use shower_core
  use shower
  use shower_pythia6
  use shower_pythia8
  use hadrons
  use mlm_matching
  use powheg_matching
  use ckkw_matching
  use tauola_interface !NODEP!
  use evt_nlo

<<Standard module head>>

<<Dispatch transforms: public>>

contains

<<Dispatch transforms: procedures>>

end module dispatch_transforms
@ %def dispatch_transforms
@
<<Dispatch transforms: public>>=
  public :: dispatch_evt_nlo
<<Dispatch transforms: procedures>>=
  subroutine dispatch_evt_nlo (evt, keep_failed_events)
    class(evt_t), intent(out), pointer :: evt
    logical, intent(in) :: keep_failed_events
    call msg_message ("Simulate: activating fixed-order NLO events")
    allocate (evt_nlo_t :: evt)
    evt%only_weighted_events = .true.
    select type (evt)
    type is (evt_nlo_t)
       evt%i_evaluation = 0
       evt%keep_failed_events = keep_failed_events
    end select
  end subroutine dispatch_evt_nlo

@ %def dispatch_evt_nlo
@
<<Dispatch transforms: public>>=
  public :: dispatch_evt_resonance
<<Dispatch transforms: procedures>>=
  subroutine dispatch_evt_resonance (evt, var_list, res_history_set, libname)
    class(evt_t), intent(out), pointer :: evt
    type(var_list_t), intent(in) :: var_list
    type(resonance_history_set_t), dimension(:), intent(in) :: res_history_set
    type(string_t), intent(in) :: libname
    logical :: resonance_history
    resonance_history = var_list%get_lval (var_str ("?resonance_history"))
    if (resonance_history) then
       allocate (evt_resonance_t :: evt)
       call msg_message ("Simulate: activating resonance insertion")
       select type (evt)
       type is (evt_resonance_t)
          call evt%set_resonance_data (res_history_set)
          call evt%set_library (libname)
       end select
    else
       evt => null ()
    end if
  end subroutine dispatch_evt_resonance

@ %def dispatch_evt_resonance
@ Initialize the ISR/EPA handler, depending on active settings.

The activation is independent for both handlers, since only one may be
needed at a time.  However, if both handlers are active, the current
implementation requires the handler modes of ISR and EPA to coincide.
<<Dispatch transforms: public>>=
  public :: dispatch_evt_isr_epa_handler
<<Dispatch transforms: procedures>>=
  subroutine dispatch_evt_isr_epa_handler (evt, var_list)
    class(evt_t), intent(out), pointer :: evt
    type(var_list_t), intent(in) :: var_list
    logical :: isr_recoil
    logical :: epa_recoil
    logical :: isr_handler_active
    logical :: epa_handler_active
    type(string_t) :: isr_handler_mode
    type(string_t) :: epa_handler_mode
    logical :: isr_keep_mass
    real(default) :: sqrts
    real(default) :: isr_q_max
    real(default) :: epa_q_max
    real(default) :: isr_mass
    real(default) :: epa_mass
    isr_handler_active = var_list%get_lval (var_str ("?isr_handler"))
    if (isr_handler_active) then
       call msg_message ("Simulate: activating ISR handler")
       isr_recoil = &
            var_list%get_lval (var_str ("?isr_recoil"))
       isr_handler_mode = &
            var_list%get_sval (var_str ("$isr_handler_mode"))
       isr_keep_mass = &
            var_list%get_lval (var_str ("?isr_handler_keep_mass"))
       if (isr_recoil) then
          call msg_fatal ("Simulate: ISR handler is incompatible &
               &with ?isr_recoil=true")
       end if
    end if
    epa_handler_active = var_list%get_lval (var_str ("?epa_handler"))
    if (epa_handler_active) then
       call msg_message ("Simulate: activating EPA handler")
       epa_recoil = var_list%get_lval (var_str ("?epa_recoil"))
       epa_handler_mode = var_list%get_sval (var_str ("$epa_handler_mode"))
       if (epa_recoil) then
          call msg_fatal ("Simulate: EPA handler is incompatible &
               &with ?epa_recoil=true")
       end if
    end if
    if (isr_handler_active .and. epa_handler_active) then
       if (isr_handler_mode /= epa_handler_mode) then
          call msg_fatal ("Simulate: ISR/EPA handler: modes must coincide")
       end if
    end if
    if (isr_handler_active .or. epa_handler_active) then
       allocate (evt_isr_epa_t :: evt)
       select type (evt)
       type is (evt_isr_epa_t)
          if (isr_handler_active) then
             call evt%set_mode_string (isr_handler_mode)
          else
             call evt%set_mode_string (epa_handler_mode)
          end if
          sqrts = var_list%get_rval (var_str ("sqrts"))
          if (isr_handler_active) then
             isr_q_max = var_list%get_rval (var_str ("isr_q_max"))
             isr_mass = var_list%get_rval (var_str ("isr_mass"))
             call evt%set_data_isr (sqrts, isr_q_max, isr_mass, isr_keep_mass)
          end if
          if (epa_handler_active) then
             epa_q_max = var_list%get_rval (var_str ("epa_q_max"))
             epa_mass = var_list%get_rval (var_str ("epa_mass"))
             call evt%set_data_epa (sqrts, epa_q_max, epa_mass)
          end if
          call msg_message ("Simulate: ISR/EPA handler mode: " &
               // char (evt%get_mode_string ()))
       end select
    else
       evt => null ()
    end if
  end subroutine dispatch_evt_isr_epa_handler

@ %def dispatch_evt_isr_epa_handler
@
<<Dispatch transforms: public>>=
  public :: dispatch_evt_decay
<<Dispatch transforms: procedures>>=
  subroutine dispatch_evt_decay (evt, var_list)
    class(evt_t), intent(out), pointer :: evt
    type(var_list_t), intent(in), target :: var_list
    logical :: allow_decays
    allow_decays = var_list%get_lval (var_str ("?allow_decays"))
    if (allow_decays) then
       allocate (evt_decay_t :: evt)
       call msg_message ("Simulate: activating decays")
       select type (evt)
       type is (evt_decay_t)
          call evt%set_var_list (var_list)
       end select
    else
       evt => null ()
    end if
  end subroutine dispatch_evt_decay

@ %def dispatch_evt_decay
@
<<Dispatch transforms: public>>=
  public :: dispatch_evt_shower
<<Dispatch transforms: procedures>>=
  subroutine dispatch_evt_shower (evt, var_list, model, fallback_model, &
       os_data, beam_structure, process)
    class(evt_t), intent(out), pointer :: evt
    type(var_list_t), intent(in) :: var_list
    type(model_t), pointer, intent(in) :: model, fallback_model
    type(os_data_t), intent(in) :: os_data
    type(beam_structure_t), intent(in) :: beam_structure
    type(process_t), intent(in), optional :: process
    type(string_t) :: lhapdf_file, lhapdf_dir, process_name
    integer :: lhapdf_member
    type(shower_settings_t) :: settings
    type(taudec_settings_t) :: taudec_settings
    call msg_message ("Simulate: activating parton shower")
    allocate (evt_shower_t :: evt)
    call settings%init (var_list)
    if (associated (model)) then
       call taudec_settings%init (var_list, model)
    else
       call taudec_settings%init (var_list, fallback_model)
    end if
    if (present (process)) then
       process_name = process%get_id ()
    else
       process_name = 'dispatch_testing'
    end if
    select type (evt)
    type is (evt_shower_t)
       call evt%init (fallback_model, os_data)
       lhapdf_member = &
            var_list%get_ival (var_str ("lhapdf_member"))
       if (LHAPDF6_AVAILABLE) then
          lhapdf_dir = &
               var_list%get_sval (var_str ("$lhapdf_dir"))
          lhapdf_file = &
               var_list%get_sval (var_str ("$lhapdf_file"))
          call lhapdf_initialize &
               (1, lhapdf_dir, lhapdf_file, lhapdf_member, evt%pdf_data%pdf)
       end if
       if (present (process))  call evt%pdf_data%setup ("Shower", &
            beam_structure, lhapdf_member, process%get_pdf_set ())
       select case (settings%method)
       case (PS_WHIZARD)
          allocate (shower_t :: evt%shower)
       case (PS_PYTHIA6)
          allocate (shower_pythia6_t :: evt%shower)
       case (PS_PYTHIA8)
          allocate (shower_pythia8_t :: evt%shower)
       case default
          call msg_fatal ('Shower: Method ' // &
            char (var_list%get_sval (var_str ("$shower_method"))) // &
            'not implemented!')
       end select
       call evt%shower%init (settings, taudec_settings, evt%pdf_data, os_data)
       call dispatch_matching (evt, settings, var_list, process_name, evt%pdf_data)
    class default
       call dispatch_matching (evt, settings, var_list, process_name)
    end select
  end subroutine dispatch_evt_shower

@ %def dispatch_evt_shower
@
<<Dispatch transforms: public>>=
  public :: dispatch_evt_shower_hook
<<Dispatch transforms: procedures>>=
  subroutine dispatch_evt_shower_hook (hook, var_list, process_instance, beam_structure, pdf_set)
    class(process_instance_hook_t), pointer, intent(out) :: hook
    type(var_list_t), intent(in) :: var_list
    class(process_instance_t), intent(in), target :: process_instance
    type(beam_structure_t), intent(in) :: beam_structure
    integer, intent(in) :: pdf_set
    type(pdf_data_t) :: pdf_data
    type(string_t) :: lhapdf_file, lhapdf_dir
    integer :: lhapdf_member
    if (var_list%get_lval (var_str ('?powheg_matching'))) then
       call msg_message ("Integration hook: add POWHEG hook")
       allocate (powheg_matching_hook_t :: hook)
       select type (hook)
       type is (powheg_matching_hook_t)
          lhapdf_member = var_list%get_ival (var_str ("lhapdf_member"))
          if (LHAPDF6_AVAILABLE) then
             lhapdf_dir = var_list%get_sval (var_str ("$lhapdf_dir"))
             lhapdf_file = var_list%get_sval (var_str ("$lhapdf_file"))
             call lhapdf_initialize (1, lhapdf_dir, lhapdf_file, lhapdf_member, pdf_data%pdf)
          end if
          call pdf_data%setup ("Shower", beam_structure, lhapdf_member, pdf_set)
          call hook%init (var_list, process_instance, pdf_data)
       end select
    else
       hook => null ()
    end if
  end subroutine dispatch_evt_shower_hook

@ %def dispatch_evt_shower_hook
@
<<Dispatch transforms: public>>=
  public :: dispatch_matching
<<Dispatch transforms: procedures>>=
  subroutine dispatch_matching (evt, settings, var_list, process_name, pdf_data)
    class(evt_t), intent(inout) :: evt
    type(shower_settings_t), intent(in) :: settings
    type(var_list_t), intent(in) :: var_list
    type(string_t), intent(in) :: process_name
    type(pdf_data_t), intent(in), optional :: pdf_data
    select type (evt)
    type is (evt_shower_t)
       if (settings%mlm_matching .and. settings%ckkw_matching) then
          call msg_fatal ("Both MLM and CKKW matching activated," // &
               LF // "     aborting simulation")
       end if
       if (settings%powheg_matching) then
          call msg_message ("Simulate: applying POWHEG matching")
          allocate (powheg_matching_t :: evt%matching)
       end if
       if (settings%mlm_matching) then
          call msg_message ("Simulate: applying MLM matching")
          allocate (mlm_matching_t :: evt%matching)
       end if
       if (settings%ckkw_matching) then
          call msg_warning ("Simulate: CKKW(-L) matching not yet supported")
          allocate (ckkw_matching_t :: evt%matching)
       end if
       if (allocated (evt%matching)) then
          call evt%matching%init (var_list, process_name)
          if (present(pdf_data)) then
             select type (matching => evt%matching)
             type is (powheg_matching_t)
                matching%process_deps%pdf_data = pdf_data
             end select
          end if
       end if
    end select
  end subroutine dispatch_matching

@ %def dispatch_matching
@
<<Dispatch transforms: public>>=
  public :: dispatch_evt_hadrons
<<Dispatch transforms: procedures>>=
  subroutine dispatch_evt_hadrons (evt, var_list, fallback_model)
    class(evt_t), intent(out), pointer :: evt
    type(var_list_t), intent(in) :: var_list
    type(model_t), pointer, intent(in) :: fallback_model
    type(shower_settings_t) :: shower_settings
    type(hadron_settings_t) :: hadron_settings
    allocate (evt_hadrons_t :: evt)
    call msg_message ("Simulate: activating hadronization")
    call shower_settings%init (var_list)
    call hadron_settings%init (var_list)
    select type (evt)
    type is (evt_hadrons_t)
       call evt%init (fallback_model)
       select case (hadron_settings%method)
       case (HADRONS_WHIZARD)
          allocate (hadrons_hadrons_t :: evt%hadrons)
       case (HADRONS_PYTHIA6)
          allocate (hadrons_pythia6_t :: evt%hadrons)
       case (HADRONS_PYTHIA8)
          allocate (hadrons_pythia8_t :: evt%hadrons)
       case default
          call msg_fatal ('Hadronization: Method ' // &
            char (var_list%get_sval (var_str ("hadronization_method"))) // &
            'not implemented!')
       end select
       call evt%hadrons%init &
            (shower_settings, hadron_settings, fallback_model)
    end select
  end subroutine dispatch_evt_hadrons

@ %def dispatch_evt_hadrons
@ We cannot put this in the [[events]] subdir due to [[eio_raw_t]],
which is defined here.
<<Dispatch transforms: public>>=
  public :: dispatch_eio
<<Dispatch transforms: procedures>>=
  subroutine dispatch_eio (eio, method, var_list, fallback_model, &
         event_callback)
    class(eio_t), allocatable, intent(inout) :: eio
    type(string_t), intent(in) :: method
    type(var_list_t), intent(in) :: var_list
    type(model_t), target, intent(in) :: fallback_model
    class(event_callback_t), allocatable, intent(in) :: event_callback
    logical :: check, keep_beams, keep_remnants, recover_beams
    logical :: use_alphas_from_file, use_scale_from_file
    logical :: fixed_order_nlo_events
    logical :: write_sqme_prc, write_sqme_ref, write_sqme_alt
    logical :: output_cross_section, ensure_order
    type(string_t) :: lhef_version, lhef_extension, raw_version
    type(string_t) :: extension_default, debug_extension, dump_extension, &
         extension_hepmc, &
         extension_lha, extension_hepevt, extension_ascii_short, &
         extension_ascii_long, extension_athena, extension_mokka, &
         extension_stdhep, extension_stdhep_up, extension_stdhep_ev4, &
         extension_raw, extension_hepevt_verb, extension_lha_verb, &
         extension_lcio
    integer :: checkpoint
    integer :: lcio_run_id, hepmc3_mode
    logical :: show_process, show_transforms, show_decay, verbose, pacified
    logical :: dump_weights, dump_compressed, dump_summary, dump_screen
    logical :: proc_as_run_id, hepmc3_write_flows
    keep_beams = &
         var_list%get_lval (var_str ("?keep_beams"))
    keep_remnants = &
         var_list%get_lval (var_str ("?keep_remnants"))
    ensure_order = &
         var_list%get_lval (var_str ("?hepevt_ensure_order"))
    recover_beams = &
         var_list%get_lval (var_str ("?recover_beams"))
    use_alphas_from_file = &
         var_list%get_lval (var_str ("?use_alphas_from_file"))
    use_scale_from_file = &
         var_list%get_lval (var_str ("?use_scale_from_file"))
    fixed_order_nlo_events = &
         var_list%get_lval (var_str ("?fixed_order_nlo_events"))
    select case (char (method))
    case ("raw")
       allocate (eio_raw_t :: eio)
       select type (eio)
       type is (eio_raw_t)
          check = &
               var_list%get_lval (var_str ("?check_event_file"))
          raw_version = &
               var_list%get_sval (var_str ("$event_file_version"))
          extension_raw = &
               var_list%get_sval (var_str ("$extension_raw"))
          call eio%set_parameters (check, use_alphas_from_file, &
               use_scale_from_file, fixed_order_nlo_events, &
               raw_version, extension_raw)
       end select
    case ("checkpoint")
       allocate (eio_checkpoints_t :: eio)
       select type (eio)
       type is (eio_checkpoints_t)
          checkpoint = &
               var_list%get_ival (var_str ("checkpoint"))
          pacified = &
               var_list%get_lval (var_str ("?pacify"))
          call eio%set_parameters (checkpoint, blank = pacified)
       end select
    case ("callback")
       allocate (eio_callback_t :: eio)
       select type (eio)
       type is (eio_callback_t)
          checkpoint = &
               var_list%get_ival (var_str ("event_callback_interval"))
          if (allocated (event_callback)) then
             call eio%set_parameters (event_callback, checkpoint)
          else
             call eio%set_parameters (event_callback_nop_t (), 0)
          end if
       end select
    case ("lhef")
       allocate (eio_lhef_t :: eio)
       select type (eio)
       type is (eio_lhef_t)
          lhef_version = &
               var_list%get_sval (var_str ("$lhef_version"))
          lhef_extension = &
               var_list%get_sval (var_str ("$lhef_extension"))
          write_sqme_prc = &
               var_list%get_lval (var_str ("?lhef_write_sqme_prc"))
          write_sqme_ref = &
               var_list%get_lval (var_str ("?lhef_write_sqme_ref"))
          write_sqme_alt = &
               var_list%get_lval (var_str ("?lhef_write_sqme_alt"))
          call eio%set_parameters ( &
               keep_beams, keep_remnants, recover_beams, &
               use_alphas_from_file, use_scale_from_file, &
               char (lhef_version), lhef_extension, &
               write_sqme_ref, write_sqme_prc, write_sqme_alt)
       end select
    case ("hepmc")
       allocate (eio_hepmc_t :: eio)
       select type (eio)
       type is (eio_hepmc_t)
          output_cross_section = &
               var_list%get_lval (var_str ("?hepmc_output_cross_section"))
          extension_hepmc = &
               var_list%get_sval (var_str ("$extension_hepmc"))
          hepmc3_write_flows = &
               var_list%get_lval (var_str ("?hepmc3_write_flows"))
          select case (char (var_list%get_sval (var_str ("$hepmc3_mode"))))
          case ("HepMC2")
             hepmc3_mode = HEPMC3_MODE_HEPMC2
          case ("HepMC3")
             hepmc3_mode = HEPMC3_MODE_HEPMC3
          case ("Root")
             hepmc3_mode = HEPMC3_MODE_ROOT
             if (extension_hepmc /= "root") then
                call msg_message ("Events: HepMC3 Root mode, using " // &
                     "event sample extension 'root'")
                extension_hepmc = "root"
             end if
          case ("RootTree")
             hepmc3_mode = HEPMC3_MODE_ROOTTREE
             if (extension_hepmc /= "root") then
                call msg_message ("Events: HepMC3 RootTree mode, using " // &
                     "event sample extension 'root'")
                extension_hepmc = "root"
             end if
          case ("HepEVT")
             hepmc3_mode = HEPMC3_MODE_HEPEVT
          case default
             call msg_fatal ("Only supported HepMC3 modes are: 'HepMC2', " // &
                  "'HepMC3', 'HepEVT', 'Root', and 'RootTree'.")
          end select
          call eio%set_parameters (recover_beams, &
               use_alphas_from_file, use_scale_from_file, &
               extension = extension_hepmc, &
               output_cross_section = output_cross_section, &
               hepmc3_mode = hepmc3_mode, &
               hepmc3_write_flows = hepmc3_write_flows)
       end select
    case ("lcio")
       allocate (eio_lcio_t :: eio)
       select type (eio)
       type is (eio_lcio_t)
          extension_lcio = &
               var_list%get_sval (var_str ("$extension_lcio"))
          proc_as_run_id = &
               var_list%get_lval (var_str ("?proc_as_run_id"))
          lcio_run_id = &
               var_list%get_ival (var_str ("lcio_run_id"))
          call eio%set_parameters (recover_beams, &
               use_alphas_from_file, use_scale_from_file, &
               extension_lcio, proc_as_run_id = proc_as_run_id, &
               lcio_run_id = lcio_run_id)
       end select
    case ("stdhep")
       allocate (eio_stdhep_hepevt_t :: eio)
       select type (eio)
       type is (eio_stdhep_hepevt_t)
          extension_stdhep = &
               var_list%get_sval (var_str ("$extension_stdhep"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, ensure_order, recover_beams, &
                use_alphas_from_file, use_scale_from_file, extension_stdhep)
       end select
    case ("stdhep_up")
       allocate (eio_stdhep_hepeup_t :: eio)
       select type (eio)
       type is (eio_stdhep_hepeup_t)
          extension_stdhep_up = &
               var_list%get_sval (var_str ("$extension_stdhep_up"))
          call eio%set_parameters (keep_beams, keep_remnants, ensure_order, &
               recover_beams, use_alphas_from_file, &
               use_scale_from_file, extension_stdhep_up)
       end select
    case ("stdhep_ev4")
       allocate (eio_stdhep_hepev4_t :: eio)
       select type (eio)
       type is (eio_stdhep_hepev4_t)
          extension_stdhep_ev4 = &
               var_list%get_sval (var_str ("$extension_stdhep_ev4"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, ensure_order, recover_beams, &
                use_alphas_from_file, use_scale_from_file, extension_stdhep_ev4)
       end select
    case ("ascii")
       allocate (eio_ascii_ascii_t :: eio)
       select type (eio)
       type is (eio_ascii_ascii_t)
          extension_default = &
               var_list%get_sval (var_str ("$extension_default"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, ensure_order, extension_default)
       end select
    case ("athena")
       allocate (eio_ascii_athena_t :: eio)
       select type (eio)
       type is (eio_ascii_athena_t)
          extension_athena = &
               var_list%get_sval (var_str ("$extension_athena"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, ensure_order, extension_athena)
       end select
    case ("debug")
       allocate (eio_ascii_debug_t :: eio)
       select type (eio)
       type is (eio_ascii_debug_t)
          debug_extension = &
               var_list%get_sval (var_str ("$debug_extension"))
          show_process = &
               var_list%get_lval (var_str ("?debug_process"))
          show_transforms = &
               var_list%get_lval (var_str ("?debug_transforms"))
          show_decay = &
               var_list%get_lval (var_str ("?debug_decay"))
          verbose = &
               var_list%get_lval (var_str ("?debug_verbose"))
          call eio%set_parameters ( &
               extension = debug_extension, &
               show_process = show_process, &
               show_transforms = show_transforms, &
               show_decay = show_decay, &
               verbose = verbose)
       end select
    case ("dump")
       allocate (eio_dump_t :: eio)
       select type (eio)
       type is (eio_dump_t)
          dump_extension = &
               var_list%get_sval (var_str ("$dump_extension"))
          pacified = &
               var_list%get_lval (var_str ("?pacify"))
          dump_weights = &
               var_list%get_lval (var_str ("?dump_weights"))
          dump_compressed = &
               var_list%get_lval (var_str ("?dump_compressed"))
          dump_summary = &
               var_list%get_lval (var_str ("?dump_summary"))
          dump_screen = &
               var_list%get_lval (var_str ("?dump_screen"))
          call eio%set_parameters ( &
               extension = dump_extension, &
               pacify = pacified, &
               weights = dump_weights, &
               compressed = dump_compressed, &
               summary = dump_summary, &
               screen = dump_screen)
       end select
    case ("hepevt")
       allocate (eio_ascii_hepevt_t :: eio)
       select type (eio)
       type is (eio_ascii_hepevt_t)
          extension_hepevt = &
               var_list%get_sval (var_str ("$extension_hepevt"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, ensure_order, extension_hepevt)
       end select
    case ("hepevt_verb")
       allocate (eio_ascii_hepevt_verb_t :: eio)
       select type (eio)
       type is (eio_ascii_hepevt_verb_t)
          extension_hepevt_verb = &
               var_list%get_sval (var_str ("$extension_hepevt_verb"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, ensure_order, extension_hepevt_verb)
       end select
    case ("lha")
       allocate (eio_ascii_lha_t :: eio)
       select type (eio)
       type is (eio_ascii_lha_t)
          extension_lha = &
               var_list%get_sval (var_str ("$extension_lha"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, ensure_order, extension_lha)
       end select
    case ("lha_verb")
       allocate (eio_ascii_lha_verb_t :: eio)
       select type (eio)
       type is (eio_ascii_lha_verb_t)
          extension_lha_verb = var_list%get_sval ( &
               var_str ("$extension_lha_verb"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, ensure_order, extension_lha_verb)
       end select
    case ("long")
       allocate (eio_ascii_long_t :: eio)
       select type (eio)
       type is (eio_ascii_long_t)
          extension_ascii_long = &
               var_list%get_sval (var_str ("$extension_ascii_long"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, ensure_order, extension_ascii_long)
       end select
    case ("mokka")
       allocate (eio_ascii_mokka_t :: eio)
       select type (eio)
       type is (eio_ascii_mokka_t)
          extension_mokka = &
               var_list%get_sval (var_str ("$extension_mokka"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, ensure_order, extension_mokka)
       end select
    case ("short")
       allocate (eio_ascii_short_t :: eio)
       select type (eio)
       type is (eio_ascii_short_t)
          extension_ascii_short = &
               var_list%get_sval (var_str ("$extension_ascii_short"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, ensure_order, extension_ascii_short)
       end select
    case ("weight_stream")
       allocate (eio_weights_t :: eio)
       select type (eio)
       type is (eio_weights_t)
          pacified = &
               var_list%get_lval (var_str ("?pacify"))
          call eio%set_parameters (pacify = pacified)
       end select
    case default
       call msg_fatal ("Event I/O method '" // char (method) &
            // "' not implemented")
    end select
    call eio%set_fallback_model (fallback_model)
  end subroutine dispatch_eio

@ %def dispatch_eio
@
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[dispatch_transforms_ut.f90]]>>=
<<File header>>

module dispatch_transforms_ut
  use unit_tests
  use dispatch_transforms_uti

<<Standard module head>>

<<Dispatch transforms: public test>>

contains

<<Dispatch transforms: test driver>>

end module dispatch_transforms_ut
@ %def dispatch_transforms_ut
@
<<[[dispatch_transforms_uti.f90]]>>=
<<File header>>

module dispatch_transforms_uti

<<Use kinds>>
<<Use strings>>
  use format_utils, only: write_separator
  use variables
  use event_base, only: event_callback_t
  use models, only: model_t, model_list_t
  use models, only: syntax_model_file_init, syntax_model_file_final
  use resonances, only: resonance_history_set_t
  use beam_structures, only: beam_structure_t
  use eio_base, only: eio_t
  use os_interface, only: os_data_t
  use event_transforms, only: evt_t
  use dispatch_transforms

<<Standard module head>>

<<Dispatch transforms: test declarations>>

contains

<<Dispatch transforms: tests>>

end module dispatch_transforms_uti
@ %def dispatch_transforms_uti
@ API: driver for the unit tests below.
<<Dispatch transforms: public test>>=
  public ::dispatch_transforms_test
<<Dispatch transforms: test driver>>=
  subroutine dispatch_transforms_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Dispatch transforms: execute tests>>
  end subroutine dispatch_transforms_test

@  %def dispatch_transforms_test
@
\subsubsection{Event I/O}
<<Dispatch transforms: execute tests>>=
  call test (dispatch_transforms_1, "dispatch_transforms_1", &
       "event I/O", &
       u, results)
<<Dispatch transforms: test declarations>>=
  public :: dispatch_transforms_1
<<Dispatch transforms: tests>>=
  subroutine dispatch_transforms_1 (u)
    integer, intent(in) :: u
    type(var_list_t) :: var_list
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(os_data_t) :: os_data
    class(event_callback_t), allocatable :: event_callback
    class(eio_t), allocatable :: eio

    write (u, "(A)")  "* Test output: dispatch_transforms_1"
    write (u, "(A)")  "*   Purpose: allocate an event I/O (eio) stream"
    write (u, "(A)")

    call var_list%init_defaults (0)
    call os_data%init ()
    call syntax_model_file_init ()
    call model_list%read_model (var_str ("SM_hadrons"), &
         var_str ("SM_hadrons.mdl"), os_data, model)

    write (u, "(A)")  "* Allocate as raw"
    write (u, "(A)")

    call dispatch_eio (eio, var_str ("raw"), var_list, &
         model, event_callback)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as checkpoints:"
    write (u, "(A)")

    call dispatch_eio (eio, var_str ("checkpoint"), var_list, &
         model, event_callback)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as LHEF:"
    write (u, "(A)")

    call var_list%set_string (var_str ("$lhef_extension"), &
         var_str ("lhe_custom"), is_known = .true.)
    call dispatch_eio (eio, var_str ("lhef"), var_list, &
         model, event_callback)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as HepMC:"
    write (u, "(A)")

    call dispatch_eio (eio, var_str ("hepmc"), var_list, &
         model, event_callback)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as weight_stream"
    write (u, "(A)")

    call dispatch_eio (eio, var_str ("weight_stream"), var_list, &
         model, event_callback)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as debug format"
    write (u, "(A)")

    call var_list%set_log (var_str ("?debug_verbose"), &
         .false., is_known = .true.)
    call dispatch_eio (eio, var_str ("debug"), var_list, &
         model, event_callback)

    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()
    call var_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_transforms_1"

  end subroutine dispatch_transforms_1

@ %def dispatch_transforms_1
@
\subsubsection{Event transforms}
This test dispatches [[evt]] (event transform) objects.
<<Dispatch transforms: execute tests>>=
  call test (dispatch_transforms_2, "dispatch_transforms_2", &
       "event transforms", &
       u, results)
<<Dispatch transforms: test declarations>>=
  public :: dispatch_transforms_2
<<Dispatch transforms: tests>>=
  subroutine dispatch_transforms_2 (u)
    integer, intent(in) :: u
    type(var_list_t), target :: var_list
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(os_data_t) :: os_data
    type(resonance_history_set_t), dimension(1) :: res_history_set
    type(beam_structure_t) :: beam_structure
    class(evt_t), pointer :: evt

    write (u, "(A)")  "* Test output: dispatch_transforms_2"
    write (u, "(A)")  "*   Purpose: configure event transform"
    write (u, "(A)")

    call syntax_model_file_init ()
    call var_list%init_defaults (0)
    call os_data%init ()
    call model_list%read_model (var_str ("SM_hadrons"), &
         var_str ("SM_hadrons.mdl"), os_data, model)

    write (u, "(A)")  "* Resonance insertion"
    write (u, "(A)")

    call var_list%set_log (var_str ("?resonance_history"), .true., &
         is_known = .true.)
    call dispatch_evt_resonance (evt, var_list, &
         res_history_set, &
         var_str ("foo_R"))
    call evt%write (u, verbose = .true., more_verbose = .true.)

    call evt%final ()
    deallocate (evt)

    write (u, "(A)")
    write (u, "(A)")  "* ISR handler"
    write (u, "(A)")

    call var_list%set_log (var_str ("?isr_handler"), .true., &
         is_known = .true.)
    call var_list%set_log (var_str ("?epa_handler"), .false., &
         is_known = .true.)
    call var_list%set_string (var_str ("$isr_handler_mode"), &
         var_str ("recoil"), &
         is_known = .true.)
    call var_list%set_real (var_str ("sqrts"), 100._default, &
         is_known = .true.)
    call var_list%set_real (var_str ("isr_mass"), 511.e-6_default, &
         is_known = .true.)
    call dispatch_evt_isr_epa_handler (evt, var_list)
    call evt%write (u, verbose = .true., more_verbose = .true.)

    call evt%final ()
    deallocate (evt)

    write (u, "(A)")
    write (u, "(A)")  "* EPA handler"
    write (u, "(A)")

    call var_list%set_log (var_str ("?isr_handler"), .false., &
         is_known = .true.)
    call var_list%set_log (var_str ("?epa_handler"), .true., &
         is_known = .true.)
    call var_list%set_string (var_str ("$epa_handler_mode"), &
         var_str ("recoil"), &
         is_known = .true.)
    call var_list%set_real (var_str ("sqrts"), 100._default, &
         is_known = .true.)
    call var_list%set_real (var_str ("epa_mass"), 511.e-6_default, &
         is_known = .true.)
    call dispatch_evt_isr_epa_handler (evt, var_list)
    call evt%write (u, verbose = .true., more_verbose = .true.)

    call evt%final ()
    deallocate (evt)

    write (u, "(A)")
    write (u, "(A)")  "* Partonic decays"
    write (u, "(A)")

    call dispatch_evt_decay (evt, var_list)
    call evt%write (u, verbose = .true., more_verbose = .true.)

    call evt%final ()
    deallocate (evt)

    write (u, "(A)")
    write (u, "(A)")  "* Shower"
    write (u, "(A)")

    call var_list%set_log (var_str ("?allow_shower"), .true., &
         is_known = .true.)
    call var_list%set_string (var_str ("$shower_method"), &
         var_str ("WHIZARD"), is_known = .true.)
    call dispatch_evt_shower (evt, var_list, model, &
         model, os_data, beam_structure)
    call evt%write (u)
    call write_separator (u, 2)

    call evt%final ()
    deallocate (evt)

    call var_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_transforms_2"

  end subroutine dispatch_transforms_2

@ %def dispatch_transforms_2
