<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtHgold 4.00">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Appendix B</title>


<div class="p"><!----></div>
  


  
 
 









  
     
  
      
     
  
 
 
 
  
  
 
 
















        














   











<div class="p"><!----></div>

<div class="p"><!----></div>


    
  




<table align="center" border="0"><tr><td>
&nbsp;</td></tr></table><!--hboxt--><br /><br />

<br /><span class="roman"><b><font size="+2"> APPENDIX&nbsp;&nbsp;C</font></b></span><br /><br />
<hr />
<br />

<br /><font size="+2"> C PROGRAMS </font><br /><br /><br /><br />


<div class="p"><!----></div>
 

<br /><br />
<p>
 

<p>
 C.1 <a href="#Introduction">Introduction </a>


<p>
 C.2 <a href="#Roundoff Error">Roundoff Error </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#cassum">CASSUM</a></td>
<td>&nbsp; <a href="#round">ROUND</a></td>
<td>&nbsp; <a href="#cdiv">CDIV</a></td>
<td>&nbsp; <a href="#cabs">CABS</a></td>
<td>&nbsp; <a href="#csqrt">CSQRT</a></td>
</tr>
</table>


<p>
 C.3 <a href="#Linear Algebraic Equations">Linear Algebraic Equations </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#gauelm">GAUELM</a></td>
<td>&nbsp; <a href="#matinv">MATINV</a></td>
<td>&nbsp; <a href="#crout">CROUT</a></td>
<td>&nbsp; <a href="#crouth">CROUTH</a></td>
<td>&nbsp; <a href="#cholsk">CHOLSK</a></td>
<td>&nbsp; <a href="#gaubnd">GAUBND</a></td>
<td>&nbsp; <a href="#svd">SVD</a></td>
<td>&nbsp; <a href="#svdevl">SVDEVL</a></td>
</tr>
</table>


<p>
 C.4 <a href="#Interpolation">Interpolation </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#divdif">DIVDIF</a></td>
<td>&nbsp; <a href="#divdif0">DIVDIF0</a></td>
<td>&nbsp; <a href="#nearst">NEARST</a></td>
<td>&nbsp; <a href="#spline">SPLINE</a></td>
<td>&nbsp; <a href="#splevl">SPLEVL</a></td>
<td>&nbsp; <a href="#smooth">SMOOTH</a></td>
<td>&nbsp; <a href="#bsplin">BSPLIN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bspint">BSPINT</a></td>
<td>&nbsp; <a href="#bspevl">BSPEVL</a></td>
<td>&nbsp; <a href="#ratnal">RATNAL</a></td>
<td>&nbsp; <a href="#poly2">POLY2</a></td>
<td>&nbsp; <a href="#linrn">LINRN</a></td>
<td>&nbsp; <a href="#locate">LOCATE</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bspint2">BSPINT2</a></td>
<td>&nbsp; <a href="#bspev2">BSPEV2</a></td>
<td>&nbsp; <a href="#bspintn">BSPINTN</a></td>
<td>&nbsp; <a href="#bspevn">BSPEVN</a></td>
<td>&nbsp; <a href="#bspevn1">BSPEVN1</a></td>
<td>&nbsp; <a href="#bspevn2">BSPEVN2</a></td>
</tr>
</table>


<p>
 C.5 <a href="#Differentiation">Differentiation </a>
&nbsp;&nbsp;&nbsp; <a href="#drvt">DRVT</a>



<p>
 C.6 <a href="#Integration">Integration </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#simson">SIMSON</a></td>
<td>&nbsp; <a href="#splint">SPLINT</a></td>
<td>&nbsp; <a href="#bspqd">BSPQD</a></td>
<td>&nbsp; <a href="#rombrg">ROMBRG</a></td>
<td>&nbsp; <a href="#epsiln">EPSILN</a></td>
<td>&nbsp; <a href="#gauss">GAUSS</a></td>
<td>&nbsp; <a href="#gaucby">GAUCBY</a></td>
<td>&nbsp; <a href="#gaucb1">GAUCB1</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#gaucb2">GAUCB2</a></td>
<td>&nbsp; <a href="#gausq2">GAUSQ2</a></td>
<td>&nbsp; <a href="#gausq">GAUSQ</a></td>
<td>&nbsp; <a href="#gaulag">GAULAG</a></td>
<td>&nbsp; <a href="#lagure">LAGURE</a></td>
<td>&nbsp; <a href="#hermit">HERMIT</a></td>
<td>&nbsp; <a href="#gaulg2">GAULG2</a></td>
<td>&nbsp; <a href="#gaulog">GAULOG</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#gausrc">GAUSRC</a></td>
<td>&nbsp; <a href="#gauleg">GAULEG</a></td>
<td>&nbsp; <a href="#gaujac">GAUJAC</a></td>
<td>&nbsp; <a href="#lagurw">LAGURW</a></td>
<td>&nbsp; <a href="#gauher">GAUHER</a></td>
<td>&nbsp; <a href="#gauswt">GAUSWT</a></td>
<td>&nbsp; <a href="#filon">FILON</a></td>
<td>&nbsp; <a href="#adpint">ADPINT</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#kronrd">KRONRD</a></td>
<td>&nbsp; <a href="#gaus16">GAUS16</a></td>
<td>&nbsp; <a href="#cauchy">CAUCHY</a></td>
<td>&nbsp; <a href="#euler">EULER</a></td>
<td>&nbsp; <a href="#bspqd2">BSPQD2</a></td>
<td>&nbsp; <a href="#bspqdn">BSPQDN</a></td>
<td>&nbsp; <a href="#mulint">MULINT</a></td>
<td>&nbsp; <a href="#ngauss">NGAUSS</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#sphnd">SPHND</a></td>
<td>&nbsp; <a href="#strint">STRINT</a></td>
<td>&nbsp; <a href="#stroud">STROUD</a></td>
<td>&nbsp; <a href="#mcarlo">MCARLO</a></td>
<td>&nbsp; <a href="#ran">RAN</a></td>
<td>&nbsp; <a href="#ranf">RANF</a></td>
<td>&nbsp; <a href="#equids">EQUIDS</a></td>
</tr>
</table>


<p>
 C.7 <a href="#Nonlinear Algebraic Equations">Nonlinear Algebraic Equations </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bisect">BISECT</a></td>
<td>&nbsp; <a href="#secant">SECANT</a></td>
<td>&nbsp; <a href="#secani">SECANI</a></td>
<td>&nbsp; <a href="#newrap">NEWRAP</a></td>
<td>&nbsp; <a href="#brent">BRENT</a></td>
<td>&nbsp; <a href="#search">SEARCH</a></td>
<td>&nbsp; <a href="#zroot">ZROOT</a></td>
<td>&nbsp; <a href="#zroot2">ZROOT2</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#muller">MULLER</a></td>
<td>&nbsp; <a href="#muler2">MULER2</a></td>
<td>&nbsp; <a href="#polyr">POLYR</a></td>
<td>&nbsp; <a href="#lagitr">LAGITR</a></td>
<td>&nbsp; <a href="#davidn">DAVIDN</a></td>
<td>&nbsp; <a href="#newton">NEWTON</a></td>
<td>&nbsp; <a href="#broydn">BROYDN</a></td>
</tr>
</table>


<p>
 C.8 <a href="#Optimisation">Optimisation </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#brackm">BRACKM</a></td>
<td>&nbsp; <a href="#golden">GOLDEN</a></td>
<td>&nbsp; <a href="#brentm">BRENTM</a></td>
<td>&nbsp; <a href="#davidm">DAVIDM</a></td>
<td>&nbsp; <a href="#bfgs">BFGS</a></td>
<td>&nbsp; <a href="#linmin">LINMIN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#flnm">FLNM</a></td>
<td>&nbsp; <a href="#nminf">NMINF</a></td>
<td>&nbsp; <a href="#linmnf">LINMNF</a></td>
<td>&nbsp; <a href="#fln">FLN</a></td>
<td>&nbsp; <a href="#simplx">SIMPLX</a></td>
<td>&nbsp; <a href="#simpx">SIMPX</a></td>
</tr>
</table>

<p>
 C.9 <a href="#Statistical Inferences">Statistical Inferences </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#shsort">SHSORT</a></td>
<td>&nbsp; <a href="#gammap">GAMMAP</a></td>
<td>&nbsp; <a href="#betap">BETAP</a></td>
<td>&nbsp; <a href="#betser">BETSER</a></td>
<td>&nbsp; <a href="#betcon1">BETCON1</a></td>
<td>&nbsp; <a href="#betcon">BETCON</a></td>
<td>&nbsp; <a href="#betai">BETAI</a></td>
<td>&nbsp; <a href="#fbeta">FBETA</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#rangau">RANGAU</a></td>
<td>&nbsp; <a href="#iranbin">IRANBIN</a></td>
<td>&nbsp; <a href="#iranpoi">IRANPOI</a></td>
<td>&nbsp; <a href="#pcor">PCOR</a></td>
</tr>
</table>



<p>
 C.10 <a href="#Functional Approximations">Functional Approximations </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#polfit">POLFIT</a></td>
<td>&nbsp; <a href="#polevl">POLEVL</a></td>
<td>&nbsp; <a href="#polfit1">POLFIT1</a></td>
<td>&nbsp; <a href="#polort">POLORT</a></td>
<td>&nbsp; <a href="#polfit2">POLFIT2</a></td>
<td>&nbsp; <a href="#polev2">POLEV2</a></td>
<td>&nbsp; <a href="#polfitn">POLFITN</a></td>
<td>&nbsp; <a href="#polevn">POLEVN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#polevn1">POLEVN1</a></td>
<td>&nbsp; <a href="#polevn2">POLEVN2</a></td>
<td>&nbsp; <a href="#llsq">LLSQ</a></td>
<td>&nbsp; <a href="#bspfit">BSPFIT</a></td>
<td>&nbsp; <a href="#bspfit2">BSPFIT2</a></td>
<td>&nbsp; <a href="#bspfitw2">BSPFITW2</a></td>
<td>&nbsp; <a href="#bspfitn">BSPFITN</a></td>
<td>&nbsp; <a href="#bspfitwn">BSPFITWN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#linfitxy">LINFITXY</a></td>
<td>&nbsp; <a href="#nllsq">NLLSQ</a></td>
<td>&nbsp; <a href="#dft">DFT</a></td>
<td>&nbsp; <a href="#fft">FFT</a></td>
<td>&nbsp; <a href="#fftr">FFTR</a></td>
<td>&nbsp; <a href="#fftn">FFTN</a></td>
<td>&nbsp; <a href="#lapinv">LAPINV</a></td>
<td>&nbsp; <a href="#pold">POLD</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#rmk">RMK</a></td>
<td>&nbsp; <a href="#rmk1">RMK1</a></td>
<td>&nbsp; <a href="#rmkd">RMKD</a></td>
<td>&nbsp; <a href="#rmkd1">RMKD1</a></td>
<td>&nbsp; <a href="#pade">PADE</a></td>
<td>&nbsp; <a href="#chebcf">CHEBCF</a></td>
<td>&nbsp; <a href="#chebex">CHEBEX</a></td>
<td>&nbsp; <a href="#chebap">CHEBAP</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#remes">REMES</a></td>
<td>&nbsp; <a href="#fm">FM</a></td>
<td>&nbsp; <a href="#gamma">GAMMA</a></td>
<td>&nbsp; <a href="#gamln">GAMLN</a></td>
<td>&nbsp; <a href="#erf">ERF</a></td>
<td>&nbsp; <a href="#erfc">ERFC</a></td>
<td>&nbsp; <a href="#bj0">BJ0</a></td>
<td>&nbsp; <a href="#bj1">BJ1</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bjn">BJN</a></td>
<td>&nbsp; <a href="#by0">BY0</a></td>
<td>&nbsp; <a href="#bjy0">BJY0</a></td>
<td>&nbsp; <a href="#by1">BY1</a></td>
<td>&nbsp; <a href="#bjy1">BJY1</a></td>
<td>&nbsp; <a href="#byn">BYN</a></td>
<td>&nbsp; <a href="#sphbjn">SPHBJN</a></td>
<td>&nbsp; <a href="#bi0">BI0</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bi1">BI1</a></td>
<td>&nbsp; <a href="#bin">BIN</a></td>
<td>&nbsp; <a href="#bk0">BK0</a></td>
<td>&nbsp; <a href="#bk1">BK1</a></td>
<td>&nbsp; <a href="#bkn">BKN</a></td>
<td>&nbsp; <a href="#dawson">DAWSON</a></td>
<td>&nbsp; <a href="#fermmo5">FERMM05</a></td>
<td>&nbsp; <a href="#ferm05">FERM05</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#ferm15">FERM15</a></td>
<td>&nbsp; <a href="#ferm25">FERM25</a></td>
<td>&nbsp; <a href="#pleg">PLEG</a></td>
<td>&nbsp; <a href="#plm">PLM</a></td>
<td>&nbsp; <a href="#ylm">YLM</a></td>
<td>&nbsp; <a href="#minmax">MINMAX</a></td>
<td>&nbsp; <a href="#polyl1">POLYL1</a></td>
<td>&nbsp; <a href="#linl1">LINL1</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#simpl1">SIMPL1</a></td>
</tr>
</table>


<p>
 C.11 <a href="#Algebraic Eigenvalue Problem">Algebraic Eigenvalue Problem </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#invit">INVIT</a></td>
<td>&nbsp; <a href="#tred2">TRED2</a></td>
<td>&nbsp; <a href="#trbak">TRBAK</a></td>
<td>&nbsp; <a href="#tql2">TQL2</a></td>
<td>&nbsp; <a href="#tridia">TRIDIA</a></td>
<td>&nbsp; <a href="#sturm">STURM</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#tinvit">TINVIT</a></td>
<td>&nbsp; <a href="#herevp">HEREVP</a></td>
<td>&nbsp; <a href="#balanc">BALANC</a></td>
<td>&nbsp; <a href="#balbak">BALBAK</a></td>
<td>&nbsp; <a href="#elmhes">ELMHES</a></td>
<td>&nbsp; <a href="#hqr">HQR</a></td>
</tr>
</table>


<p>
 C.12 <a href="#Ordinary Differential Equations">Ordinary Differential Equations </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#rkm">RKM</a></td>
<td>&nbsp; <a href="#rk4">RK4</a></td>
<td>&nbsp; <a href="#rk2">RK2</a></td>
<td>&nbsp; <a href="#mstep">MSTEP</a></td>
<td>&nbsp; <a href="#adams">ADAMS</a></td>
<td>&nbsp; <a href="#strt4">STRT4</a></td>
<td>&nbsp; <a href="#gear">GEAR</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#extp">EXTP</a></td>
<td>&nbsp; <a href="#fdm">FDM</a></td>
<td>&nbsp; <a href="#gevp">GEVP</a></td>
<td>&nbsp; <a href="#gaublk">GAUBLK</a></td>
<td>&nbsp; <a href="#setmat">SETMAT</a></td>
<td>&nbsp; <a href="#bspode">BSPODE</a></td>
</tr>
</table>


<p>
 C.13 <a href="#Integral Equations">Integral Equations </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#fred">FRED</a></td>
<td>&nbsp; <a href="#fredco">FREDCO</a></td>
<td>&nbsp; <a href="#funk">FUNK</a></td>
<td>&nbsp; <a href="#rls">RLS</a></td>
<td>&nbsp; <a href="#forw">FORW</a></td>
<td>&nbsp; <a href="#volt">VOLT</a></td>
<td>&nbsp; <a href="#volt2">VOLT2</a></td>
</tr>
</table>


<p>
 C.14 <a href="#Partial Differential Equations">Partial Differential Equations </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#crank">CRANK</a></td>
<td>&nbsp; <a href="#lines">LINES</a></td>
<td>&nbsp; <a href="#adm">ADM</a></td>
<td>&nbsp; <a href="#lax">LAX</a></td>
<td>&nbsp; <a href="#sor">SOR</a></td>
<td>&nbsp; <a href="#adi">ADI</a></td>
</tr>
</table>


<p>
   <a href="#Bibliography">Bibliography </a>

<p>


<a name="Introduction"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.1&nbsp; INTRODUCTION </b></td></tr></table><!--hboxt-->

<br />All functions in this appendix are written in ANSI C, and have
been checked to some extent, but the author cannot guarantee their correctness.
<b>Readers are welcome to use these functions at their own risk</b>.
These functions are straightforward translation of corresponding
Fortran subprograms in Appendix&nbsp;B<!--hbox-->.
It should be noted that, these functions are not a substitute for standard
mathematical software, but merely concrete (and straightforward)
examples of implementing numerical
algorithms described in this book. They are only suitable for
solving exercises and simple problems encountered in scientific computations.
Readers are expected to use these functions with `reasonable' inputs.
Passing on arbitrary or invalid input parameters may give unpredictable
results with or without any warning.
These functions can be effectively used to understand the working as well as the
limitations of various numerical algorithms, on different problems.
Apart form the mathematical software libraries a number of software
packages are also available which allow the mathematical problems
to be specified in a convenient form for numerical solution.
These software may also produce incorrect results without
any warning. Thus it is advisable to use only those software
where the user is aware of which technique is actually implemented,
so that their limitations may be known. The programs in the
online material are also provided in the same spirit. They may not
necessarily give the correct result in all cases, but since the
algorithm used is known to the readers, they can modify these
to suit their requirements.

<div class="p"><!----></div>
The functions in this Appendix are all written in ANSI C,
but may require some changes before running them on a new
system. We leave it to the readers to figure out the changes needed to
run the programs on their machines. Since these routines are simple
translation of Fortran programs, they preserve the same variable names
and arguments in most cases. Nevertheless, since there are some basic
differences between C and Fortran this appendix provides an independent
summary of usage for these functions. In this section we outline the
major differences between the C and Fortran programs.

<div class="p"><!----></div>
While in Fortran variable names are not case sensitive, C variable
names are case sensitive. Most of the variables in the C functions
in Appendix&nbsp;C use only lower case characters. However, for constants
and global variables, which may be accessible to more than one
functions, we have used upper case letters to
avoid any possible conflict with local variables in functions.
Nevertheless, in most of comments in programs and in this Appendix, the variables
appear in upper case. There are two main reasons for this, first use
of upper case clearly identifies that the string of characters is
a variable name and helps in understanding and, second it makes it
easier to translate the document from Fortran to C. We hope that this
will not confuse the readers.

<div class="p"><!----></div>
In C all subprogram units are treated as functions which can
return any required value. Hence, we have used this facility to return
the error parameter (IER in Fortran subprograms) as far as possible.
Only in those functions which are supposed to return some other
value the error parameter occurs in argument list. But in almost all cases
the significance and values returned by C functions are same as those
for IER in the corresponding Fortran subprograms.
The argument IER appears explicitly only in functions <a href="appendixc.htm#bspevl"> BSPEVL</a>, <a href="appendixc.htm#bspev2"> BSPEV2</a>, <a href="appendixc.htm#bspevn"> BSPEVN</a>,
<a href="appendixc.htm#bspevn1"> BSPEVN1</a>, <a href="appendixc.htm#bspevn2"> BSPEVN2</a>, <a href="appendixc.htm#bspqd"> BSPQD</a>, <a href="appendixc.htm#bspqd2"> BSPQD2</a>, <a href="appendixc.htm#bspqdn"> BSPQDN</a>, <a href="appendixc.htm#drvt"> DRVT</a>, <a href="appendixc.htm#muler2"> MULER2</a>, <a href="appendixc.htm#secani"> SECANI</a>, <a href="appendixc.htm#splevl"> SPLEVL</a>.
The argument IER or the returned value of the function is used as an error flag.
After execution of the functions this value should be zero if no error has
occurred. Nonzero values indicate some error condition.
Values of IER (or the function) less than 100, usually (but not necessarily)
indicate an error condition, which 
is not very serious and the result may still be useful.
However, further checks may be necessary before accepting the result.
In most of the interpolation and integration functions the returned
value is set to
less than 100 even when it fails to converge to satisfactory
accuracy. This is mainly because in most cases these functions will
still give a reasonable accuracy. But this may not be the case
in exceptional situations, due to singularity, or in case of integration
in large number of dimensions, simply because the number of points
allowed to be used may be completely inadequate.
Even a zero value of error flag does not necessarily imply that the result is correct
as all possible errors are not detected by any of these functions.
Thus additional checks are required in all cases.
But in general one can expect that the result is likely to be correct if error flag is zero.
A value greater than 100, usually
signifies that the execution had to be terminated
because of some serious error, and the result is not likely to be correct.
Of course, there will be many cases where even the results in these
cases are acceptable, but it will need careful analysis.
A few of the functions (e.g., <a href="appendixc.htm#bisect"> BISECT</a>, <a href="appendixc.htm#newrap"> NEWRAP</a>, <a href="appendixc.htm#fred"> FRED</a>,
<a href="appendixc.htm#secani"> SECANI</a>)
return a negative value of error flag under some special
circumstances, even though the execution is successful.
It may be noted that some functions call other functions.
Hence, if error flag is nonzero
the error may have occurred in the secondary functions. In such cases, only
the final value of error flag may be returned.
It may be noted that if an error condition is detected the variable
that is expected to return the required result may contain some
irrelevant value. Hence it is necessary to check the value of IER
after every call to these routines before accepting the result.
The value of IER returned by various functions has been modified since
the first edition was written, to make them more or less unique
between different
functions. In the present version, when IER &gt; 0, in most
cases the first
digit is determined by the topic covered by the function. Thus
the values 1x or 1xx are for linear algebra functions (Chapters 3 and 11),
values 2x or 2xx are for interpolation and differentiation (Chapters 4 and 5),
3x or 3xx for integration (Chapters 6),
4x or 4xx for nonlinear equations (Chapter 7),
5x or 5xx for optimisation (Chapter 8),
6x or 6xx for statistics and approximation (Chapters 9, 10),
7x or 7xx for differential and integral equations (Chapters 12, 13, 14).

<div class="p"><!----></div>
Apart from this C allocates memory dynamically and hence the variables
are not generally preserved between two successive calls to the same
function. In those functions, where the variables need to be preserved
the required variables are declared to be static. Since C also allows
additional memory to be allocated during execution, there is no need
to pass on scratch arrays as required by Fortran 77. Thus the arguments
corresponding to scratch arrays may be missing in C version of the
Fortran subprograms. Similarly, in some cases where the Fortran
subprogram uses an array of fixed size, which limits the parameter
range where the solution can be calculated. This restriction is
not necessary in C functions as the array of required size can be
allocated at run time.

<div class="p"><!----></div>
The main source of confusion between Fortran and C subprograms arises
from the treatment of arrays. While Fortran by default numbers the
array elements of array A(N) from 1 to N, in C functions the array
index varies from 0 to <span class="roman">N</span>&#8722;1. Besides C does not have much
facility to treat multi-dimensional arrays and these are essentially
treated as array of array. But the main difference arises in order in
which elements are stored in the computer memory.
Thus an array of array A[3][3] is stored in the order
A[0][0], A[0][1], A[0][2], A[1][0], A[1][1], A[1][2], A[2][0],
A[2][1], A[2][2]. Which is different from what Fortran will use to store
a two dimensional array. Basically, in Fortran the first dimension
varies most rapidly, while in C the last dimension varies most rapidly
in memory locations. To compound the problems, C does not allow the
dimensions to be passed on as argument to the function since the
dimensions have to be constant. On the other hand, Fortran allows
variable dimensions in subprograms, provided both the array name as
well as the variable defining the dimension also occur in the argument list.
For one-dimensional arrays the dimension information is not important
as it is not required to calculate the memory location of the required
array element. But for two-dimensional arrays it is not possible to
calculate the memory location unless the second dimension is known.
In Fortran we need to know the first dimension. Unfortunately, there
is no straightforward way to pass on this second dimension to a C
function. Thus in all functions in this appendix we treat a multi-dimensional
array as one dimensional array. For example, in the array A[M][N] the element
A[i][j] would be in memory location j+i<span class="roman">N</span> with respect to
the first element. We can refer to this element as A[j+i<span class="roman">N</span>] if
A is simply declared as a one-dimensional array or just the address of
its first element is passed as the argument to function.
We have followed this practice in all functions, where the second
dimension N can be variable.
To calculate this position we need the actual
value of the second dimension N. While in Fortran we will need the
first dimension of array A(M, N) for the same purpose. As a result,
the argument to be passed on to Fortran program will not be same
as that for the corresponding C function. To circumvent this problem
in most cases we have reversed the order of indices in the arrays,
thus an array element A[I][J][K] in C function will correspond to
A(K, J, I) in Fortran subprogram.
The main reason for
this choice is that in many functions it is convenient to assume that
elements are stored in the order determined by Fortran subprogram,
because the order of indices was chosen to satisfy this requirement.
If a different order is used then we may need frequent copying of
elements in another temporary array. Another advantage of this
convention is that the same number has to be passed on to the Fortran
and C programs as array dimension information.

<div class="p"><!----></div>
Only exception we have made is
for the situation where a two dimensional array represents a matrix
stored in the normal format for a linear algebra problem.
In that case A[i][j] still represents
jth column of ith row, which in Fortran is referred to as
A(i,j). For all other arrays the indices are interchanged to
follow the order in which memory is allocated. The main reason for
this exception is that the matrix elements are conventionally
written in this order. Of course, any two-dimensional array can
be treated as a matrix, but we have broken our normal convention
of interchanging indices only when the two dimensional array is
supposed to represent a matrix arising in linear algebra problem
like solving a system of linear equations or the eigenvalue
problem. In the documentation for each function, the order of
indices is spelt out, so hopefully, there would be no confusion on this account.

<div class="p"><!----></div>
Another major shortcoming of C is lack of variables of type complex.
Hence all complex variables need to be treated as arrays of length 2
or as structures and more importantly the arithmetic operations
between these variables need to be defined separately. Most functions
in this Appendix treat complex variables as arrays of length 2, while
in some cases a complex array is treated as two separate arrays
containing the real and imaginary parts. The addition, subtraction
and multiplication
of complex variables is explicitly coded in the functions as
corresponding operation on real and imaginary parts. But other
operations like division, taking absolute value or the square root
require more care to avoid possible problems with roundoff errors or
overflows and underflows. For these operations separate functions
<a href="appendixc.htm#cdiv"> CDIV</a>, <a href="appendixc.htm#cabs"> CABS</a> and <a href="appendixc.htm#csqrt"> CSQRT</a> are provided. A few of the Fortran subprograms
requiring complex arithmetic, namely,
<a href="appendixc.htm#contur"> CONTUR</a>, <a href="appendixc.htm#delves"> DELVES</a>, <a href="appendixc.htm#lagitc"> LAGITC</a>,
<a href="appendixc.htm#newrac"> NEWRAC</a>, <a href="appendixc.htm#polyc"> POLYC</a>, <a href="appendixc.htm#secanc"> SECANC</a> have not been
translated to C. Apart from
CONTUR and DELVES 
all these are complex versions of corresponding routines for
real functions. Apart from these, complex versions of other routines
like those for solution of a system of linear equations
are also not translated. The main reason for this is that
C is probably not designed for complex arithmetic and these routines
are not likely to be required by C programmers.
In principle, it is possible to call Fortran subprograms directly
from a C function and the Fortran version for any of these routines
can be used from a C function.
For calling a
Fortran subprogram from C function all arguments must be passed
through address. Further, in general the Fortran compiler adds some
prefix or suffix of underline character, so the name has to be
modified accordingly.

<div class="p"><!----></div>
All C functions in this appendix assume that variables of type int
are 32 bit integers and all real variables are assumed to be of type
double which is expected to be 64 bits. In most functions 16 bit
integers may be enough, but there are a few functions, where this
will not be sufficient. Similarly, 32 bit real variables (type float)
may be sufficient in many cases but for uniformity all functions
use real variables of type double. On most modern computers the
execution time is not significantly different between 32 bit and
64 bit real variables, but the memory requirements will be doubled
when 64 bits are used instead of 32 bits.

<div class="p"><!----></div>
Many of the functions have a parameter REPS and/or AEPS, which specify
the required
accuracy. Depending on the function this parameter could control either the relative
or the absolute error in the final result. In all cases, some heuristic
convergence test is used to check for convergence of the results.
Consequently, the actual error may not necessarily be smaller than the required
accuracy.
On the other hand, in most of the simple cases, where the convergence is very
rapid the actual error may be an order of magnitude smaller than the
required accuracy.

<div class="p"><!----></div>
In the following sections we give the description of each function
included in the online material and its usage. A brief description of each variable
in the call statement also appears in the program files. Some programs
giving actual examples of usage are also included in the online material.
Functions with an underscore in the names are simple variants of
other functions with the suffix dropped and are not described separately
in this Appendix. For example CASSUM<tt>_</tt>A is a variant of
CASSUM.
These functions are also included in the list
which can be found in the online material.

<div class="p"><!----></div>
 

<br /><br />
<a name="Roundoff Error"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.2&nbsp; ROUNDOFF ERROR </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#cassum">CASSUM</a></td>
<td>&nbsp; <a href="#round">ROUND</a></td>
<td>&nbsp; <a href="#cdiv">CDIV</a></td>
<td>&nbsp; <a href="#cabs">CABS</a></td>
<td>&nbsp; <a href="#csqrt">CSQRT</a></td>
</tr>
</table>


<div class="p"><!----></div>
<br /><br /><a name="cassum"> </a>
 <b>1.&nbsp;CASSUM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/cassum.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/sum.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
  Function to sum N terms of a series using the
cascade sum algorithm. The Ith term is calculated by the
Function TERM(I), which must be supplied by the user.
If the number of terms exceeds
2<sup><span class="roman">N</span><span class="roman">2</span><span class="roman">MAX</span></sup>&nbsp;&nbsp;(=2<sup>30</sup>), then true "binary" sum may not be calculated.
By a simple change as indicated in the program, it is possible to use
this function to sum the terms in an array TERM<!--hbox-->. In that case TERM
should be an array containing the terms to be summed.
Function CASSUM<tt>_</tt>A implements this variation.

<div class="p"><!----></div>
 <br /><br /><a name="round"> </a>
 <b>2.&nbsp;ROUND&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/round.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/round.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to round a real number
X to N digits using base B<!--hbox-->. It is assumed that
&#295; <span class="roman">B</span><sup><span class="roman">N</span></sup> &lt; 1, since
otherwise, the accuracy of computer arithmetic is not sufficient to
give N digits. The returned value of the function should be the
rounded value of X.
This function can be used to simulate calculations
using any required number of digits by rounding intermediate
result after every arithmetic operation.
Since it is fairly expensive to use this function,
it should be used for small problems only.

<div class="p"><!----></div>
 <br /><br /><a name="cdiv"> </a>
 <b>3.&nbsp;CDIV&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/cdiv.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gauswt.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform division for complex numbers.
C1, C2 and CR are all arrays of length 2 containing the real and
imaginary parts of the complex numbers. C1 is the numerator, C2 the
denominator and <span class="roman">CR</span><span class="roman"> = </span><span class="roman">C</span><span class="roman">1</span><span class="roman">/</span><span class="roman">C</span><span class="roman">2</span> is the computed ratio. CR can be
same as either C1 or C2, that is the result can be overwritten on
one of the operands. To avoid overflow or underflow in some cases
the calculations are rearranged as
explained in Eq.&nbsp;(2.34).  
<div class="p"><!----></div>
 <br /><br /><a name="cabs"> </a>
 <b>4.&nbsp;CABS&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/cabs.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gauswt.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate absolute value of a complex
number.  The calculations are
rearranged to avoid overflow or underflow by writing

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">CABS</span>(x+iy)=</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">x<sup>2</sup>+y<sup>2</sup><br /></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
=&#124;w&#124;</td><td align="left" class="cl">
<font size="+2">&nbsp;&nbsp;&#x239B;<br />&#8730;<br /></font></td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
x
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>w<br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
+</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
y
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>w<br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td></tr></table></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.1)</td></tr></table>
</td></tr></table>


where w=max(&#124;x&#124;,&#124;y&#124;). CX is an array of length 2 containing the
real and imaginary parts of the complex number and CABS is the
calculated absolute magnitude. 

<div class="p"><!----></div>
 <br /><br /><a name="csqrt"> </a>
 <b>5.&nbsp;CSQRT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/csqrt.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gauswt.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the square root of a complex
number. The calculations are rearranged as explained above to avoid
overflow or underflow and in addition the correct branch of the
square root function has to be selected. CX and CR are arrays of
length 2 containing the real and imaginary parts of the complex numbers.
CX is the input complex number while CR is the computed value of
&#8730;{<span class="roman">CX</span>}. CR can be same as CX, that is, the result can be
overwritten on the input number.

<div class="p"><!----></div>
 

<br /><br />
<a name="Linear Algebraic Equations"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.3&nbsp; LINEAR ALGEBRAIC EQUATIONS </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#gauelm">GAUELM</a></td>
<td>&nbsp; <a href="#matinv">MATINV</a></td>
<td>&nbsp; <a href="#crout">CROUT</a></td>
<td>&nbsp; <a href="#crouth">CROUTH</a></td>
<td>&nbsp; <a href="#cholsk">CHOLSK</a></td>
<td>&nbsp; <a href="#gaubnd">GAUBND</a></td>
<td>&nbsp; <a href="#svd">SVD</a></td>
<td>&nbsp; <a href="#svdevl">SVDEVL</a></td>
</tr>
</table>

<div class="p"><!----></div>
<br /><br /><a name="gauelm"> </a>
 <b>6.&nbsp;GAUELM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gauelm.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/linear.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a system of N linear equations using
Gaussian elimination with partial pivoting. N is the number of equations
as well as the number of unknown variables. NUM is the number of different
right-hand side vectors, for which the equations are to be solved. 
A is an array of length  
<span class="roman">LJ</span>&times;<span class="roman">N</span> containing the matrix of coefficients.
<span class="roman">A</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span><span class="roman">[</span><span class="roman">J</span><span class="roman">]</span> is
the coefficient of x<sub>j</sub> in the Ith equation. The matrix will be overwritten
by the function. Hence, if it is required afterwards, a separate copy
should be saved. X is an array of length  <span class="roman">LJ</span>&times;<span class="roman">NUM</span>,
containing the right-hand sides of the linear systems. The system will
be solved for each right-hand side vector given by the rows of X<!--hbox-->.
<span class="roman">X</span><span class="roman">[</span><span class="roman">J</span><span class="roman">]</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> should contain the Ith component for the Jth right-hand
side vector. After execution, the array X will contain the required solutions.
Thus the right hand side vectors too will be overwritten by the
function and if they are required afterwards, a separate copy should
be preserved.
DET is an output parameter containing the value of the determinant.
INC is an integer array of length  N, which will contain the pivoting
information after the function is executed. LJ is the actual value of the
second dimension of arrays A and X, as declared in the calling function
(LJ &#8805; <span class="roman">N</span>).
IFLG is an integer parameter which determines the kind of calculations
required. If <span class="roman">IFLG</span> &#8804; 1, the elimination is performed
and IFLG is set to 2, so that next time the elimination is not performed.
For higher values of IFLG it is assumed that elimination has already
been performed, and the matrix A is overwritten by the triangular factors,
while the array INC contains the information about interchanges.
For <span class="roman">IFLG</span> &#8804; 0, both the elimination as well as solution for the
required right-hand sides is calculated. If IFLG=1, then only the elimination
is performed and the value of determinant is calculated. If <span class="roman">IFLG</span> &#8805; 2,
then only the solution for the required right-hand sides is obtained.
It may be noted that the function resets the value of IFLG to 2. Hence,
if it is called again for a different matrix, the value of
IFLG must be set to 0 or 1, to perform elimination for the new matrix.
Error status can be obtained from the
returned value of GAUELM<!--hbox-->. A value of 101 indicates that <span class="roman">N</span> &#8804; 0, or 
<span class="roman">N</span> &gt; <span class="roman">LJ</span>, in which case, no calculations will be performed.
A value of 121 denotes that at some stage of elimination process, the pivot turned
out to be zero, in which case, the calculations are terminated at that stage.
This failure can occur only for matrices which are singular or almost singular.
This error can also arise if the second dimension of the matrix is not
specified correctly.
Note that order of subscripts in X is reverse of
that in the Fortran version, since X is not considered as a matrix.
This is to ensure that same value of LJ can serve as second dimension
for both arrays A and X.
To calculate the inverse of a matrix, the function can be called with 
NUM=<span class="roman">N</span> and array X set to a unit matrix of order N<!--hbox-->.
In this case, the transposed
inverse will be returned in the array X<!--hbox-->. Thus after calculation
we will need to transpose the array X to get the inverse matrix.
This is required because of the order in which matrices are assumed
to be stored in memory.
This function assumes that the
matrix is equilibrated and does not attempt any scaling. The determinant
is calculated in the simple form, which may give overflow or underflow for
some matrices. If the system of equations is ill-conditioned, the results could be
unreliable and the function may not give any indication of the problem.
<a href="appendixc.htm#svd"> SVD</a> should be used to check for ill-conditioning.

<div class="p"><!----></div>
 <br /><br /><a name="matinv"> </a>
 <b>7.&nbsp;MATINV&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/matinv.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/matinv.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the inverse of a square
matrix using Gaussian elimination, with partial pivoting.
N is the order of matrix, IA is the second dimension of arrays A and AI
as specified in the calling function. A is an array of
length <span class="roman">IA</span>&times;<span class="roman">N</span> containing the matrix, which must
be supplied at the time of calling.  AI is an array of
length <span class="roman">IA</span>&times;<span class="roman">N</span> which will contain the inverse of A
as calculated by the function.
Error status can be obtained from the
returned value of MATINV<!--hbox-->. Nonzero values may
be set by function GAUELM, which is used to calculate the inverse.
Instead of <a href="appendixc.htm#gauelm"> GAUELM</a> it is possible to use <a href="appendixc.htm#crout"> CROUT</a> for calculating the
triangular decomposition.

<div class="p"><!----></div>
 <br /><br /><a name="crout"> </a>
 <b>8.&nbsp;CROUT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/crout.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/linear.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a system of N linear equations using
Crout's algorithm for LU decomposition, with partial pivoting. 
N is the number of equations
as well as the number of unknown variables. NUM is the number of different
right-hand side vectors, for which the equations are to be solved. 
A is an array of length
<span class="roman">LJ</span>&times;<span class="roman">N</span>, containing the matrix of coefficients. A[i][j] is
the coefficient of x<sub>j</sub> in ith equation. This matrix will be overwritten
by the function. Hence, if it is required afterwards, a separate copy
should be saved. After execution, A will contain the triangular decomposition of
the original matrix.
X is an array of length  <span class="roman">LJ</span>&times;<span class="roman">NUM</span>,
containing the right-hand sides of the linear systems. The system will
be solved for each right-hand side vector given by the rows of X<!--hbox-->.
X[J][I] should contain the Ith component for the Jth right-hand
side vector. After execution, the array X will contain the required solutions.
Thus if the right-hand side vectors are required afterwards, a separate
copy must be preserved.
DET and IDET are the output parameters containing the value of the determinant
in a scaled form.
The actual value of the determinant is <span class="roman">DET</span>&times;2<sup><span class="roman">IDET</span></sup>.
INC is an integer array of length  N, which will contain the pivoting
information after the function is executed. LJ is the actual value of the
second dimension of arrays A and X, as declared in the calling function
(LJ &#8805; <span class="roman">N</span>).
IFLG is an integer parameter which determines the kind of calculations
required. If <span class="roman">IFLG</span> &#8804; 1, the LU decomposition is performed
and IFLG is set to 2, so that next time the triangular decomposition is not performed.
For higher values of IFLG, it is assumed that LU decomposition has already
been performed, and the matrix A is overwritten by the triangular factors,
while the array INC contains the information about interchanges.
For <span class="roman">IFLG</span> &#8804; 0, both the LU decomposition as well as the solution for the
required right-hand sides are obtained. If IFLG=1, then only LU decomposition
is performed and the value of determinant is calculated. If <span class="roman">IFLG</span> &#8805; 2,
then only the solution for the required right-hand sides are obtained.
It may be noted that, the function resets the value of IFLG to 2. Hence,
if it is called again for a different matrix, the value of
IFLG must be set to 0 or 1, to perform LU decomposition for the new matrix.
Error status can be obtained from the
returned value of CROUT<!--hbox-->. A value of 102 indicates that <span class="roman">N</span> &#8804; 0, or 
<span class="roman">N</span> &gt; <span class="roman">LJ</span>, in which case, no calculations will be performed.
A value of 122 denotes that at some stage of LU decomposition the pivot turned
out to be zero, in which case, the calculations are terminated at that stage.
This failure can occur only for matrices which are singular or almost singular.
To calculate the inverse of a matrix, the function can be called with 
NUM=<span class="roman">N</span> and array X set to a unit matrix of order N<!--hbox-->.
In this case, the transposed
inverse will be returned in the array X<!--hbox-->. Thus after calculation
we will need to transpose the array X to get the inverse matrix.
This is required because of the order in which matrices are assumed
to be stored in memory.
This function implements implicit
scaling of rows as explained in Section 3.3. If the system of equations is ill-conditioned, the results could be
unreliable and the function may not give any indication of the problem.
<a href="appendixc.htm#svd"> SVD</a> should be used to check for ill-conditioning.

<div class="p"><!----></div>
 <br /><br /><a name="crouth"> </a>
 <b>9.&nbsp;CROUTH&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/crouth.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/linear.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a system of N linear equations using
the technique of iterative refinement and the Crout's algorithm for 
LU decomposition with partial pivoting.
N is the number of equations
as well as the number of unknown variables. NUM is the number of different
right-hand side vectors, for which the equations are to be solved. 
A is an array of length  
<span class="roman">LJ</span>&times;<span class="roman">N</span>, containing the matrix of coefficients.
A[I][J] is
the coefficient of x<sub>J</sub> in Ith equation. The matrix will be preserved
by the function. B is an array of the same dimensions as A<!--hbox-->. 
After execution, B will contain the triangular decomposition of
the original matrix.
X is an array of length  <span class="roman">LJ</span>&times;<span class="roman">NUM</span>,
containing the right-hand sides of the linear systems. The system will
be solved for each right-hand side vector given by the rows of X<!--hbox-->.
X[J][I] should contain the Ith component for the Jth right-hand
side vector. After execution, the array X will contain the required solutions.
DET and IDET are the output parameters containing the value of the determinant
in a scaled form.
The actual value of the determinant will be <span class="roman">DET</span>&times;2<sup><span class="roman">IDET</span></sup>.
INC is an integer array of length  N, which will contain the pivoting
information after the function is executed. LJ is the actual value of the
second dimension of arrays A, B and X, as declared in the calling function
(LJ &#8805; <span class="roman">N</span>).
REPS is the required relative accuracy, to which the iterative refinement is
required. The iteration is terminated when the maximum change in any component
of the solution is less than REPS times the maximum component of the solution
vector.  REPS should be
greater than &#295; for the arithmetic used.
It should be noted that convergence of iteration does not guarantee
that the solution is accurate to the specified level. A reasonable estimate
of error is provided by WK[J] for the Jth right-hand side. However,
for extremely ill-conditioned matrices, it may underestimate the error.
IFLG is an integer parameter which determines the kind of calculations
required. If <span class="roman">IFLG</span> &#8804; 1, the LU decomposition is performed
and IFLG is set to 2, so that next time the LU decomposition is not performed.
For higher values of IFLG, it is assumed that LU decomposition has already
been performed and the array B contains the triangular factors,
while the array INC contains the information about interchanges.
For <span class="roman">IFLG</span> &#8804; 0, both the LU decomposition as well as solution for the
required right-hand sides are obtained. If IFLG=1, then only the LU decomposition
is performed and the value of determinant is calculated. If <span class="roman">IFLG</span> &#8805; 2,
then only the solution for the required right-hand sides are obtained.
It may be noted that the function resets the value of IFLG to 2. Hence,
if it is called again for a different matrix, the value of
IFLG must be set to 0 or 1, to perform LU decomposition for the new matrix.
WK is an array of length NUM.
After execution, WK[I] will contain the estimated error for the Ith
right-hand side.
Error status can be obtained from the returned value of CROUTH<!--hbox-->.
A value of 11 implies that the iterative refinement did not converge
to the specified accuracy.
This failure can
occur if the system of equations is extremely ill-conditioned, or if the specified
value of REPS is too low, or if the residues are accumulated using the 
same level of precision as all other calculations.
To avoid this the variable D1 should generally be of higher precision
than other variables. If the compiler supports long double arithmetic, D1
should be declared so. 
If the matrix is ill-conditioned, increasing NITR may cause the iteration
to converge, but the result is unlikely to be more reliable.
Returned value of 102 indicates that <span class="roman">N</span> &#8804; 0 or 
<span class="roman">N</span> &gt; <span class="roman">LJ</span>, in which case, no calculations will be performed.
Returned value of 122 denotes that at some stage of LU decomposition, the pivot turned
out to be zero, in which case, the calculations are terminated at that stage.
This failure can occur only for matrices which are singular or almost singular.
This function requires <a href="appendixc.htm#crout"> CROUT</a> to perform the LU decomposition
and to calculate
solution of resulting equations for a given right-hand side vector.
To calculate the inverse of a matrix, the function can be called with 
NUM=<span class="roman">N</span> and array X set to a unit matrix of order N<!--hbox-->.
In this case, the transposed
inverse will be returned in the array X<!--hbox-->. 
If the system of equations is extremely ill-conditioned, the results could be
unreliable and the function may not give any indication of problem.
However, in most cases, WK[I] will give a reasonable estimate of the actual error.
This function should give correctly rounded solution to the system as
represented in the computer, provided the system is not too ill-conditioned
for the precision of arithmetic used in the calculations.
It may be noted that for iterative refinement to converge it may be
necessary to calculate the residuals using higher precision arithmetic
as compared to that used for solution. Otherwise, the solution may not
converge. For this purpose the variable D1 should have higher precision
as compared to other variables.

<div class="p"><!----></div>
 <br /><br /><a name="cholsk"> </a>
 <b>10.&nbsp;CHOLSK&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/cholsk.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/linear.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a system of N linear equations
with a real symmetric positive definite matrix using Cholesky decomposition.
N is the number of equations
as well as the number of unknown variables. NUM is the number of different
right-hand side vectors, for which the equations are to be solved. 
A is an array of length
<span class="roman">ND</span>&times;<span class="roman">N</span>, containing the matrix of coefficients. A[I][J] is
the coefficient of x<sub>J</sub> in Ith equation. Only the lower triangular
part of the matrix may be used by the function, though the memory is
reserved for the full array.
This matrix will be overwritten
by the function. Hence, if it is required afterwards, a separate copy
should be saved. After execution, A will contain the Cholesky decomposition of
the original matrix in its lower triangular part.
X is an array of length  <span class="roman">ND</span>&times;<span class="roman">NUM</span>,
containing the right-hand sides of the linear systems. The system will
be solved for each right-hand side vector given by the rows of X<!--hbox-->.
X[J][I] should contain the Ith component for the Jth right-hand
side vector. After execution, the array X will contain the required solutions.
DET is the output parameter containing the value of the determinant.
ND is the actual value of the
second dimension of arrays A and X, as declared in the calling function
(ND &#8805; <span class="roman">N</span>).
IFLG is an integer parameter which determines the kind of calculations
required. If <span class="roman">IFLG</span> &#8804; 1, the triangular decomposition is performed
and IFLG is set to 2, so that next time the triangular decomposition is not performed.
For higher values of IFLG, it is assumed that the Cholesky
decomposition has already
been performed, and the matrix A is overwritten by the triangular factor.
For <span class="roman">IFLG</span> &#8804; 0, both the decomposition as well as the solution for the
required right-hand sides are obtained. If IFLG=1, then only decomposition
is performed and the value of determinant is calculated. If <span class="roman">IFLG</span> &#8805; 2,
then only the solution for the required right-hand sides are obtained.
It may be noted that, the function resets the value of IFLG to 2. Hence,
if it is called again for a different matrix, the value of
IFLG must be set to 0 or 1, to perform Cholesky decomposition for the new matrix.
Error status can be obtained from the returned value of CHOLSK<!--hbox-->.
A value of 103 indicates that <span class="roman">N</span> &#8804; 0, or 
<span class="roman">N</span> &gt; <span class="roman">ND</span>, in which case, no calculations will be performed.
CHOLSK=123 denotes that at some stage of Cholesky decomposition
the pivot turned
out to be zero, in which case, the calculations are terminated at that stage.
This failure can occur if the triangular decomposition does not
exist without pivoting or if the matrix is not positive definite or if
it is almost singular.
To calculate the inverse of a matrix, the function can be called with 
NUM=<span class="roman">N</span> and array X set to a unit matrix of order N<!--hbox-->.
In this case, the transposed
inverse will be returned in the array X<!--hbox-->.
If the system of equations is ill-conditioned, the results could be
unreliable and the function may not give any indication of the problem.

<div class="p"><!----></div>
 <br /><br /><a name="gaubnd"> </a>
 <b>11.&nbsp;GAUBND&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gaubnd.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gaubnd.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a system of N linear equations using
Gaussian elimination with partial pivoting for a band matrix.
The matrix is stored in the band form as explained below.
N is the number of equations
as well as the number of unknown variables. KB is the bandwidth of
the matrix, that is, a<sub>ij</sub>=0, if &#124;i&#8722;j&#124; &gt; <span class="roman">KB</span>.
NUM is the number of different
right-hand side vectors, for which the equations are to be solved. 
A is an array of length  
<span class="roman">LJ</span>&times;(3<span class="roman">KB</span>+1) containing the matrix of coefficients
which is stored in the band form.
<span class="roman">A</span><span class="roman">[</span><span class="roman">J</span>&#8722;<span class="roman">I</span><span class="roman">+</span><span class="roman">KB</span><span class="roman">]</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> is
the coefficient of x<sub>J</sub> in the Ith equation. It may be noted that
if KB is comparable to N, then the band form will require larger
storage than the simple form of storing the matrix and no purpose will
be served by using this function instead of <a href="appendixc.htm#gauelm"> GAUELM</a><!--hbox-->.
The matrix A will be overwritten
by the function. Hence, if it is required afterwards, a separate copy
should be saved. X is an array of length  <span class="roman">LJ</span>&times;<span class="roman">NUM</span>,
containing the right-hand sides of the linear systems. The system will
be solved for each right-hand side vector given by the rows of X<!--hbox-->.
X[J][I] should contain the Ith component for the Jth right-hand
side vector. After execution, the array X will contain the required solutions.
DET and IDET are the output parameters containing the value of the determinant
in a scaled form.
The actual value of the determinant is <span class="roman">DET</span>&times;2<sup><span class="roman">IDET</span></sup>.
INC is an integer array of length  N, which will contain the pivoting
information after the function is executed. LJ is the actual value of the
second dimension of arrays A and X, as declared in the calling function
(LJ &#8805; <span class="roman">N</span>).
IFLG is an integer parameter which determines the kind of calculations
required. If <span class="roman">IFLG</span> &#8804; 1, elimination is performed
and IFLG is set to 2, so that next time the elimination is not performed.
For higher values of IFLG it is assumed that elimination has already
been performed, and the matrix A is overwritten by the triangular factors,
while the array INC contains the information about interchanges.
For <span class="roman">IFLG</span> &#8804; 0, both the elimination as well as solution for the
required right-hand sides is calculated. If IFLG=1, then only the elimination
is performed and the value of determinant is calculated. If <span class="roman">IFLG</span> &#8805; 2,
then only the solution for the required right-hand sides is obtained.
For IFLG=&#8722;1, both elimination and solution are calculated
without pivoting and IFLG is set to 2. This option can be used if
the matrix is known to be diagonally dominant and pivoting is not
necessary.
It may be noted that the function resets the value of IFLG to 2. Hence,
if it is called again for a different matrix, the value of
IFLG must be set to 0 or 1 or &#8722;1, to perform elimination for the new matrix.
Error status can be obtained from the
returned value of GAUBND<!--hbox-->. A value of 104 indicates that <span class="roman">N</span> &#8804; 0, or 
<span class="roman">N</span> &gt; <span class="roman">LJ</span> or <span class="roman">KB</span> &gt; <span class="roman">N</span>, in which case,
no calculations will be performed.
GAUBND=124 implies that at some stage of elimination process, the pivot turned
out to be zero, in which case, the calculations are terminated at that stage.
This failure can occur only for matrices which are singular or almost singular.
To calculate the inverse of a matrix, the function can be called with 
NUM=<span class="roman">N</span> and array X set to a unit matrix of order N<!--hbox-->.
In this case, the transposed
inverse will be returned in the array X<!--hbox-->.
The inverse of a band matrix will in general not be banded and full
storage will be required to store the inverse.
This function assumes that the
matrix is equilibrated and does not attempt any scaling.
If the system of equations is ill-conditioned, the results could be
unreliable and the function may not give any indication of the problem.

<div class="p"><!----></div>
 <br /><br /><a name="svd"> </a>
 <b>12.&nbsp;SVD&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/svd.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/linear.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform the singular value decomposition of
a <span class="roman">M</span>&times;<span class="roman">N</span> matrix, A=U&#931;V<sup>T</sup> (<span class="roman">M</span> &#8805; <span class="roman">N</span>).
This function is
based on the procedure <i>svd</i>  in Wilkinson and Reinsch&nbsp;(1971).
A is an array of length
<span class="roman">LA</span>&times;<span class="roman">M</span> containing the matrix. After execution, the matrix U
of SVD will be overwritten on A<!--hbox-->. V is an array of length 
<span class="roman">LV</span>&times;<span class="roman">N</span>, which will contain the matrix V (not V<sup>T</sup>)
of SVD<!--hbox-->. SIGMA is an
array of length  N, which will contain the singular values of
A, i.e., the diagonal elements of the diagonal matrix &#931;. The singular
values may not be arranged in a descending order. LA is the integer variable
specifying the actual value of the second dimension of array A in the calling
function (LA &#8805; <span class="roman">N</span>).
Similarly, LV is the actual value of the second dimension of array
V in the calling function (LV &#8805; <span class="roman">N</span>).
The matrices A and V are stored in normal form with first index denoting
the row. In principle, LA and LV could be equal and one of them would
be enough, but for compatibility with Fortran version two different
values are provided.
Error status can be obtained from the
returned value of SVD<!--hbox-->. A value of 12
implies that the QR iteration used for finding SVD of the bidiagonal 
form did not converge to the required accuracy. In this case, the last value
is accepted and calculations are continued. 
This situation will generally arise only if parameter EPS is too low for the arithmetic used.
The specified value is suitable for 53-bit arithmetic.
For use with lower precision arithmetic EPS may need to be increased.
If a reasonable value of EPS is specified, then it normally requires only
two or three iterations for each singular value, as compared to the maximum number
of iterations <span class="roman">ITMAX</span>=30.
SVD=105 denotes that <span class="roman">N</span> &#8804; 0, or <span class="roman">N</span> &gt; <span class="roman">LV</span>, or <span class="roman">N</span> &#8804; 0,
or <span class="roman">M</span> &gt; <span class="roman">LA</span>, or <span class="roman">N</span> &gt; <span class="roman">M</span>, in which case, no calculations are performed.

<div class="p"><!----></div>
 <br /><br /><a name="svdevl"> </a>
 <b>13.&nbsp;SVDEVL&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/svdevl.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/linear.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to evaluate the solution of a system of
linear equations
using the SVD (<b>x</b>=V&#931;<sup>&#8722;1</sup>U<sup>T</sup><b>b</b>). 
This function assumes that SVD is already performed.
N is the number of variables in the linear system, while M is the 
number of equations. U is an array of size  <span class="roman">LU</span>&times;<span class="roman">M</span>
containing the left-hand transformation matrix in SVD<!--hbox-->. V is an array of length
<span class="roman">LV</span>&times;<span class="roman">N</span> containing the right-hand transformation matrix in
SVD<!--hbox-->. SIGMA is an array of length  N, containing the singular
values. The singular values need not be arranged in any definite order.
LU and LV are the actual values of the second dimension of arrays
U and V respectively,
in the calling function. B is an array of length M containing
the right-hand side vector. After execution,
B will contain the required solution.
REPS specifies the required accuracy
for zeroing the singular values. If &#963;<sub>i</sub> &lt; <span class="roman">REPS</span>&times;max(&#963;<sub>j</sub>),
then the corresponding &#963;<sub>i</sub><sup>&#8722;1</sup> is set to zero while calculating
the solution. For a square matrix, where none of the singular values are
reduced to zero, this function gives the unique solution. If some of the singular
values are reduced to zero, it gives solution with minimum norm to which any
arbitrary combination of columns of V corresponding to zero &#963;<sub>i</sub>
can be added, to get the general solution. If any of the singular values
are reduced to zero the routine will give the least squares solution
unless the right hand side is in the range of the matrix. The right hand
side is in the range if it is orthogonal to all columns of U corresponding
to singular values which have been reduced to zero.
For over-determined systems
(<span class="roman">M</span> &gt; <span class="roman">N</span>), this function gives the least squares solution (with minimum
norm if some of the singular values are reduced to zero). Before using
this function, the singular value decomposition should be computed using
the function <a href="appendixc.htm#svd"> SVD</a><!--hbox-->. It should be noted that, the function SVD overwrites the
matrix U on the original matrix A. The returned value SVDEVL is
always zero.

<div class="p"><!----></div>
 

<br /><br />
<a name="Interpolation"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.4&nbsp; INTERPOLATION </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#divdif">DIVDIF</a></td>
<td>&nbsp; <a href="#divdif0">DIVDIF0</a></td>
<td>&nbsp; <a href="#nearst">NEARST</a></td>
<td>&nbsp; <a href="#spline">SPLINE</a></td>
<td>&nbsp; <a href="#splevl">SPLEVL</a></td>
<td>&nbsp; <a href="#smooth">SMOOTH</a></td>
<td>&nbsp; <a href="#bsplin">BSPLIN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bspint">BSPINT</a></td>
<td>&nbsp; <a href="#bspevl">BSPEVL</a></td>
<td>&nbsp; <a href="#ratnal">RATNAL</a></td>
<td>&nbsp; <a href="#poly2">POLY2</a></td>
<td>&nbsp; <a href="#linrn">LINRN</a></td>
<td>&nbsp; <a href="#locate">LOCATE</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bspint2">BSPINT2</a></td>
<td>&nbsp; <a href="#bspev2">BSPEV2</a></td>
<td>&nbsp; <a href="#bspintn">BSPINTN</a></td>
<td>&nbsp; <a href="#bspevn">BSPEVN</a></td>
<td>&nbsp; <a href="#bspevn1">BSPEVN1</a></td>
<td>&nbsp; <a href="#bspevn2">BSPEVN2</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="divdif"> </a>
 <b>14.&nbsp;DIVDIF&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/divdif.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/interp.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function for interpolation using the Newton's
divided difference formula. XB is the x value at which interpolated value is
required. NTAB is the number of entries in the table.
Arrays X and F of length NTAB contain the abscissas and the
function values at the corresponding points. The array X must contain
abscissas in either ascending or descending order.
NUSE specifies the maximum
number of points to be used for interpolation. If NUSE is larger than
NTAB, or the parameter NMAX in the function, then it will be reduced
to the minimum of these three numbers and the error flag DIVDIF
will be set to 22. If NUSE is less than 1, it will be set to MIN(6, NTAB) and
DIVDIF will be set to 21. In all cases, after execution, NUSE will contain the
number of points actually used. Thus for subsequent calls NUSE must be
reset to the required value before call.
FB is the output array of length NUSE+1 which will contain the
interpolated values. FB[I] gives the interpolated value using I points,
and FB[NUSE] gives the final value. It may be noted that the first
element FB[0] is not used to avoid confusion with the index.
AEPS specifies the required accuracy.
Interpolation is continued, until two successive values
differ by less than AEPS<!--hbox-->. If AEPS &#8804; 0, then this convergence criterion will
never be satisfied.
DFB and DDFB are output parameters
containing the first and second derivative at the same point XB<!--hbox-->.
Error status can be obtained from the
returned value of DIVDIF<!--hbox-->. A value of 21
implies that NUSE &lt; 1, in which case it is set to MIN(6, NTAB).
DIVDIF=22 implies that NUSE &gt; NTAB, or
NUSE &gt; NMAX, in which case it is reduced appropriately.
DIVDIF=23 implies that the interpolation has not converged
to the specified accuracy.
It should be noted that the convergence criterion only checks for
convergence of interpolated value and not the derivatives. Hence, the
error in computed derivatives may be much larger. In particular,
if the derivative is required at one of the tabular points, then
AEPS should be set to zero, since otherwise the interpolated value
will converge immediately and execution will be terminated with
a very crude estimate for the derivatives.
If the derivatives are not required, then function DIVDIF0 may be used.
This function requires the function <a href="appendixc.htm#nearst"> NEARST</a>.

<div class="p"><!----></div>
 <br /><br /><a name="divdif0"> </a>
 <b>15.&nbsp;DIVDIF0&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/divdif0.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/poly2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function for interpolation using the Newton's
divided difference formula. This is a simplified version of <a href="appendixc.htm#divdif"> DIVDIF</a>
which avoids derivative calculation and has a flag to decide whether
the first point for interpolation should be chosen from the nearest value
in table or another point specified by the user. This flag may be
useful if the function is used to calculate interpolation
in higher dimensions.
XB is the x value at which interpolated value is
required. NTAB is the number of entries in the table.
Arrays X and F of length NTAB contain the abscissas and the
function values at the corresponding points. The array X must contain
abscissas in either ascending or descending order.
NUSE specifies the maximum
number of points to be used for interpolation. If NUSE is larger than
NTAB, or the parameter NMAX in the function, then it will be reduced
to the minimum of these three numbers and the error flag DIVDIF0
will be set to 22. If NUSE is less than 1, it will be set to MIN(6, NTAB) and
DIVDIF0 will be set to 21. In all cases, after execution, NUSE will contain the
number of points actually used. Thus for subsequent calls NUSE must be
reset to the required value before call.
FB is the output array of length NUSE+1 which will contain the
interpolated values. FB[I] gives the interpolated value using I points,
and FB(NUSE) gives the final value. The first element FB[0] is not
used to avoid confusion.
AEPS specifies the required accuracy.
Interpolation is continued, until two successive values
differ by less than AEPS<!--hbox-->. If AEPS &#8804; 0, then this convergence criterion will
never be satisfied.
IFLG is an integer variable used as a flag to decide the first point
to be used for interpolation. If IFLG=0 then the nearest point in the
table is used to start interpolation. For other values of IFLG a
user supplied value (IF1) is used, provided that it is admissible
(0 &#8804; IF1 &#8804; NTAB&#8722;1). IF1 specifies the first point
to be used for interpolation when IFLG &#8800; 0. For IFLG=0
the function uses the nearest point in that table and the value
of IF1 is set to index of this point, so that next time we can use
the same point if the interpolation in required at same XB with 
different F values. This situation arises if this function is used
for interpolation in more than one variables.
Error status can be obtained from the
returned value of DIVDIF0<!--hbox-->. A value of 21
implies that NUSE &lt; 1, in which case it is set
to MIN(6, NTAB).
DIVDIF0=22 implies that NUSE &gt; NTAB, or
NUSE &gt; NMAX, in which case it is reduced appropriately.
DIVDIF0=23 implies that the interpolation has not converged
to the specified accuracy.
This function requires the function <a href="appendixc.htm#nearst"> NEARST</a>.

<div class="p"><!----></div>
 <br /><br /><a name="nearst"> </a>
 <b>16.&nbsp;NEARST&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/nearst.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/interp.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to locate the nearest value in an
ordered table using a bisection algorithm.
X is an array containing the table with NTAB entries in either ascending or
descending order. After execution, X[NEARST] will be the point nearest to XB<!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="spline"> </a>
 <b>17.&nbsp;SPLINE&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/spline.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/interp.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the coefficients of cubic spline
interpolation with not-a-knot boundary conditions using N tabular points.
Arrays X and F of length N should contain the input data.
F[I] should contain the function value at X[I].
The array X must be in ascending or descending order. After execution,
array C of length 3&times;<span class="roman">N</span>, will contain the coefficients of cubic spline.
If XB is between X[I] and X[<span class="roman">I</span>+1], (0 &#8804; <span class="roman">I</span> &lt; <span class="roman">N</span>&#8722;1) the interpolant
is given by  <tt>F[I]+DX*(C[I][0]+DX*(C[I][1]+DX*C[I][2]))</tt>, where
<span class="roman">DX</span><span class="roman"> = </span><span class="roman">XB</span>&#8722;<span class="roman">X</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>.
Error status can be obtained from the
returned value of SPLINE<!--hbox-->. A value of 201
implies that the number of points is less
than 2. If the number of points is 2, linear interpolation will be used,
while for <span class="roman">N</span>=3 quadratic interpolation will be used.
For higher values of N, cubic spline interpolation with not-a-knot
boundary conditions is calculated.

<div class="p"><!----></div>
 <br /><br /><a name="splevl"> </a>
 <b>18.&nbsp;SPLEVL&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/splevl.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/interp.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function for evaluating the cubic spline interpolant at
XB, using the coefficients of cubic spline which have been calculated by the
function <a href="appendixc.htm#spline"> SPLINE</a><!--hbox-->. This function first locates the subinterval containing
the required point XB, using the technique described in Section&nbsp;4.2. N is the number of data points.
X and F are arrays of length N containing the data points,
F[I] is the tabulated function value at X[I].
C is an array of length 3&times;<span class="roman">N</span> containing the coefficients of cubic spline.
The array X must be in ascending or descending order.
DFB and DDFB are output parameters containing the first and second derivatives
of the tabulated function
at x=<span class="roman">XB</span>. IER is the error parameter.
IER=24 implies that XB is outside the
range of table on the higher side, in which case, the cubic for last
subinterval will be used. IER=25 implies that XB is outside the range on the
lower side, in which case, the cubic for the first subinterval will be used.
It may be noted that spline interpolation is extremely unreliable outside
the range of table and resulting value may have large errors.
For extrapolation, it may be better to use polynomial interpolation
with function <a href="appendixc.htm#divdif"> DIVDIF</a>, though it also has limitations.
IER=201 implies that <span class="roman">N</span> &lt; 2.
SPLEVL will return the interpolated value of the function at XB<!--hbox-->.
Before using this function, the coefficients
of cubic spline must be calculated using function <a href="appendixc.htm#spline"> SPLINE</a> or any other
equivalent function.

<div class="p"><!----></div>
 <br /><br /><a name="smooth"> </a>
 <b>19.&nbsp;SMOOTH&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/smooth.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/smooth.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to draw a smooth curve passing through a set of
data points using cubic spline interpolation.
X and F are arrays of length NTAB containing the given data points,
C is an array of length 3&times;<span class="roman">NTAB</span>, which will contain the coefficients
of cubic spline. The array X must be in either ascending or descending
order.
This function will calculate the interpolated value of
the function at NP uniformly spaced points in the interval spanned by the
tabular points. XP and FP should be arrays of length NP which will contain the
X  and F values for the uniformly spaced output table. If NP is sufficiently
large, the output arrays XP and FP can be used to plot a smooth curve through
the given points. It may be noted that this function does not actually
plot the curve but only generates data that can be used to get a
smooth plot through the data points. If additional smoothing is required
and the curve is not required to pass through data points then a
least squares approximation should be used to generate the points
using function <a href="appendixc.htm#bspfit"> BSPFIT</a> instead of <a href="appendixc.htm#spline"> SPLINE</a><!--hbox-->.
Error status can be obtained from the
returned value of SMOOTH<!--hbox-->. A value of 202
implies that <span class="roman">NP</span> &lt; 2. Other values may be set by
function SPLINE which is called to calculate the spline coefficients.
This function requires functions SPLINE
and <a href="appendixc.htm#splevl"> SPLEVL</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="bsplin"> </a>
 <b>20.&nbsp;BSPLIN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bsplin.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/interp.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the B-spline basis functions
at a specified point. X is an array of size NX containing the knots.
The knots must be in ascending order and distinct.
NX is the number of knots. K is the order
of B-spline, <span class="roman">K</span>=4 implies cubic B-splines, while <span class="roman">K</span>=2 gives linear
B-splines, etc. XB is the point at which B-splines need to be evaluated.
NDERIV specifies the number of derivatives to be calculated,
for NDERIV &#8804; 0 only the B-splines will be calculated.
For NDERIV=1, the first derivative of B-splines will also be calculated.
For NDERIV &gt; 1, the second derivative will also be calculated.
Higher derivatives are not calculated, but the function can be modified
to include calculation of higher derivatives.
B, DB and DDB are arrays of length <span class="roman">NX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2 which will contain the
values of B-splines, its first and second derivative respectively.
All <span class="roman">NX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2 basis functions and if required the derivatives are
calculated simultaneously using the recurrence relations.
Even if derivatives are not required the arrays with required size
must be supplied.
This function first locates the subinterval containing
the required point XB, using the technique described in Section&nbsp;4.2. LEFT is an output variable which will give the location of XB in the
table of knots, i.e., X[LEFT] &#8804; XB &#8804; X[LEFT+1].
Error status can be obtained from the
returned value of BSPLIN<!--hbox-->. A value of 26
implies that the required
point is outside the table on higher side. BSPLIN=27 implies that the
required point, XB is outside the range of table on lower side.
In both these cases the basis functions will be calculated using
the same recurrence relations, but the results may not be useful.
BSPLIN=203 implies that <span class="roman">NX</span> &lt; 2 or <span class="roman">K</span> &lt; 1,
in which case no calculations are done. The parameter KMAX
in the function can be trivially increased, but such high order
splines may not be meaningful.

<div class="p"><!----></div>
 <br /><br /><a name="bspint"> </a>
 <b>21.&nbsp;BSPINT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspint.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/interp.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the coefficients for
B-spline interpolation to a table of values. N is the number of
points in the table, X and F are arrays of length N, specifying
the abscissas and function values. The abscissas X must be unique
and in ascending order. F[I] is the tabulated function value at X[I].
K is the order of B-spline
interpolation required.
<span class="roman">K</span>=4 implies cubic B-splines, while <span class="roman">K</span>=2 gives linear B-splines, etc.
A is an array of length LA&times;3<span class="roman">K</span>, which will contain the triangular
decomposition of the matrix of equations
that is solved to calculate the coefficients of expansion. Since
the matrix is in band form with bandwidth <span class="roman">K</span>&#8722;1, it is stored in
band form. This matrix will be required if another interpolation
with same set of knots is required with different F<!--hbox-->. This is useful
in B-spline interpolation in higher dimensions. LA is the second
dimension of A as specified in the calling function (LA &#8805; <span class="roman">N</span>).
C is an array
of length N, which will contain the coefficients of B-spline
basis functions in expansion for interpolation. XF is an array
of size NO, which will contain the knots used for B-spline definition.
Since the number of B-spline basis functions
with NO knots is <span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, some tabular points may have to be dropped
to ensure that <span class="roman">N</span><span class="roman">=</span><span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2. This is equivalent to using the not-a-knot
boundary condition in cubic spline. The number of points to be dropped
depends on K<!--hbox-->. In all cases some points near both ends are dropped.
For linear B-splines, <span class="roman">K</span>=2 all points are used.
NO is the number of knots used for B-spline interpolation, this would
be equal to <span class="roman">N</span>+2&#8722;<span class="roman">K</span>. IFLG is an integer variable that specifies what
calculation is to be done. For IFLG &#8804; 1 the matrix is calculated
and its triangular decomposition is computed. If execution is
successful, IFLG will be set to 2, so that next time the matrix
calculations will be skipped. If IFLG &#8804; 0 the coefficients of
expansion are also calculated. If IFLG=&#8722;1, the system of equations
will be solved without pivoting. This option may not be used as
the coefficient matrix may not be diagonally dominant and some
pivot may turn out to be zero.
If IFLG=2, only the coefficients of
expansion will be calculated using the old triangular decomposition
available in A and the (hopefully new) function values F<!--hbox-->.
INC is an integer array of length N, which will contain the pivoting
information for solution of system of linear equations. This array
will be required if another interpolation with same knots is needed.
Error status can be obtained from the
returned value of BSPINT<!--hbox-->. A value of 204 implies
<span class="roman">N</span> &lt; <span class="roman">K</span> or <span class="roman">K</span> &lt; 2, in which
case no calculations are done. Other values may be set by functions
BSPLIN or GAUBND, which are called. This function requires
function <a href="appendixc.htm#bsplin"> BSPLIN</a> to calculate the B-spline basis functions and 
function <a href="appendixc.htm#gaubnd"> GAUBND</a> to solve the system of linear equations with a
band matrix. The interpolant at any required point
can be calculated using function <a href="appendixc.htm#bspevl"> BSPEVL</a>, using the calculated
coefficients of expansion.

<div class="p"><!----></div>
 <br /><br /><a name="bspevl"> </a>
 <b>22.&nbsp;BSPEVL&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspevl.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/interp.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To calculate the value of
function using available coefficients of B-spline expansion.
The calculated value is given by:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">BSPEVL</span>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">WT</span>[i] &#981;<sub>i</sub>(<span class="roman">X</span><span class="roman">0</span>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.2)</td></tr></table>
</td></tr></table>


where &#981;<sub>i</sub> are the B-spline basis functions.
It can be used to calculate the interpolated value of the function,
if the coefficients are already calculated using BSPINT<!--hbox-->.
N is the number of knots, which may not be the same as the number of
points in the table for interpolation. X is an array of
length N containing the knots for B-splines.
X[0] should contain the first knot and the knots must be distinct
and in ascending order.
K is the order of B-splines,
<span class="roman">K</span>=2 gives linear B-splines, while <span class="roman">K</span>=4 yields cubic B-splines, etc.
NDERIV specifies the number of derivatives to be calculated.
For NDERIV &#8804; 0 only the function value will be calculated.
For NDERIV=1, the first derivative is also calculated.
For NDERIV &gt; 1, the second derivative will also be calculated.
WT is the array of length N, containing the coefficients of
expansion in terms of B-spline basis functions. These coefficients
must be calculated beforehand using <a href="appendixc.htm#bspint"> BSPINT</a> or any other equivalent
function for B-spline approximations.  X0 is the point
where the function value needs to be calculated. DF is the first
derivative of function at X0, while DDF is the second derivative.
The derivatives would be calculated only if NDERIV has been set
appropriately.
IER is the error parameter, which should be zero after successful
execution. Nonzero values of IER may be set by function BSPLIN which is called
to calculate the B-spline basis functions.
This function requires function <a href="appendixc.htm#bsplin"> BSPLIN</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="ratnal"> </a>
 <b>23.&nbsp;RATNAL&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/ratnal.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/interp.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To calculate rational function interpolation.
XB is the x value at which interpolated value is
required. NTAB is the number of entries in the given table.
Arrays X and F of length NTAB contain the abscissas and the
function values at the corresponding points. The array X must contain
abscissas in either ascending or descending order.
NUSE specifies the maximum
number of points to be used for interpolation. If NUSE is larger than
NTAB or the parameter NMAX in the function, then it will be reduced
to the minimum of these three numbers and the error flag RATNAL
may be set to 22. If NUSE is less than 1, it will be set to MIN(6, NTAB) and
RATNAL will be set to 21. In all cases, after execution, NUSE will contain the
number of points actually used. Thus NUSE must be reset to required
value before subsequent calls to the function.
FB is the output parameter containing the
interpolated value. AEPS is a parameter specifying the required accuracy.
Interpolation will be continued until two successive values
differ by less than AEPS<!--hbox-->. If AEPS &#8804; 0, then this convergence criterion will
never be satisfied.
Error status can be obtained from the
returned value of RATNAL<!--hbox-->. A value of 21 implies
that NUSE &lt; 1, in which case it is set to MIN(6, NTAB).
RATNAL=22 implies that NUSE &gt; NTAB, or
NUSE &gt; NMAX, in which case it is reduced appropriately.
RATNAL=23 implies that, the interpolation has not converged
to the specified accuracy.
RATNAL=205 implies that, the execution was
terminated
because the denominator at some stage was zero. In this case, either the
interpolant has a pole at the requested point or it has a 0/0 form, and
the function will return with the interpolated value obtained in the
previous step. This value may or may not be acceptable. The reliability
of this value may be verified
by running this function with successively increasing value of NUSE,
until it encounters the singularity. If these values are converging, then
the result may be acceptable.
This function requires function <a href="appendixc.htm#nearst"> NEARST</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="poly2"> </a>
 <b>24.&nbsp;POLY2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/poly2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/poly2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function for polynomial interpolation in two dimensions.
(XB1, XB2) is the point at which interpolated value is required. X1 and X2 are
arrays of length N1 and N2 respectively, containing the abscissas. F is an
array of length NDIM&times;<span class="roman">N</span><span class="roman">2</span> containing the function values
F[J][I]=f(<span class="roman">X</span><span class="roman">1</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span><span class="roman">,</span> <span class="roman">X</span><span class="roman">2</span><span class="roman">[</span><span class="roman">J</span><span class="roman">]</span>). NDIM should be set to the actual value of the
second dimension of the array F<!--hbox--> in the calling function
(NDIM &#8805; <span class="roman">N</span><span class="roman">1</span>).
NP1 and NP2 are the number of points to be
used along the two axes for interpolation. The function may adjust
these values if required.
FB is the output parameter
containing the interpolated value.
Error status can be obtained from the
returned value of POLY2<!--hbox-->. A value of 206 implies
that <span class="roman">N</span><span class="roman">1</span> &gt; NDIM, in which case no
calculations are done.
This function calls DIVDIF0 for one-dimensional
interpolation along X1. To improve efficiency, the derivative calculation
has been removed from DIVDIF0 and a flag has been introduced to avoid
locating the nearest point every time.
This function requires functions <a href="appendixc.htm#divdif0"> DIVDIF0</a> and <a href="appendixc.htm#nearst"> NEARST</a>.

<div class="p"><!----></div>
 <br /><br /><a name="linrn"> </a>
 <b>25.&nbsp;LINRN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/linrn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/linrn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform linear interpolation in N variables.
XB is an array of length N containing the coordinates of the point at which
interpolated value is required. X is an array of length
NXD&times;<span class="roman">N</span> containing the
abscissas. X[i][j] is the jth point along ith dimension.
F is an N-dimensional array of dimension 
F[NDIM[N&#8722;1]] &#8230; [NDIM[1]][NDIM[0]] containing the function values

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">F</span><span class="roman">[</span><span class="roman">I</span><sub><span class="roman">N</span>&#8722;<span class="roman">1</span></sub><span class="roman">]</span> &#8230;<span class="roman">[</span><span class="roman">I</span><sub><span class="roman">1</span></sub><span class="roman">]</span><span class="roman">[</span><span class="roman">I</span><sub><span class="roman">0</span></sub><span class="roman">]</span>=f(<span class="roman">X</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">[</span><span class="roman">I</span><sub><span class="roman">0</span></sub><span class="roman">]</span><span class="roman">,</span> <span class="roman">X</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span><span class="roman">[</span><span class="roman">I</span><sub><span class="roman">1</span></sub><span class="roman">]</span>, &#8230;, <span class="roman">X</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span><span class="roman">[</span><span class="roman">I</span><sub><span class="roman">N</span>&#8722;<span class="roman">1</span></sub><span class="roman">]</span>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.3)</td></tr></table>
</td></tr></table>


NP is an integer array of length N, and NP[I] is the number of tabular points along
Ith coordinate. FB is the output parameter which will contain the 
interpolated value. NDIM is an integer array of length N,
specifying the dimension of F as explained above.
This array must specify the dimensions of F as used in the calling
function.
NXD is the actual value of the second dimension of X, and it should be
greater than the maximum element in NP<!--hbox-->.
As an example,
consider the case, when we want to perform interpolation in four variables,
with 4, 5, 6 and 7 points along the four coordinates, then the relevant
statements could be as follows

<div class="p"><!----></div>
<br /><tt><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;double f[8][6][5][5],x[5][10],xb[5],fb;
<br /><table align="left" border="0"><tr><td width="16" align="right">
</td></tr></table><!--hbox-->
   int n=4, nxd=10, np[4]={4,5,6,7},ndim[4]={5,5,6,8};
<br /><table align="left" border="0"><tr><td width="16" align="right">
</td></tr></table><!--hbox-->
   . . . . . . . . . . . . . . . . 
<br /><table align="left" border="0"><tr><td width="16" align="right">
</td></tr></table><!--hbox-->
   ier= linrn(n,xb,&amp;x[0][0],&amp;f[0][0][0][0],np,&amp;fb,ndim,nxd);
<div class="p"><!----></div>
</tt><br />Error status can be obtained from the
returned value of LINRN<!--hbox-->. A value of 207 implies
that NP[I] is less than two or
greater than NDIM[I] or NXD for some I,
in which case no calculations are performed.
This function requires function LOCATE<!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="locate"> </a>
 <b>26.&nbsp;LOCATE&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/locate.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/linrn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to locate a given point XB between
two points of an ordered table using the bisection algorithm.
X is the table with NP entries
in either ascending or descending order.
After execution, LOCATE returns a value such that,
XB should be between X[LOCATE] and X[LOCATE+1], unless it is outside the
range of the table. If XB is before the first point, then LOCATE=0, 
while if XB is beyond the last point, then <span class="roman">LOCATE</span>=<span class="roman">NP</span>&#8722;2.

<div class="p"><!----></div>
 <br /><br /><a name="bspint2"> </a>
 <b>27.&nbsp;BSPINT2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspint2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/poly2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the coefficients of
interpolating B-spline expansion in two dimensions. NX, NY are the
number of points along x and y, respectively in the table.
X, Y are arrays of length NX and NY containing the abscissas.
The abscissas must be distinct and in ascending order.
F is an array of size <span class="roman">LA</span>&times;<span class="roman">NY</span> containing
the function values. F[J][I] should contain f(<span class="roman">X</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span><span class="roman">,</span> <span class="roman">Y</span><span class="roman">[</span><span class="roman">J</span><span class="roman">]</span>).
K is an integer variable specifying the required order of B-splines,
<span class="roman">K</span>=4 for cubic B-splines, <span class="roman">K</span>=2 for linear B-splines, etc.
For simplicity, it is assumed that order is the same for expansions
along x and y. AX is an array of length <span class="roman">LA</span>&times;<span class="roman">3</span><span class="roman">K</span>
which will contain
the triangular decomposition of matrix for interpolation along X<!--hbox-->.
AY is an array of length <span class="roman">LA</span>&times;<span class="roman">3</span><span class="roman">K</span> which will contain
the triangular decomposition of matrix for interpolation along Y<!--hbox-->.
LA is the second dimension of arrays AX, AY, C, F as declared in the
calling function. For simplicity, the second dimension is assumed to
be the same in all these arrays. LA has to be greater than the 
maximum of NX and NY<!--hbox-->. C is an array of length
<span class="roman">LA</span>&times;<span class="roman">NY</span> which will
contain the calculated coefficients of expansion. This array will
be required to evaluate the interpolated value at any given point.
XF and YF are arrays of length MX and MY, respectively
containing the knots for B-splines along X and Y<!--hbox-->.
MX, MY are the actual number of knots
used along x and y. These numbers may not be the same as NX, NY since
some points may have to be dropped to match the number of equations and
number of B-spline basis functions. IFLG is a flag to decide the
nature of computations. For IFLG &#8804; 1 the triangular decomposition
of matrices is calculated, for larger values of IFLG it is assumed that
the triangular decomposition and other information is already available
in arrays AX, AY<!--hbox-->. INTX and INTY are integer arrays of lengths NX and NY
respectively, which will contain the information about pivoting used
to solve the system of equations for determining the coefficients
for 1-dimensional interpolation.
Error status can be obtained from the
returned value of BSPINT2<!--hbox-->. A zero value implies successful execution
of the function. Nonzero values may be set by BSPINT, BSPLIN or GAUBND
which are called. This function requires <a href="appendixc.htm#bspint"> BSPINT</a>, <a href="appendixc.htm#bsplin"> BSPLIN</a> and <a href="appendixc.htm#gaubnd"> GAUBND</a><!--hbox-->.
The interpolated value can be calculated using function <a href="appendixc.htm#bspev2"> BSPEV2</a>
with the coefficients computed by BSPINT2.

<div class="p"><!----></div>
 <br /><br /><a name="bspev2"> </a>
 <b>28.&nbsp;BSPEV2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspev2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/poly2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the value of
B-spline expansion in two dimensions using available coefficients.
The calculated value is given by:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">BSPEV</span><span class="roman">2</span>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">NX</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;</td><td nowrap="nowrap" align="center">
<small><span class="roman">NY</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">WT</span>[j][i] &#981;<sub>i</sub>(<span class="roman">X</span><span class="roman">0</span>)&#968;<sub>j</sub>(<span class="roman">Y</span><span class="roman">0</span>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.4)</td></tr></table>
</td></tr></table>


where &#981;<sub>i</sub>(x) are the B-spline basis functions along x
and &#968;<sub>i</sub>(y) are the B-spline basis functions along y.
It can be used to calculate the interpolated value of the function
if the coefficients are already calculated using <a href="appendixc.htm#bspint2"> BSPINT2</a>.
NX, NY are the number of knots along X, Y, which may not be the same as
the number of
points in the table for interpolation. X, Y are arrays of length
NX, NY containing the knots for B-splines.
The knots must be in ascending order with X[0] and Y[0] containing
the first knot along respective directions.
K is the order of B-splines,
<span class="roman">K</span>=2 gives linear B-splines, while <span class="roman">K</span>=4 yields cubic B-splines, etc.
For simplicity, the order is assumed to be the same along both axes.
NDERIV specifies the number of derivatives to be calculated.
For NDERIV &#8804; 0 only the function value will be calculated.
For NDERIV=1, the first derivatives are also calculated.
For NDERIV &gt; 1, the second derivatives will also be calculated.
WT is the array of length <span class="roman">IW</span>&times;(<span class="roman">NY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2),
containing the coefficients
of expansion in terms of B-spline basis functions. These coefficients
must be calculated beforehand using <a href="appendixc.htm#bspint2"> BSPINT2</a> or any other equivalent
function for B-spline approximations.  X0, Y0 is the point
where the function value needs to be calculated. DFX, DFY are the first
derivatives of function with respect to x,y respectively,
at (X0, Y0). while DFXX, DFXY, DFYY are the second derivatives
&#8706;<sup>2</sup>f/&#8706;x<sup>2</sup>, &#8706;<sup>2</sup>f/&#8706;x&#8706;y,
&#8706;<sup>2</sup>f/&#8706;y<sup>2</sup>.
The derivatives would be calculated only if NDERIV has been set
appropriately.
IER is the error parameter, which should be zero after successful
execution. Nonzero values of IER may be set by function BSPLIN which is called
to calculate the B-spline basis functions.
This function requires function <a href="appendixc.htm#bsplin"> BSPLIN</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="bspintn"> </a>
 <b>29.&nbsp;BSPINTN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspintn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bspintn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the coefficients for
B-spline interpolation to a table of values in N dimensions.
N is the number of dimensions. NK is an integer array of length N, giving
the number of tabular points along each dimension. NK[I] is the number
of points along x<sub>I</sub>. X is an array of length NXD&times;<span class="roman">N</span>
specifying the
abscissas along each dimension. X[J][I] is the Ith abscissa along
the Jth dimension.  For each dimension, the abscissas must be unique
and in ascending order. NXD is the second dimension of arrays X, XF
and INTX as specified in the calling function,
NXD &#8805; max(NK[0], NK[1],&#8230;,NK[N&#8722;1]).
F is an array of length NK[0]&times;NK[1]&times;&#8230;&times;NK[N&#8722;1] containing the table of values. Since BSPINTN
treats this array as a one dimensional array, the dimensions of
F in the calling function must exactly match the size of the table so that
there are no gaps in memory allocation. For example, the dimension
could be F[NK[N&#8722;1]] &#8230; [NK[1]][NK[0]]. Alternately, it could be treated
as a one dimensional array of appropriate length.
K is the order of B-spline interpolation required.
<span class="roman">K</span>=4 implies cubic B-splines, while <span class="roman">K</span>=2 gives linear B-splines, etc.
For simplicity, K is assumed to be the same along all dimensions.
AX is an array of length NXD&times;3<span class="roman">K</span>&times;<span class="roman">N</span>,
which will contain the triangular
decomposition of the matrix of equations
that is solved to calculate the coefficients of expansion for
each dimension. Since
the matrix is in band form with bandwidth <span class="roman">K</span>&#8722;1, it is stored in
band form. 
C is an array of length NK[0]&times;NK[1]&times;&#8230;&times;NK[N&#8722;1], which will contain the coefficients of B-spline
basis functions in expansion for interpolation. This array is also
treated as one-dimensional array just like F and hence the dimensions
in calling function must exactly match the size of the table.
XF is an array of size NXD&times;<span class="roman">N</span> which will contain
the knots used in each dimension.
This array will contain the knots used for B-spline interpolation in
each dimension. Since the number of B-spline basis functions
with MK[I] knots is <span class="roman">MK</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, some tabular points may have to be dropped
to ensure that <span class="roman">NK</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span><span class="roman">=</span><span class="roman">MK</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2.
This is equivalent to using the not-a-knot
boundary conditions in cubic spline interpolation.
The number of points to be dropped
depends on K<!--hbox-->. In all cases some points near both ends are dropped.
For linear B-splines, <span class="roman">K</span>=2 all points are used.
MK is an integer array of length N containing the number of knots
for B-splines in each dimension.
MK[I] is the number of knots used for B-spline interpolation, this would
be equal to NK[I]+2&#8722;<span class="roman">K</span>.
INTX is an integer array of length NXD&times;<span class="roman">N</span>, which
will contain the pivoting
information for solution of system of linear equations.
Error status can be obtained from the
returned value of BSPINTN<!--hbox-->. A zero value implies successful execution of
function. Nonzero values may be set by functions BSPINT,
BSPLIN or GAUBND, which are called.
It may be noted that for simplicity, this function does not use IFLG
to control the calculations as for large number of dimensions main
effort goes in calculating the coefficients rather than in calculating
the triangular decomposition of matrices.
This function requires
<a href="appendixc.htm#bspint"> BSPINT</a> to perform interpolation in one dimension,
<a href="appendixc.htm#bsplin"> BSPLIN</a> to calculate the B-spline basis functions and 
<a href="appendixc.htm#gaubnd"> GAUBND</a> to solve the system of linear equations with a
band matrix. The interpolant at any required point
can be calculated using function <a href="appendixc.htm#bspevn"> BSPEVN</a>, using the calculated
coefficients of expansion. If the first derivative of the function is
also required then use <a href="appendixc.htm#bspevn1"> BSPEVN1</a>, while for second derivatives use
<a href="appendixc.htm#bspevn2"> BSPEVN2</a>.

<div class="p"><!----></div>
 <br /><br /><a name="bspevn"> </a>
 <b>30.&nbsp;BSPEVN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspevn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bspintn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the value of
B-spline expansion in n-dimensions using available coefficients.
The calculated value is given by:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">BSPEVN</span>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>0</sub>=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#8230;</td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">[</span><span class="roman">n</span>&#8722;<span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>n&#8722;1</sub>=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">WT</span>[i<sub>n&#8722;1</sub>]&#8230;[i<sub>0</sub>]&times;&#981;<sub>i<sub>0</sub></sub><sup>(0)</sup>(<span class="roman">X</span><span class="roman">0</span>[0])&#8230;&#981;<sub>i<sub>n&#8722;1</sub></sub><sup>(n&#8722;1)</sup>(<span class="roman">X</span><span class="roman">0</span>[n&#8722;1]),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.5)</td></tr></table>
</td></tr></table>


where &#981;<sub>i<sub>j</sub></sub><sup>(j)</sup> are the B-spline basis functions along jth
dimension.
It can be used to calculate the interpolated value of the function
if the coefficients are already calculated using BSPINTN<!--hbox-->.
N is the number of dimensions.
NK is an integer array of length N containing the number of knots
along each dimension, which may not be the same as the number of
points in the table for interpolation.
NK[I] is the number of knots along the Ith dimension.
X is an array of length <span class="roman">NXD</span>&times;<span class="roman">N</span>
containing the knots for B-splines along each dimension.
The knots must be distinct and in ascending order with X[J][I] containing
Ith knot along Jth dimension.
NXD is the second dimension of array X in the calling function.
NXD must be greater than or equal to the maximum of <span class="roman">NK</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>.
K is the order of B-splines,
<span class="roman">K</span>=2 gives linear B-splines, while <span class="roman">K</span>=4 yields cubic B-splines, etc.
WT is the array of length (NK[0]+<span class="roman">K</span>&#8722;2)(NK[1]+<span class="roman">K</span>&#8722;2)&#8230;(NK[N&#8722;1]+<span class="roman">K</span>&#8722;2), containing the coefficients of
expansion in terms of B-spline basis functions. Since BSPEVN treats
this array as a one-dimensional array, the dimensions of this array
in the calling function must exactly match the table size, so that
there are no gaps in memory allocation. For example, the dimension
could be WT[NK[N&#8722;1]+K&#8722;2] &#8230; [NK[1]+K&#8722;2][NK[0]+K&#8722;2].
These coefficients WT
must be calculated beforehand using <a href="appendixc.htm#bspintn"> BSPINTN</a> or any other equivalent
function for B-spline approximations in n-dimensions.  X0 is an
array of length N, specifying the coordinates of the point
where the function value needs to be calculated.
IER is the error parameter, which should be zero after successful
execution. Nonzero value of IER may be set by function BSPLIN which is called
to calculate the B-spline basis functions.
This function does not calculate the derivatives of expansion. 
Since calculating derivatives could require considerable extra time
separate versions of this function <a href="appendixc.htm#bspevn1"> BSPEVN1</a> and <a href="appendixc.htm#bspevn2"> BSPEVN2</a> are
provided to calculate first and second derivatives. These functions
can be used instead of BSPEVN when derivatives are required.
This function requires function <a href="appendixc.htm#bsplin"> BSPLIN</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="bspevn1"> </a>
 <b>31.&nbsp;BSPEVN1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspevn1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bspintn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To calculate the value of
function and its first derivatives using available coefficients of
B-spline expansion in n-dimensions. This function is the version of
<a href="appendixc.htm#bspevn"> BSPEVN</a> to calculate the first derivatives in addition to function
values. It can be used when derivatives are also required. The arguments
are the same as those for BSPEVN, except for array DF of length N, which
will contain the calculated derivatives with respect to each of the
dimensions. DF[I] will contain the first derivative with respect to
x<sub>I</sub> at the point X0.
If only function value is required then <a href="appendixc.htm#bspevn">BSPEVN</a>
should be used, while if second derivative is also required then
<a href="appendixc.htm#bspevn2">BSPEVN2</a> should be used.

<div class="p"><!----></div>
 <br /><br /><a name="bspevn2"> </a>
 <b>32.&nbsp;BSPEVN2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspevn2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bspintn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To calculate the value of
function and its first and second derivatives using available coefficients of
B-spline expansion in n-dimensions. This function is the version of
<a href="appendixc.htm#bspevn"> BSPEVN</a> to calculate the first  and second derivatives in addition to function
values. It can be used when derivatives are also required. The arguments
are the same as those for BSPEVN, except for array DF of length N, which
will contain the calculated derivatives with respect to each of the
dimensions. DF[I] will contain the first derivative with respect to
x<sub>I</sub> at the point X0. DDF is an array of length
<span class="roman">N</span>&times;<span class="roman">N</span>, which will contain the calculated second
derivatives.
DDF[I][J] will contain &#8706;<sup>2</sup>f/&#8706;x<sub>I</sub>&#8706;x<sub>J</sub>
at the point X0.
If second derivatives are not required then it will be
better to use <a href="appendixc.htm#bspevn1"> BSPEVN1</a> (for first derivatives)
or <a href="appendixc.htm#bspevn">BSPEVN</a> (for only function value).

<div class="p"><!----></div>
 

<br /><br />
<a name="Differentiation"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.5&nbsp; DIFFERENTIATION </b></td></tr></table><!--hboxt-->

<br /> 

<div class="p"><!----></div>
<br /><br /><a name="drvt"> </a>
 <b>33.&nbsp;DRVT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/drvt.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/drvt.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate derivative of a function which
can be evaluated at any required point using a user supplied
function F(X). This
function uses h&#8594;0 extrapolation to obtain accurate value of the
derivative. It can evaluate the first, second, third or fourth derivative
of the given function.
A is the
value of x at which the derivative is to be evaluated. ID is the order
of the derivative required. ID can be 1, 2, 3 or 4. If any other value is
specified the function will exit with the error flag IER set to 208.
HH0 is the initial spacing to be used, which depends on the
function and the precision of the arithmetic used. A value between 0.1 
and 1 will usually be sufficient. If HH0 is too large, then sufficient
accuracy may not be achieved by the function, while if it is too small,
then roundoff error will dominate. AEPS and REPS specify the
required absolute and relative accuracy. This function exits when
the difference between successive values is less than
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">DRVT</span>&#124;), or when roundoff error is
dominating. The presence of roundoff error is detected by using a simple
test as explained in Section&nbsp;5.3. F is the name of the function which calculates the
given function at any required point. This function must be supplied by the
user. IER is the error parameter,
which will be set to 28 if sufficient accuracy is not achieved.
IER will be set to 29 if roundoff errors start dominating before 
adequate convergence is achieved. IER will be set to 208 if ID is outside
the specified range. 

<div class="p"><!----></div>
 

<br /><br />
<a name="Integration"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.6&nbsp; INTEGRATION </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#simson">SIMSON</a></td>
<td>&nbsp; <a href="#splint">SPLINT</a></td>
<td>&nbsp; <a href="#bspqd">BSPQD</a></td>
<td>&nbsp; <a href="#rombrg">ROMBRG</a></td>
<td>&nbsp; <a href="#epsiln">EPSILN</a></td>
<td>&nbsp; <a href="#gauss">GAUSS</a></td>
<td>&nbsp; <a href="#gaucby">GAUCBY</a></td>
<td>&nbsp; <a href="#gaucb1">GAUCB1</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#gaucb2">GAUCB2</a></td>
<td>&nbsp; <a href="#gausq2">GAUSQ2</a></td>
<td>&nbsp; <a href="#gausq">GAUSQ</a></td>
<td>&nbsp; <a href="#gaulag">GAULAG</a></td>
<td>&nbsp; <a href="#lagure">LAGURE</a></td>
<td>&nbsp; <a href="#hermit">HERMIT</a></td>
<td>&nbsp; <a href="#gaulg2">GAULG2</a></td>
<td>&nbsp; <a href="#gaulog">GAULOG</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#gausrc">GAUSRC</a></td>
<td>&nbsp; <a href="#gauleg">GAULEG</a></td>
<td>&nbsp; <a href="#gaujac">GAUJAC</a></td>
<td>&nbsp; <a href="#lagurw">LAGURW</a></td>
<td>&nbsp; <a href="#gauher">GAUHER</a></td>
<td>&nbsp; <a href="#gauswt">GAUSWT</a></td>
<td>&nbsp; <a href="#filon">FILON</a></td>
<td>&nbsp; <a href="#adpint">ADPINT</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#kronrd">KRONRD</a></td>
<td>&nbsp; <a href="#gaus16">GAUS16</a></td>
<td>&nbsp; <a href="#cauchy">CAUCHY</a></td>
<td>&nbsp; <a href="#euler">EULER</a></td>
<td>&nbsp; <a href="#bspqd2">BSPQD2</a></td>
<td>&nbsp; <a href="#bspqdn">BSPQDN</a></td>
<td>&nbsp; <a href="#mulint">MULINT</a></td>
<td>&nbsp; <a href="#ngauss">NGAUSS</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#sphnd">SPHND</a></td>
<td>&nbsp; <a href="#strint">STRINT</a></td>
<td>&nbsp; <a href="#stroud">STROUD</a></td>
<td>&nbsp; <a href="#mcarlo">MCARLO</a></td>
<td>&nbsp; <a href="#ran">RAN</a></td>
<td>&nbsp; <a href="#ranf">RANF</a></td>
<td>&nbsp; <a href="#rangau">RANGAU</a></td>
<td>&nbsp; <a href="#equids">EQUIDS</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="simson"> </a>
 <b>34.&nbsp;SIMSON&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/simson.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/quad.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To integrate a smooth function over
a finite interval using composite Simpson's rule.
RI is the output parameter containing the calculated
value of the integral. XL and XU are the lower and upper limits for
the integral. It is not essential to have <span class="roman">XL</span>  &lt;  <span class="roman">XU</span>. REPS and
AEPS specify the required relative and absolute accuracy. The calculations
are terminated when two successive values differ by less than
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RI</span>&#124;).
DIF is an output parameter containing
an estimate of (absolute) error calculated by the function. N is an
output parameter which will contain the number of function evaluations
used.
FUN is the name of the function to calculate the integrand.
Error status can be obtained from the
returned value of SIMSON<!--hbox-->. A value of 30 implies
that the function has failed to converge to the specified accuracy.
In most cases the computed value of the integral may still be approximately
correct. Only in extreme cases, the computed value will be far from actual
value.
In this case, RI will contain the best estimate for integral
and DIF should contain the estimated error.
The parameter NMAX in the function could be increased, if larger
number of function evaluations are to be allowed. However, in most case,
it will be better to use another technique for evaluating the integral.
Function FUN(X) must be supplied by the user.

<div class="p"><!----></div>
 <br /><br /><a name="splint"> </a>
 <b>35.&nbsp;SPLINT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/splint.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/splint.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To compute integral of a function supplied
in the form of a table of values by integrating the interpolating
cubic spline. Before calling this function, the coefficients of cubic
spline must be calculated by a call to function <a href="appendixc.htm#spline"> SPLINE</a><!--hbox-->.
SINT and TINT are the output parameters
containing the value of the integral. SINT is the estimate using
cubic spline, while TINT is the trapezoidal rule estimate, using only the
tabular points. The difference between TINT and SINT may give some
estimate of truncation error in the calculations.
If the limits are not among the tabular points, then the
function value at the end points are obtained using function <a href="appendixc.htm#splevl"> SPLEVL</a><!--hbox-->.
A and B are the lower and
upper limits of the integral. It is  essential to ensure that <span class="roman">A</span> &lt; <span class="roman">B</span>.
N is the number of points in the table of values. X and F are arrays
of length  N, containing the abscissas and function values. 
The abscissas must be supplied in ascending order. C is
an array of length 3&times;<span class="roman">N</span> containing the coefficients of cubic
spline, which may be calculated using the function SPLINE<!--hbox-->.
Error status can be obtained from the
returned value of SPLINT<!--hbox-->. A value of 31 implies
that the lower limit A is outside the limits of table,
while SPLINT=32 denotes that the upper limit
B is outside the limits of table. In such
cases, the accuracy of integration may be questionable.
SPLINT=301 implies that
<span class="roman">A</span> &gt; <span class="roman">B</span> or <span class="roman">X</span>[0] &gt; <span class="roman">X</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span>.
This function
requires function <a href="appendixc.htm#splevl"> SPLEVL</a> to evaluate the cubic spline, while function
<a href="appendixc.htm#spline"> SPLINE</a> will be required to calculate the coefficients of cubic spline
before calling this function.

<div class="p"><!----></div>
 <br /><br /><a name="bspqd"> </a>
 <b>36.&nbsp;BSPQD&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspqd.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/splint.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral of an expansion in
terms of B-spline basis functions. The expansion may be obtained by
interpolating or approximating a table of values.
Before calling this function, the coefficients of B-spline
expansion must be calculated by a call to function BSPINT<!--hbox-->.

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">BSPQD</span>=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">XU</span></small><!--sup
--><br /><br />
<small><span class="roman">XL</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp; </td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">WT</span><span class="roman">[</span><span class="roman">i</span><span class="roman">]</span>&nbsp;&nbsp;&#981;<sub>i</sub>(x)&nbsp;&nbsp;dx&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.6)</td></tr></table>
</td></tr></table>


where &#981;<sub>i</sub>(x) are the B-spline basis functions of order K<!--hbox-->.
N is the number of knots, X is an array of length N
containing the knots for B-splines. 
The knots must be in ascending order with X[0] containing the first
knot.
K is the order of B-splines,
<span class="roman">K</span>=2 gives linear B-splines, while <span class="roman">K</span>=4 yields cubic B-splines, etc.
WT is an array of length <span class="roman">N</span><span class="roman">+</span><span class="roman">K</span>&#8722;2 containing the coefficients
of expansion in terms of B-spline basis functions. These coefficients
may be calculated using <a href="appendixc.htm#bspint"> BSPINT</a> for interpolation in a table of values.
XL and XU are the lower and
upper limits of the integral.
IER is the error parameter.  IER=31 implies
that the lower limit XL is outside the limits of table,
while IER=32 denotes that the upper limit
XU is outside the limits of table. In such
cases, the accuracy of integration may be questionable.
Other values may be set by function BSPLIN which is called
to calculate B-spline basis functions.
This function
requires function <a href="appendixc.htm#bsplin"> BSPLIN</a> to evaluate the B-spline basis functions,
while function
<a href="appendixc.htm#bspint"> BSPINT</a> will be required to calculate the coefficients of B-spline
before calling this function.

<div class="p"><!----></div>
 <br /><br /><a name="rombrg"> </a>
 <b>37.&nbsp;ROMBRG&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/rombrg.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/quad.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral over
a finite interval, using
Romberg integration or the h&#8594;0 extrapolation. RI is the output parameter
containing the value of the integral. A and B are the lower and
upper limits of the integral. It is not essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>. GI is
an array of dimension  NMAX (=13),
containing the expected values of successive exponents
in the error expansion for the trapezoidal rule. If <span class="roman">GI</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> &#8804; 0,
then it will be set to 2<span class="roman">I</span>+2, which is the correct value for smooth
functions. AEPS and REPS specify the required absolute and relative accuracy. 
The calculations
are terminated when the successive values differ by less than
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RI</span>&#124;). DIF is an
output parameter giving the error as estimated by the function.
N specifies the number of abscissas to be used for the first attempt
with trapezoidal rule. After execution, N will contain the number of abscissas
actually used by the function. Hence, N will have to be reset after
every call to the function.
If <span class="roman">N</span> &lt; 2 it will be set to a default value of 2.
On the other hand, if <span class="roman">N</span> &gt; <span class="roman">NPT</span>&nbsp;&nbsp;(=100), then it will be set to a
default value of
2 and the error flag ROMBRG will be set to 33. In particular, this situation may
arise if N is not reset after the previous call to the function.
Error status can be obtained from the
returned value of ROMBRG<!--hbox-->. A value of 30 implies
that the function failed to converge to the specified
accuracy. In this case, RI will contain the best estimate for the integral
and DIF should contain the estimated error.
The parameter NMAX inside the function could be increased to allow
for larger number of function evaluations, but it is better to use some
other technique for evaluating the integral.
FUN is the name of the
function used to calculate the value of the integrand.
Function FUN(X) must be supplied by the user. This function should
be used for smooth functions with GI(I)=0. It can also handle
algebraic singularity at one or both end points, provided correct
values of GI are supplied.

<div class="p"><!----></div>
 <br /><br /><a name="epsiln"> </a>
 <b>38.&nbsp;EPSILN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/epsiln.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/quad.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To compute integral of a function over
a finite interval, using
&#1013;-algorithm to accelerate the convergence. RI is the output parameter
containing the value of the integral. A and B are the lower and
upper limits of the integral. It is not essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>.
AEPS and REPS specify the required absolute and relative accuracy. 
The calculations
are terminated when the successive values differ by less than
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RI</span>&#124;). DIF is an
output parameter giving the error as estimated by the function.
N specifies the number of abscissas to be used for the first attempt
with trapezoidal rule. After execution, N will contain the number of abscissas
actually used by the function. Hence, N will have to be reset after
every call to the function.
If <span class="roman">N</span> &lt; 2, it will be set to a default value of 2.
On the other hand, if <span class="roman">N</span> &gt; <span class="roman">NPT</span>&nbsp;&nbsp;(=100), then it will be set to a
default value of
2 and the error flag EPSILN will be set to 33. In particular, this situation may
arise if N is not reset after the previous call to the function.
Error status can be obtained from the
returned value of EPSILN<!--hbox-->. A value of 30 implies
that the function failed to converge to the specified
accuracy.
EPSILN=34 denotes that at some stage while constructing the &#1013;-table,
the denominator was zero. In this case, the calculations are continued
further after ignoring the corresponding term. This may be justified if
this problem occurs in higher columns which are not converging because
of roundoff error. A better strategy would be to stop calculating the
higher columns.
EPSILN=35 denotes that the roundoff error
is dominating and the calculations are terminated, even though the required
accuracy is not achieved.
In all these cases, RI will contain the best estimate for the integral
and DIF should contain the estimated error.
The parameter NMAX inside the function could be increased to allow
for larger number of function evaluations, but that is not
recommended. FUN is the name of the
function used to calculate the value of the integrand.
Function FUN(X) must be supplied by the user. This function could
be used for singular integrands, if only moderate accuracy is required.
It will fail to converge to high accuracy because of roundoff error.

<div class="p"><!----></div>
 <br /><br /><a name="gauss"> </a>
 <b>39.&nbsp;GAUSS&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gauss.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/quad.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral over a
finite interval, using
composite Gauss-Legendre formulae. RINT is the output parameter
containing the value of the integral. A and B are the lower and
upper limits of the integral. It is not essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>.
NP specifies the formula to be used. This function uses a composite rule
based on NP-point Gauss-Legendre formula. NP should be 2, 4, 8, 16 or 32,
since these are the only formulae for which the weights and abscissas are
incorporated. If NP is not equal to one of these values, then it will be set
to a default value of 8, and error flag will be set to 36.
AEPS and REPS specify the required absolute and relative accuracy.
The calculations
are terminated when the successive values differ by less than
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). DIF is an
output parameter giving the error as estimated by the function.
NPT is an output parameter containing the number of function
evaluations actually used.
Error status can be obtained from the
returned value of GAUSS<!--hbox-->. A value of 30 implies
that the function failed to converge to the specified accuracy.
In this case, RINT will contain the best estimate for the integral
and DIF should contain the estimated error. In such cases, attempt could
be made to use higher order Gaussian formula, NP=32 is the maximum
value allowed by this function.
The parameter NMAX inside the function could be increased to allow
for larger number of function evaluations, but it will be preferable to
use some other technique for evaluating the integral.
GAUSS=36 implies that
NP was not 2,4,8,16 or 32, in which case it is set to 8.
FUN is the name of the
function used to calculate the value of the integrand.
Function FUN(X) must be supplied by the user. This function should
be used for smooth integrands. NP could be set to a low value
if only moderate accuracy is required, while for high accuracy NP may
be increased. The optimum value of NP will depend on the degree of smoothness
of the integrand and the accuracy required.

<div class="p"><!----></div>
 <br /><br /><a name="gaucby"> </a>
 <b>40.&nbsp;GAUCBY&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gaucby.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gaucby.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral using
Gauss-Chebyshev formulae with weight function 1/&#8730;{(x&#8722;<span class="roman">A</span>)(<span class="roman">B</span>&#8722;x)}.
RINT is the output parameter
containing the value of the integral. A and B are the lower and
upper limits of the integral. It is essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>.
AEPS and REPS specify the required absolute and relative accuracy.
The calculations
are terminated when the successive values differ by less than
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). DIF is an
output parameter giving the error as estimated by the function.
NPT is an output parameter containing the number of function
evaluations actually used.
Error status can be obtained from the
returned value of GAUCBY<!--hbox-->. A value of 30 implies
that the function failed to converge to the specified accuracy.
In this case, RINT will contain the best estimate for the integral
and DIF should contain the estimated error.
The parameter NMAX inside the function could be increased to allow
for larger number of function evaluations, but it will be preferable to
use some other technique for evaluating the integral. FUN is the name of the
function used to calculate the value of the integrand multiplied
by &#8730;{(x&#8722;<span class="roman">A</span>)(<span class="roman">B</span>&#8722;x)}.
Function FUN(X) must be supplied by the user. This function should
be used for integrands with square root singularity at both ends.
It will evaluate the integral

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">B</span></small><!--sup
--><br /><br />
<small><span class="roman">A</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">FUN</span>(x)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">(x&#8722;<span class="roman">A</span>)(<span class="roman">B</span>&#8722;x)<br /></div>                                </td></tr></table></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;dx&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.7)</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
 <br /><br /><a name="gaucb1"> </a>
 <b>41.&nbsp;GAUCB1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gaucb1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gaucb1.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral using
Gauss-Chebyshev formulae with weight function &#8730;{(x&#8722;<span class="roman">A</span>)/(<span class="roman">B</span>&#8722;x)}.
RINT is the output parameter
containing the value of the integral. A and B are the lower and
upper limits of the integral. It is essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>.
AEPS and REPS specify the required absolute and relative accuracy.
The calculations
are terminated when the successive values differ by less than
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). DIF is an
output parameter giving the error as estimated by the function.
NPT is an output parameter containing the number of function
evaluations actually used.
Error status can be obtained from the
returned value of GAUCB1<!--hbox-->. A value of 30 implies
that the function failed to converge to the specified accuracy.
In this case, RINT will contain the best estimate for the integral
and DIF should contain the estimated error.
The parameter NMAX inside the function could be increased to allow
for larger number of function evaluations, but it will be preferable to
use some other technique for evaluating the integral. FUN is the name of the
function used to calculate the value of the integrand multiplied
by &#8730;{(<span class="roman">B</span>&#8722;x)/(x&#8722;<span class="roman">A</span>)}.
Function FUN(X) must be supplied by the user. This function should
be used for integrands with square root singularity at both ends.
It will evaluate the integral

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">B</span></small><!--sup
--><br /><br />
<small><span class="roman">A</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">FUN</span>(x)</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">x&#8722;<span class="roman">A</span><br /></div>                                </td></tr></table>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><span class="roman">B</span>&#8722;x<br /></div>                                </td></tr></table></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;dx&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.8)</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
 <br /><br /><a name="gaucb2"> </a>
 <b>42.&nbsp;GAUCB2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gaucb2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gaucb2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral using
Gauss-Chebyshev formulae with weight function &#8730;{(x&#8722;<span class="roman">A</span>)(<span class="roman">B</span>&#8722;x)}.
RINT is the output parameter
containing the value of the integral. A and B are the lower and
upper limits of the integral. It is essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>.
AEPS and REPS specify the required absolute and relative accuracy.
The calculations
are terminated when the successive values differ by less than
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). DIF is an
output parameter giving the error as estimated by the function.
NPT is an output parameter containing the number of function
evaluations actually used.
Error status can be obtained from the
returned value of GAUCB2<!--hbox-->. A value of 30 implies
that the function failed to converge to the specified accuracy.
In this case, RINT will contain the best estimate for the integral
and DIF should contain the estimated error.
The parameter NMAX inside the function could be increased to allow
for larger number of function evaluations, but it will be preferable to
use some other technique for evaluating the integral. FUN is the name of the
function used to calculate the value of the integrand divided
by &#8730;{(<span class="roman">B</span>&#8722;x)(x&#8722;<span class="roman">A</span>)}.
Function FUN(X) must be supplied by the user. This function should
be used for integrands with square root singularity at both ends.
It will evaluate the integral

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">B</span></small><!--sup
--><br /><br />
<small><span class="roman">A</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">FUN</span>(x)</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">(x&#8722;<span class="roman">A</span>)(<span class="roman">B</span>&#8722;x)<br /></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;dx&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.9)</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
 <br /><br /><a name="gausq2"> </a>
 <b>43.&nbsp;GAUSQ2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gausq2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gausq.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To compute integral of a function with
square root singularity over
(0, a] using a combination of Gauss-Legendre and a Gaussian formula
with 1/&#8730;x weight function.
RINT is the output parameter
containing the value of the integral. A is the upper
limit of the integral. A1 is the point at which the integral is broken,
with the integral over [<span class="roman">A</span><span class="roman">1</span><span class="roman">,</span><span class="roman">A</span>] being evaluated using Gauss-Legendre
formula, while that over (0, <span class="roman">A</span><span class="roman">1</span>] is evaluated using a
Gaussian formula with 1/&#8730;x weight function.
If <span class="roman">A</span> &lt; <span class="roman">A</span><span class="roman">1</span>, then A1 is set equal to A to
start with. A1 is adjusted by the function to achieve the required accuracy.
After execution, A1 will contain the final value used by the function.
A1 may need to be reset after every call to GAUSQ2<!--hbox-->. If the next integral is
similar to the previous one, then the value of A1 need not be reset, since
it is probably the required value.
AEPS and REPS specify the required absolute and relative accuracy.
The calculations
are terminated when the successive values differ by less than
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). Convergence is checked
separately for the two integrals.
DIF is an
output parameter giving the error as estimated by the function.
NP is the output parameter
containing the number of function evaluations
actually used. This function calls the functions
<a href="appendixc.htm#gauss"> GAUSS</a> and <a href="appendixc.htm#gausq"> GAUSQ</a> to perform the integration over required subintervals.
Error status can be obtained from the
returned value of GAUSQ2<!--hbox-->. A value of 30 implies
that the function GAUSS failed to converge to the specified
accuracy over the interval [<span class="roman">A</span><span class="roman">1</span><span class="roman">,</span><span class="roman">A</span>]. GAUSQ2=37 denotes that the function
GAUSQ failed to converge to the specified accuracy, even when A1 was reduced
to its minimum permissible value of AMN (=0.01).
This limit is provided to prevent the function from getting into an infinite
loop. This can happen if the integrand is not in a form f(x)/&#8730;x
as required for Gaussian formula. If necessary, the lower limit
AMN can be reduced.
GAUSQ2=38 denotes that both functions failed.
In all these cases, RINT will contain the best estimate for the integral
and DIF should contain the estimated error.
F is the name of the
function used to calculate the value of the integrand.
F2 is the name of the function used to calculate <tt>F(X)*SQRT(X)</tt>,
as required by the Gaussian formula. Note that the function
will calculate the integral

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)&nbsp;&nbsp;dx=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span></small><!--sup
--><br /><br />
<small><span class="roman">A</span><span class="roman">1</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)&nbsp;&nbsp;dx +</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span><span class="roman">1</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">F</span><span class="roman">2</span>(x)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8730;x<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;dx&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.10)</td></tr></table>
</td></tr></table>


Functions F(X), and F2(X) must be supplied by the user.
The requirement of two separate functions is to avoid possible problems
caused by singularity in integrand.
If <span class="roman">A</span>&#8722;<span class="roman">A</span><span class="roman">1</span> &lt; <span class="roman">AEPS</span>, then the
first integral is not evaluated. This condition may need to be changed
if the integral can make significant contribution, even though this condition
is satisfied, which may happen if the limits are very small.
This function requires functions <a href="appendixc.htm#gauss"> GAUSS</a> and <a href="appendixc.htm#gausq"> GAUSQ</a><!--hbox-->.
It should be used only
for those integrands which have square root singularity at x=0.
It can be used for integrands of form f(x)/&#8730;x, where f(x)
is regular at x=0. It can also be used for integrands of form
f(x)&#8730;x=(xf(x))/&#8730;x.

<div class="p"><!----></div>
 <br /><br /><a name="gausq"> </a>
 <b>44.&nbsp;GAUSQ&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gausq.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gausq.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">FUN</span>(x)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8730;x<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;dx&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.11)</td></tr></table>
</td></tr></table>


using Gaussian formulae with 1/&#8730;x weight function.
The function computes the integral using
different formulae, until convergence is achieved or until the table of
weights and abscissas is exhausted.
RINT is the output parameter
containing the value of the integral. A is the upper
limit of the integral. 
REPS and AEPS specify the required  accuracy, while DIF is an
output parameter giving the error as estimated by the function.
The convergence criterion used is &#124;<span class="roman">DIF</span>&#124; &lt; max(<span class="roman">REPS</span>&#124;<span class="roman">RINT</span>&#124;,<span class="roman">AEPS</span>).
NPT is an output parameter containing the number of function
evaluations actually used.
FUN is the name of the
function used to calculate the value of the integrand 
(multiplied by &#8730;x).
Error status can be obtained from the
returned value of GAUSQ<!--hbox-->. A value of 30 implies
that the function failed to converge to the specified accuracy.
In this case, RINT will contain the best estimate for the integral
and DIF should contain the estimated error. In such cases, we can try
to use a lower value of A<!--hbox-->.
Function FUN(X) must be supplied by the user. This function should
be used for integrands which have a square root singularity
(functions of form f(x)/&#8730;x or f(x)&#8730;x) at x=0.
This function should be preferably used through <a href="appendixc.htm#gausq2"> GAUSQ2</a>, in which case the
upper limit A may be adjusted if the required accuracy is not achieved.

<div class="p"><!----></div>
 <br /><br /><a name="gaulag"> </a>
 <b>45.&nbsp;GAULAG&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gaulag.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gaulag.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral of a function over
[a,&#8734;) using a combination of Gauss-Laguerre and Gauss-Legendre
quadrature formulae.
RINT is the output parameter
containing the value of the integral. A is the lower
limit of the integral. A1 is the point at which the integral is broken,
with the integral over [<span class="roman">A</span><span class="roman">,</span><span class="roman">A</span><span class="roman">1</span>] being evaluated using Gauss-Legendre
formula, while that over [<span class="roman">A</span><span class="roman">1</span>,&#8734;) is evaluated using the
Gauss-Laguerre formula. If <span class="roman">A</span><span class="roman">1</span> &lt; <span class="roman">A</span>, then A1 is set equal to A to
start with. A1 is adjusted by the function to achieve the required accuracy.
After execution, A1 will contain the final value used by the function.
A1 may need to be reset after every call to GAULAG<!--hbox-->. If the next integral is
similar to the previous one, then the value of A1 need not be reset, since
it is probably the required value.
AEPS and REPS specify the required absolute and relative accuracy.
The calculations
are terminated when the successive values differ by less than
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). Convergence is checked
separately for the two integrals.
DIF is an
output parameter giving the error as estimated by the function.
NP is the output parameter
containing the number of function evaluations
actually used. This function calls the functions
<a href="appendixc.htm#gauss"> GAUSS</a> and <a href="appendixc.htm#lagure"> LAGURE</a> to perform the integration over required subintervals.
Error status can be obtained from the
returned value of GAULAG<!--hbox-->. A value of 30 implies
that the function GAUSS failed to converge to the specified
accuracy over the interval [<span class="roman">A</span><span class="roman">,</span><span class="roman">A</span><span class="roman">1</span>].
GAULAG=37 denotes that the function
LAGURE failed to converge to the specified accuracy, even when A1 was raised
to its maximum permissible value of AMAX (=50).
This limit is provided to prevent the function from getting into an infinite
loop. This can happen if the integrand is not in a form e<sup>&#8722;x</sup>f(x)
as required for Gauss-Laguerre formula. If necessary, the upper limit
AMAX can be increased.
GAULAG=38 denotes that both functions failed.
In all these cases, RINT will contain the best estimate for the integral
and DIF should contain the estimated error.
F is the name of the
function used to calculate the value of the integrand.
F2 is the name of the function used to calculate <tt>F(X)*EXP(X)</tt>,
as required by the Gauss-Laguerre formula. Note that the function
will calculate the integral

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><br />
<small><span class="roman">A</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)&nbsp;&nbsp;dx=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span><span class="roman">1</span></small><!--sup
--><br /><br />
<small><span class="roman">A</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)&nbsp;&nbsp;dx +</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><br />
<small><span class="roman">A</span><span class="roman">1</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
e<sup>&#8722;x</sup><span class="roman">F</span><span class="roman">2</span>(x)&nbsp;&nbsp;dx&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.12)</td></tr></table>
</td></tr></table>


Both Functions F(X), and F2(X) must be supplied by the user.
The requirement of two separate functions is to avoid the problem of overflow
and underflow, which may occur if F2 is formed by adding the exponential
factor to F inside the function. If <span class="roman">A</span><span class="roman">1</span>&#8722;<span class="roman">A</span> &lt; <span class="roman">AEPS</span>, then the
first integral is not evaluated. This condition may need to be changed
if the integral can make significant contribution, even though this condition
is satisfied, which may happen if the limits are very small.
This function requires functions <a href="appendixc.htm#gauss"> GAUSS</a> and <a href="appendixc.htm#lagure"> LAGURE</a><!--hbox-->.
It should be used only
for those functions which fall off exponentially at large X<!--hbox-->. Similar
function can be written to handle singularities by combining the
Gauss-Legendre formula with another Gaussian formula for singular weight
functions.

<div class="p"><!----></div>
 <br /><br /><a name="lagure"> </a>
 <b>46.&nbsp;LAGURE&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/lagure.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gaulag.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral 
&#8747;<sub><span class="roman">A</span></sub><sup>&#8734;</sup> e<sup>&#8722;x</sup><span class="roman">F</span>(x)&nbsp;&nbsp;dx
using Gauss-Laguerre formulae. The function computes the integral using
different formulae, until convergence is achieved or until the table of
weights and abscissas is exhausted.
RINT is the output parameter
containing the value of the integral. A is the lower
limit of the integral. 
REPS and AEPS specify the required  accuracy, while DIF is an
output parameter giving the error as estimated by the function.
The convergence criterion used is &#124;<span class="roman">DIF</span>&#124; &lt; max(<span class="roman">REPS</span>&#124;<span class="roman">RINT</span>&#124;,<span class="roman">AEPS</span>).
NPT is an output parameter containing the number of function
evaluations actually used.
Error status can be obtained from the
returned value of LAGURE<!--hbox-->. A value of 30 implies
that the function failed to converge to the specified accuracy.
In this case, RINT will contain the best estimate for the integral
and DIF should contain the estimated error. In such cases, we can try
to use a higher value of A<!--hbox-->.
It may be noted that, depending on the function being integrated
the higher order formula may have problems, because of underflow and
overflow on computers with short range for the exponents.
F is the name of the
function used to calculate the value of the integrand 
(multiplied by e<sup>x</sup>).
Function F(X) must be supplied by the user. This function should
be used for integrands which fall off exponentially at large x.
It will be better to use this function through <a href="appendixc.htm#gaulag"> GAULAG</a>, which adjusts
the lower limit A to achieve the required accuracy.

<div class="p"><!----></div>
 <br /><br /><a name="hermit"> </a>
 <b>47.&nbsp;HERMIT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/hermit.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/hermit.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral 
&#8747;<sub>&#8722;&#8734;</sub><sup>&#8734;</sup> e<sup>&#8722;x<sup>2</sup></sup><span class="roman">F</span>(x)&nbsp;&nbsp;dx
using Gauss-Hermite formulae. The function computes the integral using
different formulae, until convergence is achieved or until the table of
weights and abscissas is exhausted.
RINT is the output parameter
containing the value of the integral.
REPS and AEPS specify the required  accuracy, while DIF is an
output parameter giving the error as estimated by the function.
The convergence criterion used is &#124;<span class="roman">DIF</span>&#124; &lt; max(<span class="roman">REPS</span>&#124;<span class="roman">RINT</span>&#124;,<span class="roman">AEPS</span>).
NPT is an output parameter containing the number of function
evaluations actually used.
Error status can be obtained from the
returned value of HERMIT<!--hbox-->. A value of 30 implies
that the function failed to converge to the specified accuracy.
In this case, RINT will contain the best estimate for the integral
and DIF should contain the estimated error.
It may be noted that, depending on the function being integrated
the higher order formula may have problems, because of underflow and
overflow on computers with short range for the exponents.
F is the name of the
function used to calculate the value of the integrand 
(multiplied by e<sup>x<sup>2</sup></sup>).
Function F(X) must be supplied by the user. This function should
be used for integrands which fall off exponentially as e<sup>&#8722;x<sup>2</sup></sup>
at large &#124;x&#124;. In this case it is not possible to divide the range
and hence it is not possible to apply any composite formulae or
to use a combination of formulae to improve accuracy.

<div class="p"><!----></div>
 <br /><br /><a name="gaulg2"> </a>
 <b>48.&nbsp;GAULG2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gaulg2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gaulog.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral of a function with
logarithmic singularity over
(0, a] using a combination of Gauss-Legendre and a Gaussian formula
with log(1/x) weight function.
RINT is the output parameter
containing the value of the integral. A is the upper
limit of the integral. A1 is the point at which the integral is broken,
with the integral over [<span class="roman">A</span><span class="roman">1</span><span class="roman">,</span><span class="roman">A</span>] being evaluated using Gauss-Legendre
formula, while that over (0, <span class="roman">A</span><span class="roman">1</span>] is evaluated using a
Gaussian formula with log(1/x) weight function.
If <span class="roman">A</span> &lt; <span class="roman">A</span><span class="roman">1</span>, then A1 is set equal to A to
start with. A1 is adjusted by the function to achieve the required accuracy.
After execution, A1 will contain the final value used by the function.
A1 may need to be reset after every call to GAULG2<!--hbox-->. If the next integral is
similar to the previous one, then the value of A1 need not be reset, since
it is probably the required value.
AEPS and REPS specify the required absolute and relative accuracy.
The calculations
are terminated when the successive values differ by less than
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). This criterion is applied
separately to each part of the integral.
DIF is an
output parameter giving the error as estimated by the function.
NP is the output parameter
containing the number of function evaluations
actually used. This function calls the functions
<a href="appendixc.htm#gauss"> GAUSS</a> and <a href="appendixc.htm#gaulog"> GAULOG</a> to perform the integration over required subintervals.
Error status can be obtained from the
returned value of GAULG2<!--hbox-->. A value of 31 implies
that the function GAUSS failed to converge to the specified
accuracy over the interval [<span class="roman">A</span><span class="roman">1</span><span class="roman">,</span><span class="roman">A</span>].
GAULG2=32 denotes that the function
GAULOG failed to converge to the specified accuracy, even when A1 was reduced
to its minimum permissible value of AMN (=0.01).
This limit is provided to prevent the function from getting into an infinite
loop. This can happen if the integrand is not in a form f(x)log(x)
as required for Gaussian formula. If necessary, the lower limit
AMN can be reduced.
GAULG2=34 denotes that
function GAUSS failed while evaluating the integral over [0,A1].
In case of multiple failures, the second digit of GAULG2 will be the sum
of these values.
In all these cases, RINT will contain the best estimate for the integral
and DIF should contain the estimated error.
F is the name of the
function used to calculate the value of the integrand.
F2 is the name of the function used to calculate <tt>F(X)/LOG(1/X)</tt>,
as required by the Gaussian formula. Note that the function
will find the integral

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)&nbsp;&nbsp;dx=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span></small><!--sup
--><br /><br />
<small><span class="roman">A</span><span class="roman">1</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)&nbsp;&nbsp;dx &#8722;log(<span class="roman">A</span><span class="roman">1)</span></td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span><span class="roman">1</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span><span class="roman">2</span>(x)&nbsp;&nbsp;dx+</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span><span class="roman">1</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span><span class="roman">2</span>(x)log(<span class="roman">A</span><span class="roman">1</span>/x)&nbsp;&nbsp;dx&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.13)</td></tr></table>
</td></tr></table>


Both the functions F(X), and F2(X) must be supplied by the user.
The requirement of two separate functions is to avoid possible problems
caused by singularity in integrand.
The first two integrals should not have any singularity and are evaluated
using Gauss-Legendre formula, while the last integral is evaluated using
Gaussian formula with logarithmic singularity.
Note that the last two integrals arise when the range in integral over
(0, A1] is transformed to (0, 1].
If <span class="roman">A</span>&#8722;<span class="roman">A</span><span class="roman">1</span> &lt; <span class="roman">AEPS</span>, then the
first integral is not evaluated. This condition may need to be changed
if the integral can make significant contribution, even though this condition
is satisfied, which may happen if the limits are very small.
This function requires functions <a href="appendixc.htm#gauss"> GAUSS</a> and <a href="appendixc.htm#gaulog"> GAULOG</a><!--hbox-->.
It should be used only
for those functions which have logarithmic singularity at x=0.

<div class="p"><!----></div>
 <br /><br /><a name="gaulog"> </a>
 <b>49.&nbsp;GAULOG&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gaulog.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gaulog.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)log(<span class="roman">A</span>/x)&nbsp;&nbsp;dx&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.14)</td></tr></table>
</td></tr></table>


using Gaussian formulae with log(<span class="roman">A</span>/x) weight function.
The function computes the integral using
different formulae, until convergence is achieved or until the table of
weights and abscissas is exhausted.
RINT is the output parameter
containing the value of the integral. A is the upper
limit of the integral. 
REPS and AEPS specify the required  accuracy, while DIF is an
output parameter giving the error as estimated by the function.
The convergence criterion used is &#124;<span class="roman">DIF</span>&#124; &lt; max(<span class="roman">REPS</span>&#124;<span class="roman">RINT</span>&#124;,<span class="roman">AEPS</span>).
NPT is an output parameter containing the number of function
evaluations actually used.
F is the name of the
function used to calculate the value of the integrand 
(divided by log(<span class="roman">A</span>/x)).
Error status can be obtained from the
returned value of GAULOG<!--hbox-->. A value of 30 implies
that the function failed to converge to the specified accuracy.
In this case, RINT will contain the best estimate for the integral
and DIF should contain the estimated error. In such cases, we can try
to use a lower value of A<!--hbox-->.
Function F(X) must be supplied by the user. This function should
be used for integrands which have a logarithmic singularity at x=0.
It would be better to use this function through <a href="appendixc.htm#gaulg2"> GAULG2</a> which adjusts
the value of A to achieve required accuracy.

<div class="p"><!----></div>
 <br /><br /><a name="gausrc"> </a>
 <b>50.&nbsp;GAUSRC&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gausrc.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gausrc.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate weights and abscissas of
a Gaussian quadrature formula, with arbitrary weight function.
This function requires the recurrence relation for the corresponding
orthogonal polynomials.
The recurrence relation is assumed to be in the form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P<sub>j</sub>(x)=(a<sub>j</sub> x +b<sub>j</sub>)P<sub>j&#8722;1</sub>(x)&#8722;c<sub>j</sub> P<sub>j&#8722;2</sub>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.15)</td></tr></table>
</td></tr></table>


where P<sub>j</sub>(x) is the orthogonal polynomial of degree j in x.
The coefficients a<sub>j</sub>,b<sub>j</sub>,c<sub>j</sub> for j=1,2,&#8230;,n must be supplied.
Here N is the number
of abscissas in the required Gaussian formula. Output parameters W and AB are arrays
of length  N, containing the weights and corresponding
abscissas. 
COF is an array of length 3&times;<span class="roman">N</span> containing the coefficients
in the recurrence relation for the polynomials. COF[i&#8722;1][0], COF[i&#8722;1][1]
and COF[i&#8722;1][2] are respectively, a<sub>i</sub>,b<sub>i</sub>,c<sub>i</sub> as defined above.
These coefficients must be supplied.
RI0 is the integral
 &#8747;<sub>a</sub><sup>b</sup>w(x)&nbsp;&nbsp;dx for the required weight function over the corresponding
interval. If this integral is not known it must be evaluated using
appropriate quadrature formula before using this function to calculate
the weights and abscissas.
Error status can be obtained from the
returned value of GAUSRC<!--hbox-->. A value of 302 implies that
<span class="roman">N</span> &#8804; 0, in which case no calculations are performed.
GAUSRC=321 implies that some coefficient becomes imaginary during
calculation. This could happen only if coefficients for
recurrence relation are not specified correctly.
Other values may be set by TQL2 which is called to solve the eigenvalue
problem.
There is no error check
on the output and the accuracy can be tested by integrating the
functions w(x)x<sup>j</sup>  for j=0,1,&#8230;,2<span class="roman">N</span>&#8722;1, using the calculated
weights and abscissas. This function is in general better conditioned
than <a href="appendixc.htm#gauswt"> GAUSWT</a>, which uses only the moments.
This function requires function <a href="appendixc.htm#tql2"> TQL2</a>.

<div class="p"><!----></div>
 <br /><br /><a name="gauleg"> </a>
 <b>51.&nbsp;GAULEG&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gauleg.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gauleg.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate weights and abscissas of
a Gauss-Legendre quadrature formula.
This function uses the recurrence relation for Legendre
polynomials

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
nP<sub>n</sub>(x)=(2n&#8722;1)xP<sub>n&#8722;1</sub>(x)&#8722;(n&#8722;1)P<sub>n&#8722;2</sub>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.16)</td></tr></table>
</td></tr></table>


to calculate the weights and abscissas using function GAUSRC<!--hbox-->.
Here N is the number
of abscissas in the required Gaussian formula. Output parameters W and A are arrays
of length  N, containing the weights and corresponding abscissas. 
Error status can be obtained from the
returned value of GAULEG<!--hbox-->. Zero value implies successful execution.
Nonzero values may be set by function GAUSRC<!--hbox-->.
There is no error check
on the output and the accuracy can be tested by integrating the
functions x<sup>j</sup>  for j=0,1,&#8230;,2<span class="roman">N</span>&#8722;1, using the calculated
weights and abscissas.
This function requires functions <a href="appendixc.htm#gausrc"> GAUSRC</a> and <a href="appendixc.htm#tql2"> TQL2</a>.

<div class="p"><!----></div>
 <br /><br /><a name="gaujac"> </a>
 <b>52.&nbsp;GAUJAC&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gaujac.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gaujac.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate weights and abscissas of
a Gauss-Jacobi quadrature formula.
This function uses the recurrence relation for Jacobi
polynomials

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
2n(n+&#945;+&#946;)(2n&#8722;2+&#945;+&#946;)P<sub>n</sub><sup>&#945;,&#946;</sup>(x)=</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6> </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8722;2(n&#8722;1+&#945;)(n&#8722;1+&#946;)(2n+&#945;+&#946;)P<sub>n&#8722;2</sub><sup>&#945;,&#946;</sup>(x)</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+(2n&#8722;1+&#945;+&#946;)</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
&#945;<sup>2</sup>&#8722;&#946;<sup>2</sup>+(2n+&#945;+&#946;)(2n&#8722;2+&#945;+&#946;)x</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
P<sub>n&#8722;1</sub><sup>&#945;,&#946;</sup>(x),</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.17)
</td></tr></table>


to calculate the weights and abscissas using function GAUSRC<!--hbox-->.
Here N is the number
of abscissas in the required Gaussian formula while ALP and BETA are
the indices
&#945; and &#946; in (<span class="roman">C</span>.17). The corresponding weight function is
w(x)=(1&#8722;x)<sup>&#945;</sup> (1+x)<sup>&#946;</sup> on the interval (&#8722;1,1).
Output parameters W and A are arrays
of length  N, containing the weights and corresponding
abscissas. 
Error status can be obtained from the
returned value of GAUJAC<!--hbox-->. Zero value implies successful execution.
GAUJAC=313 implies ALP &#8804; &#8722;1 or BETA &#8804; &#8722;1.
Other values may be set by function GAUSRC<!--hbox-->.
There is no error check
on the output and the accuracy can be tested by integrating the
functions (1&#8722;x)<sup>&#945;</sup>(1+x)<sup>&#946;</sup> x<sup>j</sup> for j=0,1,&#8230;,2<span class="roman">N</span>&#8722;1,
using the calculated weights and abscissas.
Setting ALP=0 and BETA=0 in this function
should yield the Gauss-Legendre formula.
Similarly, setting ALP=&#8722;1/2 and
BETA=&#8722;1/2 should yield the Gauss-Chebyshev formula.
Using &#945; = 0 one can calculate quadrature formulae for algebraic
singularity of form t<sup>&#946;</sup>, by transforming the lower limit to t=0.

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>1</small><!--sup
--><br /><br />
<small>&#8722;1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
(1&#8722;x)<sup>&#945;</sup>(1+x)<sup>&#946;</sup> f(x)&nbsp;&nbsp;dx = 2<sup>&#945;+&#946;+1</sup></td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>1</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
(1&#8722;t)<sup>&#945;</sup> t<sup>&#946;</sup> f(2t&#8722;1)&nbsp;&nbsp;dt&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.18)</td></tr></table>
</td></tr></table>


Thus for integration over interval (0,1) the weights W[I] should
be divided by 2<sup>1+&#945;+&#946;</sup> and abscissas should be (1+A[I])/2.
This function requires functions <a href="appendixc.htm#gamma"> GAMMA</a>, <a href="appendixc.htm#gausrc"> GAUSRC</a> and <a href="appendixc.htm#tql2"> TQL2</a>.

<div class="p"><!----></div>
 <br /><br /><a name="lagurw"> </a>
 <b>53.&nbsp;LAGURW&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/lagurw.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/lagurw.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate weights and abscissas of
a Gauss-Laguerre quadrature formula.
This function uses the recurrence relation for associated Laguerre
polynomials

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
nL<sub>n</sub><sup>&#945;</sup>(x)=(n+&#945;)</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
(2n&#8722;1+&#945;)&#8722;x</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
L<sub>n&#8722;1</sub><sup>&#945;</sup>(x)&#8722;(n&#8722;1+&#945;)<sup>2</sup>(n+&#945;)L<sub>n&#8722;2</sub><sup>&#945;</sup>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.19)</td></tr></table>
</td></tr></table>


to calculate the weights and abscissas using function GAUSRC<!--hbox-->.
Here N is the number
of abscissas in the required Gaussian formula and ALP is the index
&#945; in (<span class="roman">C</span>.19). The corresponding weight function is
w(x)=x<sup>&#945;</sup> e<sup>&#8722;x</sup> on the interval (0,&#8734;).
Output parameters W and A are arrays
of length  N, containing the weights and corresponding
abscissas. 
Error status can be obtained from the
returned value of LAGURW<!--hbox-->. Zero value implies successful execution.
LAGURW=313 implies ALP &#8804; &#8722;1.
Other values may be set by function GAUSRC<!--hbox-->.
There is no error check
on the output and the accuracy can be tested by integrating the
functions e<sup>&#8722;x</sup>x<sup>j+&#945;</sup> for j=0,1,&#8230;,2<span class="roman">N</span>&#8722;1,
using the calculated weights and abscissas.
For ALP=0 it will yield the standard Gauss-Laguerre
quadrature formula.
This function requires functions <a href="appendixc.htm#gamma"> GAMMA</a>, <a href="appendixc.htm#gausrc"> GAUSRC</a> and <a href="appendixc.htm#tql2"> TQL2</a>.

<div class="p"><!----></div>
 <br /><br /><a name="gauher"> </a>
 <b>54.&nbsp;GAUHER&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gauher.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gauher.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate weights and abscissas of
a Gauss-Hermite quadrature formula.
This function uses the recurrence relation for Hermite
polynomials

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
H<sub>n</sub>(x)=2xH<sub>n&#8722;1</sub>(x)&#8722; 2(n&#8722;1)H<sub>n&#8722;2</sub>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.20)</td></tr></table>
</td></tr></table>


to calculate the weights and abscissas using function GAUSRC<!--hbox-->.
Here N is the number
of abscissas in the required Gaussian formula.
The corresponding weight function is w(x)=e<sup>&#8722;x<sup>2</sup></sup> on the interval (&#8722;&#8734;,&#8734;).
Output parameters W and A are arrays
of length  N, containing the weights and corresponding
abscissas. 
Error status can be obtained from the
returned value of GAUHER<!--hbox-->. Zero value implies successful execution.
Nonzero values may be set by function GAUSRC<!--hbox-->.
There is no error check
on the output and the accuracy can be tested by integrating the
functions e<sup>&#8722;x<sup>2</sup></sup>x<sup>j</sup> for j=0,1,&#8230;,2<span class="roman">N</span>&#8722;1,
using the calculated weights and abscissas.
This function requires functions <a href="appendixc.htm#gausrc"> GAUSRC</a> and <a href="appendixc.htm#tql2"> TQL2</a>.

<div class="p"><!----></div>
 <br /><br /><a name="gauswt"> </a>
 <b>55.&nbsp;GAUSWT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gauswt.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gauswt.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate weights and abscissas of
a Gaussian quadrature formula, with arbitrary weight function.
This function requires the values of moments i.e., the integrals
FMOM(m)=&#8747;<sub>a</sub><sup>b</sup> w(x)x<sup>m</sup>&nbsp;&nbsp;dx for m=0,1,&#8230;,2<span class="roman">N</span>&#8722;1. Existence of such
formulae should be ensured before trying to use this function.
If w(x) &gt; 0 throughout the interval, then such formulae should exist.
Here N is the number
of abscissas in the required Gaussian formula. Output parameters W and AB are arrays
of length  N, containing the weights and corresponding abscissas.
FMOM is the name of the function which
calculates the moments as defined above. Function FMOM(M) must be
supplied by the user. QGAUS is a parameter which specifies the
type of formula required. If QGAUS=1, then a Gaussian formula is
found, otherwise the function calculates the
weights for an interpolatory formula with given
weight function.  In this case, the array AB must contain the required
abscissas.
Error status can be obtained from the
returned value of GAUSWT<!--hbox-->. A value of 303 implies that
<span class="roman">N</span> &#8804; 0, in which case no
calculations are performed.
GAUSWT=322 implies that the function <a href="appendixc.htm#gauelm"> GAUELM</a>
failed to find the coefficients of the required polynomial.
GAUSWT=323
implies that the function POLYR failed to find zeros of the polynomial.
Both these errors can occur only for QGAUS=1 and
in both these cases, no further calculations are performed. Similarly,
GAUSWT=324 implies that function GAUELM failed to calculate the weights.
In this case, the abscissas are already calculated, but the values may
not be reliable.
GAUSWT=322, 323, 324 will normally imply that either the
Gaussian formula does not exist or the weights and abscissas cannot
be calculated because of ill-conditioning. In latter case, improving
the accuracy of arithmetic may help. Even if GAUSWT=0, 
the results could be unreliable. In particular, the zeros of polynomial
may be complex, but only the real part may be returned in AB<!--hbox-->. This failure
can occur either because of ill-conditioning, or because the formula
does not exist.
This function requires functions <a href="appendixc.htm#polyr"> POLYR</a> and
<a href="appendixc.htm#lagitr"> LAGITR</a> for solving the required polynomial, and function <a href="appendixc.htm#gauelm"> GAUELM</a>
for solving a system of linear equations. The algorithm used here
is rather ill-conditioned and should not be used for large N, unless
very high precision arithmetic is being used. There is no error check
on the output and the accuracy can be tested by integrating the
functions w(x)x<sup>n</sup>  for n=0,1,&#8230;,2<span class="roman">N</span>&#8722;1, using the calculated
weights and abscissas.
If the recurrence relation for the corresponding
orthogonal polynomial are known then <a href="appendixc.htm#gausrc"> GAUSRC</a> should be used to
calculate the weights and abscissas.

<div class="p"><!----></div>
 <br /><br /><a name="filon"> </a>
 <b>56.&nbsp;FILON&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/filon.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/filon.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to evaluate integrals of the form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>b</small><!--sup
--><br /><br />
<small>a</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
f(x)sin(kx)&nbsp;&nbsp;dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="roman">or</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>b</small><!--sup
--><br /><br />
<small>a</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
f(x)cos(kx)&nbsp;&nbsp;dx&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.21)</td></tr></table>
</td></tr></table>


using Filon's method.
RI is an output parameter which will contain the
value of the integral. XL and XU are the lower and upper limits for
the integral. It is not essential to have <span class="roman">XL</span>  &lt;  <span class="roman">XU</span>. 
RK is the coefficient k, multiplying x in the sine or cosine function.
QSIN is a parameter to determine the type of integral,
QSIN=1, implies that the integrand
involves sin(kx) otherwise the oscillatory factor
is cos(kx). AEPS and REPS specify the required absolute and
relative accuracy. The calculations
are terminated when the successive values differ by less than
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RI</span>&#124;).
DIF is an output parameter which should contain
an estimate of (absolute) error calculated by the function. N is an
output parameter containing the number of function evaluations
used.
Error status can be obtained from the
returned value of FILON<!--hbox-->. A value of 30 implies that
the function has failed to converge to the specified accuracy.
In this case, RI will contain the best estimate for the integral
and DIF should contain the estimated error.
The parameter NMAX in the function could be increased if larger
number of function evaluations are to be allowed.
FUN is the name of the function to calculate the non-oscillatory
part f(x) in the integrand.
Function FUN(X) must be supplied by the user. The parameter THC is the
critical value of &#952;, below which the Taylor series expansion
is used to evaluate the functions &#945;(&#952;), &#946;(&#952;) and
&#947;(&#952;). THC should be of the order of (100&#295;)<sup>1/6</sup>.
The value here is appropriate for 53-bit arithmetic.
If other values are used, the errors could be larger.

<div class="p"><!----></div>
 <br /><br /><a name="adpint"> </a>
 <b>57.&nbsp;ADPINT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/adpint.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/quad.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral using
adaptive technique based on Gauss-Kronrod rule. RINT is the output parameter
containing the value of the integral. XL and XU are the lower and
upper limits of the integral. It is not essential to have <span class="roman">XL</span> &lt; <span class="roman">XU</span>.
REPS and AEPS specify the required  accuracy, while DIF is an
output parameter giving the error as estimated by the function.
The function will attempt to ensure that
<span class="roman">DIF</span> &lt; max(&#124;<span class="roman">RINT</span>&#124;&times;<span class="roman">REPS</span>,<span class="roman">AEPS</span>).
However, it is not always possible to ensure that DIF is less than the
expected tolerance and in some cases even though the execution is
successfully completed DIF may be somewhat larger than the required
accuracy.
NPT is an output parameter which will contain the number of function
evaluations actually used. NMAX is the maximum
number of function evaluations that user is prepared to allow.
If <span class="roman">NMAX</span> &#8804; 0, then NMAX will be set to a default value of MAXPT (=100000).
Error status can be obtained from the
returned value of ADPINT<!--hbox-->. A value of 31 implies that
the function failed to converge to the specified
accuracy on at least one subinterval.
ADPINT=32 denotes that this failure
occurred more than IFMAX (=5) times. In this case the accuracy requirement
is adjusted by effectively increasing AEPS within the function.
The value of parameter AEPS is not actually changed.
This failure could occur if the function has
a very strong singularity at some points, or if the accuracy requirement
is too high. In the former case, increasing IPMAX in
the function may help, provided the singularity is at x=0, since
otherwise it is not possible to subdivide the interval if it spans two consecutive
numbers in the machine representation. It may be better to shift the 
singularity to x=0.
ADPINT=325 denotes that the function failed to achieve
satisfactory accuracy in NMAX function evaluations. This situation may occur either
because of singularity, or because very high accuracy is required.
Increasing NMAX or REPS may help in such cases.
In all cases, RI will contain the best estimate for integral
and DIF should contain the estimated error. If the integrand has singularities,
then this estimate may be unreliable. F is the name of the
function used to calculate the value of the integrand.
Function F(X) must be supplied by the user. This function also needs
the function <a href="appendixc.htm#kronrd"> KRONRD</a><!--hbox--> (or <a href="appendixc.htm#gaus16"> GAUS16</a>). This function could
be used for mildly singular functions or for functions which vary
by several orders of magnitude over the interval of integration.
However, if very large interval is given and the function is
almost constant over most of the interval, spurious convergence may
take place as the function may fail to detect the variation in
function value. In such cases integration should be calculated over
smaller subintervals and sum can be calculated to get the total integral.

<div class="p"><!----></div>
 <br /><br /><a name="kronrd"> </a>
 <b>58.&nbsp;KRONRD&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/kronrd.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/quad.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral using
Gauss-Kronrod formula. RI is the output parameter
containing the value of the integral. A and B are the lower and
upper limits of the integral. It is not essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>.
DIF is an
output parameter giving the error, as estimated by the function.
The function uses 7-point Gauss-Legendre formula and its 15-point
Kronrod extension to calculate the integral. RI will contain the
estimate using 15-point Kronrod formula, while DIF contains the
magnitude of the difference between the two values.
N is an output parameter which will contain the number of function
evaluations actually used. F is the name of the
function to calculate the integrand.
Function F(X) must be supplied by the user. 
The returned value of KRONRD is always zero.
This function is used by <a href="appendixc.htm#adpint"> ADPINT</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="gaus16"> </a>
 <b>59.&nbsp;GAUS16&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gaus16.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/adpint.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral using
16 point Gauss-Legendre formula.
This function can be used instead of <a href="appendixc.htm#kronrd"> KRONRD</a> with ADPINT for adaptive
integration. It calculates the integral using 8 and 16 point Gaussian
formula and the difference between the two estimates is considered
as estimated error. This function will be less efficient as compared
to KRONRD as it requires 24 function evaluations as opposed to 15
required by KRONRD<!--hbox-->. Although, the 16 point Gauss-Legendre formula
will have higher accuracy as compared to 15 point Gauss-Kronrod formula,
the error estimate is essentially the error in 8-point Gauss-Legendre
formula and it will not be much different from that obtained by KRONRD.
Since the adaptive choice of subintervals is determined by the
estimated error, it will be almost same for both these functions.
Thus in general KRONRD should be preferred but this function is
provided as an alternative.
RI is the output parameter
containing the value of the integral obtained using 16 point formula.
A and B are the lower and
upper limits of the integral. It is not essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>.
DIF is an
output parameter giving the error, as estimated by the function.
The function uses 8 and 16-point Gauss-Legendre formulae
to calculate the integral. RI will contain the
estimate using 16-point Gaussian formula, while DIF contains the
magnitude of the difference between the two values.
N is an output parameter which will contain the number of function
evaluations actually used. F is the name of the
function to calculate the integrand.
Function F(X) must be supplied by the user. 
The returned value of GAUS16 is always zero.
This function is used by <a href="appendixc.htm#adpint"> ADPINT</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="cauchy"> </a>
 <b>60.&nbsp;CAUCHY&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/cauchy.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/cauchy.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute the Cauchy principal
value of an integral. It uses ADPINT to perform the integral as
explained in Section 6.6.10.   RI is the output parameter
containing the value of the integral. A and B are the lower and
upper limits of the integral. It is essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>.
C is the point inside the interval [A, B] where the integrand is
singular.
REPS and AEPS specify the required  accuracy, while DIF is an
output parameter giving the error as estimated by the function.
The function will attempt to ensure that
<span class="roman">DIF</span> &lt; max(&#124;<span class="roman">RINT</span>&#124;&times;<span class="roman">REPS</span>,<span class="roman">AEPS</span>).
F is the name of the
function used to calculate the value of the integrand.
FUNP is the name of the function used to calculate <span class="roman">F</span><span class="roman">(</span><span class="roman">C</span><span class="roman">+</span><span class="roman">X</span><span class="roman">)</span><span class="roman">+</span><span class="roman">F</span><span class="roman">(</span><span class="roman">C</span>&#8722;<span class="roman">X</span><span class="roman">)</span>.
Error status can be obtained from the
returned value of CAUCHY<!--hbox-->. A value of 304 implies that
<span class="roman">A</span> &gt; <span class="roman">B</span>, <span class="roman">A</span> &gt; <span class="roman">C</span>
or <span class="roman">C</span> &gt; <span class="roman">B</span>. In this case no calculations are done.
Other values may be set by function ADPINT, which is called
twice to perform the integration. The returned value is set to
<span class="roman">IER</span><span class="roman">1</span>+2<span class="roman">IER</span><span class="roman">2</span>, where IER1 and IER2 are the values
returned by the two calls to ADPINT.
In these cases DIF will contain the
estimated error in the computed value of RI<!--hbox-->.
NPT is an output parameter which will contain the number of function
evaluations actually used.
This function needs functions <a href="appendixc.htm#adpint"> ADPINT</a> and <a href="appendixc.htm#kronrd"> KRONRD</a><!--hbox-->.
Functions F(X) and FUNP(X) must be supplied by the user.
The value of C is available through global variable CAU<tt>_</tt>CC<!--hbox-->.
There is no provision
to pass on the name of the function F(X) to FUNP(X) and if needed it will
have to be put explicitly. If <span class="roman">F</span><span class="roman">(</span><span class="roman">C</span><span class="roman">+</span><span class="roman">X</span><span class="roman">)</span><span class="roman">+</span><span class="roman">F</span><span class="roman">(</span><span class="roman">C</span>&#8722;<span class="roman">X</span><span class="roman">)</span> can be simplified to
remove singularity, the roundoff errors will be reduced.

<div class="p"><!----></div>
 <br /><br /><a name="euler"> </a>
 <b>61.&nbsp;EULER&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/euler.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/euler.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute the sum of an alternating
series using Euler's transformation.

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">SUM</span>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">A</span><span class="roman">0</span>&times;(&#8722;1)<sup>i</sup> <span class="roman">TERM</span>(i).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.22)</td></tr></table>
</td></tr></table>


The series may be finite or infinite. Before applying the Euler
transformation, it is advisable to sum the first few terms (and last
few terms, if the series is finite) separately
as it helps in improving the convergence. This function sums the
first M1 terms and the last M2 terms separately and applies the Euler
transform to the remaining terms from <span class="roman">M</span><span class="roman">1</span> to <span class="roman">N</span>&#8722;<span class="roman">M</span><span class="roman">2</span>&#8722;1.
The differences are calculated until the sum of each part converges
to the specified accuracy. For finite series the contribution from
the upper end is calculated separately. At most NMAX differences are
calculated. If the sum does not converge then another attempt may
be made by increasing M1 or M2. Although, NMAX can be trivially
increased, but if the convergence is slow the error estimate will
be unreliable and it will be better to improve convergence, which is
generally achieved by increasing M1 or M2.
Increasing NMAX may not help, as in most cases the roundoff error will
dominate in higher order differences.
N is the number of terms
to be summed, while M1, M2 are the number of terms at the two ends
which need to be summed separately.
For summing an infinite series use <span class="roman">N</span>=0, in which case M2 is ignored.
A0 specifies the sign of the first
term. The sum assuming the first term to be positive is multiplied by
A0. REPS and AEPS specify the required relative and absolute accuracy.
The estimated error should be less than max(AEPS,REPS&times;&#124;SUM&#124;). DIF is the output parameter which
gives the estimated error in the computed value of the sum.
In most cases, actual error will be somewhat larger than DIF and can be estimated
by repeating the calculations with different values of M1 and M2.
N1, N2 are the number of terms from both ends actually used by the
function. M2 and N2 are relevant only for finite series. SUM is the calculated
value of the sum.
TERM is the name of the function to calculate the terms of the series.
Error status can be obtained from the
returned value of EULER<!--hbox-->. A value of 31 implies that
<span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">2</span><span class="roman">NMAX</span> &#8805; <span class="roman">N</span>, in which case
M1 is set to N and the series is summed directly. In this case although
Euler transform is not used the sum should be exact apart from roundoff
errors.
EULER=32 implies that the series obtained after Euler transform did
not converge to required accuracy at the lower end.
EULER=34 implies that the series obtained after Euler transform did
not converge to required accuracy at the upper end. This is relevant
only for finite series.
EULER=36 implies that the series obtained after Euler transform did
not converge to required accuracy at both ends.
Function TERM(I) must be supplied by the user to calculate
the Ith term of the series apart from the sign as in Eq.&nbsp;(<span class="roman">C</span>.22).
Note that in keeping with the C convention the terms are numbered
from 0 to <span class="roman">N</span>&#8722;1. This must be accounted for in writing
function TERM(I).

<div class="p"><!----></div>
 <br /><br /><a name="bspqd2"> </a>
 <b>62.&nbsp;BSPQD2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspqd2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bspqd2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral of an expansion in
terms of B-spline basis functions in two dimensions over a rectangular region.
The expansion may be obtained by
interpolating or approximating a table of values.
Before calling this function, the coefficients of B-spline
expansion must be calculated by a call to the function <a href="appendixc.htm#bspint2"> BSPINT2</a><!--hbox-->.

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">BSPQD</span><span class="roman">2</span>=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">XU</span></small><!--sup
--><br /><br />
<small><span class="roman">XL</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx </td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">YU</span></small><!--sup
--><br /><br />
<small><span class="roman">YL</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dy&nbsp;&nbsp;&nbsp; </td><td nowrap="nowrap" align="center">
<small><span class="roman">NX</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp; </td><td nowrap="nowrap" align="center">
<small><span class="roman">NY</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">WT</span><span class="roman">[</span><span class="roman">j</span><span class="roman">]</span><span class="roman">[</span><span class="roman">i</span><span class="roman">]</span>&nbsp;&nbsp;&#981;<sub>i</sub>(x)&#968;<sub>j</sub>(y),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.23)</td></tr></table>
</td></tr></table>


where &#981;<sub>i</sub>(x) are the B-spline basis functions of order K
along x, and &#968;<sub>j</sub>(y) are those along y.
The integral is evaluated recursively. First the integral along x
is evaluated for each value of j and then the integral over y is
calculated. It may be noted that the function <a href="appendixc.htm#bspqd"> BSPQD</a> to evaluate
the integral in one dimension is not called recursively.
NX, NY are the number of knots along x and y respectively.
X and Y are arrays of length NX and NY
containing the knots for B-splines.
The knots must be in ascending order with X[0], Y[0] containing the
first knot in respective directions.
K is the order of B-splines,
<span class="roman">K</span>=2 gives linear B-splines, while <span class="roman">K</span>=4 yields cubic B-splines, etc.
WT is an array of length <span class="roman">IW</span>&times;(<span class="roman">NY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)
containing the coefficients
of expansion in terms of B-spline basis functions. These coefficients
may be calculated using BSPINT2 for interpolation in a table of values.
IW is the second dimension of array WT as declared in the calling function.
XL and XU are the lower and upper limits of the integral along x.
YL and YU are the lower and upper limits of the integral along y.
IER is the error parameter. IER=0 implies successful execution
of the function. Nonzero values may be set by BSPQD which is called
to perform integration in one dimension.
This function
requires function <a href="appendixc.htm#bsplin"> BSPLIN</a> to evaluate the B-spline basis functions,
and function <a href="appendixc.htm#bspqd"> BSPQD</a> for integration in one dimension, while function
<a href="appendixc.htm#bspint2"> BSPINT2</a> will be required to calculate the coefficients of B-spline
before calling this function.

<div class="p"><!----></div>
 <br /><br /><a name="bspqdn"> </a>
 <b>63.&nbsp;BSPQDN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspqdn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bspqdn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to compute integral of an expansion in
terms of B-spline basis functions in n dimensions over a hyper-rectangular region.
The expansion may be obtained by
interpolating or approximating a table of values.
Before calling this function, the coefficients of B-spline
expansion must be calculated by a call to the function BSPINTN<!--hbox-->.
This function evaluates the integral

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">XU</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span></small><!--sup
--><br /><br />
<small><span class="roman">XL</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx<sub>0</sub>&#8230;</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">XU</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span></small><!--sup
--><br /><br />
<small><span class="roman">XL</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx<sub>N&#8722;1</sub></td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>0</sub>=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#8230;</td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>N&#8722;1</sub>=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">WT</span><span class="roman">[</span><span class="roman">i</span><sub><span class="roman">N</span>&#8722;<span class="roman">1</span></sub><span class="roman">]</span> &#8230;<span class="roman">[</span><span class="roman">i</span><sub><span class="roman">0</span></sub><span class="roman">]</span>&nbsp;&nbsp;&#981;<sub>i<sub>0</sub></sub><sup>(0)</sup>(x<sub>0</sub>)&#8230;&#981;<sub>i<sub>N&#8722;1</sub></sub><sup>(N&#8722;1)</sup>(x<sub>N&#8722;1</sub>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.24)</td></tr></table>
</td></tr></table>


where &#981;<sub>i</sub><sup>(j)</sup>(x) are the B-spline basis functions of order K
along x<sub>j</sub>.
The integral is evaluated recursively. First the integral along x<sub>0</sub>
is evaluated for each value of other indices and then the integral over x<sub>1</sub> is
calculated and so on.
It may be noted that the function <a href="appendixc.htm#bspqd"> BSPQD</a> to evaluate
the integral in one dimension is not called recursively. 
N is the number of dimensions.
NK is an integer array of length N containing the number of knots along
each direction. NK[I] is the number of knots along Ith dimension.
X is an array of length <span class="roman">NXD</span>&times;<span class="roman">N</span>
containing the knots for B-splines along each dimension.
The knots must be in ascending order.
X[J][I] is the Ith knot along Jth dimension.
It may be noted that the function <a href="appendixc.htm#bspintn"> BSPINTN</a> gives the list of knots
in the same format and that array can be directly used in this
function.
NXD is the second dimension of the array X as specified in the calling
function, NXD &#8805; max(<span class="roman">NK</span>[i]).
K is the order of B-splines,
<span class="roman">K</span>=2 gives linear B-splines, while <span class="roman">K</span>=4 yields cubic B-splines, etc.
WT is an array of length
(<span class="roman">NK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">NK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)&#8230;(<span class="roman">NK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)
containing the coefficients
of expansion in terms of B-spline basis functions. These coefficients
may be calculated using BSPINTN for interpolation in a table of values.
The coefficients are assumed to be stored in natural
Fortran order with no gaps in data. In the calling
function the array should have dimension
WT[NK[N&#8722;1]+K&#8722;2]&#8230;[NK[1]+K&#8722;2][NK[0]+K&#8722;2].
Alternately, it can be treated as a one dimensional array of required
length.
XL and XU are arrays of length N containing the lower and upper
limits of the integral along each direction.
XL[I] is the lower limit and XU[I] is the upper limit for integration
along Ith dimension.
IER is the error parameter. IER=0 implies successful execution
of the function. Nonzero values may be set by BSPQD which is called
to perform integration in one dimension.
This function
requires function <a href="appendixc.htm#bsplin"> BSPLIN</a> to evaluate the B-spline basis functions,
and function <a href="appendixc.htm#bspqd"> BSPQD</a> for integration in one dimension,
 while function
<a href="appendixc.htm#bspintn"> BSPINTN</a> will be required to calculate the coefficients of B-splines
before calling this function.

<div class="p"><!----></div>
 <br /><br /><a name="mulint"> </a>
 <b>64.&nbsp;MULINT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/mulint.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/multi.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function for integration over a hyper-rectangle
in N&nbsp;dimensions using a series of product Gauss-Legendre formulae.
A and B are arrays of length  N, with A[I] and B[I]
specifying the lower and upper limits for the Ith variable.
It is not essential to have <span class="roman">A</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> &lt; <span class="roman">B</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>. N is an integer variable
specifying the number of dimensions. There is no limit on the value of N
as far as this function is concerned, but the number of function
evaluations required to evaluate the integral for large N will put
some limit.
M is an integer array of length  N, specifying
which Gaussian formula is to be used along each axis in the first
approximation. The function will attempt to use M[I]-point Gauss-Legendre 
formula along the Ith axis. Formulae with 2, 4, 8, 16 and 32 points
are incorporated in the function.
If any other value is specified for M[I], then M[I] will be
set to the default value of 2. IND is an integer array of length 
N, specifying the number of subdivisions to be used for the first
approximation along each axis. If <span class="roman">IND</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> &lt;  1, then IND[I] is set to a
default value of 1. After execution, the arrays M and IND will contain the final
values of the formula and number of subintervals used along each axis.
M[I] and IND[I] are increased to achieve the required accuracy or
until the maximum number of function evaluations is reached.
F is the name of the function to calculate the value of integrand
at any given point. Function F(N, X) must be supplied by the user.
(Here the first argument specifies the number of dimensions, while the second
argument is an array of length N, specifying the coordinates of the
point at which the integrand is to be evaluated.) RINT is the output 
parameter which will contain the value of the integral.
REPS and AEPS specify the accuracy required by user while DIF is
an output parameter containing the estimated (absolute) error in RINT<!--hbox-->.
The function will attempt to ensure that
<span class="roman">DIF</span> &lt; max(&#124;<span class="roman">RINT</span>&#124;&times;<span class="roman">REPS</span>,<span class="roman">AEPS</span>).
NUM is an output parameter containing the number of function evaluations
actually used. MAXPT is the maximum limit on the
number of function evaluations which the user is prepared for. If
<span class="roman">MAXPT</span> &lt; 1, then it is set to a default value of MAXPTS (=1100000). The value
of MAXPT will depend on the computer time that is available and the
accuracy required.
Error status can be obtained from the
returned value of MULINT<!--hbox-->. A value of 39 implies that
the integral failed to converge to the required
accuracy in MAXPT function evaluations. In this
case, RINT will contain the best approximation to the integral and DIF
will contain the error estimate.
The error estimate may not be very reliable as the number of points
may not be sufficient to check for convergence along each dimension.
If a second attempt is to be
made with larger MAXPT, then the values of M[I] and IND[I] should not
be reset, since that will save some function evaluations in computing initial
approximations, which are known to be unsatisfactory.
MULINT=305 implies that <span class="roman">N</span>  &lt; 1.
MULINT=307 implies that the number of points exceeded
MAXPT in the first attempt itself. In such cases, no approximation for the
integral will be available.
This function
requires function <a href="appendixc.htm#ngauss"> NGAUSS</a>.

<div class="p"><!----></div>
 <br /><br /><a name="ngauss"> </a>
 <b>65.&nbsp;NGAUSS&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/ngauss.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/multi.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function for integration over a hyper-rectangle
in N&nbsp;dimensions using a  product Gauss-Legendre formula.
A and B are arrays of length  N, with A[I] and B[I]
specifying the lower and upper limits for the Ith variable.
It is not essential to have <span class="roman">A</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> &lt; <span class="roman">B</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>. N is an integer variable
specifying the number of dimensions.
M is an integer array of length  N, specifying
the Gaussian formula to be used along each axis.
The function attempts to use M[I]-point Gauss-Legendre 
formula along the Ith axis. Formulae with 2, 4, 8, 16 and 32 points
are incorporated in the function.
If any other value is specified for M[I], then
no calculations will be attempted.
IND is an integer array of length 
N, specifying the number of subdivisions to be used
along each axis. If <span class="roman">IND</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> &lt;  1, then
no calculations will be performed.
F is the name of the function to calculate the value of integrand
at any given point. The Function F(N, X) must be supplied by the user.
(Here the first argument specifies the number of dimensions, while the second
argument is an array of length N specifying the coordinates of the
point at which the integrand is to be evaluated.) RI is the output 
parameter which will contain the value of the integral.
NUM is an output parameter containing the number of function evaluations
actually used. MAXPT is the maximum limit on the
number of function evaluations which the user is prepared for. If
<span class="roman">MAXPT</span> &lt; 1, then it is set to a default value of MAXPTS (=1100000). The value
of MAXPT will depend on the computer time that is available and the
accuracy required.
Error status can be obtained from the
returned value of NGAUSS<!--hbox-->. A value of 305 implies that
<span class="roman">N</span> &lt; 1.
NGAUSS=306 implies that either M[J] is not 2, 4, 8, 16 or 32
or INT[J] &lt; 1 for some J.
NGAUSS=307 implies that the number of points exceeded
MAXPT. In all these cases no calculations are performed.
This function is called by <a href="appendixc.htm#mulint"> MULINT</a> which adjusts the number of abscissas
to be used along each dimension depending on the required accuracy. It can also
be used directly to calculate the integral using quadrature formulae with specified number of points in
each dimension.

<div class="p"><!----></div>
 <br /><br /><a name="sphnd"> </a>
 <b>66.&nbsp;SPHND&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/sphnd.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/multisp.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to transform the coordinates from
hyper-spherical to Cartesian in n-dimensions. It can be used for
integration over hyper-spherical shell in n-dimensions using function
<a href="appendixc.htm#mulint"> MULINT</a>, <a href="appendixc.htm#strint"> STRINT</a>, <a href="appendixc.htm#mcarlo"> MCARLO</a> or <a href="appendixc.htm#equids"> EQUIDS</a> when the function is known in terms
of Cartesian coordinates. For this purpose SPHND should be
passed on as the name of the function to calculate the integrand.
The limits A[I] and B[I] of integration along Ith dimension
should be [0,&#960;] for <span class="roman">I</span>=1,&#8230;,<span class="roman">N</span>&#8722;2, [0,2&#960;]
for <span class="roman">I</span><span class="roman">=</span><span class="roman">N</span>&#8722;<span class="roman">1</span> and [r<sub>l</sub>,r<sub>u</sub>] for <span class="roman">I</span><span class="roman">=</span><span class="roman">0</span>. Here r<sub>l</sub> and r<sub>u</sub> are the radial
coordinates of the hyper-spherical shell over which integration is
required. For integration over a hyper-sphere of radius R, r<sub>l</sub>=0 and
r<sub>u</sub>=R. This function gives the transformation between hyper-spherical
coordinates x<sub>i</sub> and Cartesian coordinates y<sub>i</sub>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
y<sub>0</sub></td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=x<sub>0</sub>cos(x<sub>1</sub>),</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6> </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
y<sub>1</sub></td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=x<sub>0</sub>sin(x<sub>1</sub>)cos(x<sub>2</sub>),</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
y<sub>2</sub></td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=x<sub>0</sub>sin(x<sub>1</sub>)sin(x<sub>2</sub>)cos(x<sub>3</sub>),</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&#8230;</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
y<sub>n&#8722;2</sub></td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=x<sub>0</sub>sin(x<sub>1</sub>)sin(x<sub>2</sub>)&#8230;sin(x<sub>n&#8722;2</sub>)cos(x<sub>n&#8722;1</sub>),</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
y<sub>n&#8722;1</sub></td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">=x<sub>0</sub>sin(x<sub>1</sub>)sin(x<sub>2</sub>)&#8230;sin(x<sub>n&#8722;2</sub>)sin(x<sub>n&#8722;1</sub>).</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.25)</td></tr></table>


The integral can be written as

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><br />
<small>S<sub>n</sub></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
f(x)&nbsp;&nbsp;dV = </td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>r<sub>u</sub></small><!--sup
--><br /><br />
<small>r<sub>l</sub></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx<sub>0</sub></td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#960;</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx<sub>1</sub>&#8230;</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#960;</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx<sub>n&#8722;2</sub></td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>2&#960;</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx<sub>n&#8722;1</sub> f(x) x<sub>0</sub><sup>n&#8722;1</sup></td><td nowrap="nowrap" align="center">
<small>n&#8722;2</small><!--sup
--><br /><font size="+3">&#8719;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
sin<sup>n&#8722;i&#8722;1</sup>x<sub>i</sub>&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.26)</td></tr></table>
</td></tr></table>


The function f(x) is calculated after transformation to Cartesian
coordinates and the volume element as given above is multiplied.
N is the number of dimensions, X and Y are arrays of length N
containing the coordinates of required point. X[I] are the input
hyper-spherical coordinates, while Y[I] are the Cartesian coordinates.
Function FUNSPH(N, Y) is called to calculate the required function
in Cartesian coordinates. Since there is no provision to pass on the
name of this function, it has to be the same as what appears in the routine.

<div class="p"><!----></div>
 <br /><br /><a name="strint"> </a>
 <b>67.&nbsp;STRINT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/strint.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/multi.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function for integration over a hyper-rectangle
in N&nbsp;dimensions using compound monomial rules of degree 1, 3 or 5.
A and B are arrays of length  N, with A[I] and B[I]
specifying the lower and upper limits for the Ith variable.
It is not essential to have <span class="roman">A</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> &lt; <span class="roman">B</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>. N is an integer variable
specifying the number of dimensions. There is no limit on the value of N
as far as this function is concerned, but the function <a href="appendixc.htm#stroud"> STROUD</a> which
is invoked to actually evaluate the integrals will have some limit.
If this limit is exceeded, error flag will be set.
Although, a large limit on N is allowed the result is unlikely to be
reliable for very large values of N.
M is an integer parameter specifying the formula to be used on each subdivision.
The allowed values of M are 1, 3 and 5. <span class="roman">M</span>=1 selects the one-point
formula of degree one (essentially a generalisation of the midpoint rule).
<span class="roman">M</span>=3 selects the 2N-point formula of degree 3 due to Stroud. <span class="roman">M</span>=5 selects
the (2<span class="roman">N</span><sup>2</sup>+1)-point formula of degree 5. If M is not one of these values,
it will be
set to the default value of 3. IND is an integer array of length 
N, specifying the number of subdivisions to be used for the first
approximation along each axis. If <span class="roman">IND</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> &lt;  1, then it will be set to a
default value of 1. After execution, the array IND will contain the final
values of the number of subintervals used along each axis.
F is the name of the function to calculate the value of the integrand
at any given point. Function F(N, X) must be supplied by the user.
(Here the first argument specifies the number of dimensions, while the second
argument is an array of length N, specifying the coordinates of the
point at which the integrand is to be evaluated.) RINT is the output 
parameter which will contain the value of the integral.
REPS and AEPS specify the accuracy required by user, while DIF is
an output parameter containing the estimated (absolute) error in RINT<!--hbox-->.
The function will attempt to ensure that
<span class="roman">DIF</span> &lt; max(&#124;<span class="roman">RINT</span>&#124;&times;<span class="roman">REPS</span>,<span class="roman">AEPS</span>).
NUM is an output parameter containing the number of function evaluations
actually used. MAXPT is the maximum limit on the
number of function evaluations which the user is prepared for. If
<span class="roman">MAXPT</span> &lt; 1, then it is set to a default value of MAXPTS (=1000000). The value
of MAXPT will depend on the computer time that is available and the
accuracy required.
Error status can be obtained from the
returned value of STRINT<!--hbox-->. A value of 39 implies that
the integral failed to converge to the required
accuracy in MAXPT function evaluations. In this
case, RINT will contain the best approximation to the integral and DIF
will contain the error estimate.
The error estimate may not be very reliable as the number of points
may not be sufficient to check for convergence along each dimension.
If a second attempt is to be
made with larger MAXPT, then the value of IND[I] should not
be reset, since that will save some function evaluations in computing initial
approximations, which are known to be unsatisfactory.
STRINT=308 implies that the number of points exceeded
MAXPT in the first attempt itself. In such cases, no approximation for the
integral will be available.
STRINT=309 implies that N is outside the limits accepted by STROUD.
This function requires
function STROUD.

<div class="p"><!----></div>
 <br /><br /><a name="stroud"> </a>
 <b>68.&nbsp;STROUD&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/stroud.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/multi.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function for integration over a hyper-rectangle
in N&nbsp;dimensions using a  compound monomial rule of degree 1, 3 or 5.
A and B are arrays of length  N, with A[I] and B[I]
specifying the lower and upper limits for the Ith variable.
It is not essential to have <span class="roman">A</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> &lt; <span class="roman">B</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>. N is an integer variable
specifying the number of dimensions. The value of N must be between 
1 and 50.
If N is outside these limits error flag will be set.
M is an integer specifying the formula to be used on each subdivision.
The allowed values of M are 1, 3 and 5. <span class="roman">M</span>=1 selects the one-point
formula of degree one (essentially a generalisation of the midpoint rule).
<span class="roman">M</span>=3 selects the 2N-point formula of degree 3 due to Stroud. <span class="roman">M</span>=5 selects
the (2<span class="roman">N</span><sup>2</sup>+1)-point formula of degree 5.
If any other value is specified for M, then
no calculations will be attempted.
IND is an integer array of length 
N, specifying the number of subdivisions to be used
along each axis. If <span class="roman">IND</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> &lt;  1, then
no calculations will be performed.
F is the name of the function to calculate the value of integrand
at any given point. The function F(N, X) must be supplied by the user.
(Here the first argument specifies the number of dimensions, while second
argument is an array of length N specifying the coordinates of the
point at which the integrand is to be evaluated.) RI is the output 
parameter which will contain the value of the integral.
NUM is an output parameter containing the number of function evaluations
actually used. MAXPT is the maximum limit on the
number of function evaluations which the user is prepared for. If
<span class="roman">MAXPT</span> &lt; 1, then it is set to a default value of MAXPTS (=1000000). The value
of MAXPT will depend on the computer time that is available and the
accuracy required.
Error status can be obtained from the
returned value of STROUD<!--hbox-->. A value of 308 implies that
the number of points exceeded MAXPT.
STROUD=309 implies that <span class="roman">N</span> &lt; 1 or <span class="roman">N</span> &gt; NMAX.
STROUD=310 implies that M is not 1, 3 or 5, or
IND[I] &lt; 1 for some I<!--hbox-->. In all these cases
and no calculations are performed.
This function is called by <a href="appendixc.htm#strint"> STRINT</a> which adjusts the number of abscissas
to be used along each dimension depending on the required accuracy.

<div class="p"><!----></div>
 <br /><br /><a name="mcarlo"> </a>
 <b>69.&nbsp;MCARLO&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/mcarlo.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/multi.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function for integration over a hyper-rectangle
in N&nbsp;dimensions using Monte Carlo method.
A and B are arrays of length  N, with A[I] and B[I]
specifying the lower and upper limits for the Ith variable.
It is not essential to have <span class="roman">A</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> &lt; <span class="roman">B</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>. N is an integer variable
specifying the number of dimensions.
NPT is the maximum number of function evaluations to be used for integration.
F is the name of the function to calculate the value of the integrand
at any given point. The function F(N, X) must be supplied by the user.
(Here the first argument specifies the number of dimensions, while the second
argument is an array of length N specifying the coordinates of the
point at which the integrand is to be evaluated.) RI is an output 
parameter, which will contain the value of the integral.
REPS and AEPS specify the desired accuracy.
ERR is an output parameter containing the (absolute) error estimate for
the integral. This error estimate is obtained by using the variance
&#963; as defined in Section 6.11. ERR is set to 2.576&#963;/&#8730;{<span class="roman">NP</span>} corresponding to a confidence level of 99%.
The function attempts to ensure that
<span class="roman">ERR</span> &lt; max(&#124;<span class="roman">RI</span>&#124;&times;<span class="roman">REPS</span>,<span class="roman">AEPS</span>).
NP is the number of function evaluations actually used.
Error status can be obtained from the
returned value of MCARLO<!--hbox-->. A value of 39 implies that
the function failed to converge to the specified
accuracy. In this case, RI will contain the best estimate and ERR the
corresponding error estimate.
MCARLO=311 implies that <span class="roman">N</span> &lt; 1  and no calculations are
done.
This function requires function <a href="appendixc.htm#ranf"> RANF</a>(ISEED)
to generate random numbers. If a different function is used for this purpose,
then the value of seed may have to be changed. 

<div class="p"><!----></div>
 <br /><br /><a name="ran1"> </a>
 <b>70.&nbsp;RAN1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/ran1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gaubnd.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to generate a sequence of random numbers
using a simple linear congruential method. The constants AM, A and AC 
will give overflow in integer arithmetic using 32-bits and hence these
must be treated as double precision variables.
SEED could be set to any positive value less than AM, before
first call to the function. After the first call, this variable should not be
changed in any other function. It may be noted that this function requires
a real number as seed as opposed to <a href="appendixc.htm#ranf"> RANF</a>, which needs an integer seed
as argument. Further, in this case the seed has to be positive, while
for RANF it has to be negative for initialisation. This has to be kept
in mind while changing the random number generator in any function.

<div class="p"><!----></div>
 <br /><br /><a name="ranf"> </a>
 <b>71.&nbsp;RANF&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/ranf.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/multi.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to generate a sequence of random numbers
using a combination of three linear congruential generators.
This function is based on the function RAN1 in Press <i>et al.</i>&nbsp;(2007).
The constants m,a and c for each of these generators are
chosen, such that there should be no overflow on a machine with 32-bit word
length. ISEED could be set to any negative value, before
first call to the function. After the first call, this variable should not be
changed in any other function.

<div class="p"><!----></div>
 <br /><br /><a name="equids"> </a>
 <b>72.&nbsp;EQUIDS&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/equids.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/multi.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function for integration over a hyper-rectangle
in N&nbsp;dimensions using the method based on equidistributed sequences.
A and B are arrays of length  N, with A[I] and B[I]
specifying the lower and upper limits for the Ith variable.
It is not essential to have <span class="roman">A</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> &lt; <span class="roman">B</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>. N is an integer variable
specifying the number of dimensions. N should be between 1 and NMAX (=21).
If N is outside these limits, then error flag will be set.
NPT is the maximum number of function evaluations to be used in computing the
integral.
F is the name of the function to calculate the value of the integrand
at any given point. The function F(N, X) must be supplied by the user.
(Here the first argument specifies the number of dimensions, while the second
argument is an array of length N specifying the coordinates of the
point at which the integrand is to be evaluated.) S1 and S2 are the output 
parameters which will contain the value of the integral.
These values provide the two approximations using equidistributed sequences.
If the function is sufficiently smooth, S2 is expected to be a better
approximation and could in general be used as the best approximation to
the integral.
REPS and AEPS specify the accuracy required by the user, while DIF is
an output parameter containing the estimated (absolute) error in S2.
The function attempts to ensure that
<span class="roman">DIF</span> &lt; max(&#124;<span class="roman">S</span><span class="roman">2</span>&#124;&times;<span class="roman">REPS</span>,<span class="roman">AEPS</span>).
NP is an output parameter containing the number of function evaluations
actually used.
Error status can be obtained from the
returned value of EQUIDS<!--hbox-->. A value of 39 implies that
the integral failed to converge to the required
accuracy in NPT function evaluations. In this
case, S2 (or S1) will contain the best approximation to the integral and DIF
will contain the error estimate. Evaluation of the sum in EQUIDS involves
large roundoff errors and it is recommended to use this function
with double precision.
EQUIDS=312 implies that <span class="roman">N</span> &lt; 1 or <span class="roman">N</span> &gt; NMAX.

<div class="p"><!----></div>
 

<br /><br />
<a name="Nonlinear Algebraic Equations"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.7&nbsp; NONLINEAR ALGEBRAIC EQUATIONS </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bisect">BISECT</a></td>
<td>&nbsp; <a href="#secant">SECANT</a></td>
<td>&nbsp; <a href="#secani">SECANI</a></td>
<td>&nbsp; <a href="#newrap">NEWRAP</a></td>
<td>&nbsp; <a href="#brent">BRENT</a></td>
<td>&nbsp; <a href="#search">SEARCH</a></td>
<td>&nbsp; <a href="#zroot">ZROOT</a></td>
<td>&nbsp; <a href="#zroot2">ZROOT2</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#muller">MULLER</a></td>
<td>&nbsp; <a href="#muler2">MULER2</a></td>
<td>&nbsp; <a href="#polyr">POLYR</a></td>
<td>&nbsp; <a href="#lagitr">LAGITR</a></td>
<td>&nbsp; <a href="#davidn">DAVIDN</a></td>
<td>&nbsp; <a href="#newton">NEWTON</a></td>
<td>&nbsp; <a href="#broydn">BROYDN</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="bisect"> </a>
 <b>73.&nbsp;BISECT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bisect.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/realrt.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to find a real zero of a continuous function
using the method of bisection. XL and XU bracket the interval containing the
zero. The function must have opposite signs at these two points. This
interval will be refined by bisection, and after execution XL and XU
will contain the refined estimate for the interval containing the zero.
It is not necessary to have <span class="roman">XL</span> &lt; <span class="roman">XU</span>.
X is an output parameter which will contain the interpolated value of
the zero, using the last estimate at the end points XL and XU<!--hbox-->. NB is
an input parameter specifying the number of bisections to be performed.
F is the name of the function routine to calculate the function.
Error status can be obtained from the
returned value of BISECT<!--hbox-->. A value of 401 implies that
<span class="roman">NB</span> &#8804; 0, in which case,
no calculations are performed.
BISECT=421 implies that the function has the same
sign at both the end points and hence bisection cannot be performed.
BISECT=&#8722;1 implies that the function vanishes at one of the points.
Hence, the required number of bisections have not been performed, but
in this case, X will contain the "zero".
Before invoking this function, it must be ensured that the function is
continuous in the interval. In particular, the sign change should not be due
to a singularity within the interval. The number of bisections to be performed
should be carefully chosen, since performing unnecessary bisections will
not improve the accuracy of the computed zero. The function F(X)
must be supplied by the user.

<div class="p"><!----></div>
 <br /><br /><a name="secant"> </a>
 <b>74.&nbsp;SECANT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/secant.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/realrt.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To calculate a real zero of a given function
using the secant iteration. XL and XU specify the limits within which the
zero is expected. It is essential to have <span class="roman">XL</span> &lt; <span class="roman">XU</span> i.e., XL
is the lower limit and XU is the upper limit. It is not necessary that the
function value should have opposite sign at these two points. The limits are
only used to terminate the iteration, if it is going astray. X0 is the
initial guess for the zero and it is essential to have 
<span class="roman">XL</span> &#8804; <span class="roman">X</span><span class="roman">0</span> &#8804; <span class="roman">XU</span>.
X is an output parameter containing the computed value of
the zero. REPS and AEPS specify the relative
and absolute convergence criterion. The zero should be determined
with an accuracy
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;). FUN is the name of the
external routine to calculate the required function. Function FUN(X)
must be supplied by the user.
Error status can be obtained from the
returned value of SECANT<!--hbox-->. A value of 40 implies that
the calculated values of the function at the two most recent points
was equal, and it is not possible to continue the iteration further.
This situation can arise if the zero is multiple, or if the convergence criterion
is too stringent, or sometimes just by coincidence. In the first two cases,
the computed value of the zero may be reasonable.
SECANT=402 implies that the starting value was outside the given
interval, in which case, no calculations are performed. 
SECANT=422 implies that the iteration has gone outside the prescribed
limits, and was terminated at that stage. This situation may arise, because
the zero is outside or close to the specified limits. However, this is not
essential and the iteration may tend to go outside for other reasons.
SECANT=423
implies that the iteration failed to converge to the specified accuracy.
This failure could be due to various reasons, like very stringent convergence
criterion, or excessive roundoff error in calculating the function, or 
the iteration simply failed to detect the zero.
This function attempts
to make a reasonable guess for the second starting value, using the
limiting interval and the convergence criterion. However, if the root
is too large, or too small, or if the bounding interval is very large
this choice may not be good. In such cases, the iteration may not converge.
This problem can be rectified by choosing the proper increment DX at
the first step, or by making the bounding interval smaller.
If the function is calculated in the form FUN&times;2<sup><span class="roman">JF</span></sup> 
to avoid overflows and underflows, then use the function SECAN<tt>_</tt>2 instead
of SECANT<!--hbox-->. The call statement is identical for the two functions.

<div class="p"><!----></div>
 <br /><br /><a name="secani"> </a>
 <b>75.&nbsp;SECANI&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/secani.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/secan_2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To calculate a real zero of a given function
using the secant iteration. The function is calculated in the form
F&times;2<sup><span class="roman">JF</span></sup> to avoid overflows and underflows.
It also uses the reverse communication technique for passing function
values. This function will return control to the calling function when
it needs a function evaluation. In that case, the error parameter IER
will be set to a negative value and the function should be evaluated
at X<!--hbox-->. The value of the function should be returned in the variables
F and JF<!--hbox-->. During the function evaluation variables other than F and JF
in the call statement should not be disturbed. Before the first call,
IER should be set to zero. IER &#8805; 0 implies that the execution
is complete and no more function evaluations are required. In that
case the value of X will give the root (if IER=0) or the final value
of X where the function was evaluated.
XL and XU specify the limits within which the
zero is expected. It is essential to have <span class="roman">XL</span> &lt; <span class="roman">XU</span> i.e., XL
is the lower limit and XU is the upper limit. It is not necessary that the
function value should have opposite sign at these two points. The limits are
only used to terminate the iteration, if it is going astray. X0 is the
initial guess for the zero and it is essential to have 
<span class="roman">XL</span> &#8804; <span class="roman">X</span><span class="roman">0</span> &#8804; <span class="roman">XU</span>.
X is an output parameter containing the value of x at which the
function value is required, when IER &lt; 0. For other values
of IER it will contain the computed root or a failed approximation to it.
The calculated function value is to be passed through the variables
F and JF<!--hbox-->.
REPS and AEPS specify the relative
and absolute convergence criterion. The zero should be determined
with an accuracy
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;). 
IER is the error parameter.
If IER &lt; 0, then a fresh function evaluation is required.
IER=0 implies that function execution has been successfully
completed and X should contain the calculated root.
IER=40 implies that
the calculated values of the function at the two most recent points
was equal, and it is not possible to continue the iteration further.
This situation can arise if the zero is multiple, or if the convergence criterion
is too stringent, or sometimes just by coincidence. In the first two cases,
the computed value of the zero may be reasonable.
IER=402 implies that the starting value was outside the given
interval, in which case, no calculations are performed. 
IER=422 implies that the iteration has gone outside the prescribed
limits, and was terminated at that stage. This situation may arise, because
the zero is outside or close to the specified limits. However, this is not
essential and the iteration may tend to go outside for other reasons. IER=423
implies that the iteration failed to converge to the specified accuracy.
This failure could be due to various reasons, like very stringent convergence
criterion, or excessive roundoff error in calculating the function, or 
the iteration simply failed to detect the zero.
This function attempts
to make a reasonable guess for the second starting value, using the
limiting interval and the convergence criterion. However, if the root
is too large, or too small, or if the bounding interval is very large
this choice may not be good. In such cases, the iteration may not converge.
This problem can be rectified by choosing the proper increment DX at
the first step, or by making the bounding interval smaller.

<div class="p"><!----></div>
 <br /><br /><a name="newrap"> </a>
 <b>76.&nbsp;NEWRAP&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/newrap.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/newrap.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To calculate a real zero of a given function
using the Newton-Raphson method. This function tries to estimate the
multiplicity of the zero by looking at the convergence rate and then
uses this estimate to accelerate the convergence.
XL and XU specify the limits within which the
zero is expected. It is essential to have <span class="roman">XL</span> &lt; <span class="roman">XU</span> i.e., XL
is the lower limit and XU is the upper limit. It is not necessary that the
function should have opposite signs at these two points. The limits are
only used to terminate the iteration, if it is going astray. X0 is the
initial guess for the zero and it is essential to have 
<span class="roman">XL</span> &#8804; <span class="roman">X</span><span class="roman">0</span> &#8804; <span class="roman">XU</span>. X is an output parameter containing
the computed value of the zero. REPS and AEPS specify the relative
and absolute convergence criterion. The zero should be calculated
with an accuracy
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;). FUN is the name of the
external routine to calculate the required function and its derivative.
Function FUN(X, DF) must be supplied by the user,
where DF is the first derivative of FUN<!--hbox--> at X<!--hbox-->.
Error status can be obtained from the
returned value of NEWRAP<!--hbox-->. A value of 403 implies that
the starting value was outside the given
range, in which case, no calculations are performed. 
NEWRAP=424 implies that the iteration has gone outside the prescribed
limits, and was terminated at that stage. This situation may arise, because
the zero is outside or close to the specified limits. However, this is not
essential and iteration may tend to go outside for other reasons. NEWRAP=425
implies that the iteration failed to converge to the specified accuracy.
This failure could be due to various reasons, like very stringent convergence
criterion, or excessive roundoff error in calculating the function, or 
the iteration simply failed to detect the zero. NEWRAP=426 implies that
the calculated value of the derivative at the last point is zero,
and it is not possible to continue the iteration further. In this case
the zero is detected to be simple. This can happen by coincidence.
This situation can happen if the zero is multiple, in which case
NEWRAP is set to 126&#8722;100&times;multiplicity.
In this case,
the computed value of the zero may be reasonable. On successful completion
of the function, the returned value of NEWRAP will be zero if the root
is simple and NEWRAP=&#8722;k,
if the root is detected to be multiple with multiplicity k.
Function FUN(X, DF) must be supplied by the user.

<div class="p"><!----></div>
 <br /><br /><a name="brent"> </a>
 <b>77.&nbsp;BRENT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/brent.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/realrt.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To calculate a real zero of a given function
using the Brent's method. This function is based on the procedure given
by Brent&nbsp;(1973). A and B specify the limits within which the
zero is located. It is essential that the function has opposite signs
at these two points. The values of A and B will be updated by the
function to locate the zero with required accuracy.
X is the output parameter containing the computed value of the
zero. REPS and AEPS specify the relative
and absolute convergence criterion. The zero should be calculated
with an accuracy
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;). F is the name of the
external routine to calculate the required function. Function F(X)
must be supplied by the user.
Error status can be obtained from the
returned value of BRENT<!--hbox-->. A value of 427 implies that
the function has the same sign at both the end
points and hence the Brent's method cannot be applied.
BRENT=428
implies that the iteration failed to converge to the specified accuracy.
This failure could be due to the fact that the convergence criterion
is too stringent. Increasing the parameter NIT in
the function may allow convergence, but before doing that it must be ensured
that it will be meaningful to do so. Since convergence to any arbitrary
accuracy does not ensure that the zero is correct to that accuracy.
If the accuracy requirement cannot be satisfied within the available
floating-point arithmetic, then the iteration may never converge to the
specified accuracy.
Before invoking this function, it must be ensured that the function is
continuous in the interval. In particular, the sign change should not be due
to a singularity within the interval.

<div class="p"><!----></div>
 <br /><br /><a name="search"> </a>
 <b>78.&nbsp;SEARCH&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/search.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/search.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to search for complex zeros by looking for 
sign changes in the real and imaginary parts of the function. It will
output an array of values in the two-dimensional plane giving the
quadrant value of the function at that point. Using this array the zero may be located
as explained in Section&nbsp;7.7. The zeros will be searched  in a rectangular region bounded by RX1 and RX2 along the real axis and by
RY1 and RY2 along the imaginary axis. It is not really essential to have
<span class="roman">RX</span><span class="roman">1</span> &lt; <span class="roman">RX</span><span class="roman">2</span> or <span class="roman">RY</span><span class="roman">1</span> &lt; <span class="roman">RY</span><span class="roman">2</span>. NX and NY are the number
of points along the real and imaginary axes respectively, where the
function value is calculated.
NX and NY should be greater than 1, if not, a default value of 21 will be
used.  Further, <span class="roman">NX</span> &#8804; <span class="roman">IMAX</span>&nbsp;&nbsp;(=41), otherwise it will be reduced
to the maximum permissible value of IMAX<!--hbox-->.
CFUN is the
name of the function routine to calculate the function of complex variable.
Function CFUN(Z,F) must be supplied by the user.
Here Z and F are both arrays of length 2 containing the real and imaginary
parts of the complex values. F is the function value at Z.
The output is displayed on the screen.
The returned value of the function SEARCH is always zero.

<div class="p"><!----></div>
 <br /><br /><a name="zroot"> </a>
 <b>79.&nbsp;ZROOT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/zroot.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/muller.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate complex zeros of a given function
using Muller's method. This function uses deflation to remove
the known zeros. Deflation is carried out by explicitly dividing the
function by factors of the form z&#8722;z<sub>i</sub>, where z<sub>i</sub> are the known zeros.
This function calls <a href="appendixc.htm#muller"> MULLER</a> (or <a href="appendixc.htm#muler2"> MULER2</a>) to find the zeros. N specifies
the number of zeros to be determined. CX is an array of length
2N, containing the real and imaginary parts of the N complex starting
values for the iteration. NZ
is the number of known zeros of the given function. CZERO is a
array of length  2(<span class="roman">NZ</span>+<span class="roman">N</span>) containing the real and imaginary
parts of
zeros. At the time of calling, the first 2NZ elements should
contain the known zeros of the function. All zeros found by the function
will be added to this list and the value of NZ will be increased accordingly.
REPS and AEPS specify the relative
and absolute convergence criterion. The zeros should be calculated
with an accuracy
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;). 
RMAX is a parameter to specify the approximate
range of z values, where zeros are required. If the iteration
goes outside the region &#124;<span class="roman">Z</span>&#124; &#8804; <span class="roman">RMAX</span>, then it will be terminated.
This parameter may be used to ensure that iteration does not stray into
a region which will yield overflow or some other problem.
CF is the name of the
external routine to calculate the required function. Function CF(Z, F)
(or Function CF(Z, F, JF) for MULER2)
must be supplied by the user. Here both F and Z are assumed to be
arrays of length 2 containing the real and imaginary parts of the complex
variables. F (or <span class="roman">F</span>&times;2<sup><span class="roman">JF</span></sup>) is the value of function at Z.
Error status can be obtained from the
returned value of ZROOT<!--hbox-->. A value of 41 implies that
the Muller's iteration did not converge to 
the required accuracy for at least one of the zeros, but the computed
root may still be acceptable at lower accuracy. This means that
the function MULLER has returned a nonzero value, which
is less than 100.
ZROOT=429 implies that the iteration failed to
converge for at least one of the zeros. The number of zeros successfully
found can be obtained from NZ, which will give the number of known zeros
including those which were known before the function was called.
Apart from CF, the function also requires
functions <a href="appendixc.htm#muller"> MULLER</a> or MULER2, <a href="appendixc.htm#cabs"> CABS</a>, <a href="appendixc.htm#csqrt"> CSQRT</a>, <a href="appendixc.htm#cdiv"> CDIV</a>.
To use MULER2 instead of MULLER, change
the call statement as indicated in the comments.
ZROOT2 is the version of ZROOT for use with MULER2.

<div class="p"><!----></div>
 <br /><br /><a name="zroot2"> </a>
 <b>80.&nbsp;ZROOT2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/zroot2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/muler2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To calculate complex zeros of a given function
using Muller's method. This function uses deflation to remove
the known zeros. Deflation is carried out by explicitly dividing the
function by factors of the form z&#8722;z<sub>i</sub>, where z<sub>i</sub> are the known zeros.
This function calls <a href="appendixc.htm#muler2"> MULER2</a> (or MULLER) to find the zeros. N specifies
the number of zeros to be determined. CX is an array of length
2N, containing the real and imaginary parts of the N starting
values for the iteration. NZ
is the number of known zeros of the given function. CZERO is an
array of length  2(<span class="roman">NZ</span>+<span class="roman">N</span>) containing the real and imaginary
parts of zeros. At the time of calling, the first 2NZ elements should
contain the known zeros of the function. All zeros found by the function
will be added to this list and the value of NZ will be increased accordingly.
REPS and AEPS specify the relative
and absolute convergence criterion. The zeros should be calculated
with an accuracy
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;). 
RMAX is a parameter to specify the approximate
range of z values, where zeros are required. If the iteration
goes outside the region &#124;<span class="roman">Z</span>&#124; &#8804; <span class="roman">RMAX</span>, then it will be terminated.
This parameter may be used to ensure that iteration does not stray into
a region which will yield overflow or some other problem.
CF is the name of the
external routine to calculate the required function. Function CF(Z, F, IX)
must be supplied by the user. Here both F and Z are assumed to be
arrays of length 2 containing the real and imaginary parts of the complex
argument,
and IX is an integer variable such that the function value
is given by f(<span class="roman">Z</span>)=<span class="roman">F</span>&times;2<sup><span class="roman">IX</span></sup>. This form is useful
for functions which will otherwise result in overflow or underflow.
Error status can be obtained from the
returned value of ZROOT2<!--hbox-->. A value of 41 implies that
the Muller's iteration did not converge to 
the required accuracy for at least one of the zeros, but the computed
root may still be acceptable at lower accuracy. This means that
the function MULER2 has returned with a nonzero value, which
is less than 100.
ZROOT2=429 implies that the iteration failed to
converge for at least one of the zeros. The number of zeros successfully
found can be obtained from NZ, which will give the number of known zeros
including those which were known before the function was called.
Apart from CF, the function also requires
functions <a href="appendixc.htm#muler2"> MULER2</a> (or <a href="appendixc.htm#muller"> MULLER</a>), <a href="appendixc.htm#cabs"> CABS</a>, <a href="appendixc.htm#csqrt"> CSQRT</a>, <a href="appendixc.htm#cdiv"> CDIV</a>. Function MULER2 uses
<i>reverse communication</i>  technique to pass the function value.
This function
returns the control to the calling function whenever a function evaluation
is required. This technique is useful when a large number of parameters,
including some external function names, are required
for the function evaluation. At the first call to MULER2 the error
parameter IER should be set to zero. When the control is returned to
the calling function, it should check the
value of IER to decide the action. If IER &lt; 0, then a function
evaluation is required and MULER2 should be called once
again after calculating the function. It is important to ensure that
none of the other parameters in the call statements, e.g., CX1, CX2, CX3
and IER are changed in between. Nonnegative values of IER signify that
the execution of MULER2 is complete and it should not be called again.
<a href="appendixc.htm#zroot"> ZROOT</a> is the version of ZROOT2 for use with MULLER<!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="muller"> </a>
 <b>81.&nbsp;MULLER&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/muller.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/muller.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To calculate a complex zero of a given function
using Muller's method. CX1, CX2 and CX3 are complex variables 
specifying the three starting values required for Muller's method.
All these variables are treated as arrays of length 2 containing the
real and imaginary parts.
After execution, CX3 will contain the computed value of the zero,
while CX2 and CX1 will contain the previous iterates.
REPS and AEPS specify the relative and absolute convergence criterion.
The root should be calculated with an accuracy
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">CX</span><span class="roman">3</span>&#124;). 
CF is the name of the
external routine to calculate the required function. Function CF(Z,F)
must be supplied by the user.
Here F and Z are both arrays of length 2 containing the real and
imaginary parts of complex arguments and F is the function value at Z.
NZ is the number of known zeros of the function. CZERO is an array
of length 2NZ containing the real and imaginary parts of the
known complex zeros. 
RMAX is a parameter to specify the approximate
range of z values, where zeros are required. If the iteration
gives &#124;<span class="roman">Z</span>&#124; &gt; <span class="roman">RMAX</span>, then it will be terminated.
This parameter may be used to ensure that the iteration does not stray into
a region which will yield overflows or other problems.
Error status can be obtained from the
returned value of MULLER<!--hbox-->. A value of 42 implies that
the iteration converged to a moderate accuracy specified by
the parameter REPS0 (=10<sup>&#8722;4</sup>), but after some stage the difference
between successive iterates started increasing and the iteration
was terminated. This will usually imply that specified accuracy is
too stringent, or that there is a significant roundoff error
in evaluating the function.
In such cases, the computed value of the zero should be within the
domain of indeterminacy for the function and may be acceptable.
The difference &#124;CX2&#8722;CX3&#124; should give an estimate of
accuracy achieved.
MULLER=43 implies that the moderate convergence criterion was satisfied,
but the iteration failed to converge to the required accuracy in 
specified maximum number of iterations NIT ( = 50). This failure could be
due to slow convergence and increasing the value of NIT, or a second
attempt with the new estimate as the starting value may yield a better
result. Further, the difference between CX1, CX2 and CX3 will give an
estimate of the expected error in the computed zero.
MULLER=404 implies that the three starting
values are not distinct, in which case no calculations are performed.
MULLER=431 implies that iteration has gone outside the specified limits
i.e., &#124;<span class="roman">CX</span><span class="roman">3</span>&#124; &gt; <span class="roman">RMAX</span>.
MULLER=432 implies that the iteration
has failed to converge to any reasonable accuracy.
MULLER=433 implies that the iteration cannot be continued further, because
the denominator in the iteration function vanishes. In this case,
CX1, CX2 and CX3 will contain the last three iterates. This failure can
occur at multiple zeros after the iteration has entered into the
domain of indeterminacy, in which case, the root may be acceptable.
Apart from CF this function also requires <a href="appendixc.htm#cabs"> CABS</a>, <a href="appendixc.htm#cdiv"> CDIV</a> and <a href="appendixc.htm#csqrt"> CSQRT</a> to
handle complex arithmetic.

<div class="p"><!----></div>
 <br /><br /><a name="muler2"> </a>
 <b>82.&nbsp;MULER2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/muler2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/muler2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate a complex zero of a given
function using Muller's method. This function is essentially identical
to the function <a href="appendixc.htm#muller"> MULLER</a> described earlier, except for the fact that
here the given function is calculated in the form 
f(<span class="roman">CX</span>)=<span class="roman">CF</span>&times;2<sup><span class="roman">IX</span></sup>, which is suitable for those
functions which will normally overflow or underflow on the computer.
For example, this function is very useful to calculate the zeros of determinants
arising out of finite difference approximation to differential equations.
Apart from this, it uses the reverse communication technique for passing
function values. This function will return control to the calling
function when it needs a function evaluation. In that case, the
error parameter IER will be set to a negative value and the function
should be evaluated at z=<span class="roman">CX</span>. The value of the function
should be returned in the variables CF and IX<!--hbox-->. Here CX and CF are
arrays of length 2 containing the real and imaginary parts of
complex variables while IX is an integer. The function value is expressed
in the form explained above. During the function evaluation
variables other than CF and IX in the call statement should not be disturbed.
Before the first call IER should be set to zero.
IER &#8805; 0 imply that the execution is complete and no more function
evaluations are required.
Apart from CF, CX and IX other
arguments as well as error exits are identical to those for MULLER<!--hbox-->,
except that in this case the parameter IER gives the error parameter
instead of the returned value of function.
IER=42 implies that
the iteration converged to a moderate accuracy specified by
the parameter REPS0 (=10<sup>&#8722;4</sup>), but after some stage the difference
between successive iterates started increasing and the iteration
was terminated. This will usually imply that specified accuracy is
too stringent, or that there is a significant roundoff error
in evaluating the function.
In such cases, the computed value of the zero should be within the
domain of indeterminacy for the function and may be acceptable.
The difference &#124;CX2&#8722;CX3&#124; should give an estimate of
accuracy achieved.
IER=43 implies that the moderate convergence criterion was satisfied,
but the iteration failed to converge to the required accuracy in 
specified maximum number of iterations NIT ( = 50). This failure could be
due to slow convergence and increasing the value of NIT, or a second
attempt with the new estimate as the starting value may yield a better
result. Further, the difference between CX1, CX2 and CX3 will give an
estimate of the expected error in the computed zero.
IER=404 implies that the three starting
values are not distinct, in which case no calculations are performed.
IER=431 implies that iteration has gone outside the specified limits
i.e., &#124;<span class="roman">CX</span><span class="roman">3</span>&#124; &gt; <span class="roman">RMAX</span>.
IER=432 implies that the iteration
has failed to converge to any reasonable accuracy.
IER=433 implies that the iteration cannot be continued further, because
the denominator in the iteration function vanishes. In this case,
CX1, CX2 and CX3 will contain the last three iterates. This failure can
occur at multiple zeros after the iteration has entered into the
domain of indeterminacy, in which case, the root may be acceptable.
Negative values of IER imply that the execution is not over and
MULER2 should be called back after calculating the function value at
the required point. Variables other than CF and IX should not be modified
during this function calculations.
For an example of the usage of this function see function <a href="appendixc.htm#zroot2"> ZROOT2</a> above.
Apart from CF this function also requires <a href="appendixc.htm#cabs"> CABS</a>, <a href="appendixc.htm#cdiv"> CDIV</a> and <a href="appendixc.htm#csqrt"> CSQRT</a> to
handle complex arithmetic.

<div class="p"><!----></div>
 <br /><br /><a name="polyr"> </a>
 <b>83.&nbsp;POLYR&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/polyr.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polyr.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate all zeros of a polynomial
of degree N, with real coefficients, using Laguerre's method. N is the
degree of polynomial, A is an array of length <span class="roman">N</span>+1 containing
the coefficients of the polynomial. A[I] is the coefficient of x<sup>I</sup>
in the polynomial i.e., A[0] is the constant term while A[N] is the
coefficient of x<sup>N</sup>. A[N] should be nonzero.
RR is an array of length N,
which will contain the real part of zeros of the polynomial after the execution is
complete. The roots are sorted in the order of increasing real part.
However, if the function is terminated abnormally, then the roots may
not be sorted.
RI is an array of length N, which will contain the imaginary
part of zeros of the polynomial after the execution is complete.
QREFIN is a parameter to specify if refinement of roots is needed.
QREFIN=1 specifies
that the computed zeros should be "refined" by iterating with the original
polynomial, otherwise refinement is not required.
This parameter may be useful, if there is some doubt that the iteration during
refinement has converged to some other root, thereby giving rise to an
apparent double root.
Error status can be obtained from the
returned value of POLYR<!--hbox-->. A value of 406 implies that <span class="roman">N</span> &#8804; 0,
while POLYR=408 implies that <span class="roman">A</span><span class="roman">[</span><span class="roman">N</span><span class="roman">]</span>=0.
In such cases, no calculations are performed.
POLYR=430 implies that the Laguerre's iteration failed to converge at some
stage. In this case, the roots already located until then, will be available
in arrays RR and RI<!--hbox-->.
POLYR=n&times;11 implies that the iteration for
refining the roots did not converge for n of the roots.
The parameter EPS inside the function should be of the order of &#295;
for the arithmetic being used. This value is used only to decide whether
the root is real or complex. If z=x+iy is the computed root and
&#124;y&#124; &#8804; 10EPS&times;&#124;x&#124;, then the root is assumed to be real. Depending on the
outcome of this test,
the function performs deflation for a real root, or a pair of complex
conjugate roots. This parameter EPS should be changed to appropriate
value, but the exact value may not be crucial for working of the function,
unless there are roots with very small, but nonzero imaginary parts.
This function requires function <a href="appendixc.htm#lagitr"> LAGITR</a> to perform the Laguerre's
iteration, and <a href="appendixc.htm#cabs"> CABS</a>, <a href="appendixc.htm#cdiv"> CDIV</a> and <a href="appendixc.htm#csqrt"> CSQRT</a> to
handle complex arithmetic.

<div class="p"><!----></div>
 <br /><br /><a name="lagitr"> </a>
 <b>84.&nbsp;LAGITR&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/lagitr.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polyr.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to find one root of a polynomial of degree N
with real coefficients,
using Laguerre's method. N is the degree of polynomial and A is the
array of length <span class="roman">N</span>+1 containing the coefficients.
A[I] is the coefficient of x<sup>I</sup>.
CXI is an array of length 2 containing the real and imaginary parts
of the starting value for the Laguerre's iteration. After execution,
CXI will contain the computed root.
Error status can be obtained from the
returned value of LAGITR<!--hbox-->. A value of 439 implies that
the iteration has failed to converge to
any reasonable accuracy.
LAGITR=438 implies that the denominator in the iteration
function vanishes and the iteration cannot be continued. In practice,
it is rare for this iteration to fail, unless the polynomial is too 
ill-conditioned for the precision of the arithmetic used.
This function requires <a href="appendixc.htm#cabs"> CABS</a>, <a href="appendixc.htm#cdiv"> CDIV</a> and <a href="appendixc.htm#csqrt"> CSQRT</a> to
handle complex arithmetic.

<div class="p"><!----></div>
 <br /><br /><a name="davidn"> </a>
 <b>85.&nbsp;DAVIDN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/davidn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/newton.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a system of nonlinear equations using
Davidenko's method. This method can be coupled with any function
for solving a system of nonlinear equations to improve its chances of
convergence. It can be used with function <a href="appendixc.htm#newton"> NEWTON</a> for Newton's method,
when the Jacobian can be easily calculated, or
with function <a href="appendixc.htm#broydn"> BROYDN</a> for Broyden's method, when the Jacobian is too
complicated to be calculated explicitly. FCN is the name of the function to calculate
the vector function, i.e., the left-hand sides of the equations
(the right-hand sides are assumed to be zero). This function should also
calculate the Jacobian if Newton's method is to be used. The parameters
THETA, X0[NMAXD], F0[NMAXD] are global variables used to pass on parameters
to function FCN. Here, X0 and F0 are arrays of length NMAXD containing
the initial guess and corresponding function values, which may be required to
calculate the function required for the Davidenko's method. The function
can be parametrised in any convenient way, but <span class="roman">THETA</span>=&#952;<sub>0</sub> should
have the solution X0 and <span class="roman">THETA</span>=0 should correspond to the required
function. The function FCN should be of the form

<div class="p"><!----></div>
<br /><tt><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;double THETA, X0[NMAXD], F0[NMAXD];
<br /><table align="left" border="0"><tr><td width="16" align="right">
</td></tr></table><!--hbox-->
   void fcn(int np, double x[], double f[], double *df)
<br /><table align="left" border="0"><tr><td width="16" align="right">
</td></tr></table><!--hbox-->
   {
<br /><table align="left" border="0"><tr><td width="30" align="right">
</td></tr></table><!--hbox-->
       f[0]=...;   ... ; f[NP-1]=...;
<br /><table align="left" border="0"><tr><td width="30" align="right">
</td></tr></table><!--hbox-->
       .......................
<br /><table align="left" border="0"><tr><td width="30" align="right">
</td></tr></table><!--hbox-->
       for(i=0; i&lt;np; ++i) f[i]=f[i]-THETA*F0[i];
<br /><table align="left" border="0"><tr><td width="16" align="right">
</td></tr></table><!--hbox-->
   }
<div class="p"><!----></div>
</tt>Here NP is the number of variables, X and F are the vectors <b>x</b> and
<b>f</b>, DF is the Jacobian. This form is for use with function <a href="appendixc.htm#newton"> NEWTON</a><!--hbox-->.
For use with <a href="appendixc.htm#broydn"> BROYDN</a>, the variable DF should be removed from the list
of arguments. The last
statement parametrises the function for Davidenko's method. Other
parametrisation mentioned in Section&nbsp;7.16 can also be used, but if X[I] also occurs with THETA, then the Jacobian will also need to be modified (if
Newton's method is to be used). If the function has some natural
parameter, then it can be used instead of artificial parametrisation,
provided the solution is known for some value of the parameter and
&#952; = 0 corresponds to the required solution. The last requirement
can be removed by a trivial change in the function.
The function FCN with above specifications
must be supplied by the user.

<div class="p"><!----></div>
NP is the number of variables which
must be equal to the number of equations. X is an array of length
NP containing the starting values. After execution, the solution
will be returned in the same array. It is not essential to supply the
starting values, since these values can be supplied at the time of
execution through the scanf statement. Apart from the starting values,
the function will also ask for successive values of THETA, the
parameter introduced into the equations. The value of THETA should
be changed from &#952;<sub>0</sub> to zero gradually, where &#952;<sub>0</sub> is
the value for which X0 is the exact solution
of the system of equations. The value of &#952;<sub>0</sub>
is generally assumed to be 1. Steps in which the value of THETA
should change will depend on the functions involved. If at any stage the
iteration fails to converge, a second attempt could be made with THETA
changing in smaller steps, or with a different starting value.
F is an array of length 
NP, which will contain the value of the vector function <b>f</b>
at the point specified by the array X<!--hbox-->. REPS and AEPS specify the relative
and absolute convergence criterion. 
All components of the root should be calculated to an accuracy
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>&#124;). The function initially
uses a more modest criterion, which may need to be changed if some
of the components of the root are very small, since an absolute criterion
with <span class="roman">AEPS</span><span class="roman">0</span>=10<sup>&#8722;4</sup> may be too large in that case.
For such cases, change the 
value of AEPS0 suitably. AEPS0 may be set equal to AEPS if needed.
Error status can be obtained from the
returned value of DAVIDN<!--hbox-->. A value of 407 implies that the value of
NP is greater than NMAXD (=200), or <span class="roman">NP</span> &lt; 1.
In this case, the value of NMAXD can be increased.
DAVIDN=440 implies that THETA did not reduce to zero, even after
100 steps. In this case, a second attempt could be made with the last
value of X as the starting value.
Apart from this, other values
may be set by the function NEWTON or BROYDN<!--hbox-->.
This function
requires function <a href="appendixc.htm#newton"> NEWTON</a> or <a href="appendixc.htm#broydn"> BROYDN</a> to solve the system of nonlinear
equations and function <a href="appendixc.htm#gauelm"> GAUELM</a> to solve intermediate systems
of linear equations.
To use BROYDN instead of NEWTON, the call statement should
be changed as done in
DAVIDN<tt>_</tt>B, which is the version for use with BROYDN.

<div class="p"><!----></div>
 <br /><br /><a name="newton"> </a>
 <b>86.&nbsp;NEWTON&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/newton.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/newton.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a system of nonlinear equations
using Newton's method. This method requires the calculation of the full
Jacobian at every step. This function can be used directly, if a
good approximation to the root is known. Otherwise, it
may be better to use it through function <a href="appendixc.htm#davidn"> DAVIDN</a> to improve the chances
of convergence. NP is the number of equations in the system. X is an
array of length NP containing the initial approximation to the solution.
After execution, the computed solution will be returned in the same array.
F is an array of length NP containing the value of vector function
<b>f</b> at the point specified by the array X<!--hbox-->.
FCN is the name of the function used to calculate the
left-hand sides of the system of equations (the right-hand sides
are assumed to be zero).
The function FCN(NP, X, F, DF) must be supplied by the user. (Here NP
is the number of equations in the system. X and F are arrays of
length  NP containing the values of <b>x</b> and the vector function
<b>f</b>, respectively. DF is a two-dimensional array 
of length <span class="roman">NP</span>&times;<span class="roman">NP</span> containing the Jacobian with
<span class="roman">DF</span><span class="roman">[</span><span class="roman">J</span><span class="roman">]</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>=&#8706;<span class="roman">F</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>/&#8706;<span class="roman">X</span><span class="roman">[</span><span class="roman">J</span><span class="roman">]</span>.
It should be noted that in function FCN, 
the second dimension of array DF must be equal to NP itself.)
REPS and AEPS specify the relative and absolute convergence criterion. 
All components of the root should be calculated to an accuracy
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>&#124;).
Error status can be obtained from the
returned value of NEWTON<!--hbox-->. A value of 442 implies that
the iteration did not converge to the specified accuracy.
NEWTON=441 implies that the function <a href="appendixc.htm#gauelm"> GAUELM</a> used to solve the intermediate
systems of linear equation has failed. This failure can occur if the value
of NP is unacceptable, or if the Jacobian matrix is nearly singular.

<div class="p"><!----></div>
 <br /><br /><a name="broydn"> </a>
 <b>87.&nbsp;BROYDN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/broydn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/broydn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a system of nonlinear equations
using Broyden's method. This method does not require the calculation of 
derivatives. This function can be used directly if a
good approximation to the root is known. Otherwise, it
may be better to use it through function <a href="appendixc.htm#davidn"> DAVIDN</a><tt>_</tt>B to improve the chances
of convergence. NP is the number of equations in the system. X is an
array of length NP containing the initial approximation to the solution.
After execution, the computed solution will be returned in the same array.
F is an array of length NP containing the value of vector function
<b>f</b> at the point specified by the array X<!--hbox-->.
FCN is the name of the function used to calculate the
left-hand sides of the system of equations (the right-hand sides
are assumed to be zero).
The function FCN(NP, X, F) must be supplied by the user. (Here NP
is the number of equations in the system. X and F are arrays of
length  NP containing the values of <b>x</b> and the vector function
<b>f</b><b>(</b><b>x</b><b>)</b>, respectively.)
REPS and AEPS specify the relative and absolute convergence criterion. 
All components of the root should be calculated to an accuracy
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>&#124;).
Error status can be obtained from the
returned value of BROYDN<!--hbox-->. A value of 442 implies that
the iteration did not converge to the specified accuracy.
BROYDN=441 implies that the function <a href="appendixc.htm#gauelm"> GAUELM</a> used to solve the intermediate
systems of linear equation has failed. This failure can occur if the value
of NP is unacceptable, or if the matrix is nearly singular.

<div class="p"><!----></div>
 

<br /><br />
<a name="Optimisation"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.8&nbsp; OPTIMISATION </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#brackm">BRACKM</a></td>
<td>&nbsp; <a href="#golden">GOLDEN</a></td>
<td>&nbsp; <a href="#brentm">BRENTM</a></td>
<td>&nbsp; <a href="#davidm">DAVIDM</a></td>
<td>&nbsp; <a href="#bfgs">BFGS</a></td>
<td>&nbsp; <a href="#linmin">LINMIN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#flnm">FLNM</a></td>
<td>&nbsp; <a href="#nminf">NMINF</a></td>
<td>&nbsp; <a href="#linmnf">LINMNF</a></td>
<td>&nbsp; <a href="#fln">FLN</a></td>
<td>&nbsp; <a href="#simplx">SIMPLX</a></td>
<td>&nbsp; <a href="#simpx">SIMPX</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="brackm"> </a>
 <b>88.&nbsp;BRACKM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/brackm.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/golden.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to bracket a minimum in one dimension.
At the time of
calling A and B should contain the two starting values for search.
After execution, the triplet (A, X, B) should bracket
the minimum with <span class="roman">F</span><span class="roman">(</span><span class="roman">X</span><span class="roman">)</span> &lt; min(<span class="roman">F</span><span class="roman">(</span><span class="roman">A</span><span class="roman">)</span><span class="roman">,</span> <span class="roman">F</span><span class="roman">(</span><span class="roman">B</span><span class="roman">)</span>) and 
X in between A and B<!--hbox-->. F is the name of the function routine used to
calculate the function to be minimised. Function F(X) must be supplied
by the user.
Error status can be obtained from the
returned value of BRACKM<!--hbox-->. A value of 501 implies that
<span class="roman">A</span>=<span class="roman">B</span> and no calculations are performed.
BRACKM=521 implies
that the function failed to locate a minimum. This failure can occur, if there
is no minimum, or if the initial step &#124;<span class="roman">B</span>&#8722;<span class="roman">A</span>&#124; is too large, which
causes the function to jump over the minimum, or if the minimum is too
far off as compared to the initial step size.

<div class="p"><!----></div>
 <br /><br /><a name="golden"> </a>
 <b>89.&nbsp;GOLDEN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/golden.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/golden.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To minimise a function in one dimension
using the golden section search. Before calling the function, the
minimum should be bracketed by the triplet (A, X, B) with X in between
A and B and <span class="roman">F</span><span class="roman">(</span><span class="roman">X</span><span class="roman">)</span> &lt; min(<span class="roman">F</span><span class="roman">(</span><span class="roman">A</span><span class="roman">)</span><span class="roman">,</span><span class="roman">F</span><span class="roman">(</span><span class="roman">B</span><span class="roman">)</span>). It is not necessary
to have <span class="roman">B</span> &gt; <span class="roman">A</span>, but X must be between A and B<!--hbox-->.
After execution, the
final bracket will be overwritten on (A, X, B) with the central value
X giving the best approximation to the minimiser. FX will give the
value of the function at X<!--hbox-->. The parameters REPS and AEPS specify
the relative and absolute convergence criterion.
The interval will be subdivided until
&#124;<span class="roman">B</span>&#8722;<span class="roman">A</span>&#124; &lt; max(<span class="roman">REPS</span>&#124;<span class="roman">X</span>&#124;,<span class="roman">AEPS</span>).
F is the name of the function routine used to calculate the
function to be minimised. Function F(X) must be supplied by the user.
Error status can be obtained from the
returned value of GOLDEN<!--hbox-->. A value of 50 implies that the process
of subdivision was terminated, because the function value is equal at
all the three points. This is usually due to roundoff error as explained in
Section 8.1. GOLDEN=51 implies that the required accuracy was not achieved, even after
NIT (=100) subdivisions. This problem can arise if very high accuracy is required,
or if the initial bracket is too large.
GOLDEN=522 implies that the input values of A, B, X
are not consistent, i.e., either they do not bracket a minimum or
X is not between A and B<!--hbox-->. In this case, no calculations will be performed.

<div class="p"><!----></div>
 <br /><br /><a name="brentm"> </a>
 <b>90.&nbsp;BRENTM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/brentm.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/brentm.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To minimise a function in one dimension
using the Brent's method. This function is based on the procedure
given by Brent&nbsp;(1973). Before calling this function, the
minimum should be bracketed by the triplet (A, X, B) with 
<span class="roman">F</span><span class="roman">(</span><span class="roman">X</span><span class="roman">)</span> &lt; min(<span class="roman">F</span><span class="roman">(</span><span class="roman">A</span><span class="roman">)</span><span class="roman">,</span><span class="roman">F</span><span class="roman">(</span><span class="roman">B</span><span class="roman">)</span>) and X between A and B<!--hbox-->. After execution, the
final bracket will be overwritten on (A, X, B) with the central value
X giving the best approximation to the minimiser. FX will give the
value of the function at X<!--hbox-->. The parameters REPS and AEPS specify
the relative and absolute convergence criterion. The minimiser X
should be calculated with an accuracy of
max(<span class="roman">REPS</span>&#124;<span class="roman">X</span>&#124;,<span class="roman">AEPS</span>).
F is the name of the function routine used to calculate the
function to be minimised. Function F(X) must be supplied by the user.
Error status can be obtained from the
returned value of BRENTM<!--hbox-->. A value of 51 implies that
the required accuracy was not achieved, even after
NIT (=75) iterations. This failure can occur if very high accuracy is required
or if the initial bracket is too large.
BRENTM=523 implies that the input values of A, B, X
are not consistent, i.e., either they do not bracket a minimum or
X is not between A and B<!--hbox-->. In this case, no calculations will be performed.
No test for roundoff error is
performed in this function and the result may not be accurate to the
specified accuracy, even if the interval has been reduced to the
required size.

<div class="p"><!----></div>
 <br /><br /><a name="davidm"> </a>
 <b>91.&nbsp;DAVIDM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/davidm.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/davidm.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To minimise a function in one dimension
using the Hermite cubic interpolation. This method requires the
calculation of the first derivative in addition to the function value.
X1 and X2 specify the two
distinct starting values. These values need not bracket the minimum.
After execution, X1 and X2 will contain the last two iterates with
X2 giving the best approximation to the minimiser. F2 will give the
value of the function at X2, while D2F gives the estimate for second
derivative, which is used to distinguish between a minimum and a maximum.
If D2F &gt; 0 then X2 should be a minimiser, otherwise X2 should
be a maximiser. Since D2F is merely an estimate of second derivative,
if it is close to zero the nature of extremum will be difficult to
determine.
The parameters REPS and AEPS specify
the relative and absolute convergence criterion. The minimiser X2
should be calculated with an accuracy of
max(<span class="roman">REPS</span>&#124;<span class="roman">X</span><span class="roman">2</span>&#124;,<span class="roman">AEPS</span>).
F is the name of the function routine used to calculate the
function to be minimised and its derivative.
Error status can be obtained from the
returned value of DAVIDM<!--hbox-->. A value of 52 implies that
the iteration has converged to a maximiser, rather
than a minimiser. This distinction is made on the basis of the sign of
the estimated second derivative and hence may not necessarily be correct
if roundoff error is significant. In particular, a point of inflection
can be passed on as either a minimiser or a maximiser.
DAVIDM=502 implies that <span class="roman">X</span><span class="roman">1</span>=<span class="roman">X</span><span class="roman">2</span>, in which
case, no calculations will be performed.
DAVIDM=524 implies that the iteration cannot
be continued further, since the Hermite cubic does not have a minimum
and the corresponding parabolic interpolation yields a zero denominator.
DAVIDM=525 implies that the required accuracy was not achieved, even after
NIT (=75) iterations. The convergence failure can occur if very high accuracy is required,
or if the starting values are far from the minimiser.
Function F(X, DF) must be
supplied by the user. Here DF is the first derivative of F at X<!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="bfgs"> </a>
 <b>92.&nbsp;BFGS&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bfgs.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bfgs.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To find minimum of a function of N variables
using the quasi-Newton method, with BFGS formula for updating the Hessian matrix.
This method requires the calculation of gradient vector in addition to
the function value.
X is an array of length  N, containing the starting values
for the independent variables. After execution, the minimiser will be
returned in the same array X<!--hbox-->. F gives the value of
the function at X<!--hbox-->. G is an array of length  N, which will
contain the value of the gradient vector at X (<span class="roman">G</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>=[(&#8706;<span class="roman">F</span>)/(&#8706;<span class="roman">X</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>)]). H is a two-dimensional array of length at
least <span class="roman">N</span>&times;<span class="roman">N</span>, which will
contain an approximation to the inverse of the Hessian matrix at X<!--hbox-->.
The second dimension of H must be equal to N<!--hbox-->.
F, G and H are output parameters, which
need not be initialised at the time of calling.
NUM is an output parameter containing the number of function evaluations required. 
The parameters REPS and AEPS specify
the relative and absolute convergence criterion. Each component of the
minimiser X should be calculated with an accuracy of
max(<span class="roman">REPS</span>&#124;<span class="roman">X</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>&#124;,<span class="roman">AEPS</span>).
FCN is the name of the function which calculates the
function F and the gradient vector G<!--hbox-->.
Error status can be obtained from the
returned value of BFGS<!--hbox-->. A value of 53 implies that
the Hessian matrix
is probably singular at the final point. In this case, the iteration
could have converged to a saddle point and further investigation may
be required to determine the nature of the stationary point.
This is detected by considering the
norm of the matrix H as explained in Section 8.5. This test is not very reliable,
particularly if the required accuracy is too low or too high.
BFGS=503 implies that <span class="roman">N</span> &lt; 1, in which case no
calculations are performed. BFGS=526 implies that the iteration failed to
converge to a satisfactory accuracy.
Other
values may be set by the function LINMIN, which is called to perform
the line searches.
Function FCN(N, X, F, G) must be supplied by the user.
Here N is the number of variables, F is the function value, while
X and G are arrays of length N, containing the coordinates of
the point X, where the function F and the gradient
vector G are to be evaluated.
Apart from FCN this function requires the function
<a href="appendixc.htm#linmin"> LINMIN</a> to perform the line searches and the function <a href="appendixc.htm#flnm"> FLNM</a> to calculate
the function and its derivative along the given line, as required by LINMIN.

<div class="p"><!----></div>
 <br /><br /><a name="linmin"> </a>
 <b>93.&nbsp;LINMIN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/linmin.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bfgs.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform line search as required by
the function <a href="appendixc.htm#bfgs"> BFGS</a><!--hbox-->. It implements a crude, but reasonably efficient algorithm
to find an acceptable minimum of a function of N variables
along a given direction. Any point which satisfies the conditions (8.37) is acceptable. This function requires the first derivative of the
function in addition to the function value.
This function should only be used for line search as required by
quasi-Newton methods and not for any other purpose, since the criterion
for acceptance will not suffice for other purposes.
X1 is the starting point from where the line search is to
be performed. X2 is the first guess for the minimum. After execution,
X1, F1 and DF1 will respectively contain the accepted point, the value of the function
and its first derivative along
the given direction at that point. The parameters REPS and AEPS specify
the relative and absolute convergence criterion for the function BFGS<!--hbox-->.
These parameters are used here only to terminate the line search, once
the interval has been reduced sufficiently. This situation should not arise
normally, but occasionally because of roundoff error, or error in
coding the derivatives, the function may fail to find acceptable points.
The parameters F, V, XI, N and
NUM are not used by this function, but are simply passed on to the
function <a href="appendixc.htm#flnm"> FLNM</a>, for calculating the function value and the first derivative.
F is the name of the function used to calculate the function of N
variables, V is an array of length  3N, first N elements
of which contain the direction along which the line search is to be
carried out. After execution of FLNM the next N elements will contain the coordinates of the
last point at which the function is evaluated, while the last N 
elements of this array will contain the gradient vector at the last point.
XI is an array of length  N, containing the coordinates of
the starting point for the line search. NUM is an integer variable to
keep count of the number of function evaluations.
Error status can be obtained from the
returned value of LINMIN<!--hbox-->. A value of 527 implies that
the LINMIN has
failed to find any point, where the function value is less than
or equal to that at the starting
point. This failure could be due to roundoff error, or more likely due to some error
in coding the derivatives.
LINMIN=55 or 528 implies that the function failed to
find an acceptable point, even though the interval has been reduced to
specified tolerance. In this case, the last point is accepted if
the function value is less than or equal to that at starting point (LINMIN=55), otherwise
LINMIN=528.
LINMIN=54 implies that the 
function failed to find an acceptable point in NIT (=15) iterations, but the
function value at the last approximation is less than or equal to the value
at the starting point and this point is accepted. The last two 
conditions are often encountered, when the iteration is close to convergence
and the accuracy requirement is too high. The final point may be acceptable
in such circumstances. This can be checked by verifying the value of the
gradient vector in function BFGS<!--hbox-->.
This function
requires the function <a href="appendixc.htm#flnm"> FLNM</a> and the function F to calculate the function.
Function F(N, X, FX, G) must be supplied by the user.
Here N is the number of variables, FX is the function value, while
X and G are arrays of length N, containing the coordinates of
the point X, where the function FX and the gradient
vector G are to be evaluated.

<div class="p"><!----></div>
 <br /><br /><a name="flnm"> </a>
 <b>94.&nbsp;FLNM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/flnm.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bfgs.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To calculate the function as required for the
line search routine <a href="appendixc.htm#linmin"> LINMIN</a><!--hbox-->. FCN is the name of the function used to calculate
the function of N variables. X is a parameter along the line which specifies the point at which
the function is to be evaluated. DF is the first derivative along the line.
V is an array of length 3N, the first N elements of which
specify the direction along which the search is being carried out.
Next N elements will contain the coordinates of the point at which
function is evaluated, while the last N elements contain the gradient
vector at this point.
X0 is an array of length  N, containing the coordinates of
the starting point. NUM is an integer variable which keeps a count of
function evaluations. The function will be evaluated at the point with
coordinates <span class="roman">XI</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>=<span class="roman">X</span><span class="roman">0</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>+<span class="roman">X</span>&times;<span class="roman">V</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>.
These coordinates are returned in <span class="roman">N</span> to 2<span class="roman">N</span>&#8722;1 element of array V<!--hbox-->.
The Function FCN(N, XI, F, G) must be supplied
by the user. Here XI is an array of length  N, containing
the coordinates of the required point. F is the function value at this point.
G is an array of length  N containing the gradient vector at
XI. 

<div class="p"><!----></div>
 <br /><br /><a name="nminf"> </a>
 <b>95.&nbsp;NMINF&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/nminf.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/nminf.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To find minimum of a function of N variables,
using a direction set method. This method does not require calculation
of the derivatives.
X is an array of length  N, containing the starting values
for the independent variables. After execution, the minimiser will be
returned in the same array X<!--hbox-->. F gives the value of
the function at X<!--hbox-->.
NUM is an output parameter containing the number of function evaluations required. 
The parameters REPS and AEPS specify
the relative and absolute convergence criterion. The iteration is
continued until the change in function value &#948;F during one
complete cycle consisting of N iterations, satisfies
&#124;&#948;F&#124; &lt; max(<span class="roman">REPS</span>&#124;<span class="roman">F</span>&#124;,<span class="roman">AEPS</span>).
It may be noted that unlike function <a href="appendixc.htm#bfgs"> BFGS</a>, here the convergence test
is applied on function value, rather than the minimiser.
This must be kept in mind while specifying REPS and AEPS<!--hbox-->.
In general, relative change by REPS in function value will translate
to relative variation by &#8730;{REPS} in coordinates of
minimiser.
FCN is the name of the function which calculates the
function F<!--hbox-->.
Error status can be obtained from the
returned value of NMINF<!--hbox-->. A value of 504 implies that
<span class="roman">N</span> &#8804; 1, in which case, no
calculations are performed.
NMINF=529 implies that the iteration failed to
converge to a satisfactory accuracy. Other
values may be set by the function LINMNF, which is called to perform
the line searches.
Function FCN(N, X, F) must be supplied by the user.
Here N is the number of variables, X is an array of length N containing
the parameter values at which the function value is required. F is the
calculated value of the function at X<!--hbox-->.
Apart from FCN, this function requires function
<a href="appendixc.htm#linmnf"> LINMNF</a> to perform the line searches and function <a href="appendixc.htm#fln"> FLN</a> to calculate
the function as required by LINMNF, and function <a href="appendixc.htm#svd"> SVD</a> to perform the singular
value decomposition.

<div class="p"><!----></div>
 <br /><br /><a name="linmnf"> </a>
 <b>96.&nbsp;LINMNF&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/linmnf.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/nminf.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform line search as required by the
function <a href="appendixc.htm#nminf"> NMINF</a><!--hbox-->. It implements a crude, but reasonably efficient algorithm
to find an acceptable minimum of a function of N variables
along a given direction. This function does not require any derivative.
Any point, where the function value is less than that at the starting
point is acceptable. This function should only be used for line search
as required by direction set methods. Because of the crude criterion
for acceptance it is not suitable for a general minimisation along
a given direction.
X0 is the starting point, from where the line search is to
be performed. X1 is the first guess for the minimum. After execution, X0
and F0 will contain the accepted point and the corresponding function value.
The parameters REPS and AEPS specify
the relative and absolute convergence criterion for the function NMINF<!--hbox-->.
These parameters are used here only to terminate the line search, once
the interval has been reduced sufficiently. This situation should not arise
normally, but occasionally because of roundoff error,
the function may fail to find an acceptable point.
The parameters F, V, XI, N and
NUM are not used by this function, but are simply passed on to the
function <a href="appendixc.htm#fln"> FLN</a>, to calculate the function value.
F is the name of the function used to calculate the function of N
variables, V is an array of length  N, containing
the direction along which the line search is to be
carried out. XI is an array of length  2N, the first N
elements contain the coordinates of the starting point for the line search.
After execution of FLN, the next N elements will contain the coordinates of the
last point at which the function is evaluated.
NUM is an integer variable to
keep count of the number of function evaluations.
Error status can be obtained from the
returned value of LINMNF<!--hbox-->. A value of 56 implies that
the function failed to
find an acceptable point and in this case, the starting point itself
is accepted.
The function LINMNF
requires the functions <a href="appendixc.htm#fln"> FLN</a> and F to calculate the function.
Function F(N, X, FX) must be supplied by the user.
Here N is the number of variables, X is an array of length N containing
the parameter values at which the function value is required. FX is the
calculated value of the function at X<!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="fln"> </a>
 <b>97.&nbsp;FLN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/fln.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/nminf.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To calculate the function as required for the
line search routine <a href="appendixc.htm#linmnf"> LINMNF</a><!--hbox-->. FCN is the name of the function used to calculate
the function of N variables.
X is a parameter along the line which specifies the point at which
the function is to be evaluated.
V is an array of length  N, containing
the direction along which the search is being carried out. X0 
is an array of length  2N, the first N elements of which
specify the coordinates of
the starting point. NUM is an integer variable which keeps a count of
function evaluations. The function will be evaluated at a point with
coordinates <span class="roman">XI</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>=<span class="roman">X</span><span class="roman">0</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>+<span class="roman">X</span>&times;<span class="roman">V</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>.
The last N elements of X0 are used to store XI<!--hbox-->.
The Function FCN(N, XI, F) must be supplied
by the user. Here XI is an array of length  N, containing
the coordinates of the required point and F is the function value at this point.

<div class="p"><!----></div>
 <br /><br /><a name="simplx"> </a>
 <b>98.&nbsp;SIMPLX&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/simplx.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/simplx.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a linear programming problem
using the simplex method. N is the number of variables, each of which
is constrained to be nonnegative. M1 is the number of constraints of the form
<b>a</b><sup>T</sup><b>x</b> &#8804; b<sub>i</sub> &#8805; 0, M2 is the number of constraints of the form
<b>a</b><sup>T</sup><b>x</b> &#8805; b<sub>i</sub> &#8805; 0, M3 is the number of constraints of the form
<b>a</b><sup>T</sup><b>x</b> = b<sub>i</sub> &#8805; 0. A is an array of length  <span class="roman">IA</span>&times;(<span class="roman">N</span><span class="roman">+</span><span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">1</span>). IA specifies the second dimension of A, exactly as
in the calling function (<span class="roman">IA</span> &#8805; <span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">M</span><span class="roman">3</span><span class="roman">+</span><span class="roman">2</span>). The array A
contains the tableau as explained in Section 8.7. It may be noted that in the C function the dimensions of array A have
been interchanged so effectively, the rows are treated as columns and
vice versa.
At input the first
column of A contains the cost coefficients <span class="roman">A</span><span class="roman">[</span><span class="roman">i</span><span class="roman">+</span><span class="roman">1</span><span class="roman">]</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>=c<sub>i</sub>, where
c<sub>0</sub>x<sub>0</sub>+c<sub>1</sub>x<sub>1</sub>+&#8230;+c<sub>N&#8722;1</sub>x<sub>N&#8722;1</sub> is the function to be minimised.
The next <span class="roman">M</span><span class="roman">=</span><span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">M</span><span class="roman">3</span> columns contain the coefficients for the
constraints, with the columns 1 to <span class="roman">M</span><span class="roman">1</span> containing the constraints
of the first type, columns <span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">1</span> to <span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">M</span><span class="roman">2</span> containing the constraints
of the second type and the remaining columns containing the constraints of the third type.
<span class="roman">A</span>[0][i]=b<sub>i</sub> and <span class="roman">A</span><span class="roman">[</span><span class="roman">j</span><span class="roman">+</span><span class="roman">1</span><span class="roman">]</span><span class="roman">[</span><span class="roman">i</span><span class="roman">]</span>=a<sub>j</sub> for the ith constraint.
If <span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">M</span><span class="roman">3</span> &gt; 0, then the column <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> will be used by the
function to specify the cost coefficients for the auxiliary objective
function to be minimised for finding a basic feasible vector. If only
constraints of the first type are present, then this column will not be required.
After the execution is complete, the optimal feasible vector will be
returned in the array X of length  N<!--hbox-->. F is an output parameter
containing the optimum value of the objective function.
Error status can be obtained from the
returned value of SIMPLX<!--hbox-->. A value of 57 implies that
the objective function is unbounded from below
and no optimal feasible vector exists.
SIMPLX=58 implies that,
there is no basic feasible vector. Hence, the constraints are
inconsistent or the problem is not properly formulated.
SIMPLX=505 implies that at least one of the variables N, M1, M2 and M3
is negative or IA &lt; <span class="roman">M</span>+2.
SIMPLX=506 implies that at least one of the right-hand side
coefficients in the constraints is negative. In both these cases, no
calculations are performed.
SIMPLX=531 implies that
the simplex algorithm failed to find the optimal vector in a 
reasonable number of iterations. This failure can occur either because the
number of iterations required are very large, or because the simplex
iteration has gone into a nonterminating loop because of degeneracy.
In principle, this failure can happen for the auxiliary problem for finding
a basic feasible vector also.
SIMPLX=532 implies that a basic feasible vector could not be found
to start the simplex iteration. This situation can occur if the solution
to the auxiliary problem is degenerate and the artificial variable on
the left-hand side cannot be exchanged. This situation should not arise,
unless the constraints are not linearly independent, or roundoff error
is significant.
AEPS is a
parameter to control roundoff error, any quantity less than AEPS in
magnitude is assumed to be zero. This function requires
<a href="appendixc.htm#simpx"> SIMPX</a> to actually perform the simplex minimisation.

<div class="p"><!----></div>
 <br /><br /><a name="simpx"> </a>
 <b>99.&nbsp;SIMPX&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/simpx.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/simplx.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve linear programming problems using
the simplex method. The problem is assumed to be in the standard form and
the initial tableau is supplied in the array A of
length  <span class="roman">IA</span>&times;(<span class="roman">N</span>&#8722;<span class="roman">M</span><span class="roman">+</span><span class="roman">1</span>) with <span class="roman">IA</span> &#8805; <span class="roman">M</span>+2.
IA is the second dimension of A, exactly as specified in the calling 
function. N is the total number of variables in the given problem,
including any slack or artificial variables that have been introduced.
M is the number of constraints in the problem. NV is the number of
variables excluding the artificial variables (if any). This parameter is used
only for the auxiliary function, to check if any artificial variable
is remaining on the left-hand side. QF is a parameter which determines
the column from which cost coefficients are used.
If QF=1, then the main objective function specified by
the first column of the tableau is to be minimised. Otherwise,
the auxiliary objective function specified by the last column
of A is to be minimised for finding the initial basic feasible vector.
In that case, attempt is made to remove the artificial variables from
the set of left-hand side variables, before accepting the solution.
ID and IV are integer arrays of length  <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> and 
<span class="roman">N</span>&#8722;<span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> respectively, used to store permutations of the original
variables. 
AEPS is a parameter used
to control roundoff error. Any quantity less than AEPS in magnitude is assumed
to be zero.
Error status can be obtained from the
returned value of SIMPX<!--hbox-->. A value of 57 implies that
the objective function is unbounded from below and
the optimal feasible vector does not exist.
SIMPX=531 implies that the
simplex iteration has not converged in a reasonable number of iterations.
This failure may be due to degeneracy, since that is not accounted for
in this function.

<div class="p"><!----></div>
 

<br /><br />
<a name="Statistical Inferences"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.9&nbsp; STATISTICAL INFERENCES </b></td></tr></table><!--hboxt-->

<br /> <table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#shsort">SHSORT</a></td>
<td>&nbsp; <a href="#gammap">GAMMAP</a></td>
<td>&nbsp; <a href="#betap">BETAP</a></td>
<td>&nbsp; <a href="#betser">BETSER</a></td>
<td>&nbsp; <a href="#betcon1">BETCON1</a></td>
<td>&nbsp; <a href="#betcon">BETCON</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#betai">BETAI</a></td>
<td>&nbsp; <a href="#fbeta">FBETA</a></td>
<td>&nbsp; <a href="#rangau">RANGAU</a></td>
<td>&nbsp; <a href="#iranbin">IRANBIN</a></td>
<td>&nbsp; <a href="#iranpoi">IRANPOI</a></td>
<td>&nbsp; <a href="#pcor">PCOR</a></td>
</tr>
</table>





<div class="p"><!----></div>
<br /><br /><a name="shsort"> </a>
 <b>100.&nbsp;SHSORT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/shsort.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/median.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to sort an array of length N in
ascending order, using shell sort algorithm. A is a real array of length
N, which is to be sorted. After execution the sorted elements will be
returned in the same array. N is the number of elements of array A
to be sorted.

<div class="p"><!----></div>
 <br /><br /><a name="gammap"> </a>
 <b>101.&nbsp;GAMMAP&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gammap.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/betap.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the incomplete Gamma function

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P(a,x)=</td><td nowrap="nowrap" align="center">
&#947;(a,x)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#915;(a)<br /></td><td nowrap="nowrap" align="center">
=</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#915;(a)<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>x</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
e<sup>&#8722;t</sup>t<sup>a&#8722;1</sup>&nbsp;&nbsp;dt&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.27)</td></tr></table>
</td></tr></table>


It may be noted that sometimes the incomplete Gamma function is defined by
&#947;(a,x). This should be accounted for while using the function routine.
It is difficult to approximate this function over entire range of a,x values
and it is possible that for some combination the value may not be reliable.
A is the argument for the complete Gamma function and X is the upper limit
of integration in the above equation. The function is not defined for
<span class="roman">A</span> &#8804; 0 or <span class="roman">X</span> &lt; 0 and in these cases a value of &#8722;1 will be returned
without any warning.
For x &lt; 3 it uses the power series (DiDonato &amp; Morris 1986) to approximate

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P(a,x)=</td><td nowrap="nowrap" align="center">
x<sup>a</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#915;(a+1)<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
1+a</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>n=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
(&#8722;x)<sup>n</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(a+n) n!<br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.28)</td></tr></table>
</td></tr></table>


For x &lt; 1.2a, a continued fraction approximation for complementary function

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
Q(a,x)=1&#8722;P(a,x)=</td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
e<sup>&#8722;x</sup>x<sup>a</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#915;(a)<br /></td></tr></table>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
x+</td><td nowrap="nowrap" align="center">
1&#8722;a
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
1+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x+[(2&#8722;a)/(1+[2/(x+&#8230;)])]<br /></td></tr></table></td></tr></table></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.29)</td></tr></table>
</td></tr></table>


is used. For other values of parameter the power series

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P(a,x)=</td><td nowrap="nowrap" align="center">
e<sup>&#8722;x</sup>x<sup>a</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#915;(a+1)<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
1+</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>n=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
x<sup>n</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(a+1)(a+2)&#8230;(a+n)<br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.30)</td></tr></table>
</td></tr></table>


is used.
This function requires Functions <a href="appendixc.htm#gamma">GAMMA</a> and
<a href="appendixc.htm#gammaln">GAMMALN</a> to calculate the (complete)
Gamma function or its logarithm.

<div class="p"><!----></div>
 <br /><br /><a name="betap"> </a>
 <b>102.&nbsp;BETAP&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/betap.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/betap.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the incomplete Beta function

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
I<sub>x</sub>(a,b)=</td><td nowrap="nowrap" align="center">
B<sub>x</sub>(a,b)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>B(a,b)<br /></td><td nowrap="nowrap" align="center">
=</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>B(a,b)<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>x</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
t<sup>a&#8722;1</sup>(1&#8722;t)<sup>b&#8722;1</sup>&nbsp;&nbsp;dt&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.31)
</td></tr></table>
</td></tr></table>


It may be noted that sometimes the incomplete Beta function is defined by
B<sub>x</sub>(a,b). This should be accounted for while using the function routine.
It is difficult to approximate this function over entire range of a,b,x values
and it is possible that for some combination, the value may not be reliable.
A and B are the arguments for the complete Beta function and X is the upper limit
of integration in the above equation. Here <span class="roman">A</span>&#8722;1 is the exponent of t
and <span class="roman">B</span>&#8722;1 is that of 1&#8722;t in the integral.
The function is not define for <span class="roman">A</span> &#8804; 0 or <span class="roman">B</span> &#8804; 0 or
<span class="roman">X</span> &lt; 0 or <span class="roman">X</span> &gt; 1 and in these cases a value of &#8722;1 will be returned
without any warning.
These function requires Functions <a href="appendixc.htm#betser">BETSER</a>,
<a href="appendixc.htm#betcon">BETCON</a>, <a href="appendixc.htm#betcon1">BETCON1</a>
and <a href="appendixc.htm#betai">BETAI</a> for
calculating the function using different approximations depending on the
arguments. Apart from these Function <a href="appendixc.htm#gammaln">GAMMALN</a> is required to calculate logarithm
of Gamma function and functions <a href="appendixc.htm#adpint">ADPINT</a>,
<a href="appendixc.htm#kronrd">KRONRD</a> and <a href="appendixc.htm#fbeta">FBETA</a> to calculate
the integral for some argument range.

<div class="p"><!----></div>
 <br /><br /><a name="betser"> </a>
 <b>103.&nbsp;BETSER&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/betser.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/betap.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the incomplete
Beta function (<span class="roman">C</span>.31)&nbsp;using the infinite series
(DiDonato &amp; Morris 1992)

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
I<sub>x</sub>(a,b)=</td><td nowrap="nowrap" align="center">
x<sup>a</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>a B(a,b)<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
1+a</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
(1&#8722;b)(2&#8722;b)&#8230;(j&#8722;b)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>j! (a+j)<br /></td><td nowrap="nowrap" align="center">
x<sup>j</sup></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.32)</td></tr></table>
</td></tr></table>


This series is
useful for small values of x. This function is called by <a href="appendixc.htm#betap">BETAP</a> for
some range of arguments. This routine should not be used to calculate
the function for arbitrary values of its arguments as the approximation may
not be valid.
A and B are the arguments for the complete Beta function and X is the upper limit
of integration in Eq.&nbsp;(<span class="roman">C</span>.31). This function needs Function <a href="appendixc.htm#gammaln">GAMMALN</a> to
calculate the logarithm of Gamma function.

<div class="p"><!----></div>
 <br /><br /><a name="betcon1"> </a>
 <b>104.&nbsp;BETCON1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/betcon1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/betap.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the incomplete
Beta function (<span class="roman">C</span>.31)&nbsp;using a continued fraction (DiDonato &amp; Morris 1992)
approximation

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
I<sub>x</sub>(a,b)=</td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
x<sup>a</sup>(1&#8722;x)<sup>b</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>aB(a,b)<br /></td></tr></table>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
1+</td><td nowrap="nowrap" align="center">
d<sub>1</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
1+</td><td nowrap="nowrap" align="center">
d<sub>2</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>1+&#8230;<br /></td></tr></table></td></tr></table></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.33)</td></tr></table>
</td></tr></table>


with

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
d<sub>2n</sub>=</td><td nowrap="nowrap" align="center">
n(b&#8722;n)x
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(a+2n&#8722;1)(a+2n)<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d<sub>2n+1</sub>=&#8722;</td><td nowrap="nowrap" align="center">
(a+n)(a+b+n)x
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(a+2n)(a+2n+1)<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.34)
</td></tr></table>
</td></tr></table>


This function is called by <a href="appendixc.htm#betap">BETAP</a> for
some range of arguments. This routine should not be used to calculate
the function for arbitrary values of its arguments as the approximation may
not be valid.
A and B are the arguments for the complete Beta function and X is the upper limit
of integration in Eq.&nbsp;(<span class="roman">C</span>.31). This function needs Function <a href="appendixc.htm#gammaln">GAMMALN</a> to
calculate the logarithm of Gamma function.

<div class="p"><!----></div>
 <br /><br /><a name="betcon"> </a>
 <b>105.&nbsp;BETCON&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/betcon.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/betap.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the incomplete
Beta function (<span class="roman">C</span>.31)&nbsp;using a continued fraction (DiDonato &amp; Morris 1992)
approximation

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
I<sub>x</sub>(a,b)=</td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
x<sup>a</sup>(1&#8722;x)<sup>b</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>aB(a,b)<br /></td><td nowrap="nowrap" align="center">
a<sub>1</sub></td></tr></table>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
b<sub>1</sub>+</td><td nowrap="nowrap" align="center">
a<sub>2</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
b<sub>2</sub>+</td><td nowrap="nowrap" align="center">
a<sub>3</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>b<sub>3</sub>+&#8230;<br /></td></tr></table></td></tr></table></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.35)</td></tr></table>
</td></tr></table>


where, coefficients a<sub>i</sub>,b<sub>i</sub> are defined using Eq.&nbsp;(<span class="roman">C</span>.34)

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
a<sub>1</sub>=1,&nbsp;&nbsp;&nbsp; b<sub>1</sub>=1+d<sub>1</sub>,&nbsp;&nbsp;&nbsp; a<sub>n+1</sub>=&#8722;d<sub>2n&#8722;1</sub>d<sub>2n</sub>,&nbsp;&nbsp;&nbsp;b<sub>n+1</sub>=1+d<sub>2n</sub>+d<sub>2n+1</sub>,&nbsp;&nbsp;&nbsp; (n &gt; 1).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.36)</td></tr></table>
</td></tr></table>


This function is called by <a href="appendixc.htm#betap">BETAP</a> for
some range of arguments. This routine should not be used to calculate
the function for arbitrary values of its arguments as the approximation may
not be valid.
A and B are the arguments for the complete Beta function and X is the upper limit
of integration in Eq.&nbsp;(<span class="roman">C</span>.31). This function needs Function <a href="appendixc.htm#gammaln">GAMMALN</a> to
calculate the logarithm of Gamma function.

<div class="p"><!----></div>
 <br /><br /><a name="betai"> </a>
 <b>106.&nbsp;BETAI&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/betai.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/betap.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the incomplete
Beta function (<span class="roman">C</span>.31)&nbsp;by directly evaluating the integral.
This function is called by <a href="appendixc.htm#betap">BETAP</a> for
some range of arguments. This routine should not be used to calculate
the function for arbitrary values of its arguments as it may not be very
efficient for all values of the arguments.
A and B are the arguments for the complete Beta function and X is the upper limit
of integration in Eq.&nbsp;(<span class="roman">C</span>.31). This function needs Function <a href="appendixc.htm#gammaln">GAMMALN</a> to
calculate the logarithm of Gamma function, functions <a href="appendixc.htm#adpint">ADPINT</a> and
<a href="appendixc.htm#kronrd">KRONRD</a>
to evaluate the integral. Further, the function <a href="appendixc.htm#fbeta">FBETA</a> is needed to define the integrand
for the integral.

<div class="p"><!----></div>
 <br /><br /><a name="fbeta"> </a>
 <b>107.&nbsp;FBETA&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/fbeta.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/betap.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
Function routine to calculate the integrand for
calculating the incomplete beta function. This is used by Function <a href="appendixc.htm#betai">BETAI</a>.

<div class="p"><!----></div>
 <br /><br /><a name="rangau"> </a>
 <b>108.&nbsp;RANGAU&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/rangau.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polfit.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to generate a sequence of random numbers
with Normal distribution of probability, with zero mean and unit
variance.
This function uses algorithm given by Knuth.
SEED could be set to any positive value less than AN before
first call to the function. After the first call, this variable should not be
changed in any other function, unless an independent sequence of random
numbers is required. 

<div class="p"><!----></div>
 <br /><br /><a name="iranbin"> </a>
 <b>109.&nbsp;IRANBIN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/iranbin.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/binom.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to generate a sequence of
random numbers with binomial distribution.
SEED is the seed for generating random numbers. It should be negative for
the first call to function and should not be changed in any other program,
unless an independent sequence of random number with different n or p
is required. It should be noted that although the random number is an integer
in this case, the SEED is of type Real.
N is the number of trials in the binomial distribution and
P is the probability of the event in one trial. C is a real array of
length N, which is used to store the cumulative probability table for
use in calculations. This array should not be modified in any other program.
This is used only if the mean (np) is less than RMAX, in which case
C[I] will be the probability of having I or less events.

<div class="p"><!----></div>
 <br /><br /><a name="iranpoi"> </a>
 <b>110.&nbsp;IRANPOI&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/iranpoi.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/poisson.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to generate a sequence of
random numbers with Poisson distribution.
SEED is the seed for generating random numbers. It should be negative for
the first call to function and should not be changed in any other program,
unless an independent sequence of random number with different mean
is required. It should be noted that although the random number is an integer
in this case, the SEED is of type Real.
RMU is the mean of Poisson distribution. P is a real array of
length NMAX (=200), which is used to store the cumulative probability table for
use in calculations. This array should not be modified in any other program.
This is used only if the mean (RMU) is less than some critical value, in which case
P[I] will be the probability of having I or less counts.

<div class="p"><!----></div>
 <br /><br /><a name="pcor"> </a>
 <b>111.&nbsp;PCOR&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/pcor.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/pcor.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the probability that
two uncorrelated sequences of length (n+2) will give a correlation
coefficient exceeding &#124;x&#124;. For large even values of n the series can
give large roundoff errors in which case the distribution is approximate
by normal distribution. N is the number of degrees of freedom, i.e.,
<span class="roman">N</span>+2 is the length of the sequences and XX is the value of correlation
coefficient. Since the probability distribution of correlation coefficient
for uncorrelated data is symmetric about x=0, the probability is
calculated for &#124;x&#124;. This function requires Function <a href="appendixc.htm#gammaln">GAMMALN</a> to calculate
the logarithm of Gamma function and Function <a href="appendixc.htm#erf">ERF</a> to calculate the Error
function.

<div class="p"><!----></div>
 

<br /><br />
<a name="Functional Approximations"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.10&nbsp; FUNCTIONAL APPROXIMATIONS </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#polfit">POLFIT</a></td>
<td>&nbsp; <a href="#polevl">POLEVL</a></td>
<td>&nbsp; <a href="#polfit1">POLFIT1</a></td>
<td>&nbsp; <a href="#polort">POLORT</a></td>
<td>&nbsp; <a href="#polfit2">POLFIT2</a></td>
<td>&nbsp; <a href="#polev2">POLEV2</a></td>
<td>&nbsp; <a href="#polfitn">POLFITN</a></td>
<td>&nbsp; <a href="#polevn">POLEVN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#polevn1">POLEVN1</a></td>
<td>&nbsp; <a href="#polevn2">POLEVN2</a></td>
<td>&nbsp; <a href="#llsq">LLSQ</a></td>
<td>&nbsp; <a href="#bspfit">BSPFIT</a></td>
<td>&nbsp; <a href="#bspfit2">BSPFIT2</a></td>
<td>&nbsp; <a href="#bspfitw2">BSPFITW2</a></td>
<td>&nbsp; <a href="#bspfitn">BSPFITN</a></td>
<td>&nbsp; <a href="#bspfitwn">BSPFITWN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#linfitxy">LINFITXY</a></td>
<td>&nbsp; <a href="#nllsq">NLLSQ</a></td>
<td>&nbsp; <a href="#dft">DFT</a></td>
<td>&nbsp; <a href="#fft">FFT</a></td>
<td>&nbsp; <a href="#fftr">FFTR</a></td>
<td>&nbsp; <a href="#fftn">FFTN</a></td>
<td>&nbsp; <a href="#lapinv">LAPINV</a></td>
<td>&nbsp; <a href="#pold">POLD</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#rmk">RMK</a></td>
<td>&nbsp; <a href="#rmk1">RMK1</a></td>
<td>&nbsp; <a href="#rmkd">RMKD</a></td>
<td>&nbsp; <a href="#rmkd1">RMKD1</a></td>
<td>&nbsp; <a href="#pade">PADE</a></td>
<td>&nbsp; <a href="#chebcf">CHEBCF</a></td>
<td>&nbsp; <a href="#chebex">CHEBEX</a></td>
<td>&nbsp; <a href="#chebap">CHEBAP</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#remes">REMES</a></td>
<td>&nbsp; <a href="#fm">FM</a></td>
<td>&nbsp; <a href="#gamma">GAMMA</a></td>
<td>&nbsp; <a href="#gamln">GAMLN</a></td>
<td>&nbsp; <a href="#erf">ERF</a></td>
<td>&nbsp; <a href="#erfc">ERFC</a></td>
<td>&nbsp; <a href="#bj0">BJ0</a></td>
<td>&nbsp; <a href="#bj1">BJ1</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bjn">BJN</a></td>
<td>&nbsp; <a href="#by0">BY0</a></td>
<td>&nbsp; <a href="#bjy0">BJY0</a></td>
<td>&nbsp; <a href="#by1">BY1</a></td>
<td>&nbsp; <a href="#bjy1">BJY1</a></td>
<td>&nbsp; <a href="#byn">BYN</a></td>
<td>&nbsp; <a href="#sphbjn">SPHBJN</a></td>
<td>&nbsp; <a href="#bi0">BI0</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bi1">BI1</a></td>
<td>&nbsp; <a href="#bin">BIN</a></td>
<td>&nbsp; <a href="#bk0">BK0</a></td>
<td>&nbsp; <a href="#bk1">BK1</a></td>
<td>&nbsp; <a href="#bkn">BKN</a></td>
<td>&nbsp; <a href="#dawson">DAWSON</a></td>
<td>&nbsp; <a href="#fermmo5">FERMM05</a></td>
<td>&nbsp; <a href="#ferm05">FERM05</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#ferm15">FERM15</a></td>
<td>&nbsp; <a href="#ferm25">FERM25</a></td>
<td>&nbsp; <a href="#pleg">PLEG</a></td>
<td>&nbsp; <a href="#plm">PLM</a></td>
<td>&nbsp; <a href="#ylm">YLM</a></td>
<td>&nbsp; <a href="#minmax">MINMAX</a></td>
<td>&nbsp; <a href="#polyl1">POLYL1</a></td>
<td>&nbsp; <a href="#linl1">LINL1</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#simpl1">SIMPL1</a></td>
</tr>
</table>

<div class="p"><!----></div>
<br /><br /><a name="polfit"> </a>
 <b>112.&nbsp;POLFIT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/polfit.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polfit.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform least squares polynomial fit
using orthogonal polynomials. N is the number of data points, M is
the degree of polynomial to be fitted. X, F and SIG are arrays of length
N containing the data points. F[I] is the value of function
at X[I] and SIG[I] is the corresponding error.
If error estimates are not available then all SIG[I] can be set to one.
A is an array of length
<span class="roman">M</span>+1, which will contain the coefficients of the orthogonal
polynomials in the calculated fit. ALP and BETA are arrays of length
<span class="roman">M</span>+1, which will contain the coefficients &#945;<sub>i</sub> and
&#946;<sub>i</sub> as defined in recurrence relation for orthogonal polynomials.
ALP[I]=&#945;<sub>I+1</sub> and BETA[I]=&#946;<sub>I</sub>.
Y is an array of length  N, Y[I] will contain the calculated
value of function at X[I] using the least squares fit. H is an array
of length  <span class="roman">M</span>+1 containing the &#967;<sup>2</sup> values.
H[I] will contain the &#967;<sup>2</sup> using polynomial of degree I<!--hbox-->,

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">H</span><span class="roman">[</span><span class="roman">M</span><span class="roman">]</span>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
<span class="roman">Y</span>[j]&#8722;<span class="roman">F</span>[j]
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">SIG</span>[j]<br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.37)</td></tr></table>
</td></tr></table>


As explained in Section 10.2.2, this estimate of H[I] may have a significant roundoff
error. GAM is
an array of length  <span class="roman">M</span>+1, which will contain the  quantity &#947;<sub>i</sub> for the orthogonal polynomials as defined in Section&nbsp;10.2.2.
Error status can be obtained from the
returned value of POLFIT<!--hbox-->. A value of 601 implies that
<span class="roman">M</span> &#8805; <span class="roman">N</span> or <span class="roman">M</span> &lt; 0, in which case, no calculations
are performed.  <span class="roman">POLFIT</span>=621
implies that one of the &#947;<sub>i</sub>=0, which can happen if 
the points X[I] are not distinct.
The fitted polynomial can be calculated at any point
using the coefficients A, ALP and BETA by function POLEVL.

<div class="p"><!----></div>
 <br /><br /><a name="polevl"> </a>
 <b>113.&nbsp;POLEVL&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/polevl.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polfit.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to evaluate the approximating polynomial,
and its derivatives using Clenshaw's recurrences.
This function can be used to
calculate the value of approximating polynomial at any point X, after the
required coefficients a<sub>j</sub>, &#945;<sub>j</sub> and &#946;<sub>j</sub> have been calculated
by function <a href="appendixc.htm#polfit"> POLFIT</a><!--hbox-->. M ( &gt; 0) is the degree of polynomial. 
A, ALP and BETA
are arrays of length  <span class="roman">M</span>+1, with <span class="roman">A</span>[j]=a<sub>j</sub>,
<span class="roman">ALP</span>[j]=&#945;<sub>j+1</sub> and <span class="roman">BETA</span>[j]=&#946;<sub>j</sub>. These coefficients
must be calculated before calling the function POLEVL<!--hbox-->. X is the value
of the independent variable, at which the approximation has to be evaluated.
F,  DF and DDF are output parameters containing
the calculated values of the function and its
first and second derivatives, respectively.
The returned value of POLEVL is always zero.

<div class="p"><!----></div>
 <br /><br /><a name="polfit1"> </a>
 <b>114.&nbsp;POLFIT1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/polfit1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polfit2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform least squares polynomial fit
using orthogonal polynomials. This is a version of <a href="appendixc.htm#polfit"> POLFIT</a> which can
handle multiple fits, i.e., multiple sets of function values over the
same set of abscissas and errors. This is useful for recursive use in
multiple dimensions.
N is the number of data points, M is
the degree of polynomial to be fitted. NUM is the number of different
right hand sides (function values) to be fitted.
X and SIG are arrays of length
N containing the data points and errors.
F is an array of length <span class="roman">N</span>&times;<span class="roman">NUM</span> containing the
function values for each set of points. 
F[J][I] is the value of function in Jth set
at X[I] and SIG[I] is the corresponding error.
If error estimates are not available then all SIG[I] can be set to one.
The second dimension of F must be N in the calling program.
A is an array of length (<span class="roman">M</span>+1)&times;<span class="roman">NUM</span>,
which will contain the coefficients of the orthogonal
polynomials in the calculated fit for each set.
The second dimension of A must be <span class="roman">M</span>+1 in the calling program.
ALP and BETA are arrays of length
<span class="roman">M</span>+1, which will contain the coefficients &#945;<sub>i</sub> and
&#946;<sub>i</sub> as defined in recurrence relation for orthogonal polynomials.
GAM is
an array of length  <span class="roman">M</span>+1, which will contain the quantity &#947;<sub>i</sub> for the orthogonal polynomials as defined in Section&nbsp;10.2.2.
Error status can be obtained from the
returned value of POLFIT1<!--hbox-->. A value of 601 implies that
<span class="roman">M</span> &#8805; <span class="roman">N</span> or <span class="roman">M</span> &lt; 0, in which case, no calculations
are performed.
<span class="roman">POLFIT</span><span class="roman">1</span>=621
implies that one of the &#947;<sub>i</sub>=0, which can happen if 
the points X[I] are not distinct.
The fitted polynomial can be calculated at any point
using the coefficients A, ALP and BETA by function <a href="appendixc.htm#polevl"> POLEVL</a>.

<div class="p"><!----></div>
 <br /><br /><a name="polort"> </a>
 <b>115.&nbsp;POLORT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/polort.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polfit2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to evaluate the orthogonal polynomials,
and its derivatives. It may be noted that this function calculates
the value of orthogonal polynomials at the given point as opposed
to <a href="appendixc.htm#polevl"> POLEVL</a> which calculates the value of fitted function using the
coefficients of these polynomials.
This function can be used to
calculate the value of orthogonal polynomial basis functions
at any point X, after the
required coefficients &#945;<sub>j</sub> and &#946;<sub>j</sub> have been calculated
by function <a href="appendixc.htm#polfit"> POLFIT</a><!--hbox--> or <a href="appendixc.htm#polfit1"> POLFIT1</a><!--hbox-->.
M ( &gt; 0) is the degree of polynomial. 
ALP and BETA
are arrays of length  <span class="roman">M</span>+1, with
<span class="roman">ALP</span>[j]=&#945;<sub>j+1</sub> and <span class="roman">BETA</span>[j]=&#946;<sub>j</sub>. These coefficients
must be calculated before calling the function POLORT<!--hbox-->. X is the value
of the independent variable, at which the polynomials have to be evaluated.
F,  DF and DDF are arrays of length <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span>, which will contain
the calculated values of the <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> orthogonal polynomials and its
first and second derivatives, respectively at X<!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="polfit2"> </a>
 <b>116.&nbsp;POLFIT2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/polfit2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polfit2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform least squares polynomial fit
using orthogonal polynomials in two dimensions.
The data values must be available at a rectangular grid of points
and weights are assumed to be equal for all points.
NX is the number of data points along X axis,
NY is the number of data points along Y axis.
X is an array of length NX containing
the points along X axis, while Y is an array of length NY
containing the points along the Y axis.
F is an array of length <span class="roman">LA</span>&times;<span class="roman">NY</span> containing the
function values. F[J][I] is the value at X[I], Y[J].
AX is an array of length <span class="roman">IC</span>&times;3 containing information
about the fit along X direction. AX[0][I], AX[1][I], AX[2][I] will
respectively contain the coefficients &#945;<sub>i+1</sub>, &#946;<sub>i</sub>, &#947;<sub>i</sub>
for the orthogonal polynomials.
AY is an array of length <span class="roman">IC</span>&times;3 containing information
about the fit along Y direction. AY[0][I], AY[1][I], AY[2][I] will
respectively contain the coefficients &#945;<sub>i+1</sub>, &#946;<sub>i</sub>, &#947;<sub>i</sub>
for the orthogonal polynomials. The arrays AX and AY will be calculated
by the function.
LA is the second dimension of arrays  F and FY as declared in
the calling function, <span class="roman">LA</span> &#8805; max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>).
C is an array of length <span class="roman">IC</span>&times;(<span class="roman">MY</span><span class="roman">+</span><span class="roman">1</span>) containing the
fitted coefficients for the polynomial fit in two dimensions. The
fitted polynomial would be

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">MX</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;</td><td nowrap="nowrap" align="center">
<small><span class="roman">MY</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">C</span>[j][i]&#981;<sub>i</sub>(x)&#968;<sub>j</sub>(y),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.38)</td></tr></table>
</td></tr></table>


where &#981;<sub>i</sub>(x) and &#968;<sub>j</sub>(y) are the orthogonal polynomials in x
and y respectively.
IC is the second dimension of arrays AX, AY and C as declared in the calling function,
<span class="roman">IC</span> &gt; max(<span class="roman">MX</span><span class="roman">,</span> <span class="roman">MY</span>).
MX is the required degree of polynomial in X<!--hbox-->.
MY is the required degree of polynomial in Y<!--hbox-->.
FY is an array of length <span class="roman">LA</span>&times;<span class="roman">NY</span> containing the
fitted values of the function at each of the tabular points.
CHISQ is calculated value of &#967;<sup>2</sup> for the fit.
Error status can be obtained from the
returned value of POLFIT2<!--hbox-->. A value of 602 implies that
<span class="roman">IC</span> &lt; <span class="roman">MX</span>+1 or <span class="roman">LA</span> &lt; max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>).
POLFIT2=603 implies that <span class="roman">NX</span> &#8804; <span class="roman">MX</span>,
<span class="roman">NY</span> &#8804; <span class="roman">MY</span>, <span class="roman">MX</span> &lt; 0 or <span class="roman">MY</span> &lt; 0.
In all these cases, no calculations
are performed. The fitted polynomial can be calculated at any point
using the coefficients AX, AY, C by function POLEV2.
This function requires functions <a href="appendixc.htm#polfit1"> POLFIT1</a>, <a href="appendixc.htm#polev2"> POLEV2</a> and <a href="appendixc.htm#polort"> POLORT</a>.

<div class="p"><!----></div>
 <br /><br /><a name="polev2"> </a>
 <b>117.&nbsp;POLEV2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/polev2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polfit2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to evaluate the approximating polynomial,
and its derivatives using expansion in orthogonal polynomials in
2 dimensions.
This function can be used to
calculate the value of approximating polynomial at any point, after the
required coefficients c<sub>ij</sub> as well as other auxiliary coefficients
needed to define the orthogonal polynomials have been calculated
by function <a href="appendixc.htm#polfit2"> POLFIT2</a><!--hbox-->. 
NX is the degree of polynomial in X,
NY is the degree of polynomial in Y<!--hbox-->.
AX is an array of length <span class="roman">LA</span>&times;2 containing the
coefficients &#945;<sub>i</sub> and &#946;<sub>i</sub> for orthogonal polynomials in X<!--hbox-->.
AX[0][I] contains &#945;<sub>i+1</sub> and AX[1][I] contains &#946;<sub>i</sub>.
AY is an array of length <span class="roman">LA</span>&times;2 containing the
coefficients &#945;<sub>i</sub> and &#946;<sub>i</sub> for orthogonal polynomials in Y<!--hbox-->.
AY[0][I] contains &#945;<sub>i+1</sub> and AY[1][I] contains &#946;<sub>i</sub>.
These coefficients
must be calculated before calling the function POLEV2<!--hbox--> using
POLFIT2.
LA is the second dimension of arrays AX, AY and WT in the calling function,
<span class="roman">LA</span> &gt; max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>).
WT is an array of length  <span class="roman">LA</span>&times;(<span class="roman">NY</span>+1),
containing the coefficients of the fit.
X0, Y0 are the coordinates of the point at which function value needs to
be calculated.
F is the output parameter containing
the calculated values of the function at (X0, Y0).
Output parameters, DFX and DFY are respectively, &#8706;F/&#8706;x and
&#8706;F/&#8706;y, while DFXX, DFXY, DFYY are the
second derivative &#8706;<sup>2</sup>F/&#8706;x<sup>2</sup>,
&#8706;<sup>2</sup>F/&#8706;x&#8706;y,
&#8706;<sup>2</sup>F/&#8706;y<sup>2</sup>. 
Error status can be obtained from the
returned value of POLEV2<!--hbox-->. A value of 604 implies that
max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>) &#8805; <span class="roman">LA</span>,
in which case no calculations are done.
The function requires <a href="appendixc.htm#polort"> POLORT</a>
to calculate the orthogonal basis functions in one dimensions.

<div class="p"><!----></div>
 <br /><br /><a name="polfitn"> </a>
 <b>118.&nbsp;POLFITN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/polfitn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polfitn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform least squares polynomial fit
using orthogonal polynomials in N dimensions.
The data values must be available at a hyper-rectangular grid of points
and weights are assumed to be equal for all points.
N is the number of dimensions.
NK is an integer array of length N containing the number of data points
along each axis. NK[I] is the number of points along Ith axis.
X is an array of length <span class="roman">LA</span>&times;<span class="roman">N</span> containing
the points along each axis, X[J][I] is the Ith point along the Jth
dimension.
F is an array of length <span class="roman">NK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>&times;<span class="roman">NK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span>&times;&#8230;&times;<span class="roman">NK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span> containing the
function values. F is treated as a one dimensional array in this
function and hence the dimensions of array in the calling function must
exactly match the number of points in each dimension, e.g.,
F[NK[N&#8722;1]]&#8230;[NK[1]][NK[0]].
AX is an array of length <span class="roman">LA</span>&times;(3<span class="roman">N</span>+3) containing information
about the fit along each direction. AX[3J][I], AX[3J+1][I],
AX[3J+2][I] will
respectively contain the coefficients &#945;<sub>i+1</sub>, &#946;<sub>i</sub>, &#947;<sub>i</sub>
for the orthogonal polynomials along Jth dimension.
The rest of the array is used as
scratch space while calculating fits in one dimension.
LA is the second dimension of arrays X and AX as declared in
the calling function, <span class="roman">LA</span> &#8805; max(<span class="roman">NK</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>).
C is an array of length (<span class="roman">MK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>+1)(<span class="roman">MK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">1</span>)&#8230;(<span class="roman">MK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span>+1) containing the
fitted coefficients for the polynomial fit in N dimensions. The
fitted polynomial would be

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">MK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>0</sub>=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;</td><td nowrap="nowrap" align="center">
<small><span class="roman">MK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>1</sub>=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#8230;</td><td nowrap="nowrap" align="center">
<small><span class="roman">MK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>N&#8722;1</sub>=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">C</span>[i<sub>N&#8722;1</sub>]&#8230;[i<sub>1</sub>][i<sub>0</sub>]&#981;<sub>i<sub>0</sub></sub>(x<sub>0</sub>)&#981;<sub>i<sub>1</sub></sub>(x<sub>1</sub>)&#8230;&#981;<sub>i<sub>N&#8722;1</sub></sub>(x<sub>N&#8722;1</sub>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.39)</td></tr></table>
</td></tr></table>


where &#981;<sub>i<sub>j</sub></sub>(x<sub>j</sub>) are the orthogonal polynomials along jth dimension.
C is treated as a one dimensional array in this
function and hence the dimensions of array in the calling function must
exactly match the number of polynomials in each dimension, e.g.
C[MK[N&#8722;1]+1]&#8230;[MK[1]+1][MK[0]+1].
MK is an integer array of length N containing the required degree
of polynomial in each direction.
FY is an array of the same length and shape as F which will contain the
fitted value of the function at each of the tabular points.
CHISQ is calculated value of &#967;<sup>2</sup> for the fit.
Error status can be obtained from the
returned value of POLFITN<!--hbox-->. A value of 605 implies that
<span class="roman">LA</span> &lt; max(<span class="roman">NK</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>).
In this case, no calculations
are performed. The fitted polynomial can be calculated at any point
using the coefficients C and AX by function <a href="appendixc.htm#polevn"> POLEVN</a>, <a href="appendixc.htm#polevn1"> POLEVN1</a> or
<a href="appendixc.htm#polevn2"> POLEVN2</a>. This function requires functions <a href="appendixc.htm#polfit1"> POLFIT1</a>, POLEVN, <a href="appendixc.htm#polort"> POLORT</a>.

<div class="p"><!----></div>
 <br /><br /><a name="polevn"> </a>
 <b>119.&nbsp;POLEVN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/polevn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polfitn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to evaluate the approximating polynomial
using expansion in orthogonal polynomials in N dimensions.
This function can be used to
calculate the value of approximating polynomial at any point, after the
required coefficients as well as other auxiliary coefficients
needed to define the orthogonal polynomials have been calculated
by function <a href="appendixc.htm#polfitn"> POLFITN</a><!--hbox-->. 
N is the number of dimensions.
NK is an integer array of length N containing the degree of polynomial
in each dimension.
AX is an array of length <span class="roman">LA</span>&times;(3<span class="roman">N</span>+3) containing the
coefficients &#945;<sub>i</sub> and &#946;<sub>i</sub> for orthogonal polynomials in X<!--hbox-->.
AX[3J][I] contains &#945;<sub>I+1</sub> and AX[3J+1][I] contains &#946;<sub>I</sub>
for orthogonal polynomials along Jth dimension.
These coefficients
must be calculated before calling the function POLEVN<!--hbox--> using
POLFITN<!--hbox-->.
LA is the second dimension of array AX in the calling function.
This must be the same as what was used in call to POLFITN while calculating
the coefficients.
WT is an array of length  (<span class="roman">MK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>+1)(<span class="roman">MK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span>+1)&#8230;(<span class="roman">MK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span>+1),
containing the coefficients of the fit.
This array is treated as one-dimensional array in the function and
hence its dimensions in the calling function must exactly match the
number of orthogonal polynomials in each dimension, for example,
WT[MK[N&#8722;1]+1]&#8230;[MK[1]+1][MK[0]+1].
X0 is an array of length N containing the coordinates of the point
at which function value needs to be calculated.
F is the output parameter containing
the calculated values of the function at X0.
The returned value is always zero.
This function requires <a href="appendixc.htm#polort"> POLORT</a>
to calculate the orthogonal basis functions in one dimensions.
This function does not calculate the derivatives of F<!--hbox-->.
If first derivatives
are required then one can use <a href="appendixc.htm#polevn1"> POLEVN1</a>, while for second
derivatives use <a href="appendixc.htm#polevn2"> POLEVN2</a>.

<div class="p"><!----></div>
 <br /><br /><a name="polevn1"> </a>
 <b>120.&nbsp;POLEVN1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/polevn1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polfitn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to evaluate the approximating polynomial
and its first derivative
using expansion in orthogonal polynomials in N dimensions.
This function can be used to
calculate the value of approximating polynomial at any point, after the
required coefficients as well as other auxiliary coefficients
needed to define the orthogonal polynomials have been calculated
by function POLFITN<!--hbox-->. 
This is the version of <a href="appendixc.htm#polevn"> POLEVN</a> which also calculates the first derivatives.
The arguments are the same as those for POLEVN, except for array
DF of length N, which will contain the first derivatives
of F at X0. DF[i] will contain &#8706;F/&#8706;x<sub>i</sub>.
This function does not calculate the second derivatives of F<!--hbox-->.
If second derivatives
are required then one can use <a href="appendixc.htm#polevn2"> POLEVN2</a>, while if no derivatives are
required then use <a href="appendixc.htm#polevn"> POLEVN</a>.

<div class="p"><!----></div>
 <br /><br /><a name="polevn2"> </a>
 <b>121.&nbsp;POLEVN2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/polevn2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polfitn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to evaluate the approximating polynomial
and its first and second derivatives
using expansion in orthogonal polynomials in N dimensions.
This function can be used to
calculate the value of approximating polynomial at any point, after the
required coefficients as well as other auxiliary coefficients
needed to define the orthogonal polynomials have been calculated
by function POLFITN<!--hbox-->. 
This is the version of <a href="appendixc.htm#polevn"> POLEVN</a> which also calculates the first and
second derivatives.
The arguments are same as those of POLEVN, except for arrays DF and DDF.
DF is an array of length N which will contain the first derivatives
of F at X0. DF[i] will contain &#8706;F/&#8706;x<sub>i</sub>.
DDF is an array of length <span class="roman">N</span><sup>2</sup> which will contain the
second derivatives
of F at X0. DDF[j][i] will contain &#8706;<sup>2</sup>F/&#8706;x<sub>i</sub>&#8706;x<sub>j</sub>.
The second dimension of DDF in the calling function must be equal to N<!--hbox-->.
This function calculates the first and second derivatives of F<!--hbox-->.
If second derivatives
are not required then one can use <a href="appendixc.htm#polevn1"> POLEVN1</a>, while if no derivatives are
required then use <a href="appendixc.htm#polevn"> POLEVN</a>.

<div class="p"><!----></div>
 <br /><br /><a name="llsq"> </a>
 <b>122.&nbsp;LLSQ&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/llsq.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/llsq.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate a general linear least squares
fit in K dimensions. It uses singular value decomposition (SVD) to
solve the system of equations.
The tabular points could have arbitrary distribution
in K-space and the basis functions also are arbitrary functions to be
defined by the user. N is the number of tabular points, M is the number
of basis functions, K is the number of dimensions. X is an array
of length <span class="roman">IX</span>&times;<span class="roman">N</span> containing the coordinates of tabular
points. X[J][I] is the Ith coordinate of Jth tabular point. IX is the
second dimension of X in the calling function (<span class="roman">IX</span> &#8805; <span class="roman">K</span>).
For fitting in one dimension, IX can be set to 1 and array X can be
passed on as a one dimensional array of length N<!--hbox-->. F is an array
of length N, containing the function values. F[I] is the function value
at (X[I][0], X[I][1], &#8230;, X[I][K&#8722;1]). This is treated as one dimensional
array in the function and hence should not have any gaps in storage.
This allows the function to be used for a general distribution of points
not necessarily along a hyper-rectangular mesh. EF is an array of
length N, containing the estimated error in F<!--hbox-->. This is only used for
determining the weights associated with each points. Thus, it solves
the following system of equations

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">M</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">A</span>[i]
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>[j]<br /></td><td nowrap="nowrap" align="center">
&#981;<sub>i</sub>(<span class="roman">X</span>[j][0],&#8230;,<span class="roman">X</span>[j][<span class="roman">K</span>&#8722;1])=</td><td nowrap="nowrap" align="center">
<span class="roman">F</span>[j]
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>[j]<br /></td><td nowrap="nowrap" align="center">
,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j=0,1,&#8230;,<span class="roman">N</span>&#8722;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.40)</td></tr></table>
</td></tr></table>


using SVD<!--hbox-->. A is an array of length N, which will contain the
fitted coefficients. Although, there are only M coefficients the
array must have a length of at least N, since the remaining elements
are used as scratch space.
U is an array of length <span class="roman">IU</span>&times;<span class="roman">N</span> which will contain
the matrix U from SVD of the design matrix.
V is an array of length <span class="roman">IV</span>&times;<span class="roman">M</span> which will contain
the matrix V from SVD of the design matrix, (G=U&#931;V<sup>T</sup>).
IU is the second dimension of U in the calling function (<span class="roman">IU</span> &#8805; <span class="roman">M</span>).
IV is the second dimension of V and COV in the calling function (<span class="roman">IV</span> &#8805; <span class="roman">M</span>).
SIGMA is an array of length M, which will contain the singular
values of the design matrix. Y is an array of length N which will
contain the fitted values of the function at the tabular points.
PHI is the name
of the function to calculate the basis functions at a given point.
REPS is the required accuracy for the solution of equations. All singular
values less than REPS times the largest singular value will be set to zero
during solution. This parameter can be used to eliminate the linear
combinations of basis functions that contribute little to the fit.
CHISQ is the minimum value of &#967;<sup>2</sup> defined by

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#967;<sup>2</sup>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
<span class="roman">F</span>[i]
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>[i]<br /></td><td nowrap="nowrap" align="center">
&#8722;</td><td nowrap="nowrap" align="center">
<small><span class="roman">M</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">A</span>[j]
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>[i]<br /></td><td nowrap="nowrap" align="center">
&#981;<sub>j</sub>(<span class="roman">X</span>[i][0],&#8230;,<span class="roman">X</span>[i][<span class="roman">K</span>&#8722;1])</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.41)</td></tr></table>
</td></tr></table>


COV is an array of length <span class="roman">IV</span>&times;<span class="roman">M</span> which will contain the covariance matrix
between fitted parameters. COV[I][J] is the covariance between A[I] and A[J].
The diagonal elements are the variance in fitted parameters.
Error status can be obtained from the
returned value of LLSQ<!--hbox-->. A value of 606 implies that
<span class="roman">M</span> &gt; <span class="roman">N</span>,
<span class="roman">M</span> &#8804; 0, <span class="roman">N</span> &#8804; 0 or <span class="roman">K</span> &gt; <span class="roman">IX</span>.
LLSQ=607 implies that EF[I] are not all positive. In both these cases
no calculations are done. The function PHI(M, X, FX) must be supplied
by the user to calculate the required basis functions at a given point.
Here M is the number of basis functions, X is an array of length K
containing the coordinates of the point at which the basis functions
need to be calculated. FX is an array of length M containing the
calculated basis functions at X<!--hbox-->. FX[I] should give &#981;<sub>I</sub>(<span class="roman">X</span>).
For polynomial fits in one dimension &#981;<sub>i</sub>(x)=x<sup>i</sup>, but in that
case it may be better to use <a href="appendixc.htm#polfit"> POLFIT</a> to calculate the fit.
Apart from PHI it also needs functions <a href="appendixc.htm#svd"> SVD</a> and <a href="appendixc.htm#svdevl"> SVDEVL</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="bspfit"> </a>
 <b>123.&nbsp;BSPFIT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspfit.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bspfit.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate linear least squares
fit to B-spline basis functions in one dimension.
It uses singular value decomposition (SVD) to
solve the system of equations and also allows
regularisation to be incorporated.
N is the number of tabular points, X is an array
of length  N containing the coordinates of tabular
points. F is an array
of length N, containing the function values. F[I] is the function value
at X[I].  EF is an array of
length N, containing the estimated error in F<!--hbox-->. This is only used for
determining the weights associated with each points. Thus, it solves
the following system of equations

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">C</span>[i]
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>[j]<br /></td><td nowrap="nowrap" align="center">
&#981;<sub>i</sub>(<span class="roman">X</span>[j]) = </td><td nowrap="nowrap" align="center">
<span class="roman">F</span>[j]
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>[j]<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j=0,1,&#8230;,<span class="roman">N</span>&#8722;<span class="roman">1</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.42)</td></tr></table>
</td></tr></table>


using SVD<!--hbox-->. Here &#981;<sub>i</sub>(x) are the B-spline basis functions.
K is the order of B-splines required, <span class="roman">K</span>=4 for cubic B-splines
and <span class="roman">K</span>=2 for linear B-splines, etc.
A is an array of length <span class="roman">LA</span>&times;2<span class="roman">N</span> (when RLM &gt; 0)
which will
contain the matrix U from SVD of the design matrix.
If RLM &#8804; 0 then A can be an array of length <span class="roman">LA</span>&times;<span class="roman">N</span>.
V is an array of length <span class="roman">IV</span>&times;(<span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) which will contain
the matrix V from SVD of the design matrix, (G=U&#931;V<sup>T</sup>).
LA is the second dimension of A in the calling function,
<span class="roman">LA</span> &#8805; <span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2.
IV is the second dimension of V and COV in the calling function
(<span class="roman">IV</span> &#8805; <span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2).
SIGMA is an array of length <span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, which will contain the
singular values of the design matrix.
C is an array of length 2N, which will contain the
fitted coefficients. Although, there are only <span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2 coefficients the
array must have a length of at least 2N, since the remaining elements
are used as scratch space.
XF is an array of length NO containing the
knots required to define the B-spline basis functions.
NO is the number of knots for defining B-splines. The knots must be
distinct and in ascending order with XF[0] containing the first knot.
This will yield (<span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)
B-spline basis functions for fitting.
Y is an array of length N which will
contain the fitted values of the function at the tabular points.
IFLG is an integer variable that specifies what
calculation is to be done. For IFLG &#8804; 1 the matrix is calculated
and its SVD is computed. If execution is
successful, IFLG will be set to 2, so that next time the matrix
calculations will be skipped. If IFLG &#8804; 0 the coefficients of
expansion are also calculated and the fitted values Y as well as the
CHISQ and COV are computed.
If IFLG=2, only the coefficients of
expansion will be calculated using the old SVD 
available in arrays A, V and SIGMA and the (hopefully new) function values F<!--hbox-->.
For IFLG=2 the fitted values Y, CHISQ and COV are not calculated.
If IFLG=3, the coefficients of
expansion as well as the fitted values Y and CHISQ are calculated
using the old SVD<!--hbox-->.
REPS is the required accuracy for the solution of equations. All singular
values less than REPS times the largest singular value will be set to zero
during solution. This parameter can be used to eliminate the linear
combinations of basis functions that contribute little to the fit.
RLM is the regularisation parameter &#955; for smoothing. If
&#955; &#8804; 0 no regularisation is applied, while for &#955; &gt; 0
regularisation is applied using either first or second derivative.
IDE is the integer parameter which specifies the order of derivative to be
used for regularisation. This is used only if &#955; &gt; 0, in which
case it must be either 1 or 2. For IDE=1 first derivative smoothing
is used, while for IDE=2 second derivative smoothing is applied.
The regularisation is applied at all tabular points, making the number
of equations 2N<!--hbox-->.
CHISQ is the minimum value of &#967;<sup>2</sup> defined by

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#967;<sup>2</sup>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
<span class="roman">F</span>[i]
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>[i]<br /></td><td nowrap="nowrap" align="center">
&#8722;</td><td nowrap="nowrap" align="center">
<small><span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">C</span>[j]
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>[i]<br /></td><td nowrap="nowrap" align="center">
&#981;<sub>j</sub>(<span class="roman">X</span>[i])</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.43)</td></tr></table>
</td></tr></table>


COV is an array of length <span class="roman">IV</span>&times;<span class="roman">M</span> which will contain the covariance matrix
between fitted parameters. COV[I][J] is the covariance between C[I] and C[J].
The diagonal elements are the variance in fitted parameters.
Error status can be obtained from the
returned value of BSPFIT<!--hbox-->. A value of 608 implies that
<span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span> &gt; <span class="roman">N</span>, or <span class="roman">K</span> &lt; 2.
BSPFIT=609 implies that RLM &gt; 0 but IDE is not 1 or 2.
BSPFIT=610 implies that EF[I] are not all positive. In all these cases
no calculations are done. Other values may be set by SVD or
BSPLIN<!--hbox-->. This function requires functions <a href="appendixc.htm#bsplin"> BSPLIN</a>, <a href="appendixc.htm#bspevl"> BSPEVL</a>, <a href="appendixc.htm#svd"> SVD</a>,
and <a href="appendixc.htm#svdevl"> SVDEVL</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="bspfit2"> </a>
 <b>124.&nbsp;BSPFIT2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspfit2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bspfit2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate linear least squares
fit to B-spline basis functions in two dimensions.
It uses singular value decomposition (SVD) to
solve the system of equations and also allows regularisation to be incorporated,
but it is restricted to equal weights for all points. The function
solves the system of equations in one dimension at a time, that is why the weights
have to be equal. For general least squares solution with varying weights
users can try <a href="appendixc.htm#bspfitw2"> BSPFITW2</a>, which solves the system of equations for 2 dimensions directly and
hence will require much more time.
NX is the number of tabular points along x-axis. 
NY is the number of tabular points along y-axis. 
X and Y are arrays 
of length  NX, NY containing the coordinates of tabular
points. F is an array
of length <span class="roman">LA</span>&times;<span class="roman">NY</span>, containing the function values.
F[J][I] is the function value at (X[I], Y[J]).
K is the order of B-splines required, <span class="roman">K</span>=4 for cubic B-splines
and <span class="roman">K</span>=2 for linear B-splines, etc.
For simplicity, the order is assumed to be the same in both directions.
AX is an array of length <span class="roman">IV</span>&times;2<span class="roman">NX</span> which will
contain the matrix U from SVD of the design matrix for fit along x-axis.
AY is an array of length <span class="roman">IV</span>&times;2<span class="roman">NY</span> which will
contain the matrix U from SVD of the design matrix for fit along y-axis.
These dimensions are when <span class="roman">RLM</span> &gt; 0. For <span class="roman">RLM</span> &#8804; 0 the required
dimensions are <span class="roman">IV</span>&times;<span class="roman">NX</span> and <span class="roman">IV</span>&times;<span class="roman">NY</span> for
AX and AY respectively.
LA is the second dimension of arrays F, C and FY as declared in
the calling function. All these arrays should have the same second dimension.
LA must be at least 2&times;max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>) when RLM &gt; 0, otherwise
LA must be at least max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>).
VX is an array of length <span class="roman">IV</span>&times;(<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) which will contain
the matrix V from SVD of the design matrix for fit along the x-axis.
VY is an array of length <span class="roman">IV</span>&times;(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) which will contain
the matrix V from SVD of the design matrix for fit along the y-axis.
IV is the second dimension of AX, AY, VX and VY in the calling function
(<span class="roman">IV</span> &#8805; max(<span class="roman">MX</span><span class="roman">,</span> <span class="roman">MY</span>)+<span class="roman">K</span>&#8722;2).
SIGMAX is an array of length <span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, which will contain the
singular values of the design matrix for fit along the x-axis.
SIGMAY is an array of length <span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, which will contain the
singular values of the design matrix for fit along the y-axis.
C is an array of length <span class="roman">LA</span>&times;<span class="roman">NY</span>, which will contain the
fitted coefficients. Although, there are only (<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)
coefficients the
array must have a larger length, since the remaining elements
are used as scratch space.
XF is an array of length MX containing the
knots required to define the B-spline basis functions along x.
YF is an array of length MY containing the
knots required to define the B-spline basis functions along y.
MX is the number of knots for defining B-splines along x-axis.
MY is the number of knots for defining B-splines along y-axis.
The knots must be distinct and in ascending order with XF[0], YF[0]
containing the first knot.
FY is an array of length <span class="roman">LA</span>&times;<span class="roman">NY</span> which will
contain the fitted values of the function at the tabular points.
REPS is the required accuracy for the solution of equations. All singular
values less than REPS times the largest singular value will be set to zero
during solution. This parameter can be used to eliminate the linear
combinations of basis functions that contribute little to the fit.
RLM is the regularisation parameter &#955; for smoothing. If
&#955; &#8804; 0 no regularisation is applied, while for &#955; &gt; 0
regularisation is applied using either first or second derivative.
IDE is the integer parameter which specifies the order of derivative to be
used for regularisation. This is used only if &#955; &gt; 0, in which
case it must be either 1 or 2. For IDE=1 first derivative smoothing
is used, while for IDE=2 second derivative smoothing is applied.
The regularisation is applied at all tabular points, making the number
of equations 2 times larger.
CHISQ is the minimum value of &#967;<sup>2</sup> defined by

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#967;<sup>2</sup>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">NX</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;</td><td nowrap="nowrap" align="center">
<small><span class="roman">NY</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
<span class="roman">F</span>[j][i]&#8722;</td><td nowrap="nowrap" align="center">
<small><span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j1=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;</td><td nowrap="nowrap" align="center">
<small><span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j2=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">C</span>[j2][j1]&#981;<sub>j1</sub>(<span class="roman">X</span>[i]) &#968;<sub>j2</sub>(<span class="roman">Y</span>[j])</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.44)</td></tr></table>
</td></tr></table>


Here &#981;<sub>j</sub>(x) are the basis functions in x and &#968;<sub>j</sub>(y)
are those in y.
Error status can be obtained from the
returned value of BSPFIT2<!--hbox-->. A value of 608 implies that
<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span> &gt; <span class="roman">NX</span>, <span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span> &gt; <span class="roman">NY</span>, or <span class="roman">K</span> &lt; 2.
BSPFIT2=609 implies that RLM &gt; 0 but IDE is not 1 or 2.
In all these cases
no calculations are done. Other values may be set by BSPFIT, SVD or
BSPLIN<!--hbox-->. This function requires functions
<a href="appendixc.htm#bspfit"> BSPFIT</a>, <a href="appendixc.htm#bsplin"> BSPLIN</a>, <a href="appendixc.htm#bspevl"> BSPEVL</a>, <a href="appendixc.htm#bspev2"> BSPEV2</a>, <a href="appendixc.htm#svd"> SVD</a> and <a href="appendixc.htm#svdevl"> SVDEVL</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="bspfitw2"> </a>
 <b>125.&nbsp;BSPFITW2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspfitw2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bspfit2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate linear least squares
fit to B-spline basis functions in two dimensions.
It uses singular value decomposition (SVD) to
solve the system of equations and also allows regularisation as well
as nonuniform weights to be incorporated.
This function solves the system of equations directly in two dimensions
and hence will require much more time as compared to <a href="appendixc.htm#bspfit2"> BSPFIT2</a>.
NX is the number of tabular points along x-axis. 
NY is the number of tabular points along y-axis. 
X and Y are arrays 
of length  NX, NY containing the coordinates of tabular
points. F is an array
of length <span class="roman">IC</span>&times;<span class="roman">NY</span>, containing the function values.
F[J][I] is the function value at (X[I], Y[J]).
EF is an array
of length <span class="roman">IC</span>&times;<span class="roman">NY</span>, containing the estimated errors
in F<!--hbox-->. These values are used to choose the weight for each
equation for least squares solution.
K is the order of B-splines required, <span class="roman">K</span>=4 for cubic B-splines
and <span class="roman">K</span>=2 for linear B-splines, etc.
For simplicity, order of B-splines is assumed to be the same along
each axes.
A is an array of length <span class="roman">LA</span>&times;3<span class="roman">NX</span>&times;<span class="roman">NY</span>
which will
contain the matrix U from SVD of the design matrix.
If RLM &#8804; 0 then the size of array A needs to be only
<span class="roman">LA</span>&times;<span class="roman">NX</span>&times;<span class="roman">NY</span>.
LA is the second dimension of array A as declared in
the calling function.
LA must be at least (<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2).
V is an array of length <span class="roman">IV</span>&times;(<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)
which will contain
the matrix V from SVD of the design matrix.
IV is the second dimension of V in the calling function,
<span class="roman">IV</span> &#8805; (<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2).
SIGMA is an array of length (<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2),
which will contain the singular values of the design matrix.
C is an array of length <span class="roman">IC</span>&times;(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2), which will contain the
fitted coefficients.
IC is the second dimension of arrays C, F, EF, FY as declared in the
calling function, IC must be at least NX<!--hbox-->.
XF is an array of length MX containing the
knots required to define the B-spline basis functions along x.
YF is an array of length MY containing the
knots required to define the B-spline basis functions along y.
MX is the number of knots for defining B-splines along x-axis.
MY is the number of knots for defining B-splines along y-axis.
The knots must be distinct and in ascending order with XF[0], YF[0]
containing the first knot.
FY is an array of length <span class="roman">IC</span>&times;<span class="roman">NY</span> which will
contain the fitted values of the function at the tabular points.
REPS is the required accuracy for the solution of equations. All singular
values less than REPS times the largest singular value will be set to zero
during solution. This parameter can be used to eliminate the linear
combinations of basis functions that contribute little to the fit.
RLM is the regularisation parameter &#955; for smoothing. If
&#955; &#8804; 0 no regularisation is applied, while for &#955; &gt; 0
regularisation is applied using either first or second derivative.
IDE is the integer parameter which specifies the order of derivative to be
used for regularisation. This is used only if &#955; &gt; 0, in which
case it must be either 1 or 2. For IDE=1 first derivative smoothing
is used, while for IDE=2 second derivative smoothing is applied.
The regularisation is applied at all tabular points, making the number
of equations 3 times larger.
CHISQ is the minimum value of &#967;<sup>2</sup> defined by

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">NX</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;</td><td nowrap="nowrap" align="center">
<small><span class="roman">NY</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239C;<br />
&#x239D;
</td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">F</span>[j][i]&#8722;</td><td nowrap="nowrap" align="center">
<small><span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j1=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;</td><td nowrap="nowrap" align="center">
<small><span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j2=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">A</span>[j2][j1]&#981;<sub>j1</sub>(<span class="roman">X</span>[i]) &#968;<sub>j2</sub>(<span class="roman">Y</span>[j])</td></tr></table>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>[j][i]<br /></td><td align="left" class="cl">&#x239E;<br />&#x239F;<br />
&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.45)</td></tr></table>
</td></tr></table>


Here &#981;<sub>j</sub>(x) are the basis functions in x and &#968;<sub>j</sub>(y)
are those in y.
This routine does not calculate the covariance matrix, but this can be
easily added following BSPFIT<!--hbox-->.
Error status can be obtained from the
returned value of BSPFITW2<!--hbox-->. A value of 608 implies that
<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span> &gt; <span class="roman">NX</span>, <span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span> &gt; <span class="roman">NY</span>, or <span class="roman">K</span> &lt; 2.
BSPFITW2=609 implies that RLM &gt; 0 but IDE is not 1 or 2.
BSPFITW2=610 implies that EF[J][I] are not all positive. In all these cases
no calculations are done. Other values may be set by SVD or
BSPLIN<!--hbox-->. This function requires functions
<a href="appendixc.htm#bsplin"> BSPLIN</a>, <a href="appendixc.htm#bspev2"> BSPEV2</a>, <a href="appendixc.htm#svd"> SVD</a> and <a href="appendixc.htm#svdevl"> SVDEVL</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="bspfitn"> </a>
 <b>126.&nbsp;BSPFITN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspfitn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bspfitn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate linear least squares
fit to B-spline basis functions in N dimensions.
It uses singular value decomposition (SVD) to
solve the system of equations and also allows regularisation to be incorporated,
but it is restricted to equal weights for all points. The function
solves the system of equations in one dimension at a time, that is why the weights
have to be equal. For general least squares solution with varying weights
users can try <a href="appendixc.htm#bspfitwn"> BSPFITWN</a>, which solves the system of equations for N dimensions directly and
hence will require much more time.
N is the number of dimensions.
NK is an integer array of length N containing the number of tabular
points along each axis. 
X is an array of length  <span class="roman">LA</span>&times;<span class="roman">N</span>
containing the coordinates of tabular
points. X[J][I] is the Ith point along Jth axis.
F is an array of length <span class="roman">NK</span>[0]&times;<span class="roman">NK</span>[1]&times;&#8230;&times;<span class="roman">NK</span>[<span class="roman">N</span>&#8722;1], containing the function values.
F[i<sub>N&#8722;1</sub>]&#8230;[i<sub>1</sub>][i<sub>0</sub>] is the function value at (X[0][i<sub>0</sub>],
X[1][i<sub>1</sub>], &#8230;, X[N&#8722;1][i<sub>N&#8722;1</sub>]).
This is treated as a one-dimensional array and
hence its dimensions in the calling function must exactly match the
size in each dimension, e.g., the dimensions could be
F[NK[N&#8722;1]]&#8230;[NK[1]][NK[0]]. 
K is the order of B-splines required, <span class="roman">K</span>=4 for cubic B-splines
and <span class="roman">K</span>=2 for linear B-splines, etc.
For simplicity, the order is assumed to be the same along each dimension.
A is an array of length <span class="roman">IV</span>&times;<span class="roman">LA</span>&times;<span class="roman">N</span> which will
contain the matrix U from SVD of the design matrix for fit along each
axis.
LA is the second dimension of array X,  as declared in
the calling function. The second dimension of A should be <span class="roman">LA</span>&times;<span class="roman">IV</span>.
LA must be at least 2&times;max(<span class="roman">NK</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>) when
RLM &gt; 0, otherwise
LA must be at least max(<span class="roman">NK</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>).
V is an array of length <span class="roman">IV</span><sup>2</sup>&times;<span class="roman">N</span> which will contain
the matrix V from SVD of the design matrix for fit along each axis.
IV is the second dimension of XF and SIGMA in the calling function
(<span class="roman">IV</span> &#8805; <span class="roman">K</span>&#8722;2+max<span class="roman">MK</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>). The second dimension of
V in calling function is <span class="roman">IV</span><sup>2</sup>.
SIGMA is an array of length <span class="roman">IV</span>&times;<span class="roman">N</span>,
which will contain the
singular values of the design matrix for fit along each axis.
C is an array of length <span class="roman">NK</span>[0]&times;<span class="roman">NK</span>[1]&times;&#8230;&times;<span class="roman">NK</span>[<span class="roman">N</span>&#8722;1], which will contain the
fitted coefficients. If RLM &gt; 0 this length must be 2
times larger. Note that
although there are only (<span class="roman">MK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)&#8230;(<span class="roman">MK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) coefficients the
array must have a larger length, since the remaining elements
are used as scratch space.
This is treated as a one-dimensional array and
hence its dimensions in the calling function must exactly match the
size in each dimension, e.g., the dimensions could be

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">C</span>[<span class="roman">NX</span>][<span class="roman">MK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">2</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2] &#8230;[<span class="roman">MK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2][<span class="roman">MK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2]. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.46)</td></tr></table>
</td></tr></table>


Here the first dimension has to be increased suitably to accommodate the
scratch space required. The first dimension NX should be chosen such that
the total size is greater than the required value.
If this array is only passed on to <a href="appendixc.htm#bspevn"> BSPEVN</a> or equivalent functions to
calculate the function value at any required point, then the exact
dimensions in calling function are immaterial as long as the total length
is larger than the required value.
XF is an array of length <span class="roman">IV</span>&times;<span class="roman">N</span> containing the
knots required to define the B-spline basis functions in each dimension.
The knots must be distinct and in ascending order.
XF[J][I] is the Ith knot along Jth dimension. 
MK is an integer array of length N containing the number of knots
for defining B-splines along each axis.
FY is an array of same size and shape as F which will
contain the fitted values of the function at the tabular points.
REPS is the required accuracy for the solution of equations. All singular
values less than REPS times the largest singular value will be set to zero
during solution. This parameter can be used to eliminate the linear
combinations of basis functions that contribute little to the fit.
RLM is the regularisation parameter &#955; for smoothing. If
&#955; &#8804; 0 no regularisation is applied, while for &#955; &gt; 0
regularisation is applied using either first or second derivative.
IDE is the integer parameter which specifies the order of derivative to be
used for regularisation. This is used only if &#955; &gt; 0, in which
case it must be either 1 or 2. For IDE=1 first derivative smoothing
is used, while for IDE=2 second derivative smoothing is applied.
The regularisation is applied at all tabular points, making the number
of equations 2 times larger.
CHISQ is the minimum value of &#967;<sup>2</sup> obtained using the fitted
coefficients.
Error status can be obtained from the
returned value of BSPFITN<!--hbox-->. A value of 609 implies that
RLM &gt; 0 but IDE is not 1 or 2.
In this case
no calculations are done. Other values may be set by BSPFIT, SVD or
BSPLIN<!--hbox-->. This function requires functions
<a href="appendixc.htm#bspfit"> BSPFIT</a>, <a href="appendixc.htm#bsplin"> BSPLIN</a>, <a href="appendixc.htm#bspevl"> BSPEVL</a>, <a href="appendixc.htm#bspevn"> BSPEVN</a>, <a href="appendixc.htm#svd"> SVD</a> and <a href="appendixc.htm#svdevl"> SVDEVL</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="bspfitwn"> </a>
 <b>127.&nbsp;BSPFITWN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspfitwn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bspfitn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate linear least squares
fit to B-spline basis functions in N dimensions.
It uses singular value decomposition (SVD) of the full set of
equations to obtain the fits
and also allows regularisation to be incorporated.
It incorporates unequal weights, but can require several orders of
magnitude larger time as compared to <a href="appendixc.htm#bspfitn"> BSPFITN</a> for the same size of
table. The memory required is also much larger.
Hence, it should be used only if BSPFITN is not suitable
because of highly varying weights.
N is the number of dimensions.
NK is an integer array of length N containing the number of tabular
points along each axis. 
X is an array of length  <span class="roman">LA</span>&times;<span class="roman">N</span>
containing the coordinates of tabular
points. X[J][I] is the Ith point along Jth axis.
F is an array of length <span class="roman">NK</span>[0]&times;<span class="roman">NK</span>[1]&times;&#8230;&times;<span class="roman">NK</span>[<span class="roman">N</span>&#8722;1], containing the function values.
F[i<sub>N&#8722;1</sub>]&#8230;[i<sub>1</sub>][i<sub>0</sub>] is the function value at (X[0][i<sub>0</sub>], X[1][i<sub>1</sub>],
&#8230;, X[N&#8722;1][i<sub>N&#8722;1</sub>]).
This is treated as an one-dimensional array and
hence its dimensions in the calling function must exactly match the
size in each dimension, e.g., the dimensions could be
F[NK[N&#8722;1]]&#8230;[NK[1]][NK[0]].
EF is an array of same size and shape as F, containing the estimated
errors in F<!--hbox-->.
K is the order of B-splines required, <span class="roman">K</span>=4 for cubic B-splines
and <span class="roman">K</span>=2 for linear B-splines, etc.
For simplicity, the order is assumed to be the same along each dimension.
A is an array of length

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">NK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">NK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span>&#8230;<span class="roman">NK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span>&times;(<span class="roman">MK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>)(<span class="roman">MK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>)&#8230;(<span class="roman">MK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.47)</td></tr></table>
</td></tr></table>


which will contain the matrix U from SVD of the design matrix.
If RLM &gt; 0 the required size will be <span class="roman">N</span><span class="roman">+</span><span class="roman">1</span> times larger.
LA is the second dimension of array X,  as declared in
the calling function. LA must be at least max(<span class="roman">NK</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>).
V is an array of length

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
[(<span class="roman">MK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>)(<span class="roman">MK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>)&#8230;(<span class="roman">MK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>)]<sup>2</sup>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.48)</td></tr></table>
</td></tr></table>


which will contain
the matrix V from SVD of the design matrix.
IV is the second dimension of XF in the calling function
(<span class="roman">IV</span> &#8805; max(<span class="roman">MK</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>)).
SIGMA is an array of length (<span class="roman">MK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)&#8230;(<span class="roman">MK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2), which will contain the
singular values of the design matrix.
C is an array of length <span class="roman">NK</span>[0]&times;<span class="roman">NK</span>[1]&times;&#8230;&times;<span class="roman">NK</span>[<span class="roman">N</span>&#8722;1], which will contain the
fitted coefficients. If RLM &gt; 0 this length must be <span class="roman">N</span><span class="roman">+</span><span class="roman">1</span>
times larger. Note that
although there are only (<span class="roman">MK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)&#8230;(<span class="roman">MK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) coefficients the
array must have a larger length, since the remaining elements
are used as scratch space.
This is treated as a one-dimensional array and
hence its dimensions in the calling function must exactly match the
size in each dimension, e.g., the dimensions could be
C[<span class="roman">NX</span>][<span class="roman">MK</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">2</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2] &#8230;[<span class="roman">MK</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2][<span class="roman">MK</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">+</span><span class="roman">K</span>&#8722;2].
Here the first dimension has to be increased suitably to accommodate the
scratch space required. The first dimension NX should be chosen such that
the total size is greater than the required value.
If this array is only passed on to <a href="appendixc.htm#bspevn"> BSPEVN</a> or equivalent functions to
calculate the function value at any required point, then the exact
dimensions in calling function are immaterial as long as the total length
is larger than the required value.
XF is an array of length <span class="roman">IV</span>&times;<span class="roman">N</span> containing the
knots required to define the B-spline basis functions in each dimension.
The knots must be distinct and in ascending order.
XF[J][I] is the Ith knot along Jth dimension.
MK is an integer array of length N containing the number of knots
for defining B-splines along each axis.
FY is an array of same size and shape as F which will
contain the fitted values of the function at the tabular points.
REPS is the required accuracy for the solution of equations. All singular
values less than REPS times the largest singular value will be set to zero
during solution. This parameter can be used to eliminate the linear
combinations of basis functions that contribute little to the fit.
RLM is the regularisation parameter &#955; for smoothing. If
&#955; &#8804; 0 no regularisation is applied, while for &#955; &gt; 0
regularisation is applied using either first or second derivative.
IDE is the integer parameter which specifies the order of derivative to be
used for regularisation. This is used only if &#955; &gt; 0, in which
case it must be either 1 or 2. For IDE=1 first derivative smoothing
is used, while for IDE=2 second derivative smoothing is applied.
The regularisation is applied at all tabular points, making the number
of equations <span class="roman">N</span><span class="roman">+</span><span class="roman">1</span> times larger.
CHISQ is the minimum value of &#967;<sup>2</sup> obtained using the fitted
coefficients.
Error status can be obtained from the
returned value of BSPFITWN<!--hbox-->. A value of 608 implies that
LA or IV are not
large enough to store the required quantities.
BSPFITWN=609 implies that RLM &gt; 0 but IDE is not 1 or 2.
In these cases
no calculations are done. Other values may be set by SVD or
BSPLIN<!--hbox-->. This function requires functions
<a href="appendixc.htm#bsplin"> BSPLIN</a>, <a href="appendixc.htm#bspevn"> BSPEVN</a>, <a href="appendixc.htm#svd"> SVD</a> and <a href="appendixc.htm#svdevl"> SVDEVL</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="linfitxy"> </a>
 <b>128.&nbsp;LINFITXY&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/linfitxy.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/linfitxy.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the least squares
straight line fit when there is error in both x and y values, using
the technique described in Section 10.2.4. For simplicity it is assumed
that all data points have the same errors and correlation. N is the number
of data points. X and Y are real arrays of length N, specifying the data
values. Fit of the form <span class="roman">Y</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>=a+b&times;<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> is to be calculated.
SIGX and SIGY are the estimated errors in X and Y values, while RHO is
the correlation between the errors in X and Y<!--hbox-->. XI and YI are the arrays
which will contain the fitted values of X and Y. Since both X and Y have
errors fitted values of both need to be calculated. A and B are the
fitted values of the intercept and slope, respectively. Thus
<span class="roman">YI</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>=<span class="roman">A</span>+<span class="roman">B</span>&times;<span class="roman">XI</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>. CHI is the value of
&#967;<sup>2</sup> at the fit as defined by Eq.&nbsp;(10.49). IER is the error
parameter. <span class="roman">IER</span>=617 implies that the discriminant of the quadratic
(10.59)
is negative and the calculations are aborted.

<div class="p"><!----></div>
 <br /><br /><a name="nllsq"> </a>
 <b>129.&nbsp;NLLSQ&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/nllsq.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/nllsq.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the &#967;<sup>2</sup> function for
a nonlinear least squares fit for use with function <a href="appendixc.htm#bfgs"> BFGS</a><!--hbox-->.
By suppressing the gradient calculations it can also be used with
function <a href="appendixc.htm#nminf"> NMINF</a><!--hbox-->. This is the function to be minimised by BFGS<!--hbox-->.
N is the number of parameters to be fitted, A is an array of
length N containing the values of the parameters at which the function
is required to be calculated. F is the calculated value of the function.
G is an array of length N, containing the calculated derivatives.
G[i] will contain [(&#8706;F)/(&#8706;a<sub>i</sub>)]. The data points
are passed through global variables NNLSQ, FXLSQ, XLSQ, EFLSQ, FX1LSQ,
which must be initialised in the
calling function before calling BFGS<!--hbox-->.
Here, XLSQ, FXLSQ, EFLSQ are arrays of length
NPL containing respectively, the values of abscissas, function values
and estimated errors in function values at each point. NNLSQ is the
number of data points in the table, <span class="roman">NNLSQ</span> &#8804; <span class="roman">NPL</span>.
FX1LSQ is an
array of length NP which will contain the fitted value of the
function at all points. Although EFLSQ[I] should contain the estimated
error in FXLSQ[I], in many cases it is found that multiplying all elements
of EFLSQ by suitable constant improves the convergence of BFGS significantly
without changing the minimum. Only the value of &#967;<sup>2</sup> will need to be
scaled suitably. This function needs FCN to calculate the function
value at any X for specified values of the parameters.  It may be
noted that there is no provision to pass on the name of a function
to this function and hence the name has to be explicitly changed
in the function.
Function FCN(N, A, X, F, DF) must be supplied by the user.
Here N is the number of parameters, A is an array of length
N containing the values of parameters. X specifies
the point where the function value needs to be calculated. F 
should contain the calculated function value
F(X, A), while DF is an array of length N containing the derivatives
of F<!--hbox-->. DF[I] should give [(&#8706;F)/(&#8706;A<sub>i</sub>)].
By suppressing the derivative calculations NLLSQ can also be used with
function NMINF<!--hbox-->. The corresponding version may be found in NLLSQ<tt>_</tt>F.

<div class="p"><!----></div>
 <br /><br /><a name="dft"> </a>
 <b>130.&nbsp;DFT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/dft.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fft.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the discrete Fourier transform (DFT)
using normal sum. This function is applicable to arbitrary number of
points, but it requires O(N<sup>2</sup>) arithmetic operations, and hence
should be used only when N is relatively small.
N is the number of data points.
CG is an array of length  2N,
which should contain the data
points. CF is an array of length 2N which will contain the
Fourier transform of CG<!--hbox-->.
Both CF and CG are complex and hence the arrays should contain the
real and imaginary parts stored consecutively.
IFLG is a flag, if IFLG &#8805; 0 the DFT is calculated, while if
IFLG &lt; 0 the inverse DFT will be calculated.
Error status can be obtained from the
returned value of DFT<!--hbox-->. A value of 611 implies that
<span class="roman">N</span> &lt; 2, in which case, no calculations are performed.
It may be noted that when inverse transform is calculated the
result will need to be divided by N to match the original data.
The function does not perform the division. It may be noted that
even while calculating the inverse transform the input should be provided
in array CG and calculated transform will be available in array CF.

<div class="p"><!----></div>
 <br /><br /><a name="fft"> </a>
 <b>131.&nbsp;FFT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/fft.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fft.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the discrete Fourier transform (DFT)
using a FFT algorithm. N is the number of data points which must be equal
to a power of 2. CG is an array of length  2N,
which should contain the data
points when calling the function. After execution, the DFT will be
overwritten on the same array CG<!--hbox-->. Hence, if necessary a copy of
the original
data should be preserved for later use before calling the function.
CG is complex and hence both real and imaginary parts must be stored
in the array in consecutive locations.
IFLG is a flag, if IFLG &#8805; 0 the DFT is calculated, while if
IFLG &lt; 0 the inverse DFT will be calculated.
Error status can be obtained from the
returned value of FFT<!--hbox-->. A value of 611 implies that
<span class="roman">N</span> &lt; 2, in which case, no calculations are performed.
DFT=631 implies that N is not a power of 2. This test is performed
towards the end of the calculation and hence in this case, the contents of array
CG will be destroyed.
It may be noted that when inverse transform is calculated the
result will need to be divided by N to match the original data.
The function does not perform the division.

<div class="p"><!----></div>
 <br /><br /><a name="fftr"> </a>
 <b>132.&nbsp;FFTR&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/fftr.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fftr.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the discrete Fourier transform (DFT)
of real data
using a FFT algorithm. N is the number of data points which must be equal
to a power of 2. CG is an array of length  2&times;(<span class="roman">N</span>/2),
which should contain the data points when calling the function. 
In the calling function it may be treated as a real array of length N
stored in normal order.
After execution, the DFT will be
overwritten on the same array CG as explained in Section&nbsp;10.6.  The DFT will be complex and it will contain the real and imaginary
parts stored in consecutive memory locations.
If necessary, another copy of the original
data should be preserved for later use before calling the function.
IFLG is a flag. If IFLG &#8805; 0 the DFT is calculated, while if
IFLG &lt; 0 the inverse DFT will be calculated.
Error status can be obtained from the
returned value of FFTR<!--hbox-->. A value of 611 implies that
<span class="roman">N</span>  &lt; 4 and no calculations are done.
FFTR=631 implies that N is not a power of 2.
Since this test is performed towards the end of calculations, the
contents of array CG will be destroyed.
It may be noted that when inverse transform is calculated the
result will need to be divided by N/2 to match the original data.
The function does not perform the division. This function
requires function <a href="appendixc.htm#fft"> FFT</a> for calculating the DFT of complex data and
function <a href="appendixc.htm#cdiv"> CDIV</a> to perform complex division.

<div class="p"><!----></div>
 <br /><br /><a name="fftn"> </a>
 <b>133.&nbsp;FFTN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/fftn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fftn.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the discrete Fourier transform (DFT)
in n&nbsp;dimensions using a FFT algorithm. ND is the number of dimensions.
NN is an integer array of length  ND<!--hbox-->.
NN[I] is the number of data points along the Ith coordinate,
which must be equal to a power of 2. CG is a complex array of length  
<span class="roman">NN</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>&times;<span class="roman">NN</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span>&times;&#8230;&times;<span class="roman">NN</span><span class="roman">[</span><span class="roman">ND</span>&#8722;<span class="roman">1</span><span class="roman">]</span>,
which should contain the data
points when calling the function. The data should be stored in the normal
Fortran order with

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">CG</span>[j<sub>0</sub>+j<sub>1</sub><span class="roman">NN</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>+j<sub>2</sub><span class="roman">NN</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span><span class="roman">NN</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span>+&#8230;+j<sub>ND&#8722;1</sub><span class="roman">NN</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>&#8230;<span class="roman">NN</span>[<span class="roman">ND</span>&#8722;2]] = g<sub>j<sub>0</sub>,j<sub>1</sub>,&#8230;,j<sub>ND&#8722;1</sub></sub>&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.49)</td></tr></table>
</td></tr></table>


for 0 &#8804; j<sub>r</sub> &lt; <span class="roman">NN</span>[r]&#8722;1 and 0 &#8804; r &lt; <span class="roman">ND</span>.
In fact, in the calling function CG can be treated as a
(<span class="roman">ND</span>+1)-dimensional
array with dimension CG[NN[ND&#8722;1]]&#8230;[NN[1]][NN[0]][2].
Both real and imaginary parts of data needs to be stored in consecutive
locations.
It may be noted that the dimensions of this ND-dimensional array must
be exactly equal to the number of data points in the corresponding variables.
After execution, the DFT will be
overwritten on the same array CG<!--hbox-->. Hence, if necessary a copy of original
data should be preserved for later use, before calling the function.
IFLG is a flag. If IFLG &#8805; 0 the DFT is calculated, while if
IFLG &lt; 0 the inverse DFT will be calculated.
Error status can be obtained from the
returned value of FFTN<!--hbox-->. A value of 631 implies that
at least one of the NN[I],
(<span class="roman">I</span>=0,1,&#8230;,<span class="roman">ND</span>&#8722;1) is not a power of 2.
Since this test is performed towards the end of calculations, the
contents of array CG will be destroyed.
It may be noted that when inverse transform is calculated the
result will need to be divided by
<span class="roman">NN</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>&times;<span class="roman">NN</span><span class="roman">[</span><span class="roman">1</span><span class="roman">]</span>&times;&#8230;&times;<span class="roman">NN</span><span class="roman">[</span><span class="roman">ND</span>&#8722;<span class="roman">1</span><span class="roman">]</span>
to match the original data.
The function does not perform the division.

<div class="p"><!----></div>
 <br /><br /><a name="lapinv"> </a>
 <b>134.&nbsp;LAPINV&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/lapinv.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/lapinv.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the inverse Laplace transform
of a given function F(s). N is the number of points at which the value of
the inverse function is required. T is an array of length 
N containing the points t<sub>i</sub>, at which the inverse transform is required.
The elements t<sub>i</sub> need not be in any order, but the last element <span class="roman">t</span><sub><span class="roman">N</span></sub>
should be the largest or close to the largest, since this element is
used to control the value of T<sub>0</sub> as explained in Section 10.8. F is an array of length  N, which will contain the value of
the required function at t<sub>i</sub> after execution of the function. CFS
is the name of the function routine used to calculate the function F(s).
ALPHA is an estimate for the exponential order of the function f(t) as
explained in Section 10.8. REPS is the convergence parameter. The results
are normally expected to have a relative accuracy of REPS<!--hbox-->. However,
as explained in the text, this is not guaranteed when the convergence
is slow. The results can be improved by either increasing the value
of the parameter NMAX in the function, or by removing the discontinuity
which is causing the slow convergence. The second alternative will be
more effective.
Error status can be obtained from the
returned value of LAPINV<!--hbox-->. A value of 61 implies that the
&#1013;-algorithm failed to converge for at least one of the points.
LAPINV=62 implies that the &#1013;-algorithm encountered a zero denominator
at some stage. Since only the last value will be retained, the error
flag may be misleading in those cases, where failure has occurred at more
than one points. Function CFS(CS,CF) must be supplied by the user. Here
both CS and CF are arrays of length 2 containing the real and imaginary
parts of the arguments. CF is f(CS).

<div class="p"><!----></div>
 <br /><br /><a name="pold"> </a>
 <b>135.&nbsp;POLD&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/pold.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/pold.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to evaluate a polynomial and its
derivatives at any point. N is the degree of polynomial. A is an
array of length <span class="roman">N</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial.
A[0] should contain the constant term and A[N] should be the
coefficient of <span class="roman">X</span><sup><span class="roman">N</span></sup>. X is the point at which polynomial
is to be evaluated. ND is the number of derivatives to be evaluated.
It would evaluate the first ND derivatives. The first derivative is
always evaluated, irrespective of the value of ND<!--hbox-->. PD is an array
of length ND, which will contain the computed values of the derivatives.
PD[I&#8722;1] will contain the Ith derivative of polynomial. The value of
polynomial is returned as POLD.

<div class="p"><!----></div>
 <br /><br /><a name="rmk"> </a>
 <b>136.&nbsp;RMK&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/rmk.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/rmk.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To evaluate a rational function at
any point. M is the degree of numerator, while K is the degree of
denominator. A is an
array of length <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial in
the numerator.
A[0] should contain the constant term and A[M] should be the
coefficient of <span class="roman">X</span><sup><span class="roman">M</span></sup>. B is an
array of length <span class="roman">K</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial in
the denominator.
B[0] should contain the constant term and B[K] should be the
coefficient of <span class="roman">X</span><sup><span class="roman">K</span></sup>.
X is the point at which the rational function is to be evaluated.
The value of rational function is returned as RMK.

<div class="p"><!----></div>
 <br /><br /><a name="rmk1"> </a>
 <b>137.&nbsp;RMK1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/rmk1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/rmk1.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To evaluate a rational function at
any point. This is the same as <a href="appendixc.htm#rmk"> RMK</a>, except that the constant term for
polynomial in the denominator is assumed to be one and hence is not
supplied.
M is the degree of numerator, while K is the degree of
denominator. A is an
array of length <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial in
the numerator.
A[0] should contain the constant term and A[M] should be the
coefficient of <span class="roman">X</span><sup><span class="roman">M</span></sup>. B is an
array of length K containing the coefficients of the polynomial in
the denominator.
B[I&#8722;1] should contain the coefficient of <span class="roman">X</span><sup><span class="roman">I</span></sup>.
X is the point at which the rational function is to be evaluated.
The value of rational function is returned as RMK1.

<div class="p"><!----></div>
 <br /><br /><a name="rmkd"> </a>
 <b>138.&nbsp;RMKD&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/rmkd.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/rmk.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To evaluate a rational function
and its first derivative at
any point. M is the degree of numerator, while K is the degree of
denominator. A is an
array of length <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial in
the numerator.
A[0] should contain the constant term and A[M] should be the
coefficient of <span class="roman">X</span><sup><span class="roman">M</span></sup>. B is an
array of length <span class="roman">K</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial in
the denominator.
B[0] should contain the constant term and B[K] should be the
coefficient of <span class="roman">X</span><sup><span class="roman">K</span></sup>.
X is the point at which the rational function is to be evaluated.
DF will contain the computed value of the derivative.
The value of rational function is returned as RMKD.

<div class="p"><!----></div>
 <br /><br /><a name="rmkd1"> </a>
 <b>139.&nbsp;RMKD1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/rmkd1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/rmk1.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To evaluate a rational function
and its first derivative at
any point. This is the same as <a href="appendixc.htm#rmkd"> RMKD</a>, except that the constant term for
polynomial in the denominator is assumed to be one and hence is not
supplied.
M is the degree of numerator, while K is the degree of
denominator. A is an
array of length <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial in
the numerator.
A[0] should contain the constant term and A[M] should be the
coefficient of <span class="roman">X</span><sup><span class="roman">M</span></sup>. B is an
array of length K containing the coefficients of the polynomial in
the denominator.
B[I&#8722;1] should contain the coefficient of <span class="roman">X</span><sup><span class="roman">I</span></sup>.
X is the point at which the rational function is to be evaluated.
DF will contain the computed value of the derivative.
The value of rational function is returned as RMKD1.

<div class="p"><!----></div>
 <br /><br /><a name="pade"> </a>
 <b>140.&nbsp;PADE&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/pade.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/pade.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the coefficients of Pad&#233;
approximation R<sub>mk</sub>(x) from the known coefficients of Maclaurin
series. M and K are the degrees of polynomials in the numerator and the
denominator, respectively. A is an array of length  
<span class="roman">M</span>+<span class="roman">K</span>+1, which will contain the coefficients of the Pad&#233;
approximation. <span class="roman">A</span>[i], (i=0,&#8230;,<span class="roman">K</span>&#8722;1) is the coefficient
of x<sup>i+1</sup> in the
denominator, the constant term being assumed to be unity, <span class="roman">A</span><span class="roman">[</span><span class="roman">K</span>+i],
(i=0,1,&#8230;,<span class="roman">M</span><span class="roman">)</span> is the coefficient of x<sup>i</sup> in the numerator, which
gives the Pad&#233; approximation

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
R<sub><span class="roman">MK</span></sub>(x)=</td><td nowrap="nowrap" align="center">
<span class="roman">A</span><span class="roman">[</span><span class="roman">K</span>]+<span class="roman">A</span><span class="roman">[</span><span class="roman">K</span>+1]x+<span class="roman">A</span><span class="roman">[</span><span class="roman">K</span>+2]x<sup>2</sup>+&#8230;+<span class="roman">A</span><span class="roman">[</span><span class="roman">K</span><span class="roman">+</span><span class="roman">M</span>]x<sup><span class="roman">M</span></sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>1+<span class="roman">A</span>[0]x+<span class="roman">A</span>[1]x<sup>2</sup>+&#8230;+<span class="roman">A</span><span class="roman">[</span><span class="roman">K</span>&#8722;<span class="roman">1</span><span class="roman">]</span>x<sup><span class="roman">K</span></sup><br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.50)</td></tr></table>
</td></tr></table>


C is an array of length  <span class="roman">M</span>+<span class="roman">K</span>+1 containing the
coefficients of the Maclaurin series for the required function.
<span class="roman">C</span>[i] should contain the coefficient of x<sup>i</sup> in the Maclaurin
series. These coefficients must be supplied by the user.
Error status can be obtained from the
returned value of PADE<!--hbox-->. A value of 612 implies that
either <span class="roman">M</span> &lt; 0 or <span class="roman">K</span> &lt; 0, in which case
no calculations are performed. Other values may be set by the function
GAUELM, which is called to solve the system of linear equations.
This function requires function <a href="appendixc.htm#gauelm"> GAUELM</a> to solve the system of linear
equations.

<div class="p"><!----></div>
 <br /><br /><a name="chebcf"> </a>
 <b>141.&nbsp;CHEBCF&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/chebcf.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/chebcf.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to convert a power series into a series of
Chebyshev polynomials and vice versa. N is the degree of polynomial.
C and P are arrays of length  <span class="roman">N</span>+2 containing 
respectively, the coefficients of the Chebyshev and the power series expansions.
<span class="roman">C</span>[i] is the coefficient of T<sub>i</sub>(x) in Chebyshev expansion, while
<span class="roman">P</span>[i] is the coefficient of x<sup>i</sup> in the power series. 
It should be noted that C[0] is the coefficient of T<sub>0</sub>(x) and is not doubled
as in the normal Chebyshev expansions. IFLG is the
flag which decides the type of conversion required. If IFLG=0,
then coefficients of Chebyshev expansion will be calculated. In
that case, the power series coefficients must be supplied. After 
execution, the array C will contain the coefficients of Chebyshev expansion,
while the array P is unaffected. If IFLG &#8800; 0, then the coefficients
of power series will be calculated. In that case, the coefficients of
Chebyshev expansion must be supplied and after execution, the array P
will contain the coefficients of power series, while the contents of C
will be destroyed, since this array is used as a scratch space by the function.
The returned value of the function is always zero.

<div class="p"><!----></div>
 <br /><br /><a name="chebex"> </a>
 <b>142.&nbsp;CHEBEX&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/chebex.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/chebex.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the coefficients of Chebyshev
expansion of a function that can be evaluated at any required point.
It uses orthogonality of Chebyshev polynomials over a set of discrete
points to find the coefficients and the value will only be approximately
correct.

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">FUN</span>(x)=</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
c<sub>0</sub>+</td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
c<sub>i</sub>T<sub>i</sub>(x).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.51)</td></tr></table>
</td></tr></table>


N is the number of coefficients
required. This number should be much larger than the actual number of
coefficients needed. The accuracy of computed coefficients increases
with N<!--hbox-->. There is no check to test the accuracy and it has to be
ascertained by recomputing the coefficients with larger N (say 2N)
and comparing the two values. C is an array of length N, which
will contain the computed coefficients. FUN is the name of the function
routine supplied to calculate the required function.
Error status can be obtained from the
returned value of CHEBEX<!--hbox-->. A value of 613 implies that
<span class="roman">N</span> &lt; 10, in which case no
calculations are done. Function FUN(X) must be supplied by the user.

<div class="p"><!----></div>
 <br /><br /><a name="chebap"> </a>
 <b>143.&nbsp;CHEBAP&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/chebap.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/chebap.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the coefficients of Rational function
Chebyshev
approximations T<sub>mk</sub>(x) from the known coefficients of expansion in
Chebyshev polynomials. It should be noted that, this function does not
generate minimax approximations, but if the coefficients of Chebyshev
expansion fall off rapidly, then the approximation will be close to
minimax. M and K are the degrees of polynomials in the numerator and the
denominator, respectively. A is an array of length  
<span class="roman">M</span>+<span class="roman">K</span>+1, which will contain the coefficients of the rational
function
approximation. <span class="roman">A</span>[i&#8722;1], (i=1,&#8230;,<span class="roman">K</span>) is the coefficient of 
T<sub>i</sub>(x) in the
denominator, the constant term being assumed to be unity, <span class="roman">A</span><span class="roman">[</span><span class="roman">K</span>+i],
(i=0,1,&#8230;,<span class="roman">M</span>) is the coefficient of T<sub>i</sub>(x) in the numerator, which
gives the  approximation

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
R<sub><span class="roman">MK</span></sub>(x)=</td><td nowrap="nowrap" align="center">
<span class="roman">A</span><span class="roman">[</span><span class="roman">K</span>]+<span class="roman">A</span><span class="roman">[</span><span class="roman">K</span>+1]T<sub>1</sub>(x)+<span class="roman">A</span><span class="roman">[</span><span class="roman">K</span>+2]T<sub>2</sub>(x)+&#8230;+<span class="roman">A</span><span class="roman">[</span><span class="roman">K</span><span class="roman">+</span><span class="roman">M</span>]T<sub><span class="roman">M</span></sub>(x)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>1+<span class="roman">A</span>[0]T<sub>1</sub>(x)+<span class="roman">A</span>[1]T<sub>2</sub>(x)+&#8230;+<span class="roman">A</span><span class="roman">[</span><span class="roman">K</span>&#8722;<span class="roman">1</span><span class="roman">]</span>T<sub><span class="roman">K</span></sub>(x)<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.52)</td></tr></table>
</td></tr></table>


C is an array of length  <span class="roman">M</span>+2<span class="roman">K</span>+1, containing
coefficients of the Chebyshev series for the required function.
<span class="roman">C</span>[i] should contain the coefficient of T<sub>i</sub>(x) in the Chebyshev
series. These coefficients must be supplied by the user. 
Following the usual convention of Chebyshev expansion, the coefficient
of T<sub>0</sub>(x) in the expansion is C[0]/2.
Error status can be obtained from the
returned value of CHEBAP<!--hbox-->. A value of 612 implies that
either <span class="roman">M</span> &lt; <span class="roman">0</span> or <span class="roman">K</span> &lt; 0, in which case,
no calculations are performed. Other values may be set by the function
GAUELM, which is called to solve the system of linear equations.
This function
requires function <a href="appendixc.htm#gauelm"> GAUELM</a> to solve the system of linear equations.

<div class="p"><!----></div>
 <br /><br /><a name="remes"> </a>
 <b>144.&nbsp;REMES&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/remes.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/remes.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the minimax rational function
approximation for a given function over a finite interval,
using the second algorithm of Remes.
M and K are the degrees of polynomials
in the numerator and the denominator, respectively. N is the number of points
which will be used for initial scan of extrema in the error curve. This
number should be at least 3(<span class="roman">M</span>+<span class="roman">K</span>+1), in order to be able to
isolate different extrema. XL and XU are respectively,
the lower and upper limits of the interval over which the approximation
is required. A is an array of length  <span class="roman">M</span>+<span class="roman">K</span>+2, which
will contain the coefficients in the same form as that given by the
function <a href="appendixc.htm#pade"> PADE</a><!--hbox-->. <span class="roman">A</span>[i&#8722;1], (i=1,2,&#8230;,<span class="roman">K</span>) is the coefficient
of x<sup>i</sup> in the denominator, the constant term being unity,
while <span class="roman">A</span><span class="roman">[</span><span class="roman">K</span>+i], (i=0,1,&#8230;,<span class="roman">M</span>)
is the coefficient of x<sup>i</sup> in the numerator.
If IFLG=0, then the initial guess for these coefficients
must be supplied.
X and F are arrays of length
N with F[I] containing the value of the function at X[I]. These
values need not be stored before calling the function, since the function
itself selects a uniform mesh and calculates the value of the function at the
required points. EX is an array of length  <span class="roman">M</span>+<span class="roman">K</span>+5
containing the extrema of the error curve. If IFLG=2, then the
initial guess for the extrema must be supplied, otherwise these values
are not required. In all cases, after execution, EX will contain
the extrema of the error curve for the final approximation. IE is the
number of extrema, which should be <span class="roman">M</span>+<span class="roman">K</span>+2, if the error curve
is of the standard form. Some types of nonstandard error curves can be handled
by this function (Example&nbsp;10.11). If IFLG=2, then the
value of IE must be supplied.
EMAX is the maximum error
in the final approximation calculated by the function. EPS is the
required tolerance. The iteration for calculating the coefficients of
rational function is continued until the maximum error differs by less
than EPS<!--hbox-->. The
Remes iteration is continued until the difference between different
extrema of error curve is less than 1% of the maximum error.
EPSM specifies the tolerance for finding the
extrema of the error curve. In general, it is found that a moderate
value for EPS and EPSM is enough to find approximations even to very
high accuracy.
IFLG is an integer parameter, which
specifies the nature of initial approximation for the Remes algorithm.
If IFLG=0, then the
iteration is started from a known initial approximation. In this case,
the coefficients of initial approximation must be supplied in the array
A<!--hbox-->. If IFLG=1, then no initial approximation is required and the
first iteration is performed by assuming that the extrema of error
curves are given by those of T<sub><span class="roman">M</span>+<span class="roman">K</span>+1</sub>(x). This is
the most useful case, if no approximation of the right form and with the
correct number of extrema is known. If IFLG=2, then iteration
is started with an initial approximation for the extrema of the error
curve. In this case, the approximate location of the extrema must be
supplied in the array EX and IE ( &#8805; <span class="roman">M</span>+<span class="roman">K</span>+2)
should be set equal to the number of extrema. If the error curve is expected to
be nonstandard, then it will be preferable to supply only <span class="roman">M</span>+<span class="roman">K</span>+2
extrema, where the error is expected to be the largest and is
alternating in sign.
Error status can be obtained from the
returned value of REMES<!--hbox-->. A value of 614 implies that
either <span class="roman">M</span> &lt; 0, or
<span class="roman">K</span> &lt; 0, or  XU &#8804; XL, or <span class="roman">M</span>+<span class="roman">K</span>+2 &gt; NMAXR,
in which case, no calculations are performed.
The last requirement arises because of the dimensions of global array AA,
which is used to transfer the coefficients to an
auxiliary function routine for finding extrema of the function.
REMES=632 implies that the Remes
iteration failed to converge to the specified accuracy in NIT (=30)
iterations. This failure could be due to roundoff error, or because the
starting values are not sufficiently close.
REMES=633 implies that at some stage the error curve does not
have the required number of extrema and hence the iteration cannot 
proceed further. This condition does not necessarily imply that the
error curve is nonstandard.
Apart from these, other
values may be set by the function BRENTM which is called to
find the extrema, or the function GAUELM which is called to solve
the system of linear equations.
This function requires the functions
<a href="appendixc.htm#brentm"> BRENTM</a>, <a href="appendixc.htm#gauelm"> GAUELM</a>, <a href="appendixc.htm#fm"> FM</a>, FUN and FUND<!--hbox-->.
Function FUN(X) calculates the required function, while Function FUND(X)
calculates the weight function.
REMES generates approximation of the form FUN(X) &#8776; FUND(X)R<sub><span class="roman">MK</span></sub>(X). If FUND(x)=1 and FUN(x)=f(x), then
the function will calculate minimax approximation to f(x) with respect to
the absolute error, while if FUND(x)=1/f(x) and FUN(x)=1,
then the approximation will be obtained with respect to the relative error,
provided f(x) &#8800; 0 throughout the required interval. It should be noted
that the names of the functions FUN and FUND are fixed and cannot
be changed. 
The functions FUN and FUND must be supplied
by the user. The global variables MM, KK, AA, SI are used to pass on parameters to
function FM(X), which calculates the function to be minimised. Here
AA is an array of length NMAXR which contains the
coefficients of rational function approximation. SI is a variable
which is set to positive value if minimum is to be found and to
negative value when maximum is to be found. While SI &gt; 10
implies that function value, FUN(X), is known and need not be calculated.
MM and KK are integer variables which are equal to M and K respectively.
The rational function approximation can be computed at any required value
of X, using function <a href="appendixc.htm#rmk1"> RMK1</a>(M, K, &amp;A[K], A, X).

<div class="p"><!----></div>
 <br /><br /><a name="fm"> </a>
 <b>145.&nbsp;FM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/fm.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/remes.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to be used with <a href="appendixc.htm#remes"> REMES</a><!--hbox-->. 
This function is called by <a href="appendixc.htm#brentm"> BRENTM</a> to locate the extrema of error curve.
It calculates the difference between the actual function and the rational
function approximation weighted by the required weight function. 
This difference is multiplied by SI which is set to a negative value
if we want to find a maxima. For initial scan <span class="roman">SI</span> &#8805; 10, in which
case, function value is not calculated, since it is already known.

<div class="p"><!----></div>
 <br /><br /><a name="gamma"> </a>
 <b>146.&nbsp;GAMMA&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gamma.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gamma.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Gamma function
for a real argument

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#915;(x)=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
t<sup>x&#8722;1</sup>e<sup>&#8722;t</sup>&nbsp;&nbsp;dt&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x &gt; 0).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.53)</td></tr></table>
</td></tr></table>


The computed value should generally have relative accuracy of 10<sup>&#8722;15</sup>.
The function first calculates the value of Gamma function at &#124;x&#124;. 
The values for negative argument are then calculated using

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#8722;x&#915;(&#8722;x)&#915;(x)=</td><td nowrap="nowrap" align="center">
&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>sin(&#960;x)<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.54)</td></tr></table>
</td></tr></table>


For x &gt; 1000 the Stirling's formula is used to calculate the function
value. For 8 &lt; x &#8804; 1000 a rational function approximation of
form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
log&#915;(x)=(x&#8722;</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
)logx &#8722; x +log(</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">2&#960;<br /></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
)+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
R<sub>mk</sub>(1/x<sup>2</sup>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.55)</td></tr></table>
</td></tr></table>


is used.
For 0 &lt; x &#8804; 8 the range is first translated to [2,3] using
&#915;(x+1)=x&#915;(x) and then a rational function approximation
over [2,3] is used to approximate the function value.
This function does not check for overflow or invalid arithmetic
operations. Since &#915;(x) increases very rapidly with x,
the function evaluation will lead to overflow for x larger than
approximately 170 on a 53 bit arithmetic. Similarly,
&#915;(x) diverges when x is a negative integer or zero.
If overflow is expected, then it may be better to use GAMMALN instead
which gives the logarithm of &#124;&#915;(x)&#124;.

<div class="p"><!----></div>
 <br /><br /><a name="gammaln"> </a>
 <b>147.&nbsp;GAMMALN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gammaln.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gamma.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the natural
logarithm of Gamma function for a real argument. It uses the same
approximations as those used by Function <a href="appendixc.htm#gamma"> GAMMA</a>, except that for large
arguments (&#124;x&#124; &gt; 8), it directly calculates the logarithm and hence
should not give overflow. It gives log(&#124;&#915;(X)&#124;) and hence
sign should be accounted separately.

<div class="p"><!----></div>
 <br /><br /><a name="erf"> </a>
 <b>148.&nbsp;ERF&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/erf.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/erf.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Error function

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">erf</span>(x)=</td><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">&#960;<br /></div>                                </td></tr></table></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>x</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
e<sup>&#8722;t<sup>2</sup></sup>&nbsp;&nbsp;dt&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.56)</td></tr></table>
</td></tr></table>


for a real argument. This function uses rational function approximations
of the form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
<span class="roman">erf</span>(x)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 &#8776; xR<sub>mk</sub>(x<sup>2</sup>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0 &#8804; x &lt;  2);</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
<span class="roman">erf</span>(x)</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1"> &#8776; 1&#8722;</td><td nowrap="nowrap" align="center">
e<sup>&#8722;x<sup>2</sup></sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
R&#8242;<sub>m&#8242;k&#8242;</sub>(</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2 &#8804; x &lt;  &#8734;).</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.57)</td></tr></table>


While for x &lt; 0 it uses <span class="roman">erf</span>(&#8722;x)=&#8722;<span class="roman">erf</span>(x) to evaluate
the function value. Each of the rational function approximation
has relative accuracy of better than 10<sup>&#8722;15</sup>. For large x the
value may be indistinguishable from 1.

<div class="p"><!----></div>
 <br /><br /><a name="erfc"> </a>
 <b>149.&nbsp;ERFC&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/erfc.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/erf.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the complementary
Error function

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">erfc</span>(x)=1&#8722;<span class="roman">erf</span>(x)=</td><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">&#960;<br /></div>                                </td></tr></table></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><br />
<small>x</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
e<sup>&#8722;t<sup>2</sup></sup>&nbsp;&nbsp;dt&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.58)</td></tr></table>
</td></tr></table>


for a real argument. This function uses the same approximations as
those used by ERF(X). The value should generally have relative
accuracy of 10<sup>&#8722;15</sup>.
For small arguments the value of function may
not be distinguishable from unity, while for large negative arguments
it may be indistinguishable from 2. 

<div class="p"><!----></div>
 <br /><br /><a name="bj0"> </a>
 <b>150.&nbsp;BJ0&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bj0.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Bessel function of
the first kind of order zero, J<sub>0</sub>(x) for a real argument.
For &#124;x&#124; &lt; 8 it uses a rational function approximation to
J<sub>0</sub>(x) &#8776; R<sub>mk</sub>(x<sup>2</sup>),
while for larger arguments it uses the asymptotic form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
J<sub>0</sub>(x)=</td><td align="left" class="cl">
<font size="+2">&nbsp;&nbsp;&#x239B;<br />&#8730;<br /></font></td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;x<br /></td></tr></table></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
P<sub>0</sub>(x)cos(x&#8722;</td><td nowrap="nowrap" align="center">
&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
)&#8722;Q<sub>0</sub>(x)sin(x&#8722;</td><td nowrap="nowrap" align="center">
&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
)</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.59)</td></tr></table>
</td></tr></table>


The functions P<sub>0</sub>(x) and Q<sub>0</sub>(x) are approximated by rational
function approximations of form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P<sub>0</sub>(x) &#8776; R<sub>mk</sub>(1/x<sup>2</sup>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q<sub>0</sub>(x) &#8776; </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
R<sub>m&#8242;k&#8242;</sub>(1/x<sup>2</sup>).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.60)</td></tr></table>
</td></tr></table>


All the rational function approximations have absolute accuracy of
better than 10<sup>&#8722;15</sup>, but the resulting function values may not
have the same relative accuracy at all points. Near the zeros of
J<sub>0</sub>(x) the relative accuracy would be lower. For large
arguments, &#124;x&#124; &gt; 8, where the asymptotic formula is used there
could be some cancellation between the two terms and consequent
loss of significant figures close to zeros of J<sub>0</sub>(x).

<div class="p"><!----></div>
 <br /><br /><a name="bj1"> </a>
 <b>151.&nbsp;BJ1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bj1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Bessel function of
the first kind of order one, J<sub>1</sub>(x) for a real argument.
For &#124;x&#124; &lt; 8 it uses a rational function approximation to
J<sub>1</sub>(x) &#8776; xR<sub>mk</sub>(x<sup>2</sup>),
while for larger arguments it uses the asymptotic form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
J<sub>1</sub>(x)=</td><td align="left" class="cl">
<font size="+2">&nbsp;&nbsp;&#x239B;<br />&#8730;<br /></font></td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;x<br /></td></tr></table></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
P<sub>1</sub>(x)cos(x&#8722;</td><td nowrap="nowrap" align="center">
3&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
)&#8722;Q<sub>1</sub>(x)sin(x&#8722;</td><td nowrap="nowrap" align="center">
3&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
)</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.61)</td></tr></table>
</td></tr></table>


The functions P<sub>1</sub>(x) and Q<sub>1</sub>(x) are approximated by rational
function approximations of form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P<sub>1</sub>(x) &#8776; R<sub>mk</sub>(1/x<sup>2</sup>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q<sub>1</sub>(x) &#8776; </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
R<sub>m&#8242;k&#8242;</sub>(1/x<sup>2</sup>).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.62)</td></tr></table>
</td></tr></table>


All the rational function approximations have absolute accuracy of
better than 10<sup>&#8722;15</sup>, but the resulting function values may not
have the same relative accuracy at all points. Near the zeros of
J<sub>1</sub>(x) the relative accuracy would be lower. For large
arguments, &#124;x&#124; &gt; 8, where the asymptotic formula is used there
could be some cancellation between the two terms and consequent
loss of significant figures close to zeros of J<sub>1</sub>(x).

<div class="p"><!----></div>
 <br /><br /><a name="bjn"> </a>
 <b>152.&nbsp;BJN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bjn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Bessel function of
the first kind of integral order, J<sub>n</sub>(x) for a real argument.
This function calculates J<sub>k</sub>(x) for k between 0 and n.
Since a recurrence relation is used to calculate these values, all
the values are returned. Here N is the maximum order of Bessel functions
required. For positive N, J<sub>k</sub>(x) with positive k=0,1,&#8230;,<span class="roman">N</span>
will be calculated. For negative N, J<sub>k</sub>(x) with negative
k=0,&#8722;1,&#8230;,&#8722;<span class="roman">N</span> are calculated. XB is the argument at which
the function values are required. BJ is an array which will
contain the computed values of the Bessel functions.
<span class="roman">BJ</span>[&#124;i&#124;]=J<sub>i</sub>(<span class="roman">XB</span>). Since this array is also used as
scratch space the length of the array must be at least,
&#124;<span class="roman">N</span>&#124;+16+max(25, 5&#8730;{&#124;N&#124;}). 
For &#124;<span class="roman">N</span>&#124; &lt; &#124;<span class="roman">XB</span>&#124; the recurrence relation is stable in forward
direction and hence it is used to calculate J<sub>k</sub>(x) in a straightforward
manner using the values of J<sub>0</sub>(x) and J<sub>1</sub>(x).
For smaller XB, the recurrence relation is unstable in forward direction
and hence is used in backward direction as explained in {2.38} In this case for some suitable n<sub>1</sub>, we start using J<sub>n<sub>1</sub></sub>=0 and
J<sub>n<sub>1</sub>&#8722;1</sub>=1 and calculate lower order functions using the recurrence
relation

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
J<sub>k&#8722;1</sub>(x)=</td><td nowrap="nowrap" align="center">
2k
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
J<sub>k</sub>(x)&#8722;J<sub>k+1</sub>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k=n<sub>1</sub>&#8722;1,&#8230;,2,1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.63)</td></tr></table>
</td></tr></table>


The normalisation is then found using the relation

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
J<sub>0</sub>(x)+2</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>k=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
J<sub>2k</sub>(x)=1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.64)</td></tr></table>
</td></tr></table>


Thus we can divide all values by the calculated sum to obtain the
correct values for J<sub>k</sub>(x).
To use this technique we need to select a suitably large value of
n<sub>1</sub> to start the recurrence relation. Accuracy of resulting
function values can be checked by comparing the value of J<sub>n+1</sub>(x)
without normalisation. The reciprocal of this value will give an estimate
of accuracy achieved by this process. Thus if the computed value of
J<sub>n+1</sub>(x) is not large enough an error message is printed out by the
routine. This should not normally happen, but in case for some
combination of N and XB, the chosen value of n<sub>1</sub> is not large
enough, the error message will be printed out. In such cases the
choice of N1 in the routine should be increased suitably.
In principle, this technique can be used for all values of x, but
n<sub>1</sub> has to be larger than x and hence for large x, we will need
lot of computation using this technique. Further, the use of the
recurrence relation in this form results in overflow even when the
required values are within the range of computer arithmetic. This
problem is more severe at low x, where the values can be easily
computed using the series expansion. Thus we use the series expansion
for x &#8804; 4 for computing J<sub>n</sub>(x) and J<sub>n&#8722;1</sub>(x). After that
the recurrence relation is used in backward direction to get other
values.  The overflow problem becomes very
acute when single precision arithmetic is used and it is not
recommended to use this routine in single precision.
The accuracy attained by this routine will depend on the values of
N and XB, but in general we expect accuracy of order of 10<sup>&#8722;15</sup>
which is the accuracy with which J<sub>0</sub>(x) and J<sub>1</sub>(x) are calculated.
This routine needs <a href="appendixc.htm#bj0"> BJ0</a> and <a href="appendixc.htm#bj1"> BJ1</a> to calculate J<sub>0</sub>(x) and J<sub>1</sub>(x).

<div class="p"><!----></div>
 <br /><br /><a name="by0"> </a>
 <b>153.&nbsp;BY0&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/by0.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Bessel function of
the second kind of order zero, Y<sub>0</sub>(x) for a real argument.
This function is not defined for x &#8804; 0, and the function simply
returns a value of zero without any warning or error flag.
User must ensure that x is positive.
For x &lt; 8 it uses a rational function approximation of the form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
Y<sub>0</sub>(x)=</td><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;<br /></td><td nowrap="nowrap" align="center">
{J<sub>0</sub>(x)(log(x/2)+&#947;)+x<sup>2</sup>R<sub>mk</sub>(x<sup>2</sup>)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.65)</td></tr></table>
</td></tr></table>


where &#947; is the Euler's constant.
J<sub>0</sub>(x) is computed using a rational function approximation.
For larger arguments the asymptotic form is used:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
Y<sub>0</sub>(x)=</td><td align="left" class="cl">
<font size="+2">&nbsp;&nbsp;&#x239B;<br />&#8730;<br /></font></td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;x<br /></td></tr></table></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
P<sub>0</sub>(x)sin(x&#8722;</td><td nowrap="nowrap" align="center">
&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
)+Q<sub>0</sub>(x)cos(x&#8722;</td><td nowrap="nowrap" align="center">
&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
)</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.66)</td></tr></table>
</td></tr></table>


The functions P<sub>0</sub>(x) and Q<sub>0</sub>(x) are approximated by rational
function approximations of form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P<sub>0</sub>(x) &#8776; R<sub>mk</sub>(1/x<sup>2</sup>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q<sub>0</sub>(x) &#8776; </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
R<sub>m&#8242;k&#8242;</sub>(1/x<sup>2</sup>).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.67)</td></tr></table>
</td></tr></table>


All the rational function approximations have absolute accuracy of
better than 10<sup>&#8722;15</sup>, but the resulting function values may not
have the same relative accuracy at all points. Near the zeros of
Y<sub>0</sub>(x) the relative accuracy would be lower. For large
arguments, x &gt; 8, where the asymptotic formula is used there
could be some cancellation between the two terms and consequent
loss of significant figures close to zeros of Y<sub>0</sub>(x).

<div class="p"><!----></div>
 <br /><br /><a name="bjy0"> </a>
 <b>154.&nbsp;BJY0&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bjy0.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Bessel function of
the first and second kind of order zero, J<sub>0</sub>(x),Y<sub>0</sub>(x) for a
real argument. Since computation of Y<sub>0</sub>(x) involves J<sub>0</sub>(x)
also, this function is provided to give both values together
and can be used if both functions are required.
The function of the second kind is not defined for x &#8804; 0,
and the function simply
returns a value of zero without any warning or error flag.
The value of J<sub>0</sub>(x) should be calculated even in this case.
User must ensure that x is positive if Y<sub>0</sub>(x) is also required.
For calculating J<sub>0</sub>(x) alone it will be more efficient to use <a href="appendixc.htm#bj0"> BJ0</a>.
This function is essentially same as <a href="appendixc.htm#by0"> BY0</a>, except that in this case
the function values have to appear as arguments while calling the
function. The function BY0 can also be modified to include BJ0
in its argument list, in which case it can return that value also.
In that case the line computing BJ0 should be uncommented.
Here XB is the argument at which the function values are
required. BJ0 and BY0 are the computed values of J<sub>0</sub>(<span class="roman">XB</span>) and
Y<sub>0</sub>(<span class="roman">XB</span>).

<div class="p"><!----></div>
 <br /><br /><a name="by1"> </a>
 <b>155.&nbsp;BY1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/by1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Bessel function of
the second kind of order one, Y<sub>1</sub>(x) for a real argument.
This function is not defined for x &#8804; 0, and the function simply
returns a value of zero without any warning or error flag.
User must ensure that x is positive.
For x &lt; 8 it uses a rational function approximation of the form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
Y<sub>1</sub>(x)=</td><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x23A7;<br />&#x23A8;<br />
&#x23A9;
</td><td nowrap="nowrap" align="center">
J<sub>1</sub>(x)(log(x/2)+&#947;)&#8722;</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
&#8722;xR<sub>mk</sub>(x<sup>2</sup>)</td><td align="left" class="cl">&#x23AB;<br />&#x23AC;<br />
&#x23AD;
</td><td nowrap="nowrap" align="center">
,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.68)</td></tr></table>
</td></tr></table>


where &#947; is the Euler's constant.
J<sub>1</sub>(x) is computed using a rational function approximation.
For larger arguments the asymptotic form is used:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
Y<sub>1</sub>(x)=</td><td align="left" class="cl">
<font size="+2">&nbsp;&nbsp;&#x239B;<br />&#8730;<br /></font></td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;x<br /></td></tr></table></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
P<sub>1</sub>(x)sin(x&#8722;</td><td nowrap="nowrap" align="center">
3&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
)+Q<sub>1</sub>(x)cos(x&#8722;</td><td nowrap="nowrap" align="center">
3&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
)</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.69)</td></tr></table>
</td></tr></table>


The functions P<sub>1</sub>(x) and Q<sub>1</sub>(x) are approximated by rational
function approximations of form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P<sub>1</sub>(x) &#8776; R<sub>mk</sub>(1/x<sup>2</sup>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q<sub>1</sub>(x) &#8776; </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
R<sub>m&#8242;k&#8242;</sub>(1/x<sup>2</sup>).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.70)</td></tr></table>
</td></tr></table>


All the rational function approximations have absolute accuracy of
better than 10<sup>&#8722;15</sup>, but the resulting function values may not
have the same relative accuracy at all points. Near the zeros of
Y<sub>1</sub>(x) the relative accuracy would be lower. For large
arguments, x &gt; 8, where the asymptotic formula is used there
could be some cancellation between the two terms and consequent
loss of significant figures close to zeros of Y<sub>1</sub>(x).

<div class="p"><!----></div>
 <br /><br /><a name="bjy1"> </a>
 <b>156.&nbsp;BJY1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bjy1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Bessel function of
the first and second kind of order one, J<sub>1</sub>(x),Y<sub>1</sub>(x) for a
real argument. Since computation of Y<sub>1</sub>(x) involves J<sub>1</sub>(x)
also, this function is provided to give both values together
and can be used if both functions are required.
The function of the second kind is not defined for x &#8804; 0,
and the function simply
returns a value of zero without any warning or error flag.
The value of J<sub>1</sub>(x) should be calculated even in this case.
User must ensure that x is positive if Y<sub>1</sub>(x) is also required.
For calculating J<sub>1</sub>(x) alone it will be more efficient to use <a href="appendixc.htm#bj1"> BJ1</a>.
This function is essentially same as <a href="appendixc.htm#by1"> BY1</a>, except that in this case
the function values have to appear as arguments while calling the
function. The function BY1 can also be modified to include BJ1
in its argument list, in which case it can return that value also.
In that case the line computing BJ1 should be uncommented.
Here XB is the argument at which the function values are
required. BJ1 and BY1 are the computed values of J<sub>1</sub>(<span class="roman">XB</span>) and
Y<sub>1</sub>(<span class="roman">XB</span>).

<div class="p"><!----></div>
 <br /><br /><a name="byn"> </a>
 <b>157.&nbsp;BYN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/byn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Bessel function of
the second kind of integral order, Y<sub>n</sub>(x) for a real argument.
This function calculates Y<sub>k</sub>(x) for k between 0 and n.
This function is not defined for x &#8804; 0, and the function 
does not calculate the value and does not give any warning or error
flag.
In this case values in array BY will be preserved and may
be misinterpreted as calculated value.
User must ensure that x is positive.
Since a recurrence relation is used to calculate these values, all
the values are returned. Here N is the maximum order of Bessel functions
required. For positive N, Y<sub>k</sub>(x) with positive k=0,1,&#8230;,<span class="roman">N</span>
will be calculated. For negative N, Y<sub>k</sub>(x) with negative
k=0,&#8722;1,&#8230;,&#8722;<span class="roman">N</span> are calculated. XB is the argument at which
the function values are required. BY is an array of length
&#124;<span class="roman">N</span>&#124;+1 which will
contain the computed values of the Bessel functions.
<span class="roman">BY</span>[&#124;i&#124;]=Y<sub>i</sub>(<span class="roman">XB</span>). 
Since the recurrence relation for Y<sub>n</sub>(x)

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
Y<sub>n+1</sub>(x)=</td><td nowrap="nowrap" align="center">
2n
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
Y<sub>n</sub>(x)&#8722;Y<sub>n&#8722;1</sub>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.71)</td></tr></table>
</td></tr></table>


is stable in the forward
direction for all x, these values are computed in a straightforward
manner using the values of Y<sub>0</sub>(x) and Y<sub>1</sub>(x).
This function needs <a href="appendixc.htm#by0"> BY0</a> and <a href="appendixc.htm#by1"> BY1</a> to calculate Y<sub>0</sub>(x) and Y<sub>1</sub>(x).

<div class="p"><!----></div>
 <br /><br /><a name="sphbjn"> </a>
 <b>158.&nbsp;SPHBJN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/sphbjn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the spherical Bessel function
of integral order,

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
j<sub>n</sub>(x)=</td><td align="left" class="cl">
<font size="+2">&nbsp;&nbsp;&#x239B;<br />&#8730;<br /></font></td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2x<br /></td></tr></table></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
J<sub>n+1/2</sub>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.72)</td></tr></table>
</td></tr></table>


for a real argument.
This function calculates j<sub>k</sub>(x) for k between 0 and n.
Since a recurrence relation is used to calculate these values, all
the values are returned. Here N is the maximum order of Bessel functions
required. For positive N, j<sub>k</sub>(x) with positive k=0,1,&#8230;,<span class="roman">N</span>
will be calculated. For negative N, j<sub>k</sub>(x) with negative
k=0,&#8722;1,&#8230;,&#8722;<span class="roman">N</span> are calculated. XB is the argument at which
the function values are required. BJ is an array which will
contain the computed values of the Bessel functions.
<span class="roman">BJ</span>[&#124;i&#124;]=j<sub>i</sub>(<span class="roman">XB</span>). Since this array is also used as
scratch space the length of the array must be at least,
&#124;<span class="roman">N</span>&#124;+16+max(25, 5&#8730;{&#124;N&#124;}). 
For &#124;<span class="roman">N</span>&#124; &lt; &#124;<span class="roman">XB</span>&#124; or for <span class="roman">N</span> &lt; 0 the recurrence relation
is stable in forward
direction and hence it is used to calculate j<sub>k</sub>(x) in a straightforward
manner using the values of

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
j<sub>0</sub>(x)=</td><td nowrap="nowrap" align="center">
sinx
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j<sub>1</sub>(x)=</td><td nowrap="nowrap" align="center">
sinx
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
&#8722;</td><td nowrap="nowrap" align="center">
cosx
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="roman">or</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j<sub>&#8722;1</sub>(x)=</td><td nowrap="nowrap" align="center">
cosx
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.73)</td></tr></table>
</td></tr></table>


For smaller XB and <span class="roman">N</span> &gt; 0, the recurrence is unstable
in forward direction
and hence is used in backward direction as explained in {2.38} In this case for some suitable n<sub>1</sub>, we start using j<sub>n<sub>1</sub></sub>=0 and
j<sub>n<sub>1</sub>&#8722;1</sub>=1 and calculate lower order functions using the recurrence
relation

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
j<sub>k&#8722;1</sub>(x)=</td><td nowrap="nowrap" align="center">
2k+1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
j<sub>k</sub>(x)&#8722;j<sub>k+1</sub>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k=n<sub>1</sub>&#8722;1,&#8230;,2,1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.74)</td></tr></table>
</td></tr></table>


The normalisation is then found using the value of j<sub>0</sub>(x).
Thus we can divide all values by the calculated ratio S of 
j<sub>0</sub>(x) as computed from recurrence relation to its actual value,
to obtain the correct values for j<sub>k</sub>(x).
To use this technique we need to select a suitably large value of
n<sub>1</sub> to start the recurrence relation. Accuracy of resulting
function values can be checked by comparing the value of j<sub>n+1</sub>(x)
before normalisation.  Its reciprocal will give an estimate
of accuracy achieved by this process. Thus if the computed value of
j<sub>n+1</sub>(x) is not large enough an error message is printed out by the
routine. This should not normally happen, but in case for some
combination of N and XB, the chosen value of n<sub>1</sub> is not large
enough, the error message will be printed out. In such cases the
choice of N1 in the routine should be increased suitably.
In principle, this technique can be used for all values of x, but
n<sub>1</sub> has to be larger than x and hence for large x, we will need
lot of computation using this technique. Further, the use of the
recurrence relation in this form results in overflow even when the
required values are within the range of computer arithmetic. This
problem is more severe at low x, where the values can be easily
computed using the series expansion. Thus we use the series expansion
for x &#8804; 4 for computing j<sub>n</sub>(x) and j<sub>n&#8722;1</sub>(x). After that
the recurrence relation is used in backward direction to get other
values. The overflow problem becomes very
acute when single precision arithmetic is used and it is not
recommended to use this routine in single precision.
The accuracy attained by this routine will depend on the arithmetic
used. In general, we expect to achieve accuracy of order of &#295;
in these computations, since j<sub>0</sub>(x) and j<sub>1</sub>(x) can be expressed
in terms of trigonometric functions.

<div class="p"><!----></div>
 <br /><br /><a name="bi0"> </a>
 <b>159.&nbsp;BI0&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bi0.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the modified Bessel function of
the first kind of order zero, I<sub>0</sub>(x) for a real argument.
For &#124;x&#124; &lt; 8 it uses a rational function approximation to
I<sub>0</sub>(x) &#8776; R<sub>mk</sub>(x<sup>2</sup>),
while for larger arguments it uses the asymptotic form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
I<sub>0</sub>(x)=</td><td nowrap="nowrap" align="center">
e<sup>&#124;x&#124;</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">&#124;x&#124;<br /></div>                                </td></tr></table></td><td nowrap="nowrap" align="center">
R<sub>mk</sub>(1/&#124;x&#124;).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.75)</td></tr></table>
</td></tr></table>


All the rational function approximations have absolute accuracy of
better than 10<sup>&#8722;15</sup>, but the resulting function values may not
have the same relative accuracy at all points.

<div class="p"><!----></div>
 <br /><br /><a name="bi1"> </a>
 <b>160.&nbsp;BI1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bi1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the modified Bessel function of
the first kind of order one, I<sub>1</sub>(x) for a real argument.
For &#124;x&#124; &lt; 8 it uses a rational function approximation to
I<sub>1</sub>(x) &#8776; xR<sub>mk</sub>(x<sup>2</sup>),
while for larger arguments it uses the asymptotic form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
I<sub>1</sub>(x)=</td><td nowrap="nowrap" align="center">
e<sup>&#124;x&#124;</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">&#124;x&#124;<br /></div>                                </td></tr></table></td><td nowrap="nowrap" align="center">
R<sub>mk</sub>(1/&#124;x&#124;).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.76)</td></tr></table>
</td></tr></table>


All the rational function approximations have absolute accuracy of
better than 10<sup>&#8722;15</sup>, but the resulting function values may not
have the same relative accuracy at all points.

<div class="p"><!----></div>
 <br /><br /><a name="bin"> </a>
 <b>161.&nbsp;BIN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bin.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the modified Bessel function of
the first kind of positive integral order, I<sub>n</sub>(x) for a real argument.
This function calculates I<sub>k</sub>(x) for k between 0 and n.
Since a recurrence relation is used to calculate these values, all
the values are returned. Here N is the maximum order of Bessel functions
required, I<sub>k</sub>(x) with k=0,1,&#8230;,<span class="roman">N</span>
will be calculated. N must be positive, otherwise &#124;<span class="roman">N</span>&#124; will be used.
XB is the argument at which
the function values are required. BI is an array which will
contain the computed values of the Bessel functions.
<span class="roman">BI</span>[i]=I<sub>i</sub>(<span class="roman">XB</span>). Since this array is also used as
scratch space the length of the array must be at least,
<span class="roman">N</span>+16+max(25, 5&#8730;N). 
For <span class="roman">N</span> &lt; <span class="roman">XB</span>&#8722;10 the recurrence relation is stable in forward
direction and hence it is used to calculate I<sub>k</sub>(x) in a straightforward
manner using the values of I<sub>0</sub>(x) and I<sub>1</sub>(x).
For smaller XB, the recurrence is unstable in forward direction
and hence is used in backward direction as explained in {2.38} In this case for some suitable n<sub>1</sub>, we start using I<sub>n<sub>1</sub></sub>=0 and
I<sub>n<sub>1</sub>&#8722;1</sub>=1 and calculate lower order functions using the recurrence
relation

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
I<sub>k&#8722;1</sub>(x)=</td><td nowrap="nowrap" align="center">
2k
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
I<sub>k</sub>(x)+I<sub>k+1</sub>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k=n<sub>1</sub>&#8722;1,&#8230;,2,1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.77)</td></tr></table>
</td></tr></table>


The normalisation is then found using the directly computed value
of I<sub>0</sub>(x).
Thus we can divide all values by the calculated ratio for I<sub>0</sub>(x)
to obtain the correct values for I<sub>k</sub>(x).
To use this technique we need to select a suitably large value of
n<sub>1</sub> to start the recurrence relation. Accuracy of resulting
function values can be checked by comparing the value of I<sub>n+1</sub>(x)
before normalisation. Its reciprocal will give an estimate
of accuracy achieved by this process. Thus if the computed value of
I<sub>n+1</sub>(x) is not large enough an error message is printed out by the
routine. This should not normally happen, but in case for some
combination of N and XB, the chosen value of n<sub>1</sub> is not large
enough, the error message will be printed out. In such cases the
choice of N1 in the routine should be increased suitably.
In principle, this technique can be used for all values of x, but
n<sub>1</sub> has to be larger than x and hence for large x, we will need
lot of computation using this technique. Further, the use of the
recurrence relation in this form results in overflow even when the
required values are within the range of computer arithmetic. This
problem is more severe at low x, where the values can be easily
computed using the series expansion. Thus we use the series expansion
for x &#8804; 4 for computing I<sub>n</sub>(x) and I<sub>n&#8722;1</sub>(x). After that
the recurrence relation is used in backward direction to get other
values. The overflow problem becomes very
acute when single precision arithmetic is used and it is not
recommended to use this routine in single precision.
The accuracy attained by this routine will depend on the values of
N and XB, but in general, we expect accuracy of order of 10<sup>&#8722;15</sup>
which is the accuracy with which I<sub>0</sub>(x) and I<sub>1</sub>(x) are calculated.
This routine needs <a href="appendixc.htm#bi0"> BI0</a> and <a href="appendixc.htm#bi1"> BI1</a> to calculate I<sub>0</sub>(x) and I<sub>1</sub>(x).

<div class="p"><!----></div>
 <br /><br /><a name="bk0"> </a>
 <b>162.&nbsp;BK0&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bk0.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the modified Bessel function of
the second kind of order zero, K<sub>0</sub>(x) for a real argument.
This function is not defined for x &#8804; 0, and the function simply
returns a value of zero without any warning or error flag.
User must ensure that x is positive.
For x &lt; 8 it uses a rational function approximation of the form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
K<sub>0</sub>(x)=&#8722;I<sub>0</sub>(x)(&#947;+log(x/2))+x<sup>2</sup>R<sub>mk</sub>(x<sup>2</sup>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.78)</td></tr></table>
</td></tr></table>


where &#947; is the Euler's constant and I<sub>0</sub>(x) is computed
using appropriate rational function approximation.
For larger arguments the asymptotic form is used:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
K<sub>0</sub>(x)=</td><td nowrap="nowrap" align="center">
e<sup>&#8722;x</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8730;x<br /></td><td nowrap="nowrap" align="center">
R<sub>mk</sub>(1/x).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.79)</td></tr></table>
</td></tr></table>


All the rational function approximations have absolute accuracy of
better than 10<sup>&#8722;15</sup>, but the resulting function values may not
have the same relative accuracy at all points when different terms
are combined.

<div class="p"><!----></div>
 <br /><br /><a name="bk1"> </a>
 <b>163.&nbsp;BK1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bk1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the modified Bessel function of
the second kind of order one, K<sub>1</sub>(x) for a real argument.
This function is not defined for x &#8804; 0, and the function simply
returns a value of zero without any warning or error flag.
User must ensure that x is positive.
For x &lt; 8 it uses a rational function approximation of the form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
K<sub>1</sub>(x)=I<sub>1</sub>(x)(&#947;+log(x/2))+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
&#8722;xR<sub>mk</sub>(x<sup>2</sup>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.80)</td></tr></table>
</td></tr></table>


where &#947; is the Euler's constant and I<sub>1</sub>(x) is computed
using appropriate rational function approximation.
For larger arguments the asymptotic form is used:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
K<sub>1</sub>(x)=</td><td nowrap="nowrap" align="center">
e<sup>&#8722;x</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8730;x<br /></td><td nowrap="nowrap" align="center">
R<sub>mk</sub>(1/x).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.81)</td></tr></table>
</td></tr></table>


All the rational function approximations have absolute accuracy of
better than 10<sup>&#8722;15</sup>, but the resulting function values may not
have the same relative accuracy at all points when different terms
are combined.

<div class="p"><!----></div>
 <br /><br /><a name="bkn"> </a>
 <b>164.&nbsp;BKN&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bkn.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bessel.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the modified Bessel function of
the second kind of positive integral order, K<sub>n</sub>(x) for a real argument.
This function calculates K<sub>j</sub>(x) for j between 0 and n.
This function is not defined for x &#8804; 0, and no calculations are done
but no warning is issued.
In this case values in array BK will be preserved and may
be misinterpreted as calculated value.
User must ensure that x is positive.
Since a recurrence relation is used to calculate these values, all
the values are returned. Here N is the maximum order of Bessel functions
required, K<sub>j</sub>(x) with j=0,1,&#8230;,<span class="roman">N</span>
will be calculated. N must be positive, otherwise &#124;<span class="roman">N</span>&#124; will be used.
X is the argument at which
the function values are required. BK is an array of length
<span class="roman">N</span>+1 which will
contain the computed values of the Bessel functions.
<span class="roman">BK</span>[i]=K<sub>i</sub>(<span class="roman">XB</span>). 
Since the recurrence relation is stable in forward direction for all
x, it is used in a straightforward
manner using the values of K<sub>0</sub>(x) and K<sub>1</sub>(x).
This function needs <a href="appendixc.htm#bk0"> BK0</a> and <a href="appendixc.htm#bk1"> BK1</a> to calculate K<sub>0</sub>(x) and K<sub>1</sub>(x).

<div class="p"><!----></div>
 <br /><br /><a name="dawson"> </a>
 <b>165.&nbsp;DAWSON&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/dawson.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/dawson.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Dawson's integral

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
D(x)=e<sup>&#8722;x<sup>2</sup></sup></td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>x</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
e<sup>t<sup>2</sup></sup>&nbsp;&nbsp;dt&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.82)</td></tr></table>
</td></tr></table>


using rational function approximation. The range is split into 4 parts.
In [0,2.5), [2.5,4.0), [4.0,5.5) approximation of the form
D(x)=xR<sub>mk</sub>(x<sup>2</sup>) is used while for higher values an approximation
of the form D(x)=(1/x)R<sub>mk</sub>(1/x<sup>2</sup>) is used. All approximations
have a relative accuracy of 10<sup>&#8722;15</sup>.

<div class="p"><!----></div>
 <br /><br /><a name="fermm05"> </a>
 <b>166.&nbsp;FERMM05&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/fermm05.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fermi.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Fermi integrals

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
F<sub>k</sub>(x)=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
t<sup>k</sup>&nbsp;&nbsp;dt
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>e<sup>t&#8722;x</sup>+1<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.83)</td></tr></table>
</td></tr></table>


for k=&#8722;1/2 using rational function approximations. The range is split
into 3 parts. For x &lt; 2 (including all negative values) an approximation
of the form F<sub>k</sub>(x)=e<sup>x</sup>R<sub>mk</sub>(e<sup>x</sup>) is used. For 2 &#8804; x &lt; 10 an
approximation of form F<sub>k</sub>(x)=R<sub>mk</sub>(x) is used, while for higher values
of x an approximation of the form F<sub>k</sub>(x)=x<sup>k+1</sup>R<sub>mk</sub>(1/x<sup>2</sup>) is
used. All the approximations have a relative accuracy of approximately
10<sup>&#8722;15</sup>.

<div class="p"><!----></div>
 <br /><br /><a name="ferm05"> </a>
 <b>167.&nbsp;FERM05&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/ferm05.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fermi.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Fermi integrals
for k=1/2 using approximations similar to those for k=&#8722;1/2.

<div class="p"><!----></div>
 <br /><br /><a name="ferm15"> </a>
 <b>168.&nbsp;FERM15&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/ferm15.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fermi.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Fermi integrals
for k=3/2 using approximations similar to those for k=&#8722;1/2.

<div class="p"><!----></div>
 <br /><br /><a name="ferm25"> </a>
 <b>169.&nbsp;FERM25&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/ferm25.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fermi.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Fermi integrals
for k=5/2 using approximations similar to those for k=&#8722;1/2.

<div class="p"><!----></div>
 <br /><br /><a name="pleg"> </a>
 <b>170.&nbsp;PLEG&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/pleg.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/plm.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate Legendre polynomial for a
specified value of x. L is the order of polynomial and X is the
argument at which the polynomial value is required. P is an
array of length <span class="roman">L</span><span class="roman">+</span><span class="roman">1</span>, which will contain the computed values of
the Legendre polynomials for all orders up to L,
<span class="roman">P</span>[j]=P<sub>j</sub>(X). The recurrence relation is used to compute
the values.

<div class="p"><!----></div>
 <br /><br /><a name="plm"> </a>
 <b>171.&nbsp;PLM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/plm.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/plm.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate associated Legendre functions,
P<sub>l</sub><sup>m</sup>(x) for a
specified value of x. L, M define the order of Legendre functions,
<span class="roman">L</span> &gt; 0 and &#124;<span class="roman">M</span>&#124; &#8804; <span class="roman">L</span>.
No error message is issued if L, M do not satisfy these constraints.
X is the
argument at which the function value is required. P is an
array of length <span class="roman">L</span><span class="roman">+</span><span class="roman">1</span>, which will contain the computed values of
the associated Legendre functions.
<span class="roman">P</span>[j]=P<sub>j</sub><sup><span class="roman">M</span></sup>(X) for j &#8805; <span class="roman">M</span>.
The function first computes the value of P<sub><span class="roman">M</span></sub><sup><span class="roman">M</span></sup>.
For positive m,

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P<sub>m</sub><sup>m</sup>=</td><td nowrap="nowrap" align="center">
<small>m</small><!--sup
--><br /><font size="+3">&#8719;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
(2i&#8722;1) (1&#8722;x<sup>2</sup>)<sup>m/2</sup>.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.84)</td></tr></table>
</td></tr></table>


For negative m there is extra normalisation factor.
Using this value the recurrence relation

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
(n&#8722;m)P<sub>n</sub><sup>m</sup>(x)=(2n&#8722;1)xP<sub>n&#8722;1</sub><sup>m</sup>(x)&#8722;(n&#8722;1+m)P<sub>n&#8722;2</sub><sup>m</sup>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.85)</td></tr></table>
</td></tr></table>


is used to compute the value of P<sub><span class="roman">L</span></sub><sup><span class="roman">M</span></sup>.

<div class="p"><!----></div>
 <br /><br /><a name="ylm"> </a>
 <b>172.&nbsp;YLM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/ylm.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/ylm.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the Spherical harmonic,

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
Y<sub>l</sub><sup>m</sup>(&#952;,&#981;)=(&#8722;1)<sup>m</sup>c<sub>lm</sub>P<sub>l</sub><sup>m</sup>(cos&#952;)e<sup>im&#981;</sup>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.86)</td></tr></table>
</td></tr></table>


where

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
c<sub>lm</sub><sup>2</sup>=</td><td nowrap="nowrap" align="center">
(2l+1)(l&#8722;m)!
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4&#960;(l+m)!<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.87)</td></tr></table>
</td></tr></table>


is chosen to ensure that integral of &#124;Y<sub>l</sub><sup>m</sup>&#124;<sup>2</sup> over the unit
sphere is 1. L is the degree, M is the azimuthal order. <span class="roman">L</span> &gt; 0,
&#124;<span class="roman">M</span>&#124; &#8804; <span class="roman">L</span>.  THETA
and PHI are real variables specifying the angular coordinates
&#952; and &#981;  respectively.
Y is an array of length 2 containing the real and imaginary
parts of spherical harmonic.
It is possible to use the argument x=cos&#952; instead of &#952;.
This function requires <a href="appendixc.htm#plm"> PLM</a> to compute the associated Legendre functions.
YLM<tt>_</tt>X is the version of YLM with x=cos&#952; as the argument.

<div class="p"><!----></div>
 <br /><br /><a name="minmax"> </a>
 <b>173.&nbsp;MINMAX&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/minmax.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/minmax.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate minimax rational function approximation
of discrete data using a differential correction algorithm.
M and K are the degrees of polynomials
in the numerator and the denominator, respectively. N is the number of data
points which should be at least <span class="roman">M</span>+<span class="roman">K</span>+2.
A is an array of length  <span class="roman">M</span>+<span class="roman">K</span>+2, which
will contain the coefficients in the same form as that given by the
function <a href="appendixc.htm#pade"> PADE</a><!--hbox-->. <span class="roman">A</span>[i&#8722;1], (i=1,2,&#8230;,<span class="roman">K</span>) is the coefficient
of x<sup>i</sup> in the denominator, the constant term being unity,
while <span class="roman">A</span><span class="roman">[</span><span class="roman">K</span>+i], (i=0,1,&#8230;,<span class="roman">M</span>)
is the coefficient of x<sup>i</sup> in the numerator. At the time of calling the
function, this array should contain the initial approximation for the
coefficients. If <span class="roman">K</span>=0, then the algorithm will converge from
arbitrary initial approximation and hence all elements of A may be
set to zero or any other suitable value. For <span class="roman">K</span> &#8800; 0 the
iteration is unlikely to converge, unless the starting values
are close to the actual values of the coefficients.
X and F are arrays of length N, containing the input data,
with F[I] giving the value of the function at X[I]. These
values must be supplied. EMAX is the maximum error
in the final approximation calculated by the function. EPS is the
required tolerance, the iteration is continued until the change in EMAX
is less than EPS<!--hbox-->. 
Error status can be obtained from the
returned value of MINMAX<!--hbox-->. A value of 615 implies that
either <span class="roman">M</span> &lt; 0, or
<span class="roman">K</span> &lt; 0, or <span class="roman">M</span>+<span class="roman">K</span>+2 &gt; <span class="roman">N</span>, in which case, no calculations are
performed.
MINMAX=634 implies that the iteration failed to converge
to the specified accuracy. Other values may be set by the function
SIMPX<!--hbox-->. 
This function
requires the function <a href="appendixc.htm#simpx"> SIMPX</a> to solve the LP problem.

<div class="p"><!----></div>
 <br /><br /><a name="polyl1"> </a>
 <b>174.&nbsp;POLYL1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/polyl1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polyl1.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate polynomial L<sub>1</sub>-approximation
of discrete data. M is the degree of polynomial. N is the number of data
points, which should be at least <span class="roman">M</span>+2.
A is an array of length  <span class="roman">M</span>+2, which
will contain the coefficients. <span class="roman">A</span>[i],
(i=0,1,2,&#8230;,<span class="roman">M</span>) is the coefficient of x<sup>i</sup>.
X and F are arrays of length N, containing the input data,
with F[I] containing the value of the function at X[I]. These
values must be supplied by the user. ESUM is the sum of the magnitude of the error
at all points (i.e., the L<sub>1</sub> norm of the residual)
in the final approximation calculated by the function. EPS is the
expected level of roundoff error, this parameter is passed on to the
function SIMPL1 for simplex iteration. It is used to decide the sign
of cost coefficients and pivot elements.
Error status can be obtained from the
returned value of POLYL1<!--hbox-->. A value of 616 implies that
either <span class="roman">M</span> &lt; 0, or
<span class="roman">M</span>+2 &gt; <span class="roman">N</span>, in which case no calculations are
performed. Other values may be set by the function SIMPL1.
This function
requires the function <a href="appendixc.htm#simpl1"> SIMPL1</a> to solve the LP problem using a
slightly modified simplex algorithm.

<div class="p"><!----></div>
 <br /><br /><a name="linl1"> </a>
 <b>175.&nbsp;LINL1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/linl1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polyl1.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate a general linear L<sub>1</sub>-approximation
in terms of arbitrary basis functions for
discrete data. Approximation of the form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
f(x) &#8776; </td><td nowrap="nowrap" align="center">
<small><span class="roman">M</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
a<sub>i</sub>&#981;<sub>i</sub>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.88)</td></tr></table>
</td></tr></table>


are sought, where &#981;<sub>i</sub>(x) are the basis functions. There is
no restriction on the basis functions, apart from the fact that they
should be independent on the set of points in the table.
This function can be used for approximation in multiple dimensions
as points need not be restricted to one dimension.
M is the number of basis functions. N is the number of data
points, which should be at least <span class="roman">M</span>+1.
A is an array of length  <span class="roman">M</span>+1, which
will contain the coefficients of approximation. <span class="roman">A</span>[i],
(i=0,1,&#8230;,<span class="roman">M</span>&#8722;1) is the coefficient of &#981;<sub>i</sub>.
F is an array of length N, containing the input data,
F[I] should contain the value of the function at Ith point. These
values must be supplied by the user.
G is an array of length <span class="roman">IG</span>&times;<span class="roman">N</span> containing the
values of basis functions at each point in the table, <span class="roman">G</span>[j][i] = &#981;<sub>i</sub>(x<sub>j</sub>). These values must be supplied by the user. It may
be noted that in this case the coordinates x<sub>j</sub> are not required by
the function and it could even be a vector for approximation in multiple
dimension. It is users responsibility to calculate the values
&#981;<sub>i</sub>(x<sub>j</sub>) accordingly. IG is the second dimension of G as specified
in the calling function (<span class="roman">IG</span> &#8805; <span class="roman">M</span>).
ESUM is the sum of the magnitude of the error
at all points (i.e., the L<sub>1</sub> norm of the residual)
in the final approximation calculated by the function. EPS is the
expected level of roundoff error, this parameter is passed on to the
function SIMPL1 for simplex iteration. It is used to decide the sign
of cost coefficients and pivot elements.
Error status can be obtained from the
returned value of LINL1<!--hbox-->. A value of 616 implies that
<span class="roman">M</span> &#8804; 0, or
<span class="roman">M</span>+1 &gt; <span class="roman">N</span>, in which case no calculations are
performed. Other values may be set by the function SIMPL1.
This function
requires the function <a href="appendixc.htm#simpl1"> SIMPL1</a> to solve the LP problem using a
slightly modified simplex algorithm.

<div class="p"><!----></div>
 <br /><br /><a name="simpl1"> </a>
 <b>176.&nbsp;SIMPL1&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/simpl1.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/polyl1.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve LP problems using a modified
version of the simplex algorithm, specially suitable for LP problems
arising in L<sub>1</sub>-approximations. This function is called by function
<a href="appendixc.htm#polyl1"> POLYL1</a> or <a href="appendixc.htm#linl1"> LINL1</a> and is similar to function <a href="appendixc.htm#simpx"> SIMPX</a><!--hbox-->.
The LP problem is assumed to be in the standard form and
the initial tableau is supplied in the array A of
length  <span class="roman">IA</span>&times;(<span class="roman">N</span>&#8722;<span class="roman">M</span><span class="roman">+</span><span class="roman">1</span>) with <span class="roman">IA</span> &#8805; <span class="roman">M</span>+2.
IA is the second dimension of A, exactly as specified in the calling 
function. N is the total number of variables in the given problem.
M is the number of constraints in the problem.
ID and IV are integer arrays of length  <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> and 
<span class="roman">N</span>&#8722;<span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> respectively, used to store permutations of the original
variables.
AEPS is a parameter used
to control roundoff error. Any quantity less than AEPS in magnitude is assumed
to be zero.
Error status can be obtained from the
returned value of SIMPL1<!--hbox-->. A value of 63 implies that
the objective function is unbounded from below and
the optimal feasible vector does not exist.
SIMPL1=635 implies that the
simplex iteration has not converged in a reasonable number of iterations.
This failure may be due to degeneracy, since that is not accounted for
in this function.
Since the problems arising out of L<sub>1</sub>-approximation
have very high degree of degeneracy, this function may fail to converge
in some cases, because of cycling as explained in Section&nbsp;8.7. 
<div class="p"><!----></div>
 

<br /><br />
<a name="Algebraic Eigenvalue Problem"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.11&nbsp; ALGEBRAIC EIGENVALUE PROBLEM </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#invit">INVIT</a></td>
<td>&nbsp; <a href="#tred2">TRED2</a></td>
<td>&nbsp; <a href="#trbak">TRBAK</a></td>
<td>&nbsp; <a href="#tql2">TQL2</a></td>
<td>&nbsp; <a href="#tridia">TRIDIA</a></td>
<td>&nbsp; <a href="#sturm">STURM</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#tinvit">TINVIT</a></td>
<td>&nbsp; <a href="#herevp">HEREVP</a></td>
<td>&nbsp; <a href="#balanc">BALANC</a></td>
<td>&nbsp; <a href="#balbak">BALBAK</a></td>
<td>&nbsp; <a href="#elmhes">ELMHES</a></td>
<td>&nbsp; <a href="#hqr">HQR</a></td>
</tr>
</table>


<div class="p"><!----></div>
<br /><br /><a name="invit"> </a>
 <b>177.&nbsp;INVIT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/invit.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/invit.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to find a real eigenvalue and the corresponding
eigenvector of a general real matrix using inverse iteration. M is the
order of the matrix. A is
an array of length <span class="roman">IA</span>&times;<span class="roman">M</span> containing the input matrix.
IA is the second dimension of A as specified in the calling function.
P is a variable specifying the initial shift to be used.
This shift should be close to the
required eigenvalue. U is an array of length  M, which should
contain an initial approximation to the eigenvector. This approximation
need not be close to the required eigenvector, but must be nonzero.
The initial vector U need not be normalised.
In most cases setting all components of U to 1 will be enough, but if
the initial vector so chosen is orthogonal to the required eigenvector
there may be some problem in convergence. In that case an arbitrary
choice which is not orthogonal to eigenvector will be required. For
multiple eigenvalues if more than one eigenvectors are required, then initial
vector should be chosen to be orthogonal to all known eigenvectors with
same eigenvalue to ensure that an independent eigenvector is found.
After execution, the array U will contain the required eigenvector, which
is normalised such that the maximum component is unity.
IFLG is a flag to decide the kind of iteration required. If IFLG=0,
then the shift P is kept fixed. If IFLG=1, then the shift
is varied after each iteration, using the computed Rayleigh quotient.
If IFLG=2, then the shift is varied using max(<b>v</b><sub><b>s</b><b>+</b><b>1</b></sub>)
at each iteration. IFLG=0 should be used when the eigenvalue
is already known accurately, or when iteration is strictly required to
converge to the eigenvalue nearest to P<!--hbox-->. In other cases, we may
use IFLG=1, if the matrix is Hermitian and IFLG=2 otherwise.
In practice, it is found that, even for some non-Hermitian matrices,
IFLG=1 often gives faster convergence, but that cannot be assumed.
After execution, EI and ERC give the estimated eigenvalue (corrected for
the shift P). ERC is the estimate using Rayleigh quotient,
while EI is the estimate
given by simple inverse iteration. ERC is relevant only for Hermitian
matrices, while EI is applicable to all matrices.
REPS is the required (absolute)
tolerance. The iteration is continued until the maximum change
in the eigenvalue and the M components of the eigenvector
is less than REPS<!--hbox-->.
NIT is an integer variable specifying the maximum
number of iterations required to be performed. If NIT &#8804; 0, then
a default value of NIT0 (=100) will be used.
Error status can be obtained from the
returned value of INVIT<!--hbox-->. A value of 106 implies that
<span class="roman">M</span> &#8804; 1
or <span class="roman">M</span> &gt; <span class="roman">IA</span>, in which case, no calculations are performed.
INVIT=141
implies that the vector is zero at some stage, which is usually due to
either the matrix A or the initial vector U being zero. If the matrix
is nonzero, then using a different initial vector or changing the shift P
may overcome this problem. INVIT=142 implies that the inverse
iteration has failed to converge, which could be either because the 
starting shift P is not sufficiently close to an eigenvalue, or 
because REPS is too small, or because the corresponding eigenvalue
has a nonlinear divisor. Apart from these, other values may be
set by function <a href="appendixc.htm#gauelm"> GAUELM</a>, which is called to solve the system of linear
equations. In particular, INVIT=121 implies that one of pivots
during the Gaussian elimination is zero. This problem can usually be overcome
by perturbing the shift slightly. If this problem occurs
persistently, it may be better to modify the Gaussian elimination function,
such that zero pivots are replaced by a suitably chosen small number.
To find an eigenvector of a generalised eigenvalue problem
A(&#955;)<b>x</b>=<b>0</b>, use <span class="roman">P</span>=0, <span class="roman">IFLG</span>=0,
and the matrix A should be set to A(&#955;) with &#955; equal
to the known eigenvalue. In this case the eigenvalue has to be determined
before finding the eigenvector. To find the left eigenvector of the
matrix take transpose of the matrix while applying the shift. This
is implemented in INVIT<tt>_</tt>L

<div class="p"><!----></div>
 <br /><br /><a name="tred2"> </a>
 <b>178.&nbsp;TRED2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/tred2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/realsy.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to reduce a real symmetric matrix to tridiagonal
form using Householder's method. This function is based on the
procedure <i>tred2</i>  in the <i>Handbook</i>.
A is an array of length <span class="roman">IA</span>&times;<span class="roman">N</span> containing the matrix.
After execution, the array A will be overwritten by the transformation
matrix Q, such that Q<sup>T</sup><span class="roman">A</span>Q is tridiagonal. This matrix may be required
for back-transforming the eigenvectors of tridiagonal matrix to that of
the original input matrix A<!--hbox-->.
N is the order of the matrix. IA is the second dimension of the array A, as
specified in the calling function, <span class="roman">IA</span> &#8805; <span class="roman">N</span>.
D and E are arrays of length 
N, giving the diagonal and off-diagonal elements of the reduced tridiagonal
matrix with <span class="roman">D</span>[i]=a<sub>ii</sub> and <span class="roman">E</span>[i+1]=a<sub>i,i+1</sub>=a<sub>i+1,i</sub>.
REPS is the tolerance which should be equal to &#951;/&#295;, where
&#951; is the smallest positive number that is representable in the computer
and &#295; is the machine accuracy.
For single precision  arithmetic (type float) use REPS=10<sup>&#8722;30</sup>.
For double precision  arithmetic use REPS=10<sup>&#8722;300</sup>.
Error status can be obtained from the
returned value of TRED2<!--hbox-->. A value of 107 implies that
<span class="roman">N</span> &#8804; 1 or
<span class="roman">N</span> &gt; <span class="roman">IA</span>, in which case, no calculations are performed. 

<div class="p"><!----></div>
 <br /><br /><a name="trbak"> </a>
 <b>179.&nbsp;TRBAK&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/trbak.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/realsy.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform back-transformation on eigenvectors
of reduced tridiagonal matrix to obtain the eigenvectors of the original
real symmetric matrix reduced by <a href="appendixc.htm#tred2"> TRED2</a>. This back-transformation is
not required if the eigenvectors are calculated using the function
<a href="appendixc.htm#tql2"> TQL2</a>, but will be required
if the eigenvectors are calculated by the function <a href="appendixc.htm#tridia"> TRIDIA</a><!--hbox-->. A is an
array of length <span class="roman">IA</span>&times;<span class="roman">N</span>
containing the transformation matrix Q generated by the function
TRED2. The last column of A is used as a scratch space by the function
and hence its contents will be destroyed during execution.
IA is the second dimension of A, as specified in the calling function.
N is the order of the matrix. Z is an array of length <span class="roman">IZ</span>&times;<span class="roman">N</span> containing the eigenvectors
of the reduced tridiagonal matrix. After execution, this array will be
overwritten by the eigenvectors of the original matrix A<!--hbox-->. IZ is the second
dimension of array Z, as specified in the calling function. NZ is the number
of eigenvectors. Thus, <span class="roman">Z</span>[i][j] should contain the ith component
of the jth eigenvector. This function simply performs the matrix
multiplication AZ to obtain the required eigenvectors.
The returned value of the function is always zero.

<div class="p"><!----></div>
 <br /><br /><a name="tql2"> </a>
 <b>180.&nbsp;TQL2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/tql2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/realsy.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to find eigenvalues and eigenvectors of
ZTZ<sup>T</sup> using the QL&nbsp;algorithm, where T is a symmetric tridiagonal matrix 
and Z is an orthogonal matrix.
This function is based on the procedure <i>tql2</i>  in the <i>Handbook</i>.
If the matrix Z is the transformation matrix, which reduces a real symmetric
matrix to tridiagonal form, then this function gives the eigenvectors of
the original matrix. This function can be used to find eigenvalues
and eigenvectors of a real symmetric matrix, after it is reduced to a
tridiagonal form using <a href="appendixc.htm#tred2"> TRED2</a>. In that case, Z will be the transformation
matrix generated by TRED2. To find eigenvalues and eigenvectors of a
symmetric tridiagonal matrix, set the matrix Z to an identity
matrix. Z is an array of length <span class="roman">IZ</span>&times;<span class="roman">N</span>,
containing the transformation matrix.
After execution, this array will be overwritten by the eigenvectors of
the original matrix ZTZ<sup>T</sup>, with ith column containing the ith
eigenvector. N is the order of the matrix. IZ is the second dimension of Z,
as specified in the calling function. D is an array of length 
N, containing the diagonal elements of the tridiagonal matrix with
<span class="roman">D</span>[i]=t<sub>ii</sub>. After execution, the array D will be overwritten
by the eigenvalues of the matrix. The eigenvalues are sorted in the
ascending order. E is an array of length N
containing the off-diagonal elements of the tridiagonal matrix, with
<span class="roman">E</span>[i+1]=t<sub>i,i+1</sub>=t<sub>i+1,i</sub>. E is used as a scratch space by the
function and hence its contents will be destroyed during the execution.
REPS is the tolerance which should be equal to &#295;, the machine
accuracy.
Error status can be obtained from the
returned value of TQL2<!--hbox-->. A value of 108 implies that
<span class="roman">N</span> &#8804; 1 or <span class="roman">N</span> &gt; <span class="roman">IZ</span>, in which case, no calculations are
performed. TQL2=143 implies that
the QL algorithm failed to converge for some eigenvalue, in which
case, the calculations are abandoned.

<div class="p"><!----></div>
 <br /><br /><a name="tridia"> </a>
 <b>181.&nbsp;TRIDIA&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/tridia.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/realsy.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to find some eigenvalues and eigenvectors
of a symmetric tridiagonal matrix using the Sturm sequence property,
coupled with the inverse iteration method. N is the order of the matrix.
E and D are arrays of length  N containing respectively, the
off-diagonal and diagonal elements of the symmetric tridiagonal matrix,
with <span class="roman">E</span>[i+1]=a<sub>i,i+1</sub>=a<sub>i+1,i</sub> and <span class="roman">D</span>[i]=a<sub>ii</sub>.
It is assumed that all the off-diagonal elements are nonzero. Otherwise,
the matrix should be split into two or more parts and each part should
be considered independently.
M1 and M2 are integers specifying which eigenvalues are to be calculated.
If eigenvalues &#955;<sub>i</sub> are sorted in increasing order, then all eigenvalues
from &#955;<sub><span class="roman">M</span><span class="roman">1</span></sub> to &#955;<sub><span class="roman">M</span><span class="roman">2</span></sub> will be determined. If
<span class="roman">M</span><span class="roman">1</span> &gt; <span class="roman">M</span><span class="roman">2</span>, then no calculations are performed. EI is
an array of length  <span class="roman">M</span><span class="roman">2</span>&#8722;<span class="roman">M</span><span class="roman">1</span>+1, which will contain the
eigenvalues after execution. EPS1 is a parameter, which specifies
the accuracy to which the eigenvalues should be located by bisection.
This parameter is required in some cases, since the inverse iteration with variable
shift, which is used to determine eigenvalues accurately may not always
converge to the nearest eigenvalue. If that happens, then the parameter
EPS1 can be decreased. A moderate value of the order of 0.1 or 0.01 times the
typical eigenvalues should be normally sufficient. Increasing EPS1 
will improve the efficiency, provided the inverse iteration converges.
REPS is the required tolerance in the eigenvalues and eigenvectors.
EV is an array of length <span class="roman">IV</span>&times;<span class="roman">N</span>
which will contain the calculated eigenvectors.
EV[i][j] will contain the ith component of the jth eigenvector.
IV is the second dimension of the array EV as specified in the calling
function, <span class="roman">IV</span> &#8805; (<span class="roman">M</span><span class="roman">2</span>&#8722;<span class="roman">M</span><span class="roman">1</span>+1). 
Error status can be obtained from the
returned value of TRIDIA<!--hbox-->. A value of 109 implies that <span class="roman">N</span> &#8804; 1
or <span class="roman">M</span><span class="roman">2</span>&#8722;<span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">1</span> &gt; <span class="roman">IV</span> or <span class="roman">M</span><span class="roman">1</span> &lt; 0 or <span class="roman">M</span><span class="roman">2</span> &#8805; <span class="roman">N</span>,
in which case, no calculations are performed.
Other values may be set by
function TINVIT, which is called to calculate the eigenvalues and
eigenvectors. Only the last nonzero value of error flag will be retained.
This function requires the function <a href="appendixc.htm#sturm"> STURM</a> to locate the eigenvalues
and function <a href="appendixc.htm#tinvit"> TINVIT</a> to find the eigenvalues and eigenvectors of a
symmetric tridiagonal matrix and function <a href="appendixc.htm#ran1"> RAN1</a> to generate random numbers.

<div class="p"><!----></div>
 <br /><br /><a name="sturm"> </a>
 <b>182.&nbsp;STURM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/sturm.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/realsy.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to locate required eigenvalues of a real symmetric
tridiagonal matrix using the method of bisection on the Sturm sequence.
It is assumed that all the off-diagonal elements are nonzero. Otherwise,
the matrix should be split into two or more parts and each part should
be considered independently.
N is the order of the matrix.
E and D are arrays of length  N containing respectively, the
off-diagonal and diagonal elements of the symmetric tridiagonal matrix,
with <span class="roman">E</span>[i+1]=a<sub>i,i+1</sub>=a<sub>i+1,i</sub> and <span class="roman">D</span>[i]=a<sub>ii</sub>.
M1 and M2 are integers specifying which eigenvalues are to be located.
If eigenvalues &#955;<sub>i</sub> are sorted in increasing order, then all eigenvalues
from &#955;<sub><span class="roman">M</span><span class="roman">1</span></sub> to &#955;<sub><span class="roman">M</span><span class="roman">2</span></sub> will be located. If
<span class="roman">M</span><span class="roman">1</span> &gt; <span class="roman">M</span><span class="roman">2</span>, then no calculations are performed. EL and EU
are arrays of length  M2. After execution, the ith
eigenvalue should be located in the interval (<span class="roman">EL</span>[i],<span class="roman">EU</span>[i]).
NUM is an integer variable which will contain the number of times
the Sturm sequence was evaluated for locating the eigenvalues to the
specified accuracy. REPS is the specified accuracy to which the eigenvalues
are to be located. Bisection is continued until 
&#124;<span class="roman">EU</span>[i]&#8722;<span class="roman">EL</span>[i]&#124; &lt; REPS and the eigenvalue has been isolated.
At least three bisections are performed after the eigenvalues are isolated,
that is <span class="roman">EU</span>[i&#8722;1] &lt; <span class="roman">EL</span>[i]. If at any stage the interval is too
small to be bisected further, then the iteration is naturally terminated.
This situation can arise when the matrix has very close
eigenvalues.
Error status can be obtained from the
returned value of STURM<!--hbox-->. A value of 110 implies that
<span class="roman">M</span><span class="roman">1</span>  &lt; 0 or <span class="roman">M</span><span class="roman">2</span> &gt; <span class="roman">N</span>&#8722;1, in which case no calculations are
done.

<div class="p"><!----></div>
 <br /><br /><a name="tinvit"> </a>
 <b>183.&nbsp;TINVIT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/tinvit.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/realsy.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to find a specified eigenvalue and eigenvector of a
symmetric tridiagonal matrix using inverse iteration. N is the order of the matrix. 
E and D are arrays of length  N containing respectively, the
off-diagonal and diagonal elements of the symmetric tridiagonal matrix,
with <span class="roman">E</span>[i+1]=a<sub>i,i+1</sub>=a<sub>i+1,i</sub> and <span class="roman">D</span>[i]=a<sub>ii</sub>. EL
and EU give the lower and upper limit on the
eigenvalue. The iteration will not go beyond these limits.
EI will contain the calculated eigenvalue.
EV is an array of length  N, which will contain the
calculated eigenvector. For IFLG &#8800; 0 it should contain the
previous eigenvector determined by the function as input,
so that the function can choose initial vector orthogonal to it.
REPS is the required accuracy. The iteration
is continued until either of the following three conditions are
satisfied, (1) the relative change in the eigenvalue as estimated using
the Rayleigh quotient is less than REPS, (2)
max(<b>v</b><sub><b>j</b><b>+</b><b>1</b></sub>)&#955; &gt; 1/REPS (where &#955; is an
estimate for the eigenvalue), (3) &#124;&#124;<b>u</b><sub><b>j</b><b>+</b><b>1</b></sub>&#8722;<b>u</b><sub><b>j</b></sub>&#124;&#124;<sub>1</sub> &lt; REPS.
IFLG is an integer variable used as a flag.
If IFLG=0, then the initial vector is chosen randomly. Otherwise,
the initial vector is chosen to be orthogonal to the vector EV<!--hbox-->. This device
can be used to ensure that an independent vector is found when two
or more eigenvalues are very close or equal. Since only one previous
eigenvector is used, this device may not be very effective for eigenvalues
of multiplicity greater than two.  NUM is an
integer variable, which will contain the number of iterations required
by the function.
Error status can be obtained from the
returned value of TINVIT<!--hbox-->. A value of 144 implies that
the inverse iteration failed to converge to the specified accuracy.
This function requires Function <a href="appendixc.htm#ran1"> RAN1</a>(SEED) to
generate random numbers. If a different function is used for this
purpose, the seed should be changed appropriately.

<div class="p"><!----></div>
 <br /><br /><a name="herevp"> </a>
 <b>184.&nbsp;HEREVP&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/herevp.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/herevp.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to find all eigenvalues and eigenvectors of
a complex Hermitian matrix.
This function converts the eigenvalue problem for a Hermitian matrix
into that for a real symmetric matrix of order 2N and solves this
expanded problem. The expanded eigenvalue problem is solved by
reducing the matrix to tridiagonal form using <a href="appendixc.htm#tred2"> TRED2</a> and then solving
the eigenvalue problem for tridiagonal matrix using <a href="appendixc.htm#tql2"> TQL2</a>.
AR and AI are arrays of length <span class="roman">IA</span>&times;<span class="roman">N</span>,
containing the real and imaginary parts of the matrix.
The function preserves the contents of these arrays.
N is the order of the matrix. IA is the second dimension of AR, AI
as specified in the calling function. EI is an array of length 
N, which will contain the eigenvalues of the matrix.
The eigenvalues are sorted in the ascending order.
VR and VI are arrays of length <span class="roman">IZ</span>&times;<span class="roman">N</span>, which will
contain the real and imaginary parts of eigenvectors of the
complex matrix. VR[I][J] and VI[I][J] will contain
the Ith component of Jth eigenvector.
IZ is the second dimension of arrays VR and VI as declared in the calling
function.
REPS is the tolerance which should be of the order of &#295;, the machine
accuracy.
Error status can be obtained from the
returned value of HEREVP<!--hbox-->. A value of 111 implies that
<span class="roman">N</span> &#8804; 1 or <span class="roman">N</span> &gt; <span class="roman">IA</span> or <span class="roman">N</span> &gt; <span class="roman">IZ</span>,
in which case, no calculations are
performed. Other values may be set by TRED2 or TQL2.
The function requires <a href="appendixc.htm#tred2"> TRED2</a> and <a href="appendixc.htm#tql2"> TQL2</a> to solve the eigenvalue problem
for equivalent real symmetric matrix. Since every eigenvalue of the
equivalent real matrix is repeated, there may be problem in isolating
the eigenvectors when the eigenvalue of complex matrix is multiple.
If there is some problem all eigenvectors of the 2<span class="roman">N</span>&times;2<span class="roman">N</span>
real matrix should be preserved so that the right combinations can be
identified. This function picks alternate eigenvectors.

<div class="p"><!----></div>
 <br /><br /><a name="balanc"> </a>
 <b>185.&nbsp;BALANC&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/balanc.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/unsym.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function for reducing the norm of a matrix by exact
diagonal similarity transformations. This function is based on
the procedure <i>balance</i>  in the <i>Handbook</i>.
A is an array of length <span class="roman">IA</span>&times;<span class="roman">N</span> containing the
matrix. After execution, the balanced matrix will be overwritten on the
same array. N is the order of the matrix and IA is the second dimension of
array A, as declared in the calling function. B is the base of floating-point
representation in the machine. For most machines <span class="roman">B</span>=2. 
LOW and IGH are integer variables, such
that in the balanced matrix a<sub>ij</sub>=0 if i &gt; j and (j &lt; <span class="roman">LOW</span> or
i &gt; <span class="roman">IGH</span>). This essentially means that after balancing
we have to only consider
the sub-matrix in rows and columns from LOW to IGH, since other
eigenvalues are already isolated by function BALANC<!--hbox-->. D is an
array of length  N containing the information about transformation.
The elements D[LOW] to D[IGH] will contain the elements of diagonal matrix
used for balancing, while other elements will contain the permutations
used to isolate eigenvalues.
Error status can be obtained from the
returned value of BALANC<!--hbox-->. A value of 112 implies that
<span class="roman">N</span> &#8804; 1 or <span class="roman">N</span> &gt; <span class="roman">IA</span>, in which case, no
calculations are performed.

<div class="p"><!----></div>
 <br /><br /><a name="balbak"> </a>
 <b>186.&nbsp;BALBAK&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/balbak.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/unsym.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform back-transformation of a set of
right eigenvectors from those of the balanced matrix to that for the
original matrix.  This function is based on the procedure <i>balbak</i> 
in the <i>Handbook</i>.
This function only handles real eigenvectors, but since the transformation
is real and linear, the real and imaginary parts of complex eigenvectors
can be transformed by two separate calls to this function.
N is the order of the matrix. LOW and IGH are integer
variables obtained by the function <a href="appendixc.htm#balanc"> BALANC</a><!--hbox-->. CZ is an array of
length <span class="roman">IZ</span>&times;<span class="roman">M</span> containing
the eigenvectors of the balanced matrix. After execution, the eigenvectors
of the original matrix will be overwritten on the same array.
For complex eigenvectors two calls will be needed for transforming
the real and imaginary parts separately. In that case CZ should
contain the real (or imaginary) part of the eigenvectors.
M is the 
number of eigenvectors, and IZ is the second dimension of array CZ as
declared in the calling function. D is an array of length  N,
containing the information about transformation as generated by the function
BALANC<!--hbox-->. The returned value of the function is always zero.
This function can be modified as explained in the
file, to back-transform left eigenvectors and the corresponding
version is implemented in BALBAK<tt>_</tt>L.

<div class="p"><!----></div>
 <br /><br /><a name="elmhes"> </a>
 <b>187.&nbsp;ELMHES&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/elmhes.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/unsym.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function for reducing a general real matrix to an
upper Hessenberg form using real stabilised elementary similarity
transformation. This function is based on the procedure <i>elmhes</i> 
in the <i>Handbook</i>. A is an array of length <span class="roman">IA</span>&times;<span class="roman">N</span>
containing the matrix. After execution,
the reduced matrix will be overwritten on the same array. Information
about the transformation (i.e., the elements m<sub>i,r+1</sub>)
will also be written on the (i,r) element of the same array. N is
the order of the matrix and IA is the second dimension of array A as
declared in the calling function. LOW and IGH are integer variables as
given by the function <a href="appendixc.htm#balanc"> BALANC</a> while balancing the matrix. This function
only processes the sub-matrix in rows LOW to IGH<!--hbox-->. If the matrix
is not balanced, then set <span class="roman">LOW</span>=0 and <span class="roman">IGH</span>=<span class="roman">N</span>&#8722;1 before
calling this function. INC
is an integer array of length  N, containing the information
about the row and column interchanges used during the reduction.
Error status can be obtained from the
returned value of ELMHES<!--hbox-->. A value of 113 implies that
<span class="roman">N</span> &#8804; 1 or <span class="roman">N</span> &gt; <span class="roman">IA</span>, in which case, no
calculations are performed.

<div class="p"><!----></div>
 <br /><br /><a name="hqr"> </a>
 <b>188.&nbsp;HQR&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/hqr.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/unsym.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to find eigenvalues of an upper Hessenberg
matrix using QR&nbsp;algorithm. This function is based on the procedure
<i>hqr</i>  in the <i>Handbook</i>. It
does not keep track of the transformations and hence cannot be used
to find eigenvectors. H is an array of length <span class="roman">IH</span>&times;<span class="roman">NN</span>
containing the matrix.
During execution, the contents of H will be destroyed. NN is the
order of the matrix and IH is the second dimension of H as specified in
the calling function. ER and EI are arrays of length  NN,
which will contain the real and imaginary parts of the eigenvalues.
REPS is the tolerance which should be of the order of &#295;, the machine
accuracy.
Error status can be obtained from the
returned value of HQR<!--hbox-->. A value of 114 implies that
<span class="roman">N</span> &#8804; 1 or <span class="roman">N</span> &gt; <span class="roman">IH</span>, in which case, no
calculations are performed. HQR=145 implies that
the QR&nbsp;iteration failed to converge at some stage and the calculations
are abandoned. In this case, the eigenvalues which are already
isolated should be available in arrays ER and EI.

<div class="p"><!----></div>
 

<br /><br />
<a name="Ordinary Differential Equations"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.12&nbsp; ORDINARY DIFFERENTIAL EQUATIONS </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#rkm">RKM</a></td>
<td>&nbsp; <a href="#rk4">RK4</a></td>
<td>&nbsp; <a href="#rk2">RK2</a></td>
<td>&nbsp; <a href="#mstep">MSTEP</a></td>
<td>&nbsp; <a href="#adams">ADAMS</a></td>
<td>&nbsp; <a href="#strt4">STRT4</a></td>
<td>&nbsp; <a href="#gear">GEAR</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#extp">EXTP</a></td>
<td>&nbsp; <a href="#fdm">FDM</a></td>
<td>&nbsp; <a href="#gevp">GEVP</a></td>
<td>&nbsp; <a href="#gaublk">GAUBLK</a></td>
<td>&nbsp; <a href="#setmat">SETMAT</a></td>
<td>&nbsp; <a href="#bspode">BSPODE</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="rkm"> </a>
 <b>189.&nbsp;RKM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/rkm.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/rkm.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve initial value problems in ordinary
differential equations, using a second or fourth-order Runge-Kutta
method with adaptive step size control. This function accepts
a system of first-order differential equations. N is the number
of first-order equations. Y is an array of length  N,
which should contain the initial values of the variables at input.
After successful execution, it will contain the solution at the 
required point. If the execution is aborted in between, then it
will contain the solution at some intermediate point T0, up to where
the integration was successful. DY is an array of length 
N, containing the first derivative of the solution. The derivative
need not be supplied at the time of calling. DIF is the name
of the external function, which is invoked for calculating the right-hand
side of the differential equation <b>y</b>&#8242;=<b>f</b>(t,<b>y</b>).
H is the initial step size to be tried. The function will adjust
the step size if necessary, using the technique described in Section&nbsp;12.4. After execution, H will contain the current value of the step size.
T0 is the initial value of the independent variable t, at which the
initial conditions are specified. After execution, the value of T0
will be updated, to the point up to which the integration is successful.
TN is the value of t at which the solution is required.
TN need not be greater than T0, i.e., the solution can be calculated
in forward or backward direction.  If
the integration is successful, then T0 will be set equal to TN<!--hbox-->. Thus,
if the solution is required at several points, then the function can
be called repeatedly after changing TN between every call. Other
variables need not be changed. REPS is the required relative accuracy
in each component of the solution. This function only tries to
estimate the local truncation error and the computed solution
may not be correct to the specified accuracy. NSTEP is the number of steps
used by the Runge-Kutta method, each step may require 10 or 11 function
evaluations with fourth-order Runge-Kutta method.
Each step may not be successful. NMAX is the maximum 
number of steps that the function is allowed to use. If NMAX &#8804; 0,
then a default value of NMX (=10000) will be used.
Error status can be obtained from the
returned value of RKM<!--hbox-->. A value of 701 implies that
<span class="roman">N</span> &#8804; 0, in which
case, no calculations are performed.
RKM=721 implies that step size has become smaller
than REPS&#124;TN&#8722;T0&#124;. If in a small region the step
size is actually expected to be smaller than this limit, then the
corresponding statement in the function may be modified. 
RKM=722 implies that the
step size is too small for the arithmetic used
(i.e., <span class="roman">H</span> &lt; &#295; &#124;<span class="roman">T</span><span class="roman">0</span>&#124;) and the calculations
are aborted. RKM=723
implies that the integration could not be completed in the specified number
(NMAX) of steps. The failure of this function can arise either
because of singularity, or stiffness, or because the specified accuracy
is too high.
This function requires function
<a href="appendixc.htm#rk4"> RK4</a> or <a href="appendixc.htm#rk2"> RK2</a> to perform one step of Runge-Kutta integration. Function
RK4 uses a fourth-order Runge-Kutta method, while RK2 uses a second-order
method. To use RK2 the call statements as well as the parameters
in the beginning of the function should be changed as indicated.
RKM<tt>_</tt>2 is the version of RKM for second-order method.
Further, the
function DIF(T, N, Y, DY) must be supplied by the user to calculate the
right-hand sides of the equations, i.e., the derivatives <span class="roman">Y</span>&#8242;.
Here T is the value of independent variable
and  N is the number of equations.
Y is the array containing the dependent variables at time t=<span class="roman">T</span>,
where the derivatives need to be evaluated.
DY is the array which will contain the calculated value of the derivatives.
DY[i] should contain <span class="roman">Y</span>&#8242;[i]=f<sub>i</sub>(<span class="roman">T</span><span class="roman">,</span> <span class="roman">Y</span>).

<div class="p"><!----></div>
 <br /><br /><a name="rk4"> </a>
 <b>190.&nbsp;RK4&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/rk4.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/rkm.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform one step of integration using a
fourth-order Runge-Kutta method. N is the number of first-order differential
equations in the system. T is the value of independent variable at the
initial point. This value is not updated by the function. H is the
step size to be used. Y0, DY0 and Y1 are arrays of length 
N<!--hbox-->. Y0 contains the initial value, while after execution, Y1 will contain
the final value of the solution vector at t=<span class="roman">T</span><span class="roman">+</span><span class="roman">H</span>. DY0 contains
the first derivative at Y0. Y0 and DY0 must be supplied at the time of
calling the function. DIF is the name of the external function used to calculate
the right-hand sides of the differential equations.
The function DIF as described in the write up for function <a href="appendixc.htm#rkm"> RKM</a> must be
supplied by the user.
This function is called by function RKM, but
it can be used independently to integrate an equation with constant step
size. This can be achieved by repeatedly calling the function
after updating the value of T (=<span class="roman">T</span>+<span class="roman">H</span>),
Y0 (=<span class="roman">Y</span><span class="roman">1</span>) and DY0 (using DIF).

<div class="p"><!----></div>
 <br /><br /><a name="rk2"> </a>
 <b>191.&nbsp;RK2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/rk2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/rkm_2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform one step of integration using a
second-order Runge-Kutta method. All arguments have the same meaning
as that for the function <a href="appendixc.htm#rk4"> RK4</a>.

<div class="p"><!----></div>
 <br /><br /><a name="mstep"> </a>
 <b>192.&nbsp;MSTEP&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/mstep.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/mstep.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve initial value problems in ordinary
differential equations, using a fourth-order multistep method 
with adaptive step size control. This function accepts
a system of first-order differential equations. It can be
used with either function <a href="appendixc.htm#adams"> ADAMS</a> for Adams-Bashforth-Moulton
predictor-corrector method, or function <a href="appendixc.htm#gear"> GEAR</a> for stiffly stable fourth-order
method. The change can be affected by choice of a flag.
By setting the flag appropriately, this
function can also be used to integrate the equation using a
fixed step size. This function is a crude implementation of multistep
methods with simple techniques for adjusting the step-size which
should work on simple problems. A more
sophisticated implementation will be required to handle a larger
fraction of equations efficiently.
N is the number
of first-order equations. Y is an array of length  7N,
the first N elements of
which should contain the initial values of the solution at input.
After execution, it will contain the solution at some
intermediate points. The contents of this array must be preserved, if a
second call to the function is required for continuing the integration
further. DY is an array of length 
7N, containing the first derivatives of the solution. The first derivative
need not be supplied at the time of calling. The arrays Y and DY are
used to store the solution at seven most recent points. The first index
of the array is increased in a circular manner, to avoid frequent copying
of the array elements. DIF is the name
of the external function, which is invoked for calculating the right-hand
sides of the differential equations <b>y</b>&#8242;=<b>f</b>(t,<b>y</b>).
H is the initial step size to be tried. This function generates
the starting values using the fourth-order
Runge-Kutta method, which will adjust the step
size if necessary. After the starting values are generated, the step
size can be doubled or halved as explained in Section&nbsp;12.3. After execution, H will contain the current value of the step size.
T0 is the initial value of the independent variable t, at which the
initial conditions are specified. After execution, the value of T0
will be updated to the point up to which the integration is successful.
If the execution is successful the final value of T0 may be beyond
the requested value of TN<!--hbox-->. The solution at TN is computed using
interpolation between values of solution at different values of t.
TN is the value of t at which the solution is required. If
the solution is required at several points, then the function can
be called repeatedly after changing TN between every call. Other
variables (including the scratch arrays) should not be changed,
because the function
uses the previous values of the solution as the starting values for
the new problem. YF is an array of length  N, which will
contain the final value of the solution at the required point TN, provided
the integration is successful. If the integration is aborted at some
intermediate point after the starting values were calculated, then this array
will contain the solution at the last successful point.
REPS is the required relative accuracy
in each component of the solution. This function only tries to
estimate the local truncation error. Hence, the computed solution
may not be correct to the specified accuracy. NSTP is the number of 
evaluations of the right-hand side required by the function.
NSTP is initialised only during the first call (IFLG=0 or 1) and hence it
will accumulate the number of calls to DIF from the first call, until
IFLG is reset to 0 or 1.
NMAX is the maximum number of function
evaluations that the function is allowed to use. If NMAX &#8804; 0,
then a default value of NMX (=100000) will be used.
IFLG is an integer variable used as a flag by the function.
If IFLG=0 or 1, then the integration is started by generating fresh
starting values using function <a href="appendixc.htm#strt4"> STRT4</a>. For higher values of IFLG
it is assumed that the starting values are already available in the
arrays Y and DY<!--hbox-->. The function itself resets the value of IFLG after
generating the starting values. Hence, this parameter need not be reset
between two calls, unless it is required to generate starting values again.
If IFLG=0 or 2, then the step size is adjusted according to
the required accuracy. For IFLG=1 and 3, the step size is kept
fixed and no attempt is made to check the truncation error. However,
the parameter REPS is used to check for convergence of the corrector
iteration. In this case, if the iteration on corrector fails to converge,
then error flag will be set to 729. IST is an integer parameter to
decide which multistep method is to be used. If IST=0 the
fourth-order
Adams-Bashforth-Moulton predictor-corrector method is used, while for
other values of IST, the fourth-order stiffly stable method due to
Gear is used.
WK is an array, which is used
as a scratch space by the function. The length of this array should be
2N for Adams method and 3<span class="roman">N</span>+<span class="roman">N</span><sup>2</sup>
for stiffly stable method.
Error status can be obtained from the
returned value of MSTEP<!--hbox-->. A value of 702 implies that
<span class="roman">N</span> &#8804; 0, in which
case, no calculations are performed.
MSTEP=724 or 725 implies that
function STRT4 failed to generate the required starting values.
MSTEP=726 implies that step size has become smaller
than REPS&#124;TN&#8722;T0&#124;. If in a small region the step
size is actually expected to be smaller than this limit, then the
corresponding statement in the function may be modified.
MSTEP=727 implies that the
step size is too small for the arithmetic used
(i.e., <span class="roman">H</span> &lt; &#295;&#124;<span class="roman">T</span><span class="roman">0</span>&#124;) and the calculations
are aborted.  MSTEP=728
implies that the integration could not be completed in the specified number
(NMAX) of function evaluations. The failure of this function can arise either
because of singularity, or stiffness (with ADAMS), or because
the specified accuracy
is too high. For integration with fixed step size, error flag
may be set to 729 if the corrector fails to converge.
This function requires functions
<a href="appendixc.htm#adams"> ADAMS</a>, <a href="appendixc.htm#gear"> GEAR</a> and <a href="appendixc.htm#gauelm"> GAUELM</a> to perform the integration and function <a href="appendixc.htm#strt4"> STRT4</a> and <a href="appendixc.htm#rk4"> RK4</a>
to generate the starting values. In addition the
function DIF(T, N, Y, DY) must be supplied by the user to calculate the
right-hand sides of the equations, i.e., the derivatives <span class="roman">Y</span>&#8242;.
Here T is the value of independent variable
and  N is the number of equations.
Y is the array containing the dependent variables at time t=<span class="roman">T</span>,
where the derivatives need to be evaluated.
DY is the array which will contain the calculated value of the derivatives.
DY[i] should contain <span class="roman">Y</span>&#8242;[i]=f<sub>i</sub>(<span class="roman">T</span><span class="roman">,</span> <span class="roman">Y</span>).

<div class="p"><!----></div>
 <br /><br /><a name="adams"> </a>
 <b>193.&nbsp;ADAMS&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/adams.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/mstep.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform one step of solution of an initial
value problem, using a fourth-order Adams-Bashforth-Moulton 
predictor-corrector method. This function can be easily modified to use any
other predictor-corrector formula. This function is called by function
<a href="appendixc.htm#mstep"> MSTEP</a> to perform one step of integration. N is the number of first-order
differential equations, Y and DY are arrays of length  7N,
as used by function MSTEP<!--hbox-->. DIF is the name of the function used to calculate
the right-hand sides of the equations. H is the step size and T is
the value of independent variable at which the solution is required.
REPS is the specified
accuracy. This function does not check for the truncation error, but
the parameter REPS is used to check for the convergence of corrector
iteration. NSTP is the number of function evaluations used so far.
This number is updated by the function.
IJ, IJM1, IJM2, IJM3 and IJM4 are respectively, the indices j+1, j, j&#8722;1,
j&#8722;2 and j&#8722;3 in the predictor-corrector formula.
WK is an array of length  2N, which is used to transmit the
predicted value to function MSTEP<!--hbox-->.
Error status can be obtained from the
returned value of ADAMS<!--hbox-->. A value of 729 implies that
the iteration on corrector has failed to converge.
Function DIF as described in the writeup for function <a href="appendixc.htm#mstep"> MSTEP</a>
must be supplied by the user.

<div class="p"><!----></div>
 <br /><br /><a name="strt4"> </a>
 <b>194.&nbsp;STRT4&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/strt4.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/mstep.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to generate the starting values <b>y</b><sub><b>1</b></sub>,
<b>y</b><sub><b>2</b></sub> and <b>y</b><sub><b>3</b></sub> using a fourth-order Runge-Kutta method.
The truncation error is estimated by performing one integration with
double step size. This function is called by the function <a href="appendixc.htm#mstep"> MSTEP</a><!--hbox-->.
N is the number of first-order differential equations
to be solved. Y and DY are arrays of length  4N, containing
the values of <b>y</b> and <b>y</b>&#8242; at the four starting points. While
calling the function, the initial values <b>y</b><sub><b>0</b></sub> must be stored
in the first N elements of Y<!--hbox-->. Other elements of these arrays will
be calculated by the function. DIF is the name of the function used to
calculate the right-hand sides of the differential equations. H is the
initial guess for the step size. If necessary the step size will
be adjusted by the function. T is the value of the independent variable at
the initial point. If the execution is successful, then T is updated
to <span class="roman">T</span>+3<span class="roman">H</span>. REPS is the specified relative accuracy. IFLG is
an integer parameter used as a flag. If IFLG=0, then the step
size may be adjusted while for other values of IFLG the step size
will not be adjusted. For IFLG &#8800; 0, the value of REPS is redundant,
since no attempt is made to check the truncation error.
TSTEP is the size of interval over which the
integration is requested. It is used only for convergence check.
NSTP is an integer variable which contains
the number of function evaluations used so far. This value is updated
by the function.
WK is an array of length  2N used to pass on the value for modifier.
Error status can be obtained from the
returned value of STRT4<!--hbox-->. A value of 724 implies that
the function failed to find
the starting values, because the step size became too small.
STRT4=725 implies that the routine failed to find the starting values
in the specified number (NIT=10) of attempts.
This function requires functions <a href="appendixc.htm#rk4"> RK4</a> and DIF<!--hbox-->.
Function DIF as described in the writeup for function <a href="appendixc.htm#mstep"> MSTEP</a>
must be supplied by the user.

<div class="p"><!----></div>
 <br /><br /><a name="gear"> </a>
 <b>195.&nbsp;GEAR&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gear.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/mstep.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to perform one step of solution of initial
value problem using a fourth-order stiffly stable method based on the
backward differentiation formula. This function uses the Broyden's
method to solve the implicit corrector formula.
This function is called by the function
<a href="appendixc.htm#mstep"> MSTEP</a> to perform one step of integration. N is the number of first-order
differential equations, Y and DY are arrays of length  7N
as used by function MSTEP<!--hbox-->. DIF is the name of the function used to calculate
the right-hand sides of the equations. H is the step size and T is
the value of the independent variable at which the solution is required.
REPS is the specified
accuracy. This function does not check for the truncation error, but
the parameter REPS is used to check for the convergence of corrector
iteration. NSTP is the number of function evaluations used so far.
This number is updated by the function.
IJ, IJM1, IJM2, IJM3 and IJM4 are respectively, the indices j+1, j, j&#8722;1,
j&#8722;2 and j&#8722;3 in the corrector formula. IFLAG is an integer variable used
as a flag. If IFLAG=0, initial approximation to the Jacobian
is generated, otherwise the old approximation is used. In any case,
Broyden's method will be used to update the initial approximation to
the inverse of the Jacobian. If IFLAG=0, it is set to 1 after
calculation of Jacobian so that the Jacobian is not calculated again
next time.
WK1 is an array of length 3N used to pass predicted values.
WK is an array of length <span class="roman">N</span><sup>2</sup> used to store the inverse of the
Jacobian.
Error status can be obtained from the
returned value of GEAR<!--hbox-->. A value of 729 implies that
the corrector iteration fails to converge.
Function DIF as described in write-up for <a href="appendixc.htm#mstep"> MSTEP</a> must be supplied by
the user. This function also requires
function <a href="appendixc.htm#gauelm"> GAUELM</a> to solve systems of linear equations.
The parameter CFAC in the function may need to be reduced if the
function MSTEP needs to adjust the step size too often.

<div class="p"><!----></div>
 <br /><br /><a name="extp"> </a>
 <b>196.&nbsp;EXTP&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/extp.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/extp.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve initial value problems in ordinary
differential equations using extrapolation method. This function accepts
a system of first-order differential equations. N is the number
of first-order equations. Y is an array of length  N,
which should contain the initial values of solution at input.
After successful execution, it will contain the solution at the 
required point. If the execution is aborted in between, then it
will contain the solution at some intermediate point T0, up to where
the integration was successful. DY is an array of length 
N containing the first derivative of the solution. The first derivative
need not be supplied at the time of calling. DIF is the name
of the external function, which is invoked for calculating the right-hand
sides of the differential equations <b>y</b>&#8242;=<b>f</b>(t,<b>y</b>).
H is the initial step size to be tried. The function will adjust
the step size if necessary, using the crude technique described in Section&nbsp;12.5. After execution, H will contain the current value of the step size.
T0 is the initial value of the independent variable t, at which the
initial conditions are specified. After execution, the value of T0
will be updated to the point, up to which the integration is successful.
TN is the value of t at which the solution is required. If
the integration is successful, then T0 will be set equal to TN<!--hbox-->. Thus,
if the solution is required at several points, then the function can
be called repeatedly after changing TN between every call. Other
variables need not be changed. REPS is the required relative accuracy
in each component of the solution. This function only tries to
estimate the local truncation error. Hence, the computed solution
may not be correct to the specified accuracy. NSTEP is the number of function
evaluations used by the function. This number is initialised to zero
at every call to EXTP<!--hbox-->. Thus if EXTP is called repeatedly, then the
total number of function evaluations used will need to be accumulated
separately.
NMAX is the maximum number of function
evaluations that the function is allowed to use. If NMAX &#8804; 0,
then a default value of NMX (=100000) will be used.
IFLG is an integer variable used
to decide which type of extrapolation is to be used. If IFLG=0,
then polynomial extrapolation is used, otherwise rational function
extrapolation is used.
Error status can be obtained from the
returned value of EXTP<!--hbox-->. A value of 703 implies that
<span class="roman">N</span> &#8804; 0, in which case, no calculations are performed.
EXTP=730 implies that step size has become smaller
than REPS&#124;TN&#8722;T0&#124;. If in a small region the step
size is actually expected to be smaller than this limit, then the
corresponding statement in the function may be modified.
EXTP=731 implies that the
step size is too small for the arithmetic used (i.e.,
<span class="roman">H</span> &lt; &#295;&#124;<span class="roman">T</span><span class="roman">0</span>&#124;) and the calculations
are aborted.  EXTP=732
implies that the integration could not be completed in the specified number
(NMAX) of steps. EXTP=733 implies that the denominator in the
rational function extrapolation is zero.
The failure of this function can arise either
because of singularity, or stiffness, or because the specified accuracy
is too high. For rational function extrapolation, the failure can also
be due to the fact that denominator has become zero.
In this case, polynomial extrapolation can be tried.
The function DIF(T, N, Y, DY) must be supplied by the user to calculate the
right-hand sides of the equations, i.e., the derivatives <span class="roman">Y</span>&#8242;.
Here T is the value of independent variable
and  N is the number of equations.
Y is the array containing the dependent variables at time t=<span class="roman">T</span>,
where the derivatives need to be evaluated.
DY is the array which will contain the calculated value of the derivatives.
DY[i] should contain <span class="roman">Y</span>&#8242;[i]=f<sub>i</sub>(<span class="roman">T</span><span class="roman">,</span> <span class="roman">Y</span>).

<div class="p"><!----></div>
 <br /><br /><a name="fdm"> </a>
 <b>197.&nbsp;FDM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/fdm.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fdm.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a two-point boundary value problem
with separable boundary conditions,
using finite difference method as explained in Section&nbsp;12.8. If a uniform mesh is used, then it is also possible to estimate the first-order
correction, using the method of deferred correction. N is the number of
mesh points to be used. M is the number of
first-order differential equations in the system. ML is the number of
boundary conditions at the first boundary (i.e., T[0]). PAR is an
array which is passed on to the function EQN and BCS for calculating
the required information about the equation and the boundary 
conditions. This array can be used to pass any parameters that may
be required by these functions. This array is not used by function
FDM, or any other function called by it except EQN and BCS, and its
size can be arbitrary depending on the requirements. X is an array
of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which should contain the initial guess
for the solution. After execution, it will contain the computed solution.
If the problem is linear, then there is no need for initial approximation
and this array could be initialised to zero or any other convenient
value. The function FDM treats it as a two-dimensional array of
dimension X[N][M] with X[J][I] containing the Ith component at Jth
mesh point. Unfortunately, there is no provision to pass the second
dimension of the array X, as specified in the calling function. Hence,
to obtain meaningful results, the second dimension of the array X in the calling
function must also be exactly equal to M<!--hbox-->. This problem arises because, while
solving the finite difference equations, it is convenient to assume that
the array elements are stored in consecutive positions without any gaps.
XC is also an array of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which will
contain the solution after applying the deferred correction. This array is also
stored in the same format as the array X and the same remarks apply here
too. Even if deferred correction is not requested, this array should be provided,
since it is also used as a scratch space during the computations. The
difference <span class="roman">XC</span><span class="roman">[</span><span class="roman">J</span><span class="roman">]</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span>&#8722;<span class="roman">X</span><span class="roman">[</span><span class="roman">J</span><span class="roman">]</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> gives an estimate of the truncation error
in X[J][I] provided the deferred correction is calculated.
T is an array of length  N, containing the mesh points
t<sub>j</sub>, (j=0,&#8230;,<span class="roman">N</span>&#8722;1), to be used in the finite difference approximation.
This array must be supplied by the user. If deferred correction is required,
then the mesh must be uniformly spaced, otherwise spacing can be arbitrary.
In any case, the mesh points t<sub>j</sub> must be in either ascending or descending
order.
EQN is the name of the function, which defines the differential equations.
The differential equation is assumed to be in the
form B<b>y</b>&#8242;=<b>f</b>(t,<b>y</b>), where B is a <span class="roman">M</span>&times;<span class="roman">M</span>
matrix and <b>f</b> is a vector function of length M<!--hbox-->. The matrix B
must be nonsingular. The elements of B and <b>f</b> at a given point T
are calculated by the function EQN<!--hbox-->. Apart from this, it
must also calculate the Jacobian &#8706;f<sub>i</sub>/&#8706;y<sub>j</sub> (stored in the
array A). BCS is
the name of the function, which specifies the boundary conditions.
The boundary conditions are defined by functions g<sub>i</sub>(t<sub>0</sub>,<b>y</b><sub><b>0</b></sub><b>)</b><b>=</b><b>0</b> for
i=0,&#8230;,<span class="roman">ML</span>&#8722;1 at the first point t=<span class="roman">T</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>, and
g<sub>i</sub>(t<sub>N&#8722;1</sub>,<b>y</b><sub><b>N</b>&#8722;<b>1</b></sub><b>)</b><b>=</b><b>0</b> for i=<span class="roman">ML</span>,&#8230;,<span class="roman">M</span>&#8722;1 at the last point
t=<span class="roman">T</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span>. Apart from the functions g<sub>i</sub>, this function should
also calculate the Jacobian matrix &#8706;g<sub>i</sub>/&#8706;y<sub>j</sub> (stored in the
array BC). The general form of these functions is as follows:

<div class="p"><!----></div>
<br /><tt><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;void eqn(int j, int m, int ml, double par[], double *a, 
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
      double *b, double y[], double f[], double t)
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   {
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       int i,k,m1;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       m1=m+ml;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       for(i=0; i&lt;m; ++i) {
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           f[i]=f<sub>i</sub>(<span class="roman">t</span><span class="roman">,</span><span class="roman">par</span><span class="roman">,</span><span class="roman">y</span><span class="roman">)</span>;
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           for(k=0; k&lt;m; ++k) {
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
               a[k+i*m1]=<span class="roman">&#8706;f<sub>k</sub>/&#8706;y[i]</span>;
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
               b[k+i*m1]=<span class="roman">b<sub>ki</sub>(<span class="roman">t</span>,par)</span>;
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       return;
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   }
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   void bcs(int m, int ml, double par[], double *bc, double g[],
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
       double t1, double tn, double y1[], double yn[])
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   {
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       int i,k,m1;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       m1=m+ml;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       for(i=0; i&lt;m; ++i) {
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           if(i&lt;ml) g[i]=<span class="roman">g<sub>i</sub>(<span class="roman">t</span><span class="roman">1</span>,par,<span class="roman">y</span><span class="roman">1</span>)</span>;

<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  else g[i]=g<sub>i</sub>(<span class="roman">tn</span>,par,<span class="roman">yn</span>); 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           for(k=0; k&lt;m; ++k) bc[i+k*m1]=<span class="roman">&#8706;g<sub>i</sub>/&#8706;<span class="roman">y</span><span class="roman">[</span><span class="roman">k</span><span class="roman">]</span></span>;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       return;
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   }
<div class="p"><!----></div>
</tt>It should be noted that the second dimension of A, B and BC is
<span class="roman">M</span>+<span class="roman">ML</span> instead of <span class="roman">M</span>. Here T, T1 (=<span class="roman">T</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>)
and TN (=<span class="roman">T</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span>) are the values
of t at relevant points, while the arrays Y, Y1 and YN contain
the values of <b>y</b> at these points. In function EQN the parameter
J identifies the interval at which the functions are evaluated (i.e.,
<span class="roman">T</span>=(t<sub>J</sub>+t<sub>J+1</sub>)/2).
This index is useful in cases, where the coefficients
are read in the form of a table.

<div class="p"><!----></div>
IFLAG is an integer
variable which is used as a flag. If IFLAG=0 or 1, then the
equation is treated as nonlinear and solution will be calculated
iteratively. If IFLAG=2 or 3, then the equations are treated
as linear and calculation will be terminated after the first iteration.
If IFLAG=0 or 2, then the first-order correction will be calculated
using the method of deferred correction. For other values of IFLAG, the
deferred correction will not be calculated. The deferred correction can be
calculated only if the mesh spacing is uniform and the number of points
N is at least five. REPS is the specified
accuracy. This parameter is only used to check for the convergence
of Newton's method, for solution of finite difference equations
(only for nonlinear equations i.e., IFLAG=0,1). This parameter
has no effect on truncation error, which is determined by the mesh spacing.
The truncation error can be estimated by the difference between X and
XC, if deferred correction is used.
Error status can be obtained from the
returned value of FDM<!--hbox-->. A value of 704 implies that <span class="roman">N</span> &lt; 3,
or <span class="roman">M</span> &#8804; <span class="roman">ML</span>, or <span class="roman">ML</span> &#8804; 0, in which case, no calculations
are performed. FDM=734 implies that <span class="roman">N</span> &#8804; 4 and deferred
correction is requested. In this case, the deferred correction is not
calculated. FDM=735 implies that the finite difference matrix
is singular and the solution cannot be obtained. This problem may be due
to some error in specifying the equation matrix or boundary conditions.
FDM=736 implies that the mesh spacing is not
uniform, in which case, the deferred correction will not be calculated.
FDM=737 implies that the Newton's iteration
for solving the finite difference equations fails to converge.
This function requires function <a href="appendixc.htm#setmat"> SETMAT</a> for setting up the matrix of
finite difference equations, and function <a href="appendixc.htm#gaublk"> GAUBLK</a> to solve the system of
linear equations defined by the block matrix as explained in Section&nbsp;12.8. Apart from these, the functions EQN and BCS specifying the problem must
be supplied by the user.

<div class="p"><!----></div>
 <br /><br /><a name="gevp"> </a>
 <b>198.&nbsp;GEVP&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gevp.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/gevp.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a generalised eigenvalue problem for
a system of differential equations, with separable boundary conditions,
using finite difference method as explained in Section&nbsp;12.9. If a uniform mesh is used, then it is also possible to estimate the first-order
correction to the eigenvalue, using the method of deferred correction. 
N is the number of mesh points to be used. M is the number of
first-order differential equations in the system. ML is the number of
boundary conditions at the first boundary (i.e., T[0]). PAR is an
array which is passed on to the functions EQN, EQND, BCS and BCSD
for calculating
the required information about the equation and the boundary 
conditions. The first element of PAR is used to pass the eigenvalue
and hence it should not be used for any other purpose. After execution,
PAR[0] will contain the calculated eigenvalue without applying the deferred correction.
Other elements of this array can be used to pass any parameter that may
be required by these functions. Other elements of the array are not
used by function
GEVP or any other function called by it except EQN, BCS, EQND and BCSD,
and its
size can be arbitrary depending on the requirements. X is an array
of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which 
will contain the computed eigenfunction. Even if the eigenfunction is
not required, this array should be provided.
The function GEVP treats it as a two-dimensional array of
dimension X[N][M], with X[J][I] containing the Ith component at Jth
mesh point. Unfortunately, there is no provision to pass the second
dimension of the array X as specified in the calling function. Hence,
to obtain meaningful results, the second dimension of the array X in the calling
function must also be exactly equal to M<!--hbox-->. This problem arises, because while
solving the finite difference equations it is convenient to assume that
the array elements are stored in consecutive positions without any gaps.
XC is also an array of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which will
contain the left eigenvector of the finite difference matrix, which is
required for calculating the deferred correction. This array is also
stored in the same format as the array X and the same remarks apply here
too. Even if deferred correction is not requested, this array should be provided,
since it is also used as a scratch space during the computations. 
T is an array of length  N, containing the mesh points
t<sub>j</sub> for j=0,&#8230;,<span class="roman">N</span>&#8722;1 to be used in the finite difference approximation.
This array must be supplied by the user. If deferred correction is required,
then the mesh must be uniformly spaced, otherwise spacing can be arbitrary.
In any case, the mesh points t<sub>j</sub> must be in either ascending or descending
order.
E0 is the initial guess for the eigenvalue. After execution, E0 will
contain the corrected eigenvalue, provided deferred correction is calculated.

<div class="p"><!----></div>
EQN is the name of the function which defines the differential equation.
The differential equation is assumed to be in the
form B<b>y</b>&#8242;=A<b>y</b>, where A and B are <span class="roman">M</span>&times;<span class="roman">M</span>
matrices. The matrix B must be nonsingular.
The elements of A and B which could be arbitrary functions
of the eigenvalue &#955; and t,
are calculated by the function EQN<!--hbox-->. BCS is
the name of the function which specifies the boundary conditions.
The boundary conditions are defined by C<sub>1</sub><b>y</b><sub><b>0</b></sub><b>=</b><b>0</b>,
and C<sub>N</sub><b>y</b><sub><b>N</b>&#8722;<b>1</b></sub><b>=</b><b>0</b>, where C<sub>1</sub> and C<sub>N</sub> are <span class="roman">ML</span>&times;<span class="roman">M</span> 
and <span class="roman">(</span><span class="roman">M</span>&#8722;<span class="roman">ML</span><span class="roman">)</span>&times;<span class="roman">M</span> matrices, respectively.
These matrices are combined
in one <span class="roman">M</span>&times;<span class="roman">M</span> matrix BC, the first ML rows of which correspond
to the boundary conditions at the first boundary (t=<span class="roman">T</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>), while
the remaining rows refer to boundary conditions at the last point
(t=<span class="roman">T</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span>). EQND is the name of the function to calculate the
derivatives of matrices A and B (as defined in EQN) with respect to the
eigenvalue &#955;. Similarly, BCSD is the name of the function to calculate
the derivatives of matrix BC (as defined in BCS) with respect to the
eigenvalue &#955;. Following the C convention the indices of
arrays A, B and BC are interchanged as compared to the Fortran
subprogram, thus the rows are really columns. The order of index
should be clear from the form of functions given below.
If deferred correction is not required, then the
functions EQND and BCSD are not called, but in order to satisfy the
compiler and the linker, dummy functions may be required.
The general form of these functions is as follows:

<div class="p"><!----></div>
<br /><tt><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;void eqn(int j, int m, int ml, double par[], double *a, 
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
       double *b, double y[], double f[], double t)
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   {
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       int i,k,m1;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       m1=m+ml;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       for(i=0; i&lt;m; ++i) {
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           f[i]=0.0;
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           for(k=0; k&lt;m; ++k) {
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
               a[k+i*m1]=<span class="roman">a<sub>ki</sub>(<span class="roman">t</span><span class="roman">,</span><span class="roman">par</span><span class="roman">)</span></span>;
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
               b[k+i*m1]=<span class="roman">b<sub>ki</sub>(<span class="roman">t</span><span class="roman">,</span><span class="roman">par</span><span class="roman">)</span></span>;
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       return;
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   }
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   void bcs(int m, int ml, double par[], double *bc, double g[],
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
       double t1, double tn, double y1[], double yn[])
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   {
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       int i,k,m1;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       m1=m+ml;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       for(i=0; i&lt;m; ++i) {
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           g[i]=0.0;
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           for(k=0; k&lt;m; ++k) {
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
               if(i&lt;ml) bc[i+k*m1]=<span class="roman">bc<sub>ik</sub>(<span class="roman">t</span><span class="roman">1</span>,par)</span>;
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
               else bc[i+k*m1]=bc<sub>ik</sub>(<span class="roman">tn</span>,par); 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       return;
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   }
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   void eqnd(int j, int m, int ml, double par[], double *a, 
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
      double *b, double t)
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   {
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       int i,k,m1;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       m1=m+ml;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       for(i=0; i&lt;m; ++i) {
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           for(k=0; k&lt;m; ++k) {
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
               a[k+i*m1]=<span class="roman">&#8706;a<sub>ki</sub>(<span class="roman">t</span><span class="roman">,</span><span class="roman">par</span><span class="roman">)</span><span class="roman">/</span>&#8706;<span class="roman">par</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span></span>;
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
               b[k+i*m1]=<span class="roman">&#8706;b<sub>ki</sub>(<span class="roman">t</span><span class="roman">,</span><span class="roman">par</span><span class="roman">)</span><span class="roman">/</span>&#8706;<span class="roman">par</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span></span>;
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       return;
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   }
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   void bcsd(int m, int ml, double par[], double *bc,
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
       double t1, double tn)
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   {
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       int i,k,m1;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       m1=m+ml;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       for(i=0; i&lt;m; ++i) {
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           for(k=0; k&lt;m; ++k) {
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
               if(i&lt;ml) bc[i+k*m1]=<span class="roman">&#8706;bc<sub>ik</sub>(<span class="roman">t</span><span class="roman">1</span>,par)/&#8706;par[0]</span>;
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
               else bc[i+k*m1]=&#8706;bc<sub>ik</sub>(<span class="roman">tn</span>,par)/&#8706;par[0]; 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       return;
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   }
<div class="p"><!----></div>
</tt>It should be noted that the second dimension of A, B and BC is
<span class="roman">M</span>+<span class="roman">ML</span> instead of <span class="roman">M</span>. Here T, T1 (=<span class="roman">T</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>)
and TN (=<span class="roman">T</span><span class="roman">[</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">]</span>) are the values
of t at relevant points. The arrays Y, Y1, YN, F and G are not
really required for eigenvalue problem, but are provided for consistency.
Thus, in EQN and BCS, F[I] and G[I]
should be set to zero in order to be consistent with function <a href="appendixc.htm#fdm"> FDM</a>, since
the same function <a href="appendixc.htm#setmat"> SETMAT</a> is used in both cases.
In functions EQN and EQND, the parameter
J identifies the interval at which the functions are evaluated (i.e.,
<span class="roman">T</span>=(t<sub>J</sub>+t<sub>J+1</sub>)/2). This index is useful in cases, where the coefficients
are read in the form of a table.

<div class="p"><!----></div>
IFLAG is an integer
variable which is used as a flag. If IFLAG=0, then only
the eigenvalue is calculated. If IFLAG=1, then eigenvector
is also calculated, using the method of inverse iteration.
If IFLAG=2, then the first-order correction to the eigenvalue
is also calculated,
using the method of deferred correction. The deferred correction can be
calculated only if the mesh spacing is uniform and the number of mesh
points N is at least five. REPS is the specified
accuracy. This parameter is only used to check for the convergence
of Muller's method (or secant method) for finding zeros of the
determinant, and the inverse
iteration method for finding eigenvectors. This parameter
has no effect on the truncation error, which is determined by the mesh spacing.
If deferred correction is used, then the difference <span class="roman">E</span><span class="roman">0</span>&#8722;<span class="roman">PAR</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>
will give an estimate of the truncation error in PAR[0]. EL and EU
respectively, specify the lower and upper limit on eigenvalue.
These parameters are used to specify the region in which the eigenvalues
are to be searched. These parameters are passed on to function <a href="appendixc.htm#secani"> SECANI</a>,
(or <a href="appendixc.htm#muler2"> MULER2</a>)
which terminates the iteration if at any stage it goes outside the
specified limits.
Error status can be obtained from the
returned value of GEVP<!--hbox-->. A value of 704 implies that <span class="roman">N</span> &lt; 3,
or <span class="roman">M</span> &#8804; <span class="roman">ML</span> or <span class="roman">ML</span> &#8804; 0. In this case, no calculations
are performed.
GEVP=734 implies that <span class="roman">N</span> &#8804; 4 and deferred
correction is requested. In this case, the deferred correction is not
calculated. 
GEVP=735 implies that
one of the pivots has vanished during the calculation and hence the
eigenvector cannot be calculated. In this case, the eigenvalue will be
calculated.
This problem can be avoided by perturbing the eigenvalue slightly and 
recalculating the determinant before calculating the eigenvector.
GEVP=736 implies that the mesh spacing is not
uniform, in which case the deferred correction will not be calculated.
GEVP=738 implies that the eigenvector vanishes,
in which case the calculations are terminated. In this case also the eigenvalue
is already calculated and will be stored in PAR[0]. 
GEVP=739 implies that the inverse iteration
for calculating the eigenvector failed to converge.
GEVP=740 implies that the inverse iteration
for calculating the left eigenvector failed to converge.
Apart from these, other values may be set by function SECANI
(or MULER2),
which is called to find zeros of the determinant.
The function GEVP requires function <a href="appendixc.htm#setmat"> SETMAT</a> for setting up the matrix of
finite difference equations, and function <a href="appendixc.htm#gaublk"> GAUBLK</a> to solve the system of
linear equations, or to calculate the determinant of the block matrix 
as explained in Section&nbsp;12.8. Function <a href="appendixc.htm#muler2"> MULER2</a>, <a href="appendixc.htm#secani"> SECANI</a> or any other equivalent function
is required for finding zeros of the determinant. It may be noted that
function MULER2 requires the function to be complex, but if we want
to avoid unnecessary use of complex arithmetic for calculating real
eigenvalues, then we can take the real part of CX and calculate the real
function DET and pass it back to MULER2 in the complex variable CF<!--hbox-->.
In principle, such a procedure can lead to trouble, if the iterates
become complex at some stage and the next iterate has the same real part.
This problem can be avoided if SECANI is used.
Both SECANI and MULER2 use reverse communication technique and hence
the control is passed back to GEVP when a function evaluation is
required.
Apart from these, the functions EQN, EQND, BCS and BCSD specifying the 
problem must be supplied by the user.

<div class="p"><!----></div>
 <br /><br /><a name="gaublk"> </a>
 <b>199.&nbsp;GAUBLK&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/gaublk.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fdm.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a system of linear equations involving
finite difference matrix of the form described in Section&nbsp;12.8. This function uses
Gaussian elimination with partial pivoting. N is the number of
mesh points, M is the number of first-order differential equations in the
system. ML is the number of boundary conditions at the first boundary.
A is an array of length  (<span class="roman">M</span><span class="roman">+</span><span class="roman">ML</span>)&times;2<span class="roman">M</span>&times;<span class="roman">N</span> containing the matrix (Section&nbsp;12.8). IFLG is an integer variable used as a flag.
If IFLG=0, the function performs elimination as well as the 
solution of linear
equations. If IFLG=1, then only the elimination is performed.
In both these cases, the determinant is calculated and IFLG is set to 2.
If IFLG=2,
then it is assumed that elimination is already performed and the
triangular factors are stored in the same array A<!--hbox-->. In this case, only the
linear equations are solved. DET is a variable specifying the
scaled value
of the determinant, IDET is an integer variable which contains the
exponent part of the determinant. The actual value of the
determinant is <span class="roman">DET</span>&times;2<sup><span class="roman">IDET</span></sup>. INC is an integer array of
length  <span class="roman">M</span>&times;<span class="roman">N</span>, which contains information about
row interchanges used during Gaussian elimination. X is an
array of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which should contain
the right-hand sides of the linear equations. After execution, the solution
will be returned in the same array.
Error status can be obtained from the
returned value of GAUBLK<!--hbox-->. A value of 735 implies that
one of the pivots vanishes during
elimination and hence the equations cannot be solved. In this
case, the determinant will vanish, but that does not cause any
problem for finding eigenvalues, which are obtained by finding zeros
of the determinant. This function is called by functions <a href="appendixc.htm#fdm"> FDM</a> and <a href="appendixc.htm#gevp"> GEVP</a><!--hbox-->.

<div class="p"><!----></div>
 <br /><br /><a name="setmat"> </a>
 <b>200.&nbsp;SETMAT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/setmat.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fdm.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to setup the finite difference matrix for a
system of first-order differential equations with separable boundary
conditions, using a central difference approximation. This function
is called by functions <a href="appendixc.htm#fdm"> FDM</a> and <a href="appendixc.htm#gevp"> GEVP</a><!--hbox-->. N is the number
of mesh points, M is the number of first-order differential equations
in the system, ML is the number of boundary conditions at the first
boundary. A is an array of length  (<span class="roman">M</span><span class="roman">+</span><span class="roman">ML</span>)&times;2<span class="roman">M</span>&times;<span class="roman">N</span>, which will contain the finite difference matrix
for the linearised equations. BC is an array of length 
(<span class="roman">M</span><span class="roman">+</span><span class="roman">ML</span>)&times;(<span class="roman">M</span>+1), which is used to store information
about the boundary conditions. X and XC are arrays of length
<span class="roman">M</span>&times;<span class="roman">N</span>. X should contain the approximation
to solution of the boundary value problem, while after execution,
XC will contain the right-hand sides of the finite difference equations.
X[J][I] should contain the Ith component at Jth mesh point.
T is an array of length  N containing the mesh points.
PAR is an array containing parameters, which are passed on to the
functions EQN and BCS<!--hbox-->. EQN and BCS are the names
of functions for defining the differential equation and
the boundary conditions, respectively. These functions must be supplied
by the user, as explained in the write up for functions <a href="appendixc.htm#fdm"> FDM</a> or <a href="appendixc.htm#gevp"> GEVP</a><!--hbox-->.
The returned value of the function is always zero.

<div class="p"><!----></div>
 <br /><br /><a name="bspode"> </a>
 <b>201.&nbsp;BSPODE&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/bspode.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/bspode.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a two-point boundary value problem
with separable boundary conditions,
using expansion method with B-spline basis functions
as explained in Section&nbsp;12.10. NK is the number of knots to be used.
K is the order of B-splines to be used. <span class="roman">K</span>=4 corresponds to cubic
B-splines, while <span class="roman">K</span>=2 gives linear B-splines, etc. The order may
need to be increased to get higher accuracy.
M is the number of
first-order differential equations in the system. ML is the number of
boundary conditions at the first boundary (i.e., T[0]). PAR is an
array which is passed on to the function EQN and BCS for calculating
the required information about the equation and the boundary 
conditions. This array can be used to pass any parameters that may
be required by these functions. This array is not used by function
BSPODE, or any other function called by it except EQN and BCS, and its
size can be arbitrary depending on the requirements. X is an array
of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which 
will contain the computed solution. X[J][I] will contain the Ith component
of solution at TX[J]. The second dimension of X must be equal to M in
the calling function.
A is an array of length (<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)&times;<span class="roman">M</span> containing
the coefficients of expansion in terms of B-splines. At the time of
calling it should contain the initial guess to the coefficients, while
after execution it will contain the calculated coefficients.
If the problem is linear, then there is no need for initial approximation
and this array could be initialised to zero or any other convenient
value. The function BSPODE treats it as a two-dimensional array of
dimension A[<span class="roman">M</span>][<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2] with A[J][I] containing the
coefficient of Ith basis function in Jth component of the solution.

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">X</span><sub>j</sub>(t)=</td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;3</small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">A</span>[j][i]&#981;<sub>i</sub>(t),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j=0,&#8230;,<span class="roman">M</span>&#8722;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.89)</td></tr></table>
</td></tr></table>


Unfortunately, there is no provision to pass the second
dimension of the array X or A, as specified in the calling function.
Hence,
to obtain meaningful results, the second dimension of the array A in the calling
function must also be exactly equal to <span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2.
This problem arises because, while
solving the system of equations, it is convenient to assume that
the array elements are stored in consecutive positions without any gaps.
T is an array of length  NK, containing the knots
t<sub>j</sub>, (j=0,&#8230;,<span class="roman">NK</span>&#8722;1), to be used for calculating the B-spline
basis functions.
This array must be supplied by the user. The knots must be in ascending
order with T[0] and T[NK&#8722;1] as the two boundaries.
N is the number of mesh points to be used for obtaining the equations
connecting the coefficients of expansion, <span class="roman">N</span> &#8805; <span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2.
TX is an array of length N containing the mesh points
to be used for calculating the coefficients. This array must be supplied
by the user if IFLAG &gt; 1, otherwise the function computes the
elements of this array assuming uniform spacing and covering the
interval T[0] to T[NK&#8722;1]. The solution will be calculated at all these
points. If the solution is required at any other point then function
<a href="appendixc.htm#bspevl"> BSPEVL</a> can be used with the calculated coefficients.
EQN is the name of the function, which defines the differential equations.
The differential equation is assumed to be in the
form B<b>y</b>&#8242;=<b>f</b>(t,<b>y</b>), where B is a <span class="roman">M</span>&times;<span class="roman">M</span>
matrix and <b>f</b> is a vector function of length M<!--hbox-->. The matrix B
must be nonsingular. The elements of B and <b>f</b> at a given point T
are calculated by the function EQN<!--hbox-->. Apart from this, it
must also calculate the Jacobian &#8706;f<sub>i</sub>/&#8706;y<sub>j</sub> (stored in the
array A). BCS is
the name of the function, which specifies the boundary conditions.
The boundary conditions are defined by functions g<sub>i</sub>(t<sub>0</sub>,<b>y</b><sub><b>0</b></sub><b>)</b><b>=</b><b>0</b> for
i=0,&#8230;,<span class="roman">ML</span>&#8722;1 at the first point t=<span class="roman">T</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>, and
g<sub>i</sub>(t<sub>NK&#8722;1</sub>,<b>y</b><sub><b>NK</b>&#8722;<b>1</b></sub><b>)</b><b>=</b><b>0</b> for i=<span class="roman">ML</span>,&#8230;,<span class="roman">M</span>&#8722;1 at the last point
t=<span class="roman">T</span><span class="roman">[</span><span class="roman">NK</span>&#8722;<span class="roman">1</span><span class="roman">]</span>. Apart from the functions g<sub>i</sub>, this function should
also calculate the Jacobian matrix &#8706;g<sub>i</sub>/&#8706;y<sub>j</sub> (stored in the
array BC). The general form of these functions is as follows:

<div class="p"><!----></div>
<br /><tt><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;void eqn(int j, int m, int ml, double par[], double *a, 
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
      double *b, double y[], double f[], double t)
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   {
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       int i,k;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       for(i=0; i&lt;m; ++i) {
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           f[i]=f<sub>i</sub>(<span class="roman">t</span><span class="roman">,</span><span class="roman">par</span><span class="roman">,</span><span class="roman">y</span><span class="roman">)</span>;
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           for(k=0; k&lt;m; ++k) {
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
               a[k+i*m]=<span class="roman">&#8706;f<sub>k</sub>/&#8706;y[i]</span>;
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
               b[k+i*m]=<span class="roman">b<sub>ki</sub>(<span class="roman">t</span>,par)</span>
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       return;
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   }
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   void bcs(int m, int ml, double par[], double *bc, double g[],
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
       double t1, double tn, double y1[], double yn[])
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   {
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       int i,k;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       for(i=0; i&lt;m; ++i) {
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           if(i&lt;ml) g[i]=<span class="roman">g<sub>i</sub>(<span class="roman">t</span><span class="roman">1</span>,par,<span class="roman">y</span><span class="roman">1</span>)</span>;
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           else g[i]=g<sub>i</sub>(<span class="roman">tn</span>,par,<span class="roman">yn</span>); 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
           for(k=0; k&lt;m; ++k) bc[i+k*m]=<span class="roman">&#8706;g<sub>i</sub>/&#8706;<span class="roman">y</span><span class="roman">[</span><span class="roman">k</span><span class="roman">]</span></span>;
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       }
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
       return;
<br /><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
   }
<div class="p"><!----></div>
</tt>It should be noted that these functions are same as those required by
<a href="appendixc.htm#fdm"> FDM</a> except that
the second dimension of arrays A, B and BC is
<span class="roman">M</span> instead of <span class="roman">M</span><span class="roman">+</span><span class="roman">ML</span>.
Here T, T1 (=<span class="roman">T</span><span class="roman">[</span><span class="roman">0</span><span class="roman">]</span>) and TN (=<span class="roman">T</span><span class="roman">[</span><span class="roman">NK</span>&#8722;<span class="roman">1</span><span class="roman">]</span>) are the values
of t at relevant points, while the arrays Y, Y1 and YN contain
the values of <b>y</b> at these points. In function EQN the parameter
J identifies the interval at which the functions are evaluated (i.e.,
TX[j]). This index is useful in cases, where the coefficients
are read in the form of a table.

<div class="p"><!----></div>
IFLAG is an integer
variable which is used as a flag. If IFLAG=0 or 2, then the
equation is treated as nonlinear and solution will be calculated
iteratively. If IFLAG=1 or 3, then the equations are treated
as linear and calculation will be terminated after the first iteration.
If IFLAG=0 or 1, then the array TX need not be initialised at
the time of calling as the function will compute the elements
assuming uniform spacing. 
For other values of IFLAG, the array TX must be supplied by the user.
REPS is the specified
accuracy. This parameter is only used to check for the convergence
of Newton's method, for solution of system of equations
(only for nonlinear equations i.e., IFLAG=0,2). This parameter
has no effect on truncation error, which is determined by the knots
and the order of B-splines.
Error status can be obtained from the
returned value of BSPODE<!--hbox-->. A value of 705 implies that <span class="roman">N</span> &lt; 3,
or <span class="roman">M</span> &#8804; <span class="roman">ML</span>, or <span class="roman">ML</span> &#8804; 0, or <span class="roman">N</span> &lt; <span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2,
in which case, no calculations
are performed. 
BSPODE=741 implies that the Newton's iteration
for solving the system of equations fails to converge.
This function requires function <a href="appendixc.htm#bsplin"> BSPLIN</a>, <a href="appendixc.htm#bspevl"> BSPEVL</a>, <a href="appendixc.htm#svd"> SVD</a> and <a href="appendixc.htm#svdevl"> SVDEVL</a>.
Apart from these, the functions EQN and BCS specifying the problem must
be supplied by the user.

<div class="p"><!----></div>
 

<br /><br />
<a name="Integral Equations"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.13&nbsp; INTEGRAL EQUATIONS </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#fred">FRED</a></td>
<td>&nbsp; <a href="#fredco">FREDCO</a></td>
<td>&nbsp; <a href="#funk">FUNK</a></td>
<td>&nbsp; <a href="#rls">RLS</a></td>
<td>&nbsp; <a href="#forw">FORW</a></td>
<td>&nbsp; <a href="#volt">VOLT</a></td>
<td>&nbsp; <a href="#volt2">VOLT2</a></td>
</tr>
</table>

<div class="p"><!----></div>
<br /><br /><a name="fred"> </a>
 <b>202.&nbsp;FRED&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/fred.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fred.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a linear Fredholm equation
as defined by Eq.&nbsp;(13.1) using quadrature methods.  M is the number of abscissas to be used in the
quadrature formula. A and B are variables specifying respectively, the
lower and the upper limit of the integral. WT and X are arrays of length
M, which will return the weights and abscissas
used by the quadrature formula.
F and FC are arrays of length  M, which will contain the 
calculated solution. F[I] will contain the computed solution at the abscissa
X[I], while if the trapezoidal rule is used, then FC[I] will contain
the value
obtained after applying deferred correction, using the Gregory's formula
including second-order differences. Array FC is not required for
other quadrature formulae. Hence, in that case, a dummy array of length one
may be provided. FG and FKER are the names of the functions
provided to calculate the functions g(x) and K(x,t). For Fredholm
equation of the third kind g(x) is not required, but a dummy function
giving some nonzero value (e.g., g(x)=1) should be provided. In fact,
this function supplies the starting vector for the inverse iteration
and if necessary a reasonable guess for the eigenfunction may
be provided via this function. However, in most cases, the inverse
iteration method does converge to the eigenvalue, even when initial
vector is far from the eigenvector and such a guess is not essential,
but it can be used to improve the efficiency. EI
gives the initial guess for the eigenvalue of the Fredholm equation
of the third kind. After execution, EI will contain the calculated eigenvalue.
For equations of other kinds, EI will be ignored.

<div class="p"><!----></div>
IQ is an integer variable used to specify the quadrature formula to be used.
If <span class="roman">IQ</span>=1, then trapezoidal rule is used, for <span class="roman">IQ</span>=2,
Simpson's 1/3 rule is used, for <span class="roman">IQ</span>=4, 8, 16, 32 a composite
rule using 4, 8, 16 or 32-point Gauss-Legendre formula is used. If
IQ is negative, then it is assumed that weights and abscissas are supplied
in the arrays WT and X<!--hbox-->. Other
values of IQ will cause an error return. For <span class="roman">IQ</span> &gt; 1 if the number
of points are not compatible with the composite quadrature formula, then
the next lower value of M is used. For example, if <span class="roman">IQ</span>=4 and
<span class="roman">M</span>=11, then computations will be performed using only 8 points, but the
value of M remains unchanged. In this case, a warning is issued by setting
the returned value of FRED to &#8722;11.
IT is an integer variable, which specifies the kind of
Fredholm equation to be solved. <span class="roman">IT</span>=1,2 and 3 corresponds to the
Fredholm equations of the first, second and third kind, respectively.
This function can only find a real eigenvalue.
REPS is a parameter specifying the required (relative) accuracy in calculating
the eigenvalues. This parameter is used only if <span class="roman">IT</span>=3. It is
only passed on to the function INVIT for calculating the eigenvalue.
Error status can be obtained from the
returned value of FRED<!--hbox-->. A value of 706 implies that
<span class="roman">IT</span> &gt; 3, or <span class="roman">IT</span> &#8804; 0, or the number of points M are not
sufficient for application of the specified quadrature formula.
In this case, no calculations are performed.
FRED=707 implies that
the value of IQ is not proper, in which case also no calculations are performed.
FRED=&#8722;11 implies that the number of points have been adjusted.
In this case, the calculations are performed with a smaller value of M,
which is applicable for the quadrature formula requested. Apart from these,
other values may be set by functions GAUELM and INVIT, which are called
by this function. Function FRED requires function <a href="appendixc.htm#gauelm"> GAUELM</a>
to solve the system of linear equations, and function
<a href="appendixc.htm#invit"> INVIT</a> (for <span class="roman">IT</span>=3) to calculate the eigenvalue and the eigenvector.
It should be noted that function INVIT is called with IFLG=0,
which keeps the shift P constant, to ensure convergence to the nearest
eigenvalue. Consequently, the convergence could be rather slow in some
cases. It may be more
efficient to use other values of IFLG, but in that case, the inverse
iteration will not necessarily converge to the nearest eigenvalue.
Functions FG(X) and FKER(X, T) must be supplied by the user.

<div class="p"><!----></div>
 <br /><br /><a name="fredco"> </a>
 <b>203.&nbsp;FREDCO&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/fredco.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fredco.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a linear Fredholm equation of
the first or second kind using the collocation
method. The function is approximated by an expansion of the form
f(x)=&#8721;<sub>i=0</sub><sup><span class="roman">N</span>&#8722;<span class="roman">1</span></sup> a<sub>i</sub>&nbsp;PHI(i,x). The basis functions PHI(I, X) must
be supplied by the user. N is the number of points (which equals the
number of basis functions) to be used in the
collocation method. A and B are variables specifying respectively, the
lower and the upper limit of the integral.
F is an array of length  N, which will contain the 
calculated coefficients of the expansion. F[I] contains the coefficient (a<sub>i</sub>)
of PHI(I, X) in the expansion for the solution. X is an array of length
N, which specifies the points to be used for collocation.
This array must be supplied by the user. REPS and AEPS specify 
the accuracy with which the integrals are to be calculated.
If <span class="roman">IQ</span>=0, then these parameters are passed on to the function
<a href="appendixc.htm#adpint"> ADPINT</a>, while in other cases, these parameters are ignored.
IQ is
an integer variable used to specify the treatment of integrals
required to calculate

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">PSI</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">X</span><span class="roman">)</span>=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>B</small><!--sup
--><br /><br />
<small>A</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">FKER</span><span class="roman">(</span><span class="roman">X</span><span class="roman">,</span> <span class="roman">T</span><span class="roman">)</span>&nbsp;&nbsp;<span class="roman">PHI</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">T</span><span class="roman">)</span>&nbsp;&nbsp;d<span class="roman">T</span>&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.90)</td></tr></table>
</td></tr></table>


If <span class="roman">IQ</span> &#8800; 0, then it is assumed that the function PSI(I, X) is supplied
separately, while if <span class="roman">IQ</span>=0, then the integrals are calculated using
the function ADPINT<!--hbox-->. This function uses external function <a href="appendixc.htm#funk"> FUNK</a>
to calculate the integrand, which in turn requires the functions PHI(I, X) and
FKER(X, T). IT is an integer variable which specifies the kind of
Fredholm equation to be solved. <span class="roman">IT</span>=1 and 2 corresponds to the
Fredholm equations of the first and second kind, respectively.
Error status can be obtained from the
returned value of FREDCO<!--hbox-->. A value of 708 implies that
<span class="roman">IT</span> &gt; 2, or <span class="roman">IT</span> &#8804; 0, or <span class="roman">N</span> &lt; 1,
in which case, no calculations are performed. Apart from these,
other values may be set by the functions GAUELM or ADPINT, which are called
by this function. This function requires function <a href="appendixc.htm#gauelm"> GAUELM</a>
to solve the system of linear equations, functions
<a href="appendixc.htm#adpint"> ADPINT</a> and <a href="appendixc.htm#kronrd"> KRONRD</a> (for <span class="roman">IQ</span>=0) to evaluate the
integrals and function <a href="appendixc.htm#funk"> FUNK</a>(X)
to evaluate the required integrand.
Further, the functions FG(X) (=g(x)), PHI(I, X) (=&#981;<sub>i</sub>(x))
and FKER(X, T) (=K(x,t),
for <span class="roman">IQ</span>=0) or PSI(I, X) (for <span class="roman">IQ</span> &#8800; 0) must be supplied
by the user. Depending on value of IQ, some of these functions may not
be required, but even in that case a dummy function to satisfy the compiler
or linker may be needed.
The names of these functions are fixed and cannot be passed
on to the function FREDCO, because the functions FKER and PHI
are called by the function FUNK, and there is no simple way
of passing on these
names to FUNK<!--hbox-->. In order to maintain consistency, the names of other functions
are also not passed on to the function. The global variables XFRED
and IFRED are used to pass on the value of x and i to FUNK for
calculating the integrand.
This function
can also be used to solve linear Volterra equations, by defining the kernel
to be zero for t &gt; x.

<div class="p"><!----></div>
 <br /><br /><a name="funk"> </a>
 <b>204.&nbsp;FUNK&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/funk.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/fredco.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the integrand for calculating
&#968;<sub>i</sub>(x) as required by function <a href="appendixc.htm#fredco"> FREDCO</a><!--hbox-->. Function FKER(X, T) is the
kernel K(x,t), while PHI(I, T) are the basis functions &#981;<sub>i</sub>(t) used
for the expansion. Names of these functions have to be the same as
there is no provision to pass on the names to FUNK<!--hbox-->.
The values of X and I are passed on through the global variables
XFRED and IFRED.

<div class="p"><!----></div>
 <br /><br /><a name="rls"> </a>
 <b>205.&nbsp;RLS&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/rls.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/rls.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a linear inverse problem in one
dimension using Regularised Least Squares (RLS) technique with B-spline
basis functions. The inverse problem is defined as

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
d<sub>i</sub>=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>b</small><!--sup
--><br /><br />
<small>a</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
K<sub>i</sub>(t)f(t)&nbsp;&nbsp;dt, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=0,1,&#8230;,<span class="roman">NM</span>&#8722;<span class="roman">1</span><span class="roman">;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <span class="roman">(</span><span class="roman">C</span><span class="roman">.</span><span class="roman">91</span><span class="roman">)</span></td></tr></table>
</td></tr></table>


where the unknown function f(t) is to be obtained using given data
d<sub>i</sub> and kernels K<sub>i</sub>(t) for all i. The corresponding forward problem
where d<sub>i</sub> are calculated for a given f(t) is solved by the function
<a href="appendixc.htm#forw"> FORW</a><!--hbox-->. 
The kernel is given in the form
of table of values at a grid of points in t covering the required
interval. Alternately, it is possible to provide directly the coefficients
of matrix which are

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
a<sub>ij</sub>=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>b</small><!--sup
--><br /><br />
<small>a</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
K<sub>i</sub>(t)&#981;<sub>j</sub>(t)&nbsp;&nbsp;dt&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.92)</td></tr></table>
</td></tr></table>


where &#981;<sub>j</sub>(t) is the jth basis function. This form is more
efficient to use and can be utilised when many options are to be
tried with the same data points and set of knots.
The function itself
calculates these integrals and hence during second and subsequent
calls this option can be used, provided the data points and knots
have not been modified. Using the coefficients a<sub>ij</sub> instead of
kernels also saves storage space.
It may be noted
that for this to be useful, d<sub>i</sub> need not have the same values
between different
sets, only the set of NM kernels should be the same between different
inversion problems.
This option is useful as the solution will
need to be calculated with different values of regularisation parameter
before the optimum value is found. This function can also
estimate the errors in computed solution using Monte Carlo
simulation.

<div class="p"><!----></div>
NK is the number of knots defining the B-spline basis functions.
The number of basis functions would be <span class="roman">NK</span>+<span class="roman">K</span>&#8722;2.
XO is an array of length at least  NK
which should contain the knots for defining the B-splines.
The knots must be in ascending order with XO[0] containing the first
knot.
K is the order of B-splines required, <span class="roman">K</span>=2 for linear B-splines
while <span class="roman">K</span>=4 for cubic B-splines, etc. NR is the number of points used
for defining the kernels. R is an array of length NR, which should
contain the points r<sub>i</sub> at which kernel values are available. This array
should be in ascending order. The same set of points are used to
calculate the solution after the coefficients of expansion are obtained.
Hence, this array will be required even if matrix coefficients are
directly available (unless <span class="roman">NR</span>=0). RKER is an array of
length <span class="roman">IK</span>&times;<span class="roman">NR</span> containing the kernels for the
inverse problem. RKER[j][i] should contain K<sub>i</sub>(r<sub>j</sub>). This array
must be supplied if IFLG &lt; 2, otherwise it is not required.
A dummy array may be required to satisfy the compiler, even if IFLG &#8805; 2.
The mesh r<sub>j</sub> need not be uniformly spaced as the integrals are
evaluated using the trapezoidal rule. Since the accuracy of trapezoidal
rule is low and also because in realistic problems the kernels are generally highly
oscillatory, a large number of mesh points will be required to
define the integrals to a good accuracy. IK is the second dimension
of arrays RKER and AC, as specified in the calling function. IK
must be at least <span class="roman">NM</span><span class="roman">+</span><span class="roman">NS</span>. AC is an array of length
<span class="roman">IK</span>&times;(<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) containing the coefficients of the
matrix defining the inversion problem. AC[j][i] should contain
the coefficient a<sub>ij</sub> defined by (<span class="roman">C</span>.92). If IFLG &lt; 2,
these coefficients are calculated by evaluating the integrals in
(<span class="roman">C</span>.92)&nbsp;using the trapezoidal rule. These calculations require
substantial computing and hence on subsequent attempts the
calculations can be suppressed by using IFLG=2, 3. The matrix
coefficients depend on the kernels (and the number of data points)
and the knots and order of
B-splines. Thus if these are not modified between two calls, it
is preferable to use IFLG=2 to find the solution using
pre-calculated coefficients. If either the kernels or basis functions
are modified then IFLG should be reset to 0 to force calculations
of the coefficients once again.

<div class="p"><!----></div>
NM is the number of data points (and kernels) in the inversion problem.
For each data point, the corresponding kernel must be supplied.
NS is the number of points to be used for calculating the regularisation
term. The function chooses a uniform mesh covering the full interval
for this purpose. ALP is the regularisation parameter, which must be
positive. IDE is an integer parameter, which specifies the order
of derivative to be used for regularisation. IDE should be 1 or 2
for first or second derivative smoothing. DI is an array of
length NM, which should contain the data d<sub>i</sub>, for inversion.
DE is an array of length NM, containing the estimated errors in
d<sub>i</sub>. These errors must be positive. DF is an array of length
NM, which will contain the normalised residuals obtained by fit.
If DS[I] is the computed value of DI[I] using the solution, then
the residual DF[I]=(DI[I]&#8722;DS[I])/DE[I]. Ideally, these residuals
should have a Gaussian distribution with zero mean and unit variance.
A significant trend in the residual would generally imply that
ALP should be reduced or number of knots is not sufficient to
represent the solution. F is an array of length NR which will
contain the calculated solution at R[I]. B is an array of length
<span class="roman">NM</span><span class="roman">+</span><span class="roman">NS</span>, which will contain the coefficients of expansion. The computed
solution is

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
f(t)=</td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">B</span>[i]&#981;<sub>i</sub>(t).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.93)</td></tr></table>
</td></tr></table>


These coefficients can be used to compute the solution at any required
point using function <a href="appendixc.htm#bspevl"> BSPEVL</a><!--hbox-->. Although, the number of coefficients is
only <span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>, the rest of the array is used as scratch space.

<div class="p"><!----></div>
IFLG is an integer parameter, which specifies the type of calculation
required. If IFLG=0, the matrix coefficients are computed using the
kernels. The system of equations is solved to find the solution and
IFLG is set to 4 after calculations. The calculation of integrals to
find matrix coefficients take significant time and hence this option
should be used only when the coefficients are not available. After
the first call to RLS, the coefficients are computed and returned in
array AC<!--hbox-->. These coefficients should be used again if another solution
is required with same set of kernels but with different regularisation
(ALP or IDE) or with different data points DI for the same set of kernels.
If IFLG=1, the matrix coefficients are computed using the
kernels. The system of equations is setup and the <a href="appendixc.htm#svd"> SVD</a> of the matrix is
computed, but the solution for given DI is not computed. In this
case also IFLG is set to 4 after calculations. Thus during subsequent
calls solution for different DI's can be computed using <a href="appendixc.htm#svdevl"> SVDEVL</a><!--hbox-->.
If IFLG=2, the matrix coefficients are assumed to be known and
available in array AC<!--hbox-->. These coefficients are used to setup the
matrix and find the solution and IFLG is set to 4 after calculations.
This option is more efficient than IFLG=0, and should be used when
the coefficients have already been computed. In this case the kernels RKER
are not used.
If IFLG=3, the matrix coefficients are assumed to be known and
available in array AC<!--hbox-->. These coefficients are used to setup the
matrix and its SVD is computed, but the solution for given DI is
not computed. In this
case also IFLG is set to 4 after calculations. Thus during subsequent
calls solution for different DI's can be computed using the function SVDEVL<!--hbox-->.

<div class="p"><!----></div>
If IFLG=4, the SVD of equation matrix is assumed to be available in
arrays, A, AV and SIGMA<!--hbox-->. These can be used to compute the solution for
a given data set DI very efficiently. It may be noted that the
matrix of equations depends only on the knots, kernels, regularisation parameters,
(ALP and IDE) and errors DE,
but not
on DI<!--hbox-->. So if only DI is changed there is no need to recompute the
SVD<!--hbox-->. This is very useful, since on many applications several
different data sets have to be inverted. Another application comes
in estimating errors in computed inverse solution. For this purpose
we need to solve the problem with different DI, which differ only
in addition of different realisation of random errors to same
basic data. Thus for estimating the errors in inversion although
several different solutions are required, the net effort is not
much since the SVD, which takes much more time, is computed only once.
It should be noted that in all cases the function sets IFLG to 4
so if during subsequent call the matrix needs to be changed, IFLG
must be set to 0 or 2 before calling. This would be needed if
either the knots, kernels or errors DE are changed. If only 
errors are modified, then IFLG can be set to 2, to avoid
computation of coefficients. While if kernels or knots are modified then
IFLG should be set to 0, so that the coefficients are recomputed.
It may be noted that the set of kernels may change if we are interested
in studying the effect of dropping some of these modes on the computed
solution.

<div class="p"><!----></div>
REPS is the required accuracy for solution of equations using SVD<!--hbox-->.
All singular values less than REPS times the largest singular
value will be set to zero during solution.
CHISQ is the computed value of &#967;<sup>2</sup> define by

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#967;<sup>2</sup>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">NM</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">DF</span>[i]<sup>2</sup> = </td><td nowrap="nowrap" align="center">
<small><span class="roman">NM</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">DE</span>[i]<br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
<span class="roman">DI</span>[i]&#8722;</td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">3</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
a<sub>ij</sub><span class="roman">B</span>(j)</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.94)</td></tr></table>
</td></tr></table>


SUMD is the value of regularisation term computed at the solution,
for IDE=2, it is given by

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">SUMD</span>=</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
<span class="roman">R</span><span class="roman">[</span><span class="roman">NR</span>&#8722;<span class="roman">1</span><span class="roman">]</span>&#8722;<span class="roman">R</span>[0]
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">NS</span>&#8722;1<br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">NS</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
d<sup>2</sup>f
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>dt<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
(t<sub>i</sub>)</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.95)</td></tr></table>
</td></tr></table>


where t<sub>i</sub> are the points at which smoothing is applied. For IDE=1
the second derivative is replaced by first derivative. The values
of CHISQ and SUMD for different values of ALP can be used to infer
the optimal value of ALP using L-curve. A is an array of length
<span class="roman">IV</span>&times;(<span class="roman">NM</span><span class="roman">+</span><span class="roman">NS</span>) containing the matrix U of SVD of the matrix of
equations. AV is an array of length <span class="roman">IV</span>&times;(<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)
containing the matrix V of SVD of the matrix of equations. IV is the
second dimension of arrays A and AV as declared in the calling function. SIGMA
is an array of length (<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) containing the singular
values of the matrix. If IFLG &lt;  4, the arrays A, AV and
SIGMA will be calculated, otherwise they must be supplied.
NSIM is the number of data sets to be used for Monte Carlo simulation
for estimating the errors in solution. If NSIM &lt; 2, error
estimates are not calculated. FE is an array of length NR which
will contain the estimated errors. FE[I] would contain the estimated
error in F[I]. This is calculated only if NSIM &gt; 1.
Error status can be obtained from the
returned value of RLS<!--hbox-->. A value of 705 implies that <span class="roman">NM</span> &#8804; <span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2 or <span class="roman">IK</span> &lt; <span class="roman">NM</span><span class="roman">+</span><span class="roman">NS</span> or <span class="roman">IV</span> &lt; <span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2.
RLS=710 implies that ALP &lt;  0 or IDE &lt;  1
or IDE &gt;  2. In all these cases no calculations are done.
Other values may be set by functions BSPLIN or SVD which are called.
It may be noted that the function allows solution to be computed
even when ALP=0, although the solution would be unacceptable
in this case.
This function requires functions <a href="appendixc.htm#bsplin"> BSPLIN</a>, <a href="appendixc.htm#bspevl"> BSPEVL</a>, <a href="appendixc.htm#svd"> SVD</a>, <a href="appendixc.htm#svdevl"> SVDEVL</a> and
<a href="appendixc.htm#rangau"> RANGAU</a>.

<div class="p"><!----></div>
 <br /><br /><a name="forw"> </a>
 <b>206.&nbsp;FORW&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/forw.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/rls.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 To solve the forward problem corresponding to the
inverse problem solved by <a href="appendixc.htm#rls"> RLS</a><!--hbox-->. This function evaluates the required
integrals using the trapezoidal rule.
NP is the number of points used in defining the kernels. NM is
the number of data points, d<sub>i</sub> to be calculated. This should be
the same as the number of kernels that are supplied in RKER<!--hbox-->.
R is an array of length <span class="roman">NP</span> containing the points
at which values of kernels are available.
RKER is an array of length <span class="roman">IK</span>&times;<span class="roman">NP</span> containing
the kernels for the inverse problem, RKER[j][i]=K<sub>i</sub>(<span class="roman">R</span>[j]).
These kernels are the same as what are used by RLS for inversion.
IK is the second dimension of RKER as declared in the calling function,
<span class="roman">IK</span> &#8805; <span class="roman">NM</span>. DI is an array of length NM, which will
contain the calculated data points d<sub>i</sub>, using the kernels.
F is an array of length NP containing the function values,
<span class="roman">F</span>[i]=f(<span class="roman">R</span>[i]). If IFLG=0, the function values are
calculated using user supplied function FUN, otherwise,
these values must be supplied while calling the function.
FUN is the name of the function routine to calculate the given function.
This is used only if IFLG=0, otherwise the function values are to
be supplied in the array F<!--hbox-->. In the latter case a dummy function will
still be required to satisfy the compiler or linker.
Error status can be obtained from the
returned value of FORW<!--hbox-->. A value of 711 implies that
<span class="roman">IK</span> &lt; <span class="roman">NM</span> and no
calculations are done. IFLG is an integer parameter that is used as
a flag to decide the type of computation required. If IFLG=0,
then the function values are calculated using a user supplied
function FUN<!--hbox-->. These values are returned in the array F and IFLG is
set to 1, so that next time the values need not be calculated.
If data points corresponding to different kernels are required
then IFLG need not be reset. If a different FUN is used next time
then IFLG must be reset to 0. For other values of IFLG the
function values must be supplied in the array F<!--hbox-->. Function FUN(X)
must be supplied by the user to calculate f(x).
If the data points DI calculated by this function are supplied to
<a href="appendixc.htm#rls"> RLS</a> without adding any errors and using the same kernels with very
small RLM, then the
inverted function should match the function FUN used by FORW to a
very good accuracy.

<div class="p"><!----></div>
 <br /><br /><a name="volt"> </a>
 <b>207.&nbsp;VOLT&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/volt.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/volt.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve linear Volterra equations using quadrature
method based on the trapezoidal rule. N is the number of points at which
the function value needs to be estimated. A is a variable specifying
the lower limit of the integral. It is also the
initial point, from which the solution is required. H is the
step size to be used in the quadrature method. The points
are assumed to have a uniform spacing of H<!--hbox-->. F and X are arrays of
length  N, which will contain the calculated value of the solution
at a set of uniformly spaced points. F[I] is the calculated solution at
X[I]. FG and FKER are the names of the functions used to calculate
the g(x) and the kernel K(x,t), respectively. IT is an
integer variable specifying the kind of integral equation. If
<span class="roman">IT</span>=2, Volterra equation of the second kind are solved, while for
other values of IT a Volterra equation of the first kind is solved.
If <span class="roman">IT</span>=&#8722;1, then the computed values are smoothed as explained in
Section&nbsp;13.8. This option can be used only for equations of the first kind.
It should be noted that smoothing cannot be applied to the first and
the last point.
Error status can be obtained from the
returned value of VOLT<!--hbox-->. A value of 712 implies that <span class="roman">N</span> &lt; 3,
in which
case no calculations are performed. VOLT=751 implies that the
denominator is zero at some stage, in which case, no further calculations
can be performed. This failure usually occurs for equations of the first kind
when either <span class="roman">H</span>=0 or K(x,x)=0. Functions FG(X) and FKER(X, T)
must be supplied by the user.

<div class="p"><!----></div>
 <br /><br /><a name="volt2"> </a>
 <b>208.&nbsp;VOLT2&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/volt2.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/volt2.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve nonlinear Volterra equation of the second
kind

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>x</small><!--sup
--><br /><br />
<small><span class="roman">A</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
K(x,t,f(t))&nbsp;&nbsp;dt=f(x)+g(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.96)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.97)</td></tr></table>
</td></tr></table>


using quadrature
method based on the Simpson's rule. N is the number of points at which
the function value needs to be estimated. A is
the lower limit of the integral. It is also
the initial point from which the solution is required. H is
the step size to be used in the quadrature method. The points
are assumed to have a uniform spacing of H<!--hbox-->. F and X are arrays of
length  N, which will contain the calculated value of the solution
at a set of uniformly spaced points. F[I] is the calculated solution at
X[I]. FG and FKER are the names of the functions used to calculate
the g(x) and the kernel K(x,t,f), respectively.
REPS is a parameter, which specifies the (relative) accuracy to which the
resulting nonlinear algebraic equations are solved. This parameter does not control the
truncation error, which is determined by H<!--hbox-->. It is only used to
decide the termination criterion for the fixed-point iteration, while
solving the nonlinear equations for F[I].
Error status can be obtained from the
returned value of VOLT2<!--hbox-->. A value of 712 implies that <span class="roman">N</span> &lt; 3,
in which
case no calculations are performed. VOLT2=752 implies that the
fixed-point iteration fails to converge at some point, in which case,
the calculations are aborted at that point.
In this case the values already calculated so far will be available in arrays
X and F, but their reliability may need to be checked.
Functions FG(X) and FKER(X, T, F) must be supplied by the user.
It may be noted that FKER is not the kernel in the usual sense since
it also includes the unknown function f(t) as it appears inside the
integral in Eq.&nbsp;(<span class="roman">C</span>.96).

<div class="p"><!----></div>
 

<br /><br />
<a name="Partial Differential Equations"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">C</span>.14&nbsp; PARTIAL DIFFERENTIAL EQUATIONS </b></td></tr></table><!--hboxt-->

<br />
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#crank">CRANK</a></td>
<td>&nbsp; <a href="#lines">LINES</a></td>
<td>&nbsp; <a href="#adm">ADM</a></td>
<td>&nbsp; <a href="#lax">LAX</a></td>
<td>&nbsp; <a href="#sor">SOR</a></td>
<td>&nbsp; <a href="#adi">ADI</a></td>
</tr>
</table>



<br />All functions in this chapter are simple implementations of
finite difference
methods. Although these functions may accept equations in somewhat
general form with variable coefficients, the result may not be reliable in
all cases. For example, if the coefficient A of the parabolic equation
in <a href="appendixc.htm#crank"> CRANK</a> is negative in some range of (x,t) values, no reliable solution 
can be computed. The function
does not check for such inconsistencies and no error message will be
issued. Similarly, some functions allow for rather general boundary
conditions, but the accuracy may be only first order in &#8710;t,
if the boundary conditions depend on time explicitly.
Further, for special differential equations, it is possible
to improve the efficiency significantly by writing the difference
equations directly without calculating the coefficients. Similarly,
the boundary conditions can be implemented directly to improve efficiency
in some of the functions (e.g., <a href="appendixc.htm#adi"> ADI</a>). On the other hand,
those functions which
accept boundary condition in simple Dirichlet form only, can be modified
to incorporate more general boundary conditions. Hence, these
functions can only be treated as concrete (and straightforward)
examples of implementing
the algorithms covered in Chapter 14. They are not expected to be
particularly efficient or robust. Users are expected to modify these
functions to suit their problems.

<div class="p"><!----></div>
 <br /><br /><a name="crank"> </a>
 <b>209.&nbsp;CRANK&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/crank.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/crank.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a linear parabolic equation of the form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;t<br /></td><td nowrap="nowrap" align="center">
=A(x,t)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+B(x,t)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
+C(x,t)u+D(x,t),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.98)</td></tr></table>
</td></tr></table>


subject to
boundary conditions

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
A<sub>0</sub>(t)u(<span class="roman">X</span><span class="roman">0</span>,t)+B<sub>0</sub>(t)</td><td nowrap="nowrap" align="center">
&#8706;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
u(<span class="roman">X</span><span class="roman">0</span>,t)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=F<sub>0</sub>(t),</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6> </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
A<sub>n</sub>(t)u(<span class="roman">XN</span>,t)+B<sub>n</sub>(t)</td><td nowrap="nowrap" align="center">
&#8706;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
u(<span class="roman">XN</span>,t)</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">=F<sub>n</sub>(t),</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.99)</td></tr></table>


using the Crank-Nicolson difference scheme (14.29). Although the coefficients in the boundary conditions are functions
of time, if B<sub>0</sub>=0 at some time step, then it must be so at every time
step. The same is true for the coefficient B<sub>n</sub>. This essentially means that if
boundary condition is of Dirichlet type, it should remain so at all times.

<div class="p"><!----></div>
T is the initial value of time.
After execution, it is replaced by the value of t at the last point.
DT is the time step to be used in the computations. (<span class="roman">X</span><span class="roman">0</span>,<span class="roman">XN</span>)
is the range of x values over which the equation needs to be solved.
NT is the number of time steps each of length DT, over which the equation
is to be integrated. NX is the number of mesh points in the X direction.
X is an array of length  NX, which contains the mesh points in
X direction. This array need not be initialised at input, since the function
assumes a uniform mesh spacing and calculates the required mesh points.
U is an array of length  NX, containing the solution at some
time step. This array can be used to supply the
initial values, while after execution, it will contain the solution at
the required time. COF and BC are the names of the functions used
to calculate the coefficients in the differential
equation and the boundary conditions,
respectively. Functions COF(X, T, A, B, C, D) and 
BC(T, X0, XN, A0, B0, F0, AN, BN, FN) must be supplied by the user.
Function COF should
calculate the coefficients A, B, C, D at a given value of X and T<!--hbox-->.
Function BC should calculate the coefficients A0, B0, F0, AN, BN and FN
for a given value of T at the end points X0 and XN<!--hbox-->. FIC is the name
of the
function, which may be used to calculate the initial values for
the solution, when IFLG=0. Function FIC(X, T) must be supplied by the
user if IFLG=0. This function calculates the solution u(x,t) at the
initial time T<!--hbox-->. For other values of IFLG a dummy function FIC
may be required to satisfy the compiler or the linker.
IFLG is
an integer variable used as a flag. If IFLG=0, the initial values
are calculated using the function FIC supplied by the user.
For other values of IFLG the initial values must be supplied in the
array U at the time of calling. In any case, the function sets IFLG to
1, so that during subsequent calls to the function, the initial values
are taken from the array U<!--hbox-->. This function can be used to calculate the
solution at several values of T by calling it repeatedly, after changing
DT and NT appropriately. Other variables should not be changed.
Error status can be obtained from the
returned value of CRANK<!--hbox-->. A value of 713 implies that
<span class="roman">DT</span>=0, or <span class="roman">XN</span>=<span class="roman">X</span><span class="roman">0</span>, or
<span class="roman">NX</span> &#8804; 2, in which case, no calculations are performed.
CRANK=761 implies that the difference equations are singular
and the solution cannot be calculated. This problem may arise due to some
error in specifying the equation or the boundary conditions.

<div class="p"><!----></div>
 <br /><br /><a name="lines"> </a>
 <b>210.&nbsp;LINES&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/lines.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/lines.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a system of nonlinear parabolic
equations of the form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&#8706;u<sub>i</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;t<br /></td><td nowrap="nowrap" align="center">
=f<sub>i</sub></td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
x,t,<b>u</b>,</td><td nowrap="nowrap" align="center">
&#8706;<b>u</b>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
,</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup><b>u</b>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<sup>2</sup><br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (i=0,1,&#8230;,<span class="roman">NELIN</span>&#8722;1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.100)</td></tr></table>
</td></tr></table>


subject to Dirichlet boundary conditions <b>u</b>(<span class="roman">X</span><span class="roman">0</span>,t)=<b>g</b><sub><b>1</b></sub>(t)
and <b>u</b>(<span class="roman">XN</span>,t)=<b>g</b><sub><b>2</b></sub>(t), using the method of lines.
This function is
actually used through the functions <a href="appendixc.htm#mstep"> MSTEP</a> or <a href="appendixc.htm#rkm"> RKM</a> of Chapter&nbsp;12. Since the
system of resulting ordinary differential equations are expected to be stiff,
it is preferable to use the
function MSTEP with <a href="appendixc.htm#gear"> GEAR</a><!--hbox-->. Function LINES specifies the
system of ordinary differential equations, as required by the function
MSTEP (function DIF in the arguments for MSTEP).
The parameters for the
partial differential equations are passed via the global variables,
DXLIN, X0LIN, XNLIN, XLIN, U0LIN, UNLIN, NXLIN, NELIN<!--hbox-->.
The relevant variables amongst these must be initialised before
calling the function MSTEP<!--hbox-->. NXLIN is the number of mesh points in the x
direction. NELIN is the number of parabolic equations in the system.
DXLIN is the step size in x direction. (<span class="roman">X</span><span class="roman">0</span><span class="roman">LIN</span>,<span class="roman">XNLIN</span>)
is the interval over which the solution is to be calculated. Since the
boundary conditions are assumed to be in the Dirichlet form, the solution at the
end points need not be calculated. Hence, the number of ordinary differential
equations <span class="roman">N</span>=(<span class="roman">NXLIN</span>&#8722;2)<span class="roman">NELIN</span>. XLIN is an array of length
 <span class="roman">NXLIN</span>&#8722;2, containing the mesh points x<sub>i</sub>, excluding the
end points. This array must be initialised before calling the function
MSTEP<!--hbox-->.
U0LIN and UNLIN are arrays of length
NELIN, containing the boundary values (at X0LIN and XNLIN)
of the solution at the current
time. These arrays need not be initialised before calling MSTEP, since
the boundary values are calculated by function LINES using a user
supplied function BC<!--hbox-->.
The arguments of LINES have the same definition as specified for function
DIF as required by MSTEP or <a href="appendixc.htm#rkm"> RKM</a><!--hbox-->. T is the value of t at which the
derivatives of solution are required. N is the number of ordinary
differential equations (which would be (<span class="roman">NXLIN</span>&#8722;2)<span class="roman">NELIN</span>).
U and DU are arrays of length N<!--hbox-->. U will specify the values of
solution at required point and DU will contain the time derivative of
all these functions as calculated by LINES<!--hbox-->.

<div class="p"><!----></div>
This function requires functions FCN and BC to supply the information
about the equations and the boundary conditions. 
Function FCN(NELIN, X, T, U, UX, UXX, DU) calculates the derivatives 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">DU</span><span class="roman">[</span><span class="roman">I</span><span class="roman">]</span> = </td><td nowrap="nowrap" align="center">
&#8706;u<sub>i</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;t<br /></td><td nowrap="nowrap" align="center">
=f<sub>i</sub>(<span class="roman">X</span><span class="roman">,</span> <span class="roman">T</span><span class="roman">,</span> <span class="roman">U</span><span class="roman">,</span><span class="roman">UX</span><span class="roman">,</span> <span class="roman">UXX</span>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<span class="roman">I</span>=0,&#8230;,<span class="roman">NELIN</span>&#8722;1),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.101)</td></tr></table>
</td></tr></table>


for a given value 
of X, T,  U[J], UX[J], UXX[J], (<span class="roman">J</span>=0,&#8230;,<span class="roman">NELIN</span>&#8722;1), as specified
by the differential equation. Here U, UX,
UXX and DU are arrays of length  NELIN, containing <b>u</b>, &#8706;<b>u</b>/&#8706;x, &#8706;<sup>2</sup><b>u</b>/&#8706;x<sup>2</sup>, &#8706;<b>u</b>/&#8706;t
respectively. 
Function BC(NELIN, T, X0LIN, XNLIN, U0LIN, UNLIN) calculates the boundary values
U0LIN[I], UNLIN[I], (<span class="roman">I</span>=0,&#8230;,<span class="roman">NELIN</span>&#8722;1) for a given value of
T, X0LIN and XNLIN<!--hbox-->. The names of the functions FCN and BC are fixed and cannot
be passed on as arguments. The initial values should be supplied to the
function <a href="appendixc.htm#mstep"> MSTEP</a> at the time of calling. The <span class="roman">NELIN</span>&times;(<span class="roman">NXLIN</span>&#8722;2)
components of the initial vector are arranged in the normal Fortran
order, with NELIN components of <b>u</b> at each of the <span class="roman">NXLIN</span>&#8722;2 mesh points
stored consecutively. Thus, u<sub>j</sub>(x<sub>k</sub>) occupies the k&times;<span class="roman">NELIN</span>+j
position in the initial vector. The final result at the required value of
time will also be returned in the same order.

<div class="p"><!----></div>
 <br /><br /><a name="adm"> </a>
 <b>211.&nbsp;ADM&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/adm.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/adm.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a parabolic equation in two space variables

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;t<br /></td><td nowrap="nowrap" align="center">
=A<sub>xx</sub>(x,y,t)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+A<sub>yy</sub>(x,y,t)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;<sup>2</sup> y<br /></td><td nowrap="nowrap" align="center">
+A<sub>x</sub>(x,y,t)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
+A<sub>y</sub>(x,y,t)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;y<br /></td><td nowrap="nowrap" align="center">
+A<sub>u</sub>(x,y,t)u+A<sub>0</sub>(x,y,t)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.102)</td></tr></table>
</td></tr></table>


with Dirichlet boundary conditions over a rectangular region,
using alternating direction method. This function uses the difference scheme
<br />
<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td><td nowrap="nowrap" align="center">
u<sub>jl</sub><sup>n+1/2</sup>&#8722;u<sub>jl</sub><sup>n</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
&#8710;t</td></tr></table></td><td nowrap="nowrap" align="center">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(&#8710;x)<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
A<sub>xx</sub><sup>n+1/2</sup>&#948;<sub>x</sub><sup>2</sup>u<sub>jl</sub><sup>n+1/2</sup>+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#8710;x<br /></td><td nowrap="nowrap" align="center">
A<sub>x</sub><sup>n+1/2</sup>&#948;<sub>x</sub> u<sub>jl</sub><sup>n+1/2</sup></td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6> </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&nbsp;&nbsp;+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(&#8710;y)<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
A<sub>yy</sub><sup>n</sup>&#948;<sub>y</sub><sup>2</sup>u<sub>jl</sub><sup>n</sup>+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#8710;y<br /></td><td nowrap="nowrap" align="center">
A<sub>y</sub><sup>n</sup>&#948;<sub>y</sub> u<sub>jl</sub><sup>n</sup></td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&nbsp;&nbsp;+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
(A<sub>u</sub><sup>n</sup>u<sub>jl</sub><sup>n</sup>+A<sub>u</sub><sup>n+1/2</sup>u<sub>jl</sub><sup>n+1/2</sup>)+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
(A<sub>0</sub><sup>n+1/2</sup>+A<sub>0</sub><sup>n</sup>),</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td><td nowrap="nowrap" align="center">
u<sub>jl</sub><sup>n+1</sup>&#8722;u<sub>jl</sub><sup>n+1/2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
&#8710;t</td></tr></table></td><td nowrap="nowrap" align="center">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(&#8710;x)<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
A<sub>xx</sub><sup>n+1/2</sup>&#948;<sub>x</sub><sup>2</sup>u<sub>jl</sub><sup>n+1/2</sup>+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#8710;x<br /></td><td nowrap="nowrap" align="center">
A<sub>x</sub><sup>n+1/2</sup>&#948;<sub>x</sub> u<sub>jl</sub><sup>n+1/2</sup></td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&nbsp;&nbsp;+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(&#8710;y)<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
A<sub>yy</sub><sup>n+1</sup>&#948;<sub>y</sub><sup>2</sup>u<sub>jl</sub><sup>n+1</sup>+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#8710;y<br /></td><td nowrap="nowrap" align="center">
A<sub>y</sub><sup>n+1</sup>&#948;<sub>y</sub> u<sub>jl</sub><sup>n+1</sup></td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&nbsp;&nbsp;+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
(A<sub>u</sub><sup>n+1</sup>u<sub>jl</sub><sup>n+1</sup>+A<sub>u</sub><sup>n+1/2</sup>u<sub>jl</sub><sup>n+1/2</sup>)+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
(A<sub>0</sub><sup>n+1/2</sup>+A<sub>0</sub><sup>n+1</sup>),</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.103)</td></tr></table>


where all coefficients on the right-hand side are evaluated at x=x<sub>j</sub>
and y=y<sub> <span class="roman">l</span></sub>. T is the initial value of time, DT is the time step to be used.
After execution, T will be replaced by the current value of time.
(<span class="roman">X</span><span class="roman">0</span>, <span class="roman">XN</span>) and (<span class="roman">Y</span><span class="roman">0</span>, <span class="roman">YN</span>) are the intervals along
x and y axes, in which the solution is required. NT is the number of
time steps, NX and NY are the number of mesh points in the x and y
directions. X is an array of length  NX, which will contain
the mesh points x<sub>j</sub> in x direction. Y is an array of length
NY, which will contain the mesh points y<sub> <span class="roman">l</span></sub> in y direction.
The arrays X and Y need not be initialised before calling the function,
since the function assumes a uniform spacing and initialises the arrays
before proceeding with the calculations. U is an array of length
<span class="roman">IU</span>&times;<span class="roman">NY</span>, which contains the solution u.
This array can also be used to pass the initial values of the solution
(if IFLG &#8800; 0). U[J][I] is the solution u(x<sub>I</sub>,y<sub>J</sub>).
IU ( &#8805; <span class="roman">NX</span>)
is the second dimension of U as declared in the
calling function. COF is the name of the function to calculate the
coefficients of the equation. Function COF(X, Y, T, AXX, AYY, AX, AY, AU, A0)
should calculate the coefficients AXX, AYY, AX, AY, AU and A0 at a given
value of X, Y and T<!--hbox-->. BC is the name of the function to calculate
the boundary values. Function BC(IB, X, Y, T) should calculate the
boundary values for the solution. Here IB is an integer variable, which
takes the value 1, 2, 3, 4 corresponding to the four boundary lines.
The boundary values are given by

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
u(<span class="roman">X</span><span class="roman">0</span>,y,t)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=<span class="roman">BC</span><span class="roman">(</span><span class="roman">1</span><span class="roman">,</span><span class="roman">X</span><span class="roman">0</span>,y,t),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u(<span class="roman">XN</span>, y,t)=<span class="roman">BC</span><span class="roman">(</span><span class="roman">2</span><span class="roman">,</span><span class="roman">XN</span>,y,t),</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
u(x,<span class="roman">Y</span><span class="roman">0</span>,t)</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">=<span class="roman">BC</span>(3,x,<span class="roman">Y</span><span class="roman">0</span>,t),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u(x,<span class="roman">YN</span>,t)=<span class="roman">BC</span>(4,x,<span class="roman">YN</span>,t).</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.104)</td></tr></table>


If the boundary values depend on time, then the accuracy of difference
approximation may be only O(&#8710;t) instead of O((&#8710;t)<sup>2</sup>). FIC is the name of the
function, which may be used to calculate the initial values for
the solution, when IFLG=0. Function FIC(X, Y, T) must be supplied by the
user, if IFLG=0. This function calculates the solution u(x,y,t) at the
initial time T<!--hbox-->. For other values of IFLG a dummy function FIC
may be required to satisfy the compiler, or the linker.
IFLG is
an integer variable used as a flag. If IFLG=0, the initial values
are calculated using the function FIC supplied by the user.
For other values of IFLG, the initial values must be supplied in the
array U at the time of calling. In any case, the function sets IFLG to
1, so that during subsequent calls to the function, the initial values
are taken from the array U<!--hbox-->. This function can be used to calculate the
solution at several values of T, by calling it repeatedly after changing
DT and NT appropriately. Other variables should not be changed.
Error status can be obtained from the
returned value of ADM<!--hbox-->. A value of 714 implies that
<span class="roman">DT</span>=0, or <span class="roman">XN</span>=<span class="roman">X</span><span class="roman">0</span>, or
<span class="roman">YN</span>=<span class="roman">Y</span><span class="roman">0</span>, or <span class="roman">NX</span> &#8804; 2, or <span class="roman">NY</span> &#8804; 2, or 
<span class="roman">IU</span> &lt; <span class="roman">NX</span>, in which case, no calculations are performed.
ADM=762 implies that the difference equations are singular
and the solution cannot be calculated. This problem may arise due to some
error in specifying the equation.

<div class="p"><!----></div>
 <br /><br /><a name="lax"> </a>
 <b>212.&nbsp;LAX&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/lax.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/lax.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a system of hyperbolic equations in the
conservation law form, using Lax-Wendroff difference scheme. The equations
are assumed to be in the form &#8706;<b>u</b>/&#8706;t+&#8706;<b>f</b>/&#8706;x=0, where <b>f</b>(x,t,<b>u</b>) can be a nonlinear function of <b>u</b>.
N is the number of equations in the system, T is the initial value of time.
After execution, T will be replaced by the current value of t. DT is the
time step to be used. The time step is kept fixed.
(<span class="roman">X</span><span class="roman">0</span>, <span class="roman">XN</span>) is the interval along x-axis,
on which the solution is required. NT is the number of time steps over which
integration is to be performed, NX is the number of mesh points to be used
along the x-axis. X is an array of length  NX, used to 
store the coordinates of the mesh points x<sub>j</sub>. This array need not be
initialised before calling the function, since the function assumes
a uniform spacing and calculates x<sub>j</sub> before performing the calculations.
U is an array of length
<span class="roman">IU</span>&times;<span class="roman">NX</span>, which contains the solution u.
This array can also be used to pass the initial values of the solution
(if IFLG &#8800; 0). IU[J][I] contains the Ith component of the solution
u<sub>i</sub> at Jth mesh point x<sub>j</sub>. 
IU ( &#8805; <span class="roman">N</span>) is the second dimension of U, as declared in the
calling function. FLUX is the name of the function, which is
used to calculate the
flux <b>f</b> occurring in the differential equations.
Function FLUX(N, X, T, U, F) should calculate the flux F[I], 
(<span class="roman">I</span>=0,&#8230;,<span class="roman">N</span>&#8722;1) for a given
value of X, T and U[J], (<span class="roman">J</span>=0,&#8230;,<span class="roman">N</span>&#8722;1).
BC is the name of the function to calculate
the boundary values. Function BC(IB, N, X, T, IW, A) should calculate the
coefficients required for the boundary conditions.
Here IB is an integer variable which
takes the value 1 or 2 corresponding to <span class="roman">X</span>=<span class="roman">X</span><span class="roman">0</span> and XN, respectively.
IW is an integer array of length  N, which contains information
about the type of boundary condition on each component of <b>u</b> or <b>f</b>.
If IW[I]=0, then the boundary condition is of the simple Dirichlet
form a<sub>i1</sub>(t)u<sub>i</sub>=a<sub>i3</sub>(t), otherwise the boundary condition is applied to the
corresponding component of the flux

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
a<sub>i1</sub>(t)f<sub>i</sub>+a<sub>i2</sub>(t)</td><td nowrap="nowrap" align="center">
&#8706;f<sub>i</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
=a<sub>i3</sub>(t).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.105)</td></tr></table>
</td></tr></table>


The coefficients a<sub>ij</sub> are returned in the array A, which should be
dimensioned as A[3][N] in the function BC<!--hbox-->.
FIC is the name of the function, which
may be used to calculate the initial values for
the solution if IFLG=0. Function FIC(N, X, T, U) must be supplied by the
user, when IFLG=0. This function calculates the solution u<sub>i</sub>(<span class="roman">X</span>,<span class="roman">T</span>), 
(i=0,&#8230;,<span class="roman">N</span>&#8722;1) at the
initial time T<!--hbox-->. For other values of IFLG a dummy function FIC
may be required to satisfy the compiler or the linker.
(In function FIC, U is an array of length  N, which returns the value of
the solution u<sub>i</sub> for i=0,&#8230;,<span class="roman">N</span>&#8722;1.)
IFLG is
an integer variable used as a flag. If IFLG=0, the initial values
are calculated using the function FIC supplied by the user.
For other values of IFLG, the initial values must be supplied in the
array U<!--hbox-->. In any case, the function sets IFLG to
1, so that during subsequent calls to the function, the initial values
are taken from the array U<!--hbox-->. This function can be used to calculate the
solution at several values of T by calling it repeatedly, after changing
DT and NT appropriately. Other variables should not be changed.
Error status can be obtained from the
returned value of LAX<!--hbox-->. A value of 715 implies that
<span class="roman">DT</span>=0, or <span class="roman">XN</span>=<span class="roman">X</span><span class="roman">0</span>, or
<span class="roman">NX</span> &#8804; 2, or <span class="roman">IU</span> &lt; <span class="roman">N</span>,
in which case, no calculations are performed.
LAX=763 implies that the denominator vanishes while calculating the
boundary values
and hence the solution cannot be continued. This problem may arise due to some
error in specifying the boundary conditions.

<div class="p"><!----></div>
 <br /><br /><a name="sor"> </a>
 <b>213.&nbsp;SOR&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/sor.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/sor.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a linear second-order elliptic equation
<br />
<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
A<sub>xx</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+A<sub>xy</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x&#8706;y<br /></td><td nowrap="nowrap" align="center">
+A<sub>yy</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;y<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+A<sub>x</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6> </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+A<sub>y</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;y<br /></td><td nowrap="nowrap" align="center">
+A<sub>0</sub>(x,y)u+F(x,y)=0,</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.106)</td></tr></table>


with Dirichlet boundary conditions on a rectangular region. Although
arbitrary coefficients will be accepted by this function, the result
may be meaningful only when the resulting equation is elliptic, i.e.
A<sub>xx</sub>A<sub>yy</sub>&#8722;4A<sub>xy</sub><sup>2</sup> &gt; 0. This
function uses the SOR method to solve the difference equations
<br />
<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
A<sub>xx</sub></td><td nowrap="nowrap" align="center">
2u<sub>jl</sub>&#8722;u<sub>j&#8722;1,l</sub>&#8722;u<sub>j+1,l</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(&#8710;x)<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+A<sub>xy</sub></td><td nowrap="nowrap" align="center">
u<sub>j+1,l&#8722;1</sub>+u<sub>j&#8722;1,l+1</sub>&#8722;u<sub>j+1,l+1</sub>&#8722;u<sub>j&#8722;1,l&#8722;1</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4&#8710;x&#8710;y<br /></td><td nowrap="nowrap" align="center">
</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6> </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+A<sub>yy</sub></td><td nowrap="nowrap" align="center">
2u<sub>jl</sub>&#8722;u<sub>j,l&#8722;1</sub>&#8722;u<sub>j,l+1</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(&#8710;y)<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+A<sub>x</sub></td><td nowrap="nowrap" align="center">
u<sub>j&#8722;1,l</sub>&#8722;u<sub>j+1,l</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#8710;x<br /></td><td nowrap="nowrap" align="center">
+A<sub>y</sub></td><td nowrap="nowrap" align="center">
u<sub>j,l&#8722;1</sub>&#8722;u<sub>j,l+1</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#8710;y<br /></td><td nowrap="nowrap" align="center">
&#8722;A<sub>0</sub>u<sub>jl</sub>=F,</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.107)</td></tr></table>


where all coefficients are evaluated at (x<sub>j</sub>,y<sub> <span class="roman">l</span></sub>). The points
(<span class="roman">X</span><span class="roman">0</span><span class="roman">,</span> <span class="roman">Y</span><span class="roman">0</span>) and (<span class="roman">XN</span><span class="roman">,</span> <span class="roman">YN</span>) define the rectangle over which the
solution is required. NX and NY are the number of mesh points along the x
and y directions. X and Y are arrays of lengths 
NX and NY respectively,
which contain the mesh points x<sub>j</sub> and y<sub> <span class="roman">l</span></sub>. These arrays need not
be initialised before calling the function, since the function
assumes a uniform spacing and initialises these arrays before proceeding
with the calculations.
U is an array of length
<span class="roman">IU</span>&times;<span class="roman">NY</span>, which contains the solution. U[J][I]
will contain the computed approximation to u(x<sub>i</sub>,y<sub>j</sub>). Before calling the
function, an initial approximation to the solution should be supplied
in this array. IU ( &#8805; <span class="roman">NX</span>) is the value of the second dimension of array
U, as declared in the calling function. COF is the name of the function used
to calculate the coefficients in the equation. 
Function COF(X, Y, AXX, AXY, AYY, AX, AY, A0, F) should calculate the coefficients
AXX, AXY, AYY, AX, AY, A0 and F at a given value of X and Y<!--hbox-->. BC is the
name of the function to calculate the boundary values. 
Function BC(IB, X, Y) should calculate the
boundary values for the solution. Here IB is an integer variable which
takes the value 1, 2, 3, 4, corresponding to the four boundary lines.
The boundary values are given by

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
u(<span class="roman">X</span><span class="roman">0</span>,y)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=<span class="roman">BC</span><span class="roman">(</span><span class="roman">1</span><span class="roman">,</span><span class="roman">X</span><span class="roman">0</span>, y),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u(<span class="roman">XN</span>,y)=<span class="roman">BC</span><span class="roman">(</span><span class="roman">2</span><span class="roman">,</span> <span class="roman">XN</span>,y),</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
u(x,<span class="roman">Y</span><span class="roman">0</span>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">=<span class="roman">BC</span>(3,x,<span class="roman">Y</span><span class="roman">0</span>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u(x,<span class="roman">YN</span>)=<span class="roman">BC</span>(4,x,<span class="roman">YN</span>).</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.108)</td></tr></table>


OMEGA is the value of the relaxation parameter &#969; to be used in
the calculation. For meaningful results 1 &lt; &#969; &lt; 2, but this condition is not
checked by the function. If OMEGA &#8804; 0, then the function
uses the optimum value for the Poisson's equation, based on the number
of mesh points in each direction (Section&nbsp;14.8). AEPS is the convergence parameter, which specifies
the accuracy to which the difference equations are to be solved. The
iteration is terminated when the maximum change in all elements is less
than AEPS<!--hbox-->. It should be noted that, this parameter does not affect the truncation
error, which depends only on the number of mesh points. For optimum results,
AEPS should be somewhat smaller than the expected accuracy in the solution.
Accuracy of the solution can be checked by repeating the calculations
with different number of mesh points. NIT is an output parameter,
which gives the number of SOR iterations required by the function
to achieve the specified accuracy.
Error status can be obtained from the
returned value of SOR<!--hbox-->. A value of 716 implies that
<span class="roman">XN</span>=<span class="roman">X</span><span class="roman">0</span>, or
<span class="roman">YN</span>=<span class="roman">Y</span><span class="roman">0</span>, or <span class="roman">NX</span> &#8804; 2, or <span class="roman">NY</span> &#8804; 2,
or <span class="roman">IU</span> &lt; <span class="roman">NX</span>, in which case, no calculations are performed.
SOR=764 implies that the diagonal term in the difference
equation vanishes and the calculations are abandoned.
This failure may arise due to some error in specifying the equation, or the
equation may be such that the diagonal term actually vanishes at some
mesh point. In the latter case, changing mesh spacing along some axis may make
the coefficient nonzero. SOR=765 implies that the SOR iteration
failed to converge in MAXIT (=1000) iterations.

<div class="p"><!----></div>
 <br /><br /><a name="adi"> </a>
 <b>214.&nbsp;ADI&nbsp;&nbsp;&nbsp;</b>(<a href="../c/fun/adi.c">function</a>,&nbsp;&nbsp;&nbsp;
<a href="../c/xmp/adi.c">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixc.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to solve a linear second-order elliptic equation
<br />
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
A<sub>xx</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+A<sub>yy</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;y<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+A<sub>x</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
+A<sub>y</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;y<br /></td><td nowrap="nowrap" align="center">
+A<sub>0</sub>(x,y)u+F(x,y)=0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">C</span>.109)</td></tr></table>
</td></tr></table>

on a rectangular region using the Alternating Direction Implicit iterative
(ADI) method. Although
arbitrary coefficients will be accepted by this function, the result
may be meaningful only when the resulting equation is elliptic, i.e.
A<sub>xx</sub>A<sub>yy</sub> &gt; 0. This
function accepts more general boundary conditions of the form
A<sub>0</sub>u+A<sub>n</sub> &#8706;<sub>n</sub>u=F, where &#8706;<sub>n</sub>u is the normal derivative.
The points
(<span class="roman">X</span><span class="roman">0</span><span class="roman">,</span> <span class="roman">Y</span><span class="roman">0</span>) and (<span class="roman">XN</span><span class="roman">,</span> <span class="roman">YN</span>) define the rectangle, over which the
solution is required. KN is the parameter k in the ADI algorithm. This
function repeats a cycle of 2<sup>k</sup> iterations, until the result converges.
The convergence criterion is tested after each iteration. Hence, the
actual number of iterations may not be a multiple of 2<sup>k</sup>. Ideally
k should be chosen such that convergence takes place in approximately 2<sup>k</sup>
iterations, but the exact choice may not be very crucial.
NX and NY are the number of mesh points along the x and y directions. 
X and Y are arrays of lengths  NX and NY, respectively
containing the mesh points x<sub>j</sub> and y<sub> <span class="roman">l</span></sub>. These arrays need not
be initialised before calling the function, since the function
assumes a uniform spacing and initialises these arrays before proceeding
with the calculations.
U is an array of length
<span class="roman">IU</span>&times;<span class="roman">NY</span>, which contains the solution. U[J][I]
will contain the computed approximation to u(x<sub>i</sub>,y<sub>j</sub>). Before calling the
function an initial approximation to the solution should be supplied
in this array. IU ( &#8805; <span class="roman">NX</span>) is the value of the second dimension of the array
U, as declared in the calling function. COF is the name of the function used
to calculate the coefficients in the equation. 
Function COF(X, Y, AXX, AYY, AX, AY, A0, F) should calculate the coefficients
AXX, AYY, AX, AY, A0 and F at a given value of X and Y<!--hbox-->. BC is the name of
the function to calculate the coefficients for the boundary conditions. 
Function BC(IB, X, Y, A0, AN, F) should calculate the coefficients A0, AN and F
for the boundary conditions. Here IB is an integer variable which
takes the value 1, 2, 3, 4, corresponding to the four boundary lines
x=<span class="roman">X</span><span class="roman">0</span>, x=<span class="roman">XN</span>, y=<span class="roman">Y</span><span class="roman">0</span> and y=<span class="roman">YN</span>, respectively.
EL and EU are respectively, the lower and upper limit on the eigenvalues
of the partitions X and Y of the finite difference matrix.
If <span class="roman">EL</span> &#8804; 0, then the value for Poisson's equation will be used.
Similarly, if <span class="roman">EU</span> &#8804; <span class="roman">EL</span>, then the value for Poisson's equation
will be used.
AEPS is the convergence parameter, which specifies
the accuracy to which the difference equations are to be solved. The
iteration is terminated when the maximum change in all elements is less
than AEPS<!--hbox-->. It should be noted that, this parameter does not affect the truncation
error, which depends only on the number of mesh points. For optimum results,
AEPS should be somewhat smaller than the expected accuracy in the solution.
Accuracy of the solution can be checked by repeating the calculations
with different number of mesh points. NIT is an output parameter,
which gives the number of ADI iterations required by the function
to achieve the specified accuracy.
Error status can be obtained from the
returned value of ADI<!--hbox-->. A value of 717 implies that
<span class="roman">XN</span>=<span class="roman">X</span><span class="roman">0</span>, or
<span class="roman">YN</span>=<span class="roman">Y</span><span class="roman">0</span>, or <span class="roman">NX</span> &#8804; 2, or <span class="roman">NY</span> &#8804; 2,
or <span class="roman">IU</span> &lt; <span class="roman">NX</span>, in which case, no calculations are performed.
ADI=766 implies that the matrix for ADI iteration is singular
and the calculations are abandoned.
This problem may arise due to some error in specifying the equation or the boundary
conditions. ADI=767 implies that the ADI iteration
failed to converge in MAXIT (=1000) iterations.

<div class="p"><!----></div>

<br /><br />



<table align="center" border="0"><tr><td>
<font size="+1"> BIBLIOGRAPHY </font></td></tr></table><!--hboxt-->
<br />
   

<div class="p"><!----></div>
Brent, R. P. (1973): <i>Algorithms for Minimization Without Derivatives,</i> Prentice-Hall, Englewood Cliffs, New Jersey.

<div class="p"><!----></div>
DiDonato R., Morris, A. H. Jr. (1986) <i>Computation of the Incomplete
Gamma Function Ratios and their Inverse,</i> ACM Transactions on Mathematical
Software (TOMS), <b>12</b>, p.&nbsp;377.

<div class="p"><!----></div>
DiDonato R., Morris, A. H. Jr. (1992) <i>Algorithm 708: Significant
Digit Computation of the Incomplete
Beta Function Ratios,</i> ACM Transactions on Mathematical
Software (TOMS), <b>18</b>, p.&nbsp;360.

<div class="p"><!----></div>
Kernighan, B. W. and Ritchie, D. M. (1988): <i>The C Programming Language,</i> (2nd ed.), Prentice Hall, New Jersey.

<div class="p"><!----></div>
Press, W. H., Teukolsky, S. A., Vetterling, W. T. and Flannery, B. P. (2007): <i>Numerical Recipes : The Art of Scientific Computing,</i> (3rd ed.) Cambridge University Press, New York.

<div class="p"><!----></div>
Wilkinson, J. H. and Reinsch, C. (1971): <i>Linear Algebra: Handbook for Automatic Computation,</i> Vol.&nbsp;2, Springer-Verlag, Berlin.

<div class="p"><!----></div>
<p>
&nbsp;<a href="readme.htm">doc</a>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="../c/readme.htm">C programs</a>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="../f77/readme.htm">Fortran programs</a>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="../readme.htm">[Home]</a>

<p>

<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>Hgold</a>,
version 4.00.<br />On 29 Nov 2012, 14:04.</small>
</html>
