% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*-
% WHIZARD code as NOWEB source: matrix elements and process libraries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{FKS Subtraction Scheme}
\includemodulegraph{fks}

The code in this chapter implements the FKS subtraction scheme for use
with \whizard.

These are the modules:
\begin{description}
\item[fks\_regions]
  Given a process definition, identify singular regions in the
  associated phase space.
\item[virtual]
  Handle the virtual correction matrix element.
\item[real\_subtraction]
  Handle the real-subtraction matrix element.
\item[nlo\_data]
  Manage the subtraction objects.
\item[dglap\_remnant]
  Handle the DGLAP Remnant matrix element.
\end{description}

This chapter deals with next-to-leading order contributions to cross sections.
Basically, there are three major issues to be adressed: The creation
of the $N+1$-particle flavor structure, the construction of the
$N+1$-particle phase space and the actual calculation of the real- and
virtual-subtracted matrix elements. The first is dealt with using the
[[auto_components]] class, and it will be shown that the second
and third issue are connected in FKS subtraction.

\section{Brief outline of FKS subtraction}
{\em In the current state, this discussion is only concerned with
  lepton collisions. For hadron collisions, renormalization of parton
  distributions has to be taken into account. Further, for QCD
  corrections, initial-state radiation is necessarily
  present.}

The aim is to calculate the next-to-leading order cross section
according to
\begin{equation*}
  d\sigma_{\rm{NLO}} = \mathcal{B} + \mathcal{V} +
  \mathcal{R}d\Phi_{\rm{rad}}.
\end{equation*}
Analytically, the divergences, in terms of poles in the complex
quantity $\varepsilon = 2-d/2$, cancel. However, this is in general
only valid in an arbitrary, complex number of dimensions. This is,
roughly, the content of the KLN-theorem. \whizard, as any
other numerical program, is confined to four dimensions. We will
assume that the KLN-theorem is valid and that there exist subtraction
terms $\mathcal{C}$ such that
\begin{equation*}
  d\sigma_{\rm{NLO}} = \mathcal{B} + \underbrace{\mathcal{V} +
    \mathcal{C}}_{\text{finite}} + \underbrace{\mathcal{R} -
    \mathcal{C}}_{\text{finite}},
\end{equation*}
i.e. the subtraction terms correspond to the divergent limits of the
real and virtual matrix element.

Because $\mathcal{C}$ subtracts the divergences of $\mathcal{R}$ as
well as those of $\mathcal{V}$, it suffices to consider one of them,
so we focus on $\mathcal{R}$. For this purpose, $\mathcal{R}$ is
rewritten as
\begin{equation*}
  \mathcal{R} = \frac{1}{\xi^2}\frac{1}{1-y} \left(\xi^2
    (1-y)\mathcal{R}\right) =
  \frac{1}{\xi^2}\frac{1}{1-y}\tilde{\mathcal{R}},
\end{equation*}
with $\xi = \left(2k_{\rm{rad}}^0\right)/\sqrt{s}$ and $y =
\cos\theta$, where $k_{\rm{rad}}^0$ denotes the energy of the radiated
parton and $\theta$ is the angle between emitter and radiated
parton. $\tilde{\mathcal{R}}$ is finite, therefore the whole
singularity structure is contained in the prefactor
$\xi^{-2}(1-y)^{-1}$. Combined with the $d$-dimensional phase space
element,
\begin{equation*}
  \frac{d^{d-1}k}{2k^0(2\pi)^{d-1}} =
  \frac{s^{1-\varepsilon}}{(4\pi)^{d-1}}\xi^{1-2\varepsilon}\left(1-y^2\right)^{-\varepsilon}
  d\xi dy d\Omega^{d-2},
\end{equation*}
this yields
\begin{equation*}
  d\Phi_{\rm{rad}} \mathcal{R} = dy (1-y)^{-1-\varepsilon} d\xi
  \xi^{-1-2\varepsilon} \tilde{R}.
\end{equation*}
This can further be rewritten in terms of plus-distributions,
\begin{align*}
\xi^{-1-2\varepsilon} &= -\frac{1}{2\varepsilon}\delta(\xi) +
\left(\frac{1}{\xi}\right)_+ -
2\varepsilon\left(\frac{\log\xi}{\xi}\right)_+ +
\mathcal{O}(\varepsilon^2),\\
(1-y)^{-1-\varepsilon} &= -\frac{2^{-\varepsilon}}{\varepsilon}
\delta(1-y) + \left(\frac{1}{1-y}\right)_+ - \varepsilon
\left(\frac{1}{1-y}\right)_+\log(1-y) + \mathcal{O}(\varepsilon^2),
\end{align*}
(imagine that all this is written inside of integrals, which are
spared for ease of notation) such that
\begin{align*}
d\Phi_{\rm{rad}} \mathcal{R} &= -\frac{1}{2\varepsilon} dy
(1-y)^{-1-\varepsilon}\tilde{R} (0,y) -
d\xi\left[\frac{2^{-\varepsilon}}{\varepsilon}\left(\frac{1}{\xi}\right)_+
  - 2\left(\frac{\log\xi}{\xi}\right)_+\right] \tilde{R}(\xi,1) \\
                              &+ dy d\xi \left(\frac{1}{\xi}\right)_+
                              \left(\frac{1}{1-y}\right)_+
                              \tilde{R}(\xi, y) +
                              \mathcal{O}(\varepsilon).\\
\end{align*}
The summand in the second line is of order $\mathcal{O}(1)$ and is the
only one to reproduce $\mathcal{R}(\xi,y)$. It thus constitutes the
sum of the real matrix element and the corresponding counterterms.
The first summand consequently consists of the subtraction terms to
the virtual matrix elements. Above formula thus allows to calculate
all quantities to render the matrix elements finite.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Identifying singular regions}
In the FKS subtraction scheme, the phase space is decomposed into
disjoint singular regions, such that
\begin{equation}
\label{eq:S_complete}
  \sum_i \mathcal{S}_i + \sum_{ij}\mathcal{S}_{ij} = 1.
\end{equation}
The quantities $\mathcal{S}_i$ and $\mathcal{S}_{ij}$ are functions of
phase space corresponding to a pair of particles indices which can
make up a divergent phase space region. We call such an index pair a
fundamental tuple. For example, the process $e^+ \, e^- \rightarrow u
\, \bar{u} \, g$ has two singular regions, $(3,5)$ and $(4,5)$,
indicating that the gluon can be soft or collinear with respect to
either the quark or the anti-quark. Therefore, the functions $S_{ij}$
have to be chosen in such a way that their contribution makes up most
of \eqref{eq:S_complete} in phase-space configurations where
(final-state) particle $j$ is collinear to particle $i$ or/and
particle $j$ is soft. The functions $S_i$ is the corresponding
quantity for initial-state divergences.

As a singular region we understand the collection of real flavor
structures associated with an emitter and a list of all possible
fundamental tuples. As an example, consider the process $e^+ \, e^-
\rightarrow u \, \bar{u} \, g$. At next-to-leading order, processes
with an additionally radiated particle have to be considered. In this
case, these are $e^+ \, e^- \rightarrow u \, \bar{u}, \, g \, g$,
and $e^+ \, e^- \rightarrow u \, \bar{u} \, u \, \bar{u}$ (or the same
process with any other quark). Table \ref{table:singular regions} sums
up all possible singular regions for this problem.
\begin{table}
\begin{tabular}{|c|c|c|c|}
  \hline
  \texttt{alr} & \texttt{flst\_alr} & \texttt{emitter} &
  \texttt{ftuple\_list}\\ \hline
  1 & [-11,11,2,-2,21,21] & 3 & {(3,5), (3,6), (4,5), (4,6), (5,6)} \\ \hline
  2 & [-11,11,2,-2,21,21] & 4 & {(3,5), (3,6), (4,5), (4,6), (5,6)} \\ \hline
  3 & [-11,11,2,-2,21,21] & 5 & {(3,5), (3,6), (4,5), (4,6), (5,6)} \\ \hline
  4 & [-11,11,2,-2,2,-2]  & 5 & {(3,4), (3,6), (4,5), (5,6)} \\
  \hline
\end{tabular}
\caption{List of singular regions. The particles are represented by
  their PDG codes. The third column contains the emitter for the
  specific singular region. For the process involving an additional
  gluon, the gluon can either be emitted from one of the quarks or
  from the first gluon. Each emitter yields the same list of
  fundamental tuples, five in total. The last singular region
  corresponds to the process where the gluon splits up into two
  quarks. As the matrix element for this process has no information
  on which quarks originate from a gluon splitting, there are ftuples
  for all the quark pairs and not just those involving the emitter.}
\label{table:singular regions}
\end{table}
\\
\begin{table}
\begin{tabular}{|c|c|c|c|}
  \hline
  \texttt{alr} & \texttt{ftuple} & \texttt{emitter} &
  \texttt{flst\_alr} \\ \hline
  1 & $(3,5)$ & 5 & [-11,11,-2,21,2,21] \\ \hline
  2 & $(4,5)$ & 5 & [-11,11,2,21,-2,21] \\ \hline
  3 & $(3,6)$ & 5 & [-11,11,-2,21,2,21] \\ \hline
  4 & $(4,6)$ & 5 & [-11,11,2,21,-2,21] \\ \hline
  5 & $(5,6)$ & 5 & [-11,11,2,-2,21,21] \\ \hline
  6 & $(5,6)$ & 5 & [-11,11,2,-2,2,-2] \\ \hline
\end{tabular}
\caption{Initial list of singular regions}
\label{table:ftuples and flavors}
\end{table}
Thus, during the preparation of a NLO-calculation, the possible
singular regions have to be identified. [[fks_regions.f90]] deals
with this issue.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{FKS Regions}
<<[[fks_regions.f90]]>>=
<<File header>>

module fks_regions

<<Use kinds>>
<<Use strings>>
  use diagnostics
  use os_interface
  use constants
  use process_constants
  use lorentz
  use models
  use resonances, only: resonance_contributors_t, resonance_history_t
  use phs_fks, only: phs_identifier_t, check_for_phs_identifier

  use nlo_data

<<Standard module head>>

<<FKS regions: public>>

<<FKS regions: parameters>>

<<FKS regions: types>>

<<FKS regions: interfaces>>

  interface
<<FKS regions: sub interfaces>>
  end interface

contains

<<FKS regions: main procedures>>

end module fks_regions

@ %def fks_regions
@
<<[[fks_regions_sub.f90]]>>=
<<File header>>

submodule (fks_regions) fks_regions_s

<<Use debug>>
  use format_utils, only: write_separator
  use numeric_utils
  use string_utils, only: str
  use io_units
  use permutations
  use physics_defs
  use flavors
  use pdg_arrays

  implicit none

contains

<<FKS regions: procedures>>

end submodule fks_regions_s

@ %def fks_regions_s
@ There are three fundamental splitting types: $q \rightarrow qg$, $g
\rightarrow gg$ and $g \rightarrow qq$ for FSR and additionally $q
\rightarrow gq$ for ISR which is different from $q \rightarrow qg$ by
which particle enters the hard process.
<<FKS regions: parameters>>=
  integer, parameter :: UNDEFINED_SPLITTING = 0
  integer, parameter :: F_TO_FV = 1
  integer, parameter :: V_TO_VV = 2
  integer, parameter :: V_TO_FF = 3
  integer, parameter :: F_TO_VF = 4

@
@ We group the indices of the emitting and the radiated particle in
the [[ftuple]]-object.
<<FKS regions: public>>=
  public :: ftuple_t
<<FKS regions: types>>=
  type :: ftuple_t
    integer, dimension(2) :: ireg = [-1,-1]
    integer :: i_res = 0
    integer :: splitting_type
    logical :: pseudo_isr = .false.
    logical :: qcd_split = .false.
  contains
  <<FKS regions: ftuple: TBP>>
  end type ftuple_t

@ %def ftuple_t
@
<<FKS regions: interfaces>>=
  interface assignment(=)
     module procedure ftuple_assign
  end interface

  interface operator(==)
     module procedure ftuple_equal
  end interface

  interface operator(>)
     module procedure ftuple_greater
  end interface

  interface operator(<)
     module procedure ftuple_less
  end interface

<<FKS regions: sub interfaces>>=
    pure module subroutine ftuple_assign (ftuple_out, ftuple_in)
      type(ftuple_t), intent(out) :: ftuple_out
      type(ftuple_t), intent(in) :: ftuple_in
    end subroutine ftuple_assign
<<FKS regions: procedures>>=
  pure module subroutine ftuple_assign (ftuple_out, ftuple_in)
    type(ftuple_t), intent(out) :: ftuple_out
    type(ftuple_t), intent(in) :: ftuple_in
    ftuple_out%ireg = ftuple_in%ireg
    ftuple_out%i_res = ftuple_in%i_res
    ftuple_out%splitting_type = ftuple_in%splitting_type
    ftuple_out%pseudo_isr = ftuple_in%pseudo_isr
    ftuple_out%qcd_split = ftuple_in%qcd_split
  end subroutine ftuple_assign

@ %def ftuple_assign
@
<<FKS regions: sub interfaces>>=
    elemental module function ftuple_equal (f1, f2) result (value)
      logical :: value
      type(ftuple_t), intent(in) :: f1, f2
    end function ftuple_equal
<<FKS regions: procedures>>=
  elemental module function ftuple_equal (f1, f2) result (value)
    logical :: value
    type(ftuple_t), intent(in) :: f1, f2
    value = all (f1%ireg == f2%ireg) .and. f1%i_res == f2%i_res &
         .and. f1%splitting_type == f2%splitting_type &
         .and. (f1%pseudo_isr .eqv. f2%pseudo_isr) &
         .and. (f1%qcd_split .eqv. f2%qcd_split)
  end function ftuple_equal

@ %def ftuple_equal
@
<<FKS regions: procedures>>=
  elemental function ftuple_equal_ireg (f1, f2) result (value)
    logical :: value
    type(ftuple_t), intent(in) :: f1, f2
    value = all (f1%ireg == f2%ireg)
  end function ftuple_equal_ireg

@ %def ftuple_equal_ireg
@
<<FKS regions: sub interfaces>>=
    elemental module function ftuple_greater (f1, f2) result (greater)
      logical :: greater
      type(ftuple_t), intent(in) :: f1, f2
    end function ftuple_greater
<<FKS regions: procedures>>=
  elemental module function ftuple_greater (f1, f2) result (greater)
    logical :: greater
    type(ftuple_t), intent(in) :: f1, f2
    if (f1%ireg(1) == f2%ireg(1)) then
       greater = f1%ireg(2) > f2%ireg(2)
    else
       greater = f1%ireg(1) > f2%ireg(1)
    end if
  end function ftuple_greater

@ %def ftuple_greater
@
<<FKS regions: sub interfaces>>=
    elemental module function ftuple_less (f1, f2) result (less)
      logical :: less
      type(ftuple_t), intent(in) :: f1, f2
    end function ftuple_less
<<FKS regions: procedures>>=
  elemental module function ftuple_less (f1, f2) result (less)
    logical :: less
    type(ftuple_t), intent(in) :: f1, f2
    if (f1%ireg(1) == f2%ireg(1)) then
       less = f1%ireg(2) < f2%ireg(2)
    else
       less = f1%ireg(1) < f2%ireg(1)
    end if
  end function ftuple_less

@ %def ftuple_less
<<FKS regions: procedures>>=
  subroutine ftuple_sort_array (ftuple_array, equivalences)
    type(ftuple_t), intent(inout), dimension(:), allocatable :: ftuple_array
    logical, intent(inout), dimension(:,:), allocatable :: equivalences
    type(ftuple_t) :: ftuple_tmp
    logical, dimension(:), allocatable :: eq_tmp
    integer :: i1, i2, n
    n = size (ftuple_array)
    allocate (eq_tmp (n))
    do i1 = 2, n
       i2 = i1
       do while (ftuple_array(i2 - 1) > ftuple_array(i2))
          ftuple_tmp = ftuple_array(i2 - 1)
          eq_tmp = equivalences(i2, :)
          ftuple_array(i2 - 1) = ftuple_array(i2)
          ftuple_array(i2) = ftuple_tmp
          equivalences(i2 - 1, :) = equivalences(i2, :)
          equivalences(i2, :) = eq_tmp
          i2 = i2 - 1
          if (i2 == 1) exit
       end do
    end do
  end subroutine ftuple_sort_array

@ %def ftuple_sort_array
@
<<FKS regions: ftuple: TBP>>=
  procedure :: write => ftuple_write
<<FKS regions: sub interfaces>>=
    module subroutine ftuple_write (ftuple, unit, newline)
      class(ftuple_t), intent(in) :: ftuple
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: newline
    end subroutine ftuple_write
<<FKS regions: procedures>>=
  module subroutine ftuple_write (ftuple, unit, newline)
    class(ftuple_t), intent(in) :: ftuple
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: newline
    integer :: u
    logical :: nl
    u = given_output_unit (unit); if (u < 0) return
    nl = .true.; if (present(newline)) nl = newline
    if (all (ftuple%ireg > -1)) then
       if (ftuple%i_res > 0) then
          if (nl) then
             write (u, "(A1,I1,A1,I1,A1,I1,A1)") &
                 '(', ftuple%ireg(1), ',', ftuple%ireg(2), ';', ftuple%i_res, ')'
          else
             write (u, "(A1,I1,A1,I1,A1,I1,A1)", advance = "no") &
                 '(', ftuple%ireg(1), ',', ftuple%ireg(2), ';', ftuple%i_res, ')'
          end if
       else
          if (nl) then
             write (u, "(A1,I1,A1,I1,A1)") &
                  '(', ftuple%ireg(1), ',', ftuple%ireg(2), ')'
          else
             write (u, "(A1,I1,A1,I1,A1)", advance = "no") &
                  '(', ftuple%ireg(1), ',', ftuple%ireg(2), ')'
          end if
       end if
    else
       write (u, "(A)") "(Empty)"
    end if
  end subroutine ftuple_write

@ %def ftuple_write
@
<<FKS regions: procedures>>=
  function ftuple_string (ftuples, latex)
    type(string_t) :: ftuple_string
    type(ftuple_t), intent(in), dimension(:) :: ftuples
    logical, intent(in) :: latex
    integer :: i, nreg
    if (latex) then
       ftuple_string = var_str ("$\left\{")
    else
       ftuple_string = var_str ("{")
    end if
    nreg = size(ftuples)
    do i = 1, nreg
       if (ftuples(i)%i_res == 0) then
          ftuple_string = ftuple_string // var_str ("(") // &
               str (ftuples(i)%ireg(1)) // var_str (",") // &
               str (ftuples(i)%ireg(2)) // var_str (")")
       else
          ftuple_string = ftuple_string // var_str ("(") // &
               str (ftuples(i)%ireg(1)) // var_str (",") // &
               str (ftuples(i)%ireg(2)) // var_str (";") // &
               str (ftuples(i)%i_res) // var_str (")")
       end if
       if (ftuples(i)%pseudo_isr) ftuple_string = ftuple_string // var_str ("*")
       if (i < nreg) ftuple_string = ftuple_string // var_str (",")
    end do
    if (latex) then
       ftuple_string = ftuple_string // var_str ("\right\}$")
    else
       ftuple_string = ftuple_string // var_str ("}")
    end if
  end function ftuple_string

@ %def ftuple_string
@
<<FKS regions: ftuple: TBP>>=
  procedure :: get => ftuple_get
<<FKS regions: sub interfaces>>=
    module subroutine ftuple_get (ftuple, pos1, pos2)
      class(ftuple_t), intent(in) :: ftuple
      integer, intent(out) :: pos1, pos2
    end subroutine ftuple_get
<<FKS regions: procedures>>=
  module subroutine ftuple_get (ftuple, pos1, pos2)
    class(ftuple_t), intent(in) :: ftuple
    integer, intent(out) :: pos1, pos2
    pos1 = ftuple%ireg(1)
    pos2 = ftuple%ireg(2)
  end subroutine ftuple_get

@ %def ftuple_get
@
<<FKS regions: ftuple: TBP>>=
  procedure :: set => ftuple_set
<<FKS regions: sub interfaces>>=
    module subroutine ftuple_set (ftuple, pos1, pos2)
      class(ftuple_t), intent(inout) :: ftuple
      integer, intent(in) ::  pos1, pos2
    end subroutine ftuple_set
<<FKS regions: procedures>>=
  module subroutine ftuple_set (ftuple, pos1, pos2)
    class(ftuple_t), intent(inout) :: ftuple
    integer, intent(in) ::  pos1, pos2
    ftuple%ireg(1) = pos1
    ftuple%ireg(2) = pos2
  end subroutine ftuple_set

@ %def ftuple_set
@ Determines the splitting type for FSR. There are three different
types of splittings relevant here: $g \to gg$ tagged [[V_TO_VV]], $g
\to qq$ tagged [[V_TO_FF]] and $q \to qg$ tagged [[F_TO_FV]]. For FSR,
there is no need to differentiate between $q \to qg$ and $q \to gq$
splittings.
<<FKS regions: ftuple: TBP>>=
  procedure :: determine_splitting_type_fsr => &
       ftuple_determine_splitting_type_fsr
<<FKS regions: sub interfaces>>=
    module subroutine ftuple_determine_splitting_type_fsr (ftuple, flv, i, j)
      class(ftuple_t), intent(inout) :: ftuple
      type(flv_structure_t), intent(in) :: flv
      integer, intent(in) :: i, j
    end subroutine ftuple_determine_splitting_type_fsr
<<FKS regions: procedures>>=
  module subroutine ftuple_determine_splitting_type_fsr (ftuple, flv, i, j)
    class(ftuple_t), intent(inout) :: ftuple
    type(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i, j
    associate (flst => flv%flst)
       if (is_vector (flst(i)) .and. is_vector (flst(j))) then
          ftuple%splitting_type = V_TO_VV
       else if (flst(i)+flst(j) == 0 &
             .and. is_fermion (flst(i))) then
          ftuple%splitting_type = V_TO_FF
       else if (is_fermion(flst(i)) .and. is_massless_vector (flst(j)) &
             .or. is_fermion(flst(j)) .and. is_massless_vector (flst(i))) then
          ftuple%splitting_type = F_TO_FV
       else
          ftuple%splitting_type = UNDEFINED_SPLITTING
       end if
    end associate
  end subroutine ftuple_determine_splitting_type_fsr

@ %def ftuple_determine_splitting_type_fsr
@ Determines the splitting type for ISR. There are four different
types of splittings relevant here: $g \to gg$ tagged [[V_TO_VV]], $g
\to qq$ tagged [[V_TO_FF]], $q \to qg$ tagged [[F_TO_FV]] and $q \to
gq$ tagged [[F_TO_VF]]. The latter two need to be considered
separately for ISR as they differ with respect to which particle
enters the hard process. A splitting [[F_TO_FV]] may lead to soft
divergences while [[F_TO_VF]] does not.

We also want to emphasize that the splitting type naming convention
for ISR names the splittings considering backwards evolution. So in
the splitting [[V_TO_FF]], it is the \textit{gluon} that enteres the
hard process.

Special treatment here is required if emitter $0$ is assigned. This is
the case only when a gluon was radiated from any of the IS
particles. In this case, both splittings are soft divergent so we can
equivalently choose $1$ or $2$ as the emitter here even if both have
different flavors.
<<FKS regions: ftuple: TBP>>=
  procedure :: determine_splitting_type_isr => &
       ftuple_determine_splitting_type_isr
<<FKS regions: sub interfaces>>=
    module subroutine ftuple_determine_splitting_type_isr (ftuple, flv, i, j)
      class(ftuple_t), intent(inout) :: ftuple
      type(flv_structure_t), intent(in) :: flv
      integer, intent(in) :: i, j
    end subroutine ftuple_determine_splitting_type_isr
<<FKS regions: procedures>>=
  module subroutine ftuple_determine_splitting_type_isr (ftuple, flv, i, j)
    class(ftuple_t), intent(inout) :: ftuple
    type(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i, j
    integer :: em
    em = i; if (i == 0) em = 1
    associate (flst => flv%flst)
       if (is_vector (flst(em)) .and. is_vector (flst(j))) then
          ftuple%splitting_type = V_TO_VV
       else if (is_massless_vector(flst(em)) .and. is_fermion(flst(j))) then
          ftuple%splitting_type = F_TO_VF
       else if (is_fermion(flst(em)) .and. is_massless_vector(flst(j))) then
          ftuple%splitting_type = F_TO_FV
       else if (is_fermion(flst(em)) .and. is_fermion(flst(j))) then
          ftuple%splitting_type = V_TO_FF
       else
          ftuple%splitting_type = UNDEFINED_SPLITTING
       end if
    end associate
  end subroutine ftuple_determine_splitting_type_isr

@ %def ftuple_determine_splitting_type_isr

<<FKS regions: ftuple: TBP>>=
  procedure :: determine_sub_correction_type => &
       ftuple_determine_sub_correction_type
<<FKS regions: sub interfaces>>=
    module subroutine ftuple_determine_sub_correction_type &
         (ftuple, flv_born, flv_real, i, j)
      class(ftuple_t), intent(inout) :: ftuple
      type(flv_structure_t), intent(in) :: flv_born, flv_real
      integer, intent(in) :: i, j
    end subroutine ftuple_determine_sub_correction_type
<<FKS regions: procedures>>=
  module subroutine ftuple_determine_sub_correction_type &
       (ftuple, flv_born, flv_real, i, j)
    class(ftuple_t), intent(inout) :: ftuple
    type(flv_structure_t), intent(in) :: flv_born, flv_real
    integer, intent(in) :: i, j
    type(flv_structure_t) :: flv_test_qcd
    integer :: em
    em = i; if (i == 0) em = 1
    select case (ftuple%splitting_type)
    case (V_TO_VV)
       ftuple%qcd_split = is_gluon (flv_real%flst(em)) .and. is_gluon (flv_real%flst(j))
    case (F_TO_VF)
       ftuple%qcd_split = is_gluon (flv_real%flst(em))
    case (F_TO_FV)
       if (i == 0) then
          ftuple%qcd_split = is_gluon (flv_real%flst(j))
       else
          ftuple%qcd_split = is_gluon (flv_real%flst(i)) .or. is_gluon (flv_real%flst(j))
       end if
    case (V_TO_FF)
       if (any ([i, j] <= flv_real%n_in)) then
          flv_test_qcd = flv_real%insert_particle_isr (i, j, GLUON)
       else
          flv_test_qcd = flv_real%insert_particle_fsr (i, j, GLUON)
       end if
       ftuple%qcd_split = flv_test_qcd .equiv. flv_born
    case (UNDEFINED_SPLITTING)
       ftuple%qcd_split = .false.
    end select
  end subroutine ftuple_determine_sub_correction_type

@ %def ftuple_determine_sub_correction_type
@ Two debug functions to check the consistency of [[ftuples]]
<<FKS regions: ftuple: TBP>>=
  procedure :: has_negative_elements => ftuple_has_negative_elements
  procedure :: has_identical_elements => ftuple_has_identical_elements
<<FKS regions: sub interfaces>>=
    elemental module function ftuple_has_negative_elements &
         (ftuple) result (value)
      logical :: value
      class(ftuple_t), intent(in) :: ftuple
    end function ftuple_has_negative_elements
    elemental module function ftuple_has_identical_elements &
         (ftuple) result (value)
      logical :: value
      class(ftuple_t), intent(in) :: ftuple
    end function ftuple_has_identical_elements
<<FKS regions: procedures>>=
  elemental module function ftuple_has_negative_elements &
       (ftuple) result (value)
    logical :: value
    class(ftuple_t), intent(in) :: ftuple
    value = any (ftuple%ireg < 0)
  end function ftuple_has_negative_elements

  elemental module function ftuple_has_identical_elements &
       (ftuple) result (value)
    logical :: value
    class(ftuple_t), intent(in) :: ftuple
    value = ftuple%ireg(1) == ftuple%ireg(2)
  end function ftuple_has_identical_elements

@ %def ftuple_has_negative_elements, ftuple_has_identical_elements
@ Each singular region can have a different number of
emitter-radiation pairs. This is coped with using the linked list
[[ftuple_list]].
<<FKS regions: types>>=
  type :: ftuple_list_t
    integer :: index = 0
    type(ftuple_t) :: ftuple
    type(ftuple_list_t), pointer :: next => null ()
    type(ftuple_list_t), pointer :: prev => null ()
    type(ftuple_list_t), pointer :: equiv => null ()
  contains
   <<FKS regions: ftuple list: TBP>>
  end type ftuple_list_t

@ %def ftuple_list_t
@
<<FKS regions: ftuple list: TBP>>=
  procedure :: write => ftuple_list_write
<<FKS regions: sub interfaces>>=
    module subroutine ftuple_list_write (list, unit, verbose)
      class(ftuple_list_t), intent(in), target :: list
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: verbose
    end subroutine ftuple_list_write
<<FKS regions: procedures>>=
  module subroutine ftuple_list_write (list, unit, verbose)
    class(ftuple_list_t), intent(in), target :: list
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    type(ftuple_list_t), pointer :: current
    logical :: verb
    integer :: u
    u = given_output_unit (unit); if (u < 0) return
    verb = .false.; if (present (verbose)) verb = verbose
    select type (list)
    type is (ftuple_list_t)
       current => list
       do
          call current%ftuple%write (unit = u, newline = .false.)
          if (verb .and. associated (current%equiv))  &
               write (u, '(A)', advance = "no") "'"
          if (associated (current%next)) then
             current => current%next
          else
             exit
          end if
       end do
       write (u, *) ""
    end select
  end subroutine ftuple_list_write

@ %def ftuple_list_write
@
<<FKS regions: ftuple list: TBP>>=
  procedure :: append => ftuple_list_append
<<FKS regions: sub interfaces>>=
    module subroutine ftuple_list_append (list, ftuple)
      class(ftuple_list_t), intent(inout), target :: list
      type(ftuple_t), intent(in) :: ftuple
    end subroutine ftuple_list_append
<<FKS regions: procedures>>=
  module subroutine ftuple_list_append (list, ftuple)
    class(ftuple_list_t), intent(inout), target :: list
    type(ftuple_t), intent(in) :: ftuple
    type(ftuple_list_t), pointer :: current

    select type (list)
    type is (ftuple_list_t)
       if (list%index == 0) then
          nullify (list%next)
          list%index = 1
          list%ftuple = ftuple
       else
          current => list
          do
             if (associated (current%next)) then
                current => current%next
             else
                allocate (current%next)
                nullify (current%next%next)
                nullify (current%next%equiv)
                current%next%prev => current
                current%next%index = current%index + 1
                current%next%ftuple = ftuple
                exit
             end if
          end do
       end if
    end select
  end subroutine ftuple_list_append

@ %def ftuple_list_append
@
<<FKS regions: ftuple list: TBP>>=
  procedure :: get_n_tuples => ftuple_list_get_n_tuples
<<FKS regions: sub interfaces>>=
    impure elemental module function ftuple_list_get_n_tuples &
         (list) result(n_tuples)
      integer :: n_tuples
      class(ftuple_list_t), intent(in), target :: list
    end function ftuple_list_get_n_tuples
<<FKS regions: procedures>>=
  impure elemental module function ftuple_list_get_n_tuples &
       (list) result(n_tuples)
    integer :: n_tuples
    class(ftuple_list_t), intent(in), target :: list
    type(ftuple_list_t), pointer :: current
    n_tuples = 0
    select type (list)
    type is (ftuple_list_t)
       current => list
       if (current%index > 0) then
          n_tuples = 1
          do
             if (associated (current%next)) then
                current => current%next
                n_tuples = n_tuples + 1
             else
                exit
             end if
          end do
       end if
     end select
  end function ftuple_list_get_n_tuples

@ %def ftuple_list_get_n_tuples
@
<<FKS regions: ftuple list: TBP>>=
  procedure :: get_entry => ftuple_list_get_entry
<<FKS regions: sub interfaces>>=
    module function ftuple_list_get_entry (list, index) result (entry)
      type(ftuple_list_t), pointer :: entry
      class(ftuple_list_t), intent(in), target :: list
      integer, intent(in) :: index
    end function ftuple_list_get_entry
<<FKS regions: procedures>>=
  module function ftuple_list_get_entry (list, index) result (entry)
    type(ftuple_list_t), pointer :: entry
    class(ftuple_list_t), intent(in), target :: list
    integer, intent(in) :: index
    type(ftuple_list_t), pointer :: current
    integer :: i
    entry => null()
    select type (list)
    type is (ftuple_list_t)
       current => list
       if (index == 1) then
          entry => current
       else
          do i = 1, index - 1
             current => current%next
          end do
          entry => current
       end if
    end select
  end function ftuple_list_get_entry

@ %def ftuple_list_get_entry
@
<<FKS regions: ftuple list: TBP>>=
  procedure :: get_ftuple => ftuple_list_get_ftuple
<<FKS regions: sub interfaces>>=
    module function ftuple_list_get_ftuple (list, index)  result (ftuple)
      type(ftuple_t) :: ftuple
      class(ftuple_list_t), intent(in), target :: list
      integer, intent(in) :: index
    end function ftuple_list_get_ftuple
<<FKS regions: procedures>>=
  module function ftuple_list_get_ftuple (list, index)  result (ftuple)
    type(ftuple_t) :: ftuple
    class(ftuple_list_t), intent(in), target :: list
    integer, intent(in) :: index
    type(ftuple_list_t), pointer :: entry
    entry => list%get_entry (index)
    ftuple = entry%ftuple
  end function ftuple_list_get_ftuple

@ %def ftuple_list_get_ftuple
@
<<FKS regions: ftuple list: TBP>>=
  procedure :: set_equiv => ftuple_list_set_equiv
<<FKS regions: sub interfaces>>=
    module subroutine ftuple_list_set_equiv (list, i1, i2)
      class(ftuple_list_t), intent(in) :: list
      integer, intent(in) :: i1, i2
    end subroutine ftuple_list_set_equiv
<<FKS regions: procedures>>=
  module subroutine ftuple_list_set_equiv (list, i1, i2)
    class(ftuple_list_t), intent(in) :: list
    integer, intent(in) :: i1, i2
    type(ftuple_list_t), pointer :: list1, list2 => null ()
    select type (list)
    type is (ftuple_list_t)
       if (list%get_ftuple (i1) > list%get_ftuple (i2)) then
          list1 => list%get_entry (i2)
          list2 => list%get_entry (i1)
       else
          list1 => list%get_entry (i1)
          list2 => list%get_entry (i2)
       end if
       do
          if (associated (list1%equiv)) then
             list1 => list1%equiv
          else
             exit
          end if
       end do
       list1%equiv => list2
    end select
  end subroutine ftuple_list_set_equiv

@ %def ftuple_list_set_equiv
@
<<FKS regions: ftuple list: TBP>>=
  procedure :: check_equiv => ftuple_list_check_equiv
<<FKS regions: sub interfaces>>=
    module function ftuple_list_check_equiv(list, i1, i2) result (eq)
      class(ftuple_list_t), intent(in) :: list
      integer, intent(in) :: i1, i2
      logical :: eq
    end function ftuple_list_check_equiv
<<FKS regions: procedures>>=
  module function ftuple_list_check_equiv(list, i1, i2) result (eq)
    class(ftuple_list_t), intent(in) :: list
    integer, intent(in) :: i1, i2
    logical :: eq
    type(ftuple_list_t), pointer :: current
    eq = .false.
    select type (list)
    type is (ftuple_list_t)
       current => list%get_entry (i1)
       do
          if (associated (current%equiv)) then
             current => current%equiv
             if (current%index == i2) then
                eq = .true.
                exit
             end if
          else
             exit
          end if
       end do
    end select
  end function ftuple_list_check_equiv

@ %def ftuple_list_sort
@
<<FKS regions: ftuple list: TBP>>=
  procedure :: to_array => ftuple_list_to_array
<<FKS regions: sub interfaces>>=
    module subroutine ftuple_list_to_array &
         (ftuple_list, ftuple_array, equivalences, ordered)
      class(ftuple_list_t), intent(in), target :: ftuple_list
      type(ftuple_t), intent(out), dimension(:), allocatable :: ftuple_array
      logical, intent(out), dimension(:,:), allocatable :: equivalences
      logical, intent(in) :: ordered
    end subroutine ftuple_list_to_array
<<FKS regions: procedures>>=
  module subroutine ftuple_list_to_array &
       (ftuple_list, ftuple_array, equivalences, ordered)
    class(ftuple_list_t), intent(in), target :: ftuple_list
    type(ftuple_t), intent(out), dimension(:), allocatable :: ftuple_array
    logical, intent(out), dimension(:,:), allocatable :: equivalences
    logical, intent(in) :: ordered
    integer :: i_tuple, n
    type(ftuple_list_t), pointer :: current => null ()
    integer :: i1, i2
    type(ftuple_t) :: ftuple_tmp
    logical, dimension(:), allocatable :: eq_tmp
    n = ftuple_list%get_n_tuples ()
    allocate (ftuple_array (n), equivalences (n, n))
    equivalences = .false.
    select type (ftuple_list)
    type is (ftuple_list_t)
       current => ftuple_list
       i_tuple = 1
       do
          ftuple_array(i_tuple) = current%ftuple
          if (associated (current%equiv)) then
             i1 = current%index
             i2 = current%equiv%index
             equivalences (i1, i2) = .true.
          end if
          if (associated (current%next)) then
             current => current%next
             i_tuple = i_tuple + 1
          else
             exit
          end if
       end do
    end select
    if (ordered) call ftuple_sort_array (ftuple_array, equivalences)
  end subroutine ftuple_list_to_array

@ %def ftuple_list_to_array
@
<<FKS regions: procedures>>=
  subroutine print_equivalence_matrix (ftuple_array, equivalences)
    type(ftuple_t), intent(in), dimension(:) :: ftuple_array
    logical, intent(in), dimension(:,:) :: equivalences
    integer :: i, i1, i2
    print *, 'Equivalence matrix: '
    do i = 1, size (ftuple_array)
       call ftuple_array(i)%get(i1,i2)
       print *, 'i: ', i, '(', i1, i2, '): ', equivalences(i,:)
    end do
  end subroutine print_equivalence_matrix

@ %def print_equivalence_matrix
@ Class for working with the flavor specification arrays.
<<FKS regions: public>>=
  public :: flv_structure_t
<<FKS regions: types>>=
  type :: flv_structure_t
    integer, dimension(:), allocatable :: flst
    integer, dimension(:), allocatable :: tag
    integer :: nlegs = 0
    integer :: n_in = 0
    logical, dimension(:), allocatable :: massive
    logical, dimension(:), allocatable :: colored
    real(default), dimension(:), allocatable :: charge
    real(default) :: prt_symm_fs = 1._default
    integer :: eqv_index = 0
  contains
  <<FKS regions: flv structure: TBP>>
  end type flv_structure_t

@ %def flv_structure_t
@
Returns \texttt{true} if the two particles at position \texttt{i}
and \texttt{j} in the flavor array can originate from the same
splitting. For this purpose, the function first checks whether the splitting is
allowed at all. If this is the case, the emitter is removed from the
flavor array. If the resulting array is equivalent to the Born flavor
structure \texttt{flv\_born}, the pair is accepted as a valid
splitting.

We first check whether the splitting is possible. The array
[[flv_orig]] contains all particles which share a vertex with the
particles at position [[i]] and [[j]]. If any of these particles belongs
to the initial state, a PDG-ID flip is necessary to correctly recognize
the vertex. If its size is equal to zero, no splitting is possible and
the subroutine is exited. Otherwise, we loop over all possible underlying
Born flavor structures and check if any of them equals the actual underlying
Born flavor structure. For a quark emitting a gluon, [[flv_orig]] contains
the PDG code of the anti-quark. To be on the safe side, a second array is created,
which contains both the positively and negatively signed PDG
codes. Then, the origial tuple $(i,j)$ is removed from the real flavor
structure and the particles in [[flv_orig2]] are inserted.
If the resulting Born configuration is equal to the underlying Born
configuration, up to a permutation of final-state particles, the tuple
$(i,j)$ is accepted as valid.
<<FKS regions: flv structure: TBP>>=
  procedure :: valid_pair => flv_structure_valid_pair
<<FKS regions: sub interfaces>>=
    module function flv_structure_valid_pair &
       (flv, i, j, flv_ref, model) result (valid)
      logical :: valid
      class(flv_structure_t), intent(in) :: flv
      integer, intent(in) :: i,j
      type(flv_structure_t), intent(in) :: flv_ref
      type(model_t), intent(in) :: model
    end function flv_structure_valid_pair
<<FKS regions: procedures>>=
  module function flv_structure_valid_pair &
     (flv, i, j, flv_ref, model) result (valid)
    logical :: valid
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i,j
    type(flv_structure_t), intent(in) :: flv_ref
    type(model_t), intent(in) :: model
    integer :: k, n_orig
    type(flv_structure_t) :: flv_test
    integer, dimension(:), allocatable :: flv_orig
    valid = .false.
    if (all ([i, j] <= flv%n_in)) return
    if (i <= flv%n_in .and. is_fermion(flv%flst(i))) then
       call model%match_vertex (-flv%flst(i), flv%flst(j), flv_orig)
    else if (j <= flv%n_in .and. is_fermion(flv%flst(j))) then
       call model%match_vertex (flv%flst(i), -flv%flst(j), flv_orig)
    else
       call model%match_vertex (flv%flst(i), flv%flst(j), flv_orig)
    end if
    n_orig = size (flv_orig)
    if (n_orig == 0) then
       return
    else
      do k = 1, n_orig
         if (any ([i, j] <= flv%n_in)) then
            flv_test = flv%insert_particle_isr (i, j, flv_orig(k))
         else
            flv_test = flv%insert_particle_fsr (i, j, flv_orig(k))
         end if
         valid = flv_ref .equiv. flv_test
         call flv_test%final ()
         if (valid) return
      end do
    end if
    deallocate (flv_orig)
  end function flv_structure_valid_pair

@ %def flv_structure_valid_pair
@ This function checks whether two flavor arrays are the same up to a
permutation of the final-state particles
<<FKS regions: procedures>>=
  function flv_structure_equivalent (flv1, flv2, with_tag) result (equiv)
    logical :: equiv
    type(flv_structure_t), intent(in) :: flv1, flv2
    logical, intent(in) :: with_tag
    type(flv_perm_t) :: perm
    integer :: n
    n = size (flv1%flst)
    equiv = .true.
    if (n /= size (flv2%flst)) then
       call msg_fatal &
            ('flv_structure_equivalent: flavor arrays do not have equal lengths')
    else if (flv1%n_in /= flv2%n_in) then
       call msg_fatal &
            ('flv_structure_equivalent: flavor arrays do not have equal n_in')
    else
       call perm%init (flv1, flv2, flv1%n_in, flv1%nlegs, with_tag)
       equiv = perm%eqv (flv2, flv1, with_tag)
       call perm%final ()
    end if
  end function flv_structure_equivalent

@ %def flv_structure_equivalent
@
<<FKS regions: sub interfaces>>=
    module function flv_structure_equivalent_no_tag (flv1, flv2) result(equiv)
      logical :: equiv
      type(flv_structure_t), intent(in) :: flv1, flv2
    end function flv_structure_equivalent_no_tag
    module function flv_structure_equivalent_with_tag (flv1, flv2) result(equiv)
      logical :: equiv
      type(flv_structure_t), intent(in) :: flv1, flv2
    endfunction flv_structure_equivalent_with_tag
<<FKS regions: procedures>>=
  module function flv_structure_equivalent_no_tag (flv1, flv2) result(equiv)
    logical :: equiv
    type(flv_structure_t), intent(in) :: flv1, flv2
    equiv = flv_structure_equivalent (flv1, flv2, .false.)
  end function flv_structure_equivalent_no_tag

  module function flv_structure_equivalent_with_tag (flv1, flv2) result(equiv)
    logical :: equiv
    type(flv_structure_t), intent(in) :: flv1, flv2
    equiv = flv_structure_equivalent (flv1, flv2, .true.)
  end function flv_structure_equivalent_with_tag


@ %def flv_structure_equivalent_no_tag, flv_structure_equivalent_with_tag
@
<<FKS regions: sub interfaces>>=
    pure module subroutine flv_structure_assign_flv (flv_out, flv_in)
      type(flv_structure_t), intent(out) :: flv_out
      type(flv_structure_t), intent(in) :: flv_in
    end subroutine flv_structure_assign_flv
<<FKS regions: procedures>>=
  pure module subroutine flv_structure_assign_flv (flv_out, flv_in)
    type(flv_structure_t), intent(out) :: flv_out
    type(flv_structure_t), intent(in) :: flv_in
    flv_out%nlegs = flv_in%nlegs
    flv_out%n_in = flv_in%n_in
    flv_out%prt_symm_fs = flv_in%prt_symm_fs
    if (allocated (flv_in%flst)) then
       allocate (flv_out%flst (size (flv_in%flst)))
       flv_out%flst = flv_in%flst
    end if
    if (allocated (flv_in%tag)) then
       allocate (flv_out%tag (size (flv_in%tag)))
       flv_out%tag = flv_in%tag
    end if
    if (allocated (flv_in%massive)) then
       allocate (flv_out%massive (size (flv_in%massive)))
       flv_out%massive = flv_in%massive
    end if
    if (allocated (flv_in%colored)) then
       allocate (flv_out%colored (size (flv_in%colored)))
       flv_out%colored = flv_in%colored
    end if
  end subroutine flv_structure_assign_flv

@ %def flv_structure_assign_flv
@
<<FKS regions: sub interfaces>>=
    pure module subroutine flv_structure_assign_integer (flv_out, iarray)
      type(flv_structure_t), intent(out) :: flv_out
      integer, intent(in), dimension(:) :: iarray
    end subroutine flv_structure_assign_integer
<<FKS regions: procedures>>=
  pure module subroutine flv_structure_assign_integer (flv_out, iarray)
    type(flv_structure_t), intent(out) :: flv_out
    integer, intent(in), dimension(:) :: iarray
    integer :: i
    flv_out%nlegs = size (iarray)
    allocate (flv_out%flst (flv_out%nlegs))
    allocate (flv_out%tag (flv_out%nlegs))
    flv_out%flst = iarray
    flv_out%tag = [(i, i = 1, flv_out%nlegs)]
  end subroutine flv_structure_assign_integer

@ %def flv_structure_assign_integer
@ Returs a new flavor array with the particle at position
\texttt{index} removed.
<<FKS regions: flv structure: TBP>>=
  procedure :: remove_particle => flv_structure_remove_particle
<<FKS regions: sub interfaces>>=
    module function flv_structure_remove_particle (flv, index) result (flv_new)
      type(flv_structure_t) :: flv_new
      class(flv_structure_t), intent(in) :: flv
      integer, intent(in) :: index
    end function flv_structure_remove_particle
<<FKS regions: procedures>>=
  module function flv_structure_remove_particle (flv, index) result (flv_new)
    type(flv_structure_t) :: flv_new
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: index
    integer :: n1, n2
    integer :: i, removed_tag
    n1 = size (flv%flst); n2 = n1 - 1
    allocate (flv_new%flst (n2), flv_new%tag (n2))
    flv_new%nlegs = n2
    flv_new%n_in = flv%n_in
    removed_tag = flv%tag(index)
    if (index == 1) then
       flv_new%flst(1 : n2) = flv%flst(2 : n1)
       flv_new%tag(1 : n2) = flv%tag(2 : n1)
    else if (index == n1) then
       flv_new%flst(1 : n2) = flv%flst(1 : n2)
       flv_new%tag(1 : n2) = flv%tag(1 : n2)
    else
       flv_new%flst(1 : index - 1) = flv%flst(1 : index - 1)
       flv_new%flst(index : n2) = flv%flst(index + 1 : n1)
       flv_new%tag(1 : index - 1) = flv%tag(1 : index - 1)
       flv_new%tag(index : n2) = flv%tag(index + 1 : n1)
    end if
    do i = 1, n2
       if (flv_new%tag(i) > removed_tag) &
            flv_new%tag(i) = flv_new%tag(i) - 1
    end do
    call flv_new%compute_prt_symm_fs (flv_new%n_in)
  end function flv_structure_remove_particle

@ %def flv_structure_remove_particle
@ Removes the particles at position i1 and i2 and inserts a new
particle of matching flavor at position i1.
<<FKS regions: flv structure: TBP>>=
  procedure :: insert_particle_fsr => flv_structure_insert_particle_fsr
<<FKS regions: sub interfaces>>=
    module function flv_structure_insert_particle_fsr &
         (flv, i1, i2, flv_add) result (flv_new)
      type(flv_structure_t) :: flv_new
      class(flv_structure_t), intent(in) :: flv
      integer, intent(in) :: i1, i2, flv_add
    end function flv_structure_insert_particle_fsr
<<FKS regions: procedures>>=
  module function flv_structure_insert_particle_fsr &
       (flv, i1, i2, flv_add) result (flv_new)
    type(flv_structure_t) :: flv_new
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i1, i2, flv_add
    if (flv%flst(i1) + flv_add == 0 .or. flv%flst(i2) + flv_add == 0) then
       flv_new = flv%insert_particle (i1, i2, -flv_add)
    else
       flv_new = flv%insert_particle (i1, i2, flv_add)
    end if
  end function flv_structure_insert_particle_fsr

@ %def flv_structure_insert_particle_fsr
@ Same as [[insert_particle_fsr]] but for ISR, the two particles are
not exchangeable.
<<FKS regions: flv structure: TBP>>=
  procedure :: insert_particle_isr => flv_structure_insert_particle_isr
<<FKS regions: sub interfaces>>=
    module function flv_structure_insert_particle_isr &
         (flv, i_in, i_out, flv_add) result (flv_new)
      type(flv_structure_t) :: flv_new
      class(flv_structure_t), intent(in) :: flv
      integer, intent(in) :: i_in, i_out, flv_add
    end function flv_structure_insert_particle_isr
<<FKS regions: procedures>>=
  module function flv_structure_insert_particle_isr &
       (flv, i_in, i_out, flv_add) result (flv_new)
    type(flv_structure_t) :: flv_new
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i_in, i_out, flv_add
    if (flv%flst(i_in) + flv_add == 0) then
       flv_new = flv%insert_particle (i_in, i_out, -flv_add)
    else
       flv_new = flv%insert_particle (i_in, i_out, flv_add)
    end if
  end function flv_structure_insert_particle_isr

@ %def flv_structure_insert_particle_isr
@ Removes the particles at position i1 and i2 and inserts a new
particle at position i1.
<<FKS regions: flv structure: TBP>>=
  procedure :: insert_particle => flv_structure_insert_particle
<<FKS regions: sub interfaces>>=
    module function flv_structure_insert_particle &
         (flv, i1, i2, particle) result (flv_new)
      type(flv_structure_t) :: flv_new
      class(flv_structure_t), intent(in) :: flv
      integer, intent(in) :: i1, i2, particle
    end function flv_structure_insert_particle
<<FKS regions: procedures>>=
  module function flv_structure_insert_particle &
       (flv, i1, i2, particle) result (flv_new)
    type(flv_structure_t) :: flv_new
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i1, i2, particle
    type(flv_structure_t) :: flv_tmp
    integer :: n1, n2
    integer :: new_tag
    n1 = size (flv%flst); n2 = n1 - 1
    allocate (flv_new%flst (n2), flv_new%tag (n2))
    flv_new%nlegs = n2
    flv_new%n_in = flv%n_in
    new_tag = maxval(flv%tag) + 1
    if (i1 < i2) then
       flv_tmp = flv%remove_particle (i1)
       flv_tmp = flv_tmp%remove_particle (i2 - 1)
    else if(i2 < i1) then
       flv_tmp = flv%remove_particle(i2)
       flv_tmp = flv_tmp%remove_particle(i1 - 1)
    else
       call msg_fatal ("flv_structure_insert_particle: Indices are identical!")
    end if
    if (i1 == 1) then
       flv_new%flst(1) = particle
       flv_new%flst(2 : n2) = flv_tmp%flst(1 : n2 - 1)
       flv_new%tag(1) = new_tag
       flv_new%tag(2 : n2) = flv_tmp%tag(1 : n2 - 1)
    else if (i1 == n1 .or. i1 == n2) then
       flv_new%flst(1 : n2 - 1) = flv_tmp%flst(1 : n2 - 1)
       flv_new%flst(n2) = particle
       flv_new%tag(1 : n2 - 1) = flv_tmp%tag(1 : n2 - 1)
       flv_new%tag(n2) = new_tag
    else
       flv_new%flst(1 : i1 - 1) = flv_tmp%flst(1 : i1 - 1)
       flv_new%flst(i1) = particle
       flv_new%flst(i1 + 1 : n2) = flv_tmp%flst(i1 : n2 - 1)
       flv_new%tag(1 : i1 - 1) = flv_tmp%tag(1 : i1 - 1)
       flv_new%tag(i1) = new_tag
       flv_new%tag(i1 + 1 : n2) = flv_tmp%tag(i1 : n2 - 1)
    end if
    call flv_new%compute_prt_symm_fs (flv_new%n_in)
  end function flv_structure_insert_particle

@ %def flv_structure_insert_particle
@ Counts the number of occurances of a particle in a
flavor array
<<FKS regions: flv structure: TBP>>=
  procedure :: count_particle => flv_structure_count_particle
<<FKS regions: sub interfaces>>=
    module function flv_structure_count_particle (flv, part) result (n)
      class(flv_structure_t), intent(in) :: flv
      integer, intent(in) :: part
      integer :: n
    end function flv_structure_count_particle
<<FKS regions: procedures>>=
  module function flv_structure_count_particle (flv, part) result (n)
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: part
    integer :: n
    n = count (flv%flst == part)
  end function flv_structure_count_particle

@ %def flv_structure_count_particle
@ Initializer for flavor structures
<<FKS regions: flv structure: TBP>>=
  procedure :: init => flv_structure_init
<<FKS regions: sub interfaces>>=
    module subroutine flv_structure_init (flv, aval, n_in, tags)
      class(flv_structure_t), intent(inout) :: flv
      integer, intent(in), dimension(:) :: aval
      integer, intent(in) :: n_in
      integer, intent(in), dimension(:), optional :: tags
    end subroutine flv_structure_init
<<FKS regions: procedures>>=
  module subroutine flv_structure_init (flv, aval, n_in, tags)
    class(flv_structure_t), intent(inout) :: flv
    integer, intent(in), dimension(:) :: aval
    integer, intent(in) :: n_in
    integer, intent(in), dimension(:), optional :: tags
    integer :: i, n
    integer, dimension(:), allocatable :: aval_unique
    integer, dimension(:), allocatable :: mult
    n = size (aval)
    allocate (flv%flst (n), flv%tag (n))
    flv%flst = aval
    if (present (tags)) then
       flv%tag = tags
    else
       do i = 1, n
          flv%tag(i) = i
       end do
    end if
    flv%nlegs = n
    flv%n_in = n_in
    call flv%compute_prt_symm_fs (flv%n_in)
  end subroutine flv_structure_init

@ %def flv_structure_init
@
<<FKS regions: flv structure: TBP>>=
  procedure :: compute_prt_symm_fs => flv_structure_compute_prt_symm_fs
<<FKS regions: sub interfaces>>=
    module subroutine flv_structure_compute_prt_symm_fs (flv, n_in)
      class(flv_structure_t), intent(inout) :: flv
      integer, intent(in) :: n_in
    end subroutine flv_structure_compute_prt_symm_fs
<<FKS regions: procedures>>=
  module subroutine flv_structure_compute_prt_symm_fs (flv, n_in)
    class(flv_structure_t), intent(inout) :: flv
    integer, intent(in) :: n_in
    integer, dimension(:), allocatable :: flst_unique
    integer, dimension(:), allocatable :: mult
    integer :: i
    flst_unique = remove_duplicates_from_int_array (flv%flst(n_in + 1 :))
    allocate (mult(size (flst_unique)))
    do i = 1, size (flst_unique)
       mult(i) = count (flv%flst(n_in + 1 :) == flst_unique(i))
    end do
    flv%prt_symm_fs = one / product (gamma (real (mult + 1, default)))
  end subroutine flv_structure_compute_prt_symm_fs

@ %def flv_structure_compute_prt_symm_fs
@
<<FKS regions: flv structure: TBP>>=
  procedure :: write => flv_structure_write
<<FKS regions: sub interfaces>>=
    module subroutine flv_structure_write (flv, unit)
      class(flv_structure_t), intent(in) :: flv
      integer, intent(in), optional :: unit
    end subroutine flv_structure_write
<<FKS regions: procedures>>=
  module subroutine flv_structure_write (flv, unit)
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit); if (u < 0) return
    write (u, '(A)') char (flv%to_string ())
  end subroutine flv_structure_write

@ %def flv_structure_write
@
<<FKS regions: flv structure: TBP>>=
  procedure :: to_string => flv_structure_to_string
<<FKS regions: sub interfaces>>=
    module function flv_structure_to_string (flv) result (flv_string)
      type(string_t) :: flv_string
      class(flv_structure_t), intent(in) :: flv
    end function flv_structure_to_string
<<FKS regions: procedures>>=
  module function flv_structure_to_string (flv) result (flv_string)
    type(string_t) :: flv_string
    class(flv_structure_t), intent(in) :: flv
    integer :: i, n
    if (allocated (flv%flst)) then
       flv_string = var_str ("[")
       n = size (flv%flst)
       do i = 1, n - 1
          flv_string = flv_string // str (flv%flst(i)) // var_str(",")
       end do
       flv_string = flv_string // str (flv%flst(n)) // var_str("]")
    else
       flv_string = var_str ("[not allocated]")
    end if
  end function flv_structure_to_string

@ %def flv_structure_to_string
@ Creates the underlying Born flavor structure for a given real flavor
structure if the particle at position \texttt{emitter} is removed
<<FKS regions: flv structure: TBP>>=
  procedure :: create_uborn => flv_structure_create_uborn
<<FKS regions: sub interfaces>>=
    module function flv_structure_create_uborn &
         (flv, emitter, nlo_correction_type) result(flv_uborn)
      type(flv_structure_t) :: flv_uborn
      class(flv_structure_t), intent(in) :: flv
      type(string_t), intent(in) :: nlo_correction_type
      integer, intent(in) :: emitter
    end function flv_structure_create_uborn
<<FKS regions: procedures>>=
  module function flv_structure_create_uborn &
       (flv, emitter, nlo_correction_type) result(flv_uborn)
    type(flv_structure_t) :: flv_uborn
    class(flv_structure_t), intent(in) :: flv
    type(string_t), intent(in) :: nlo_correction_type
    integer, intent(in) :: emitter
    integer n_legs
    integer :: f1, f2
    integer :: gauge_boson

    n_legs = size(flv%flst)
    allocate (flv_uborn%flst (n_legs - 1), flv_uborn%tag (n_legs - 1))
    gauge_boson = determine_gauge_boson_to_be_inserted ()

    if (emitter > flv%n_in) then
       f1 = flv%flst(n_legs); f2 = flv%flst(n_legs - 1)
       if (is_massless_vector (f1)) then
          !!! Emitted particle is a gluon or photon => just remove it
          flv_uborn = flv%remove_particle(n_legs)
       else if (is_fermion (f1) .and. is_fermion (f2) .and. f1 + f2 == 0) then
          !!! Emission type is a gauge boson splitting into two fermions
          flv_uborn = flv%insert_particle(n_legs - 1, n_legs, gauge_boson)
       else
          call msg_error ("Create underlying Born: Unsupported splitting type.")
          call msg_error (char (str (flv%flst)))
          call msg_fatal ("FKS - FAIL")
       end if
    else if (emitter > 0) then
       f1 = flv%flst(n_legs); f2 = flv%flst(emitter)
       if (is_massless_vector (f1)) then
          flv_uborn = flv%remove_particle(n_legs)
       else if (is_fermion (f1) .and. is_massless_vector (f2)) then
          flv_uborn = flv%insert_particle (emitter, n_legs, -f1)
       else if (is_fermion (f1) .and. is_fermion (f2) .and. f1 == f2) then
          flv_uborn = flv%insert_particle(emitter, n_legs, gauge_boson)
       end if
    else
       flv_uborn = flv%remove_particle (n_legs)
    end if

  contains
    integer function determine_gauge_boson_to_be_inserted ()
      select case (char (nlo_correction_type))
      case ("QCD")
         determine_gauge_boson_to_be_inserted = GLUON
      case ("EW")
         determine_gauge_boson_to_be_inserted = PHOTON
      case ("Full")
         call msg_fatal ("NLO correction type 'Full' not yet implemented!")
      case default
         call msg_fatal ("Invalid NLO correction type! Valid inputs " // &
              "are: QCD, EW and Full (default: QCD)")
      end select
    end function determine_gauge_boson_to_be_inserted

  end function flv_structure_create_uborn

@ %def flv_structure_create_uborn
@
<<FKS regions: flv structure: TBP>>=
  procedure :: init_mass_color_and_charge => &
       flv_structure_init_mass_color_and_charge
<<FKS regions: sub interfaces>>=
    module subroutine flv_structure_init_mass_color_and_charge (flv, model)
      class(flv_structure_t), intent(inout) :: flv
      type(model_t), intent(in) :: model
    end subroutine flv_structure_init_mass_color_and_charge
<<FKS regions: procedures>>=
  module subroutine flv_structure_init_mass_color_and_charge (flv, model)
    class(flv_structure_t), intent(inout) :: flv
    type(model_t), intent(in) :: model
    integer :: i
    type(flavor_t) :: flavor
    allocate (flv%massive (flv%nlegs), flv%colored(flv%nlegs), &
         flv%charge(flv%nlegs))
    do i = 1, flv%nlegs
       call flavor%init (flv%flst(i), model)
       flv%massive(i) = flavor%get_mass () > 0
       flv%colored(i) = &
            is_quark (flv%flst(i)) .or. is_gluon (flv%flst(i))
       flv%charge(i) = flavor%get_charge ()
    end do
  end subroutine flv_structure_init_mass_color_and_charge

@ %def flv_structure_init_mass_color_and_charge
@
<<FKS regions: flv structure: TBP>>=
  procedure :: get_last_two => flv_structure_get_last_two
<<FKS regions: sub interfaces>>=
    module function flv_structure_get_last_two (flv, n) result (flst_last)
      integer, dimension(2) :: flst_last
      class(flv_structure_t), intent(in) :: flv
      integer, intent(in) :: n
    end function flv_structure_get_last_two
<<FKS regions: procedures>>=
  module function flv_structure_get_last_two (flv, n) result (flst_last)
    integer, dimension(2) :: flst_last
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: n
    flst_last = [flv%flst(n - 1), flv%flst(n)]
  end function flv_structure_get_last_two

@ %def flv_structure_get_last_two
@
<<FKS regions: flv structure: TBP>>=
  procedure :: final => flv_structure_final
<<FKS regions: sub interfaces>>=
    module subroutine flv_structure_final (flv)
      class(flv_structure_t), intent(inout) :: flv
    end subroutine flv_structure_final
<<FKS regions: procedures>>=
  module subroutine flv_structure_final (flv)
    class(flv_structure_t), intent(inout) :: flv
    if (allocated (flv%flst)) deallocate (flv%flst)
    if (allocated (flv%tag)) deallocate (flv%tag)
    if (allocated (flv%massive)) deallocate (flv%massive)
    if (allocated (flv%colored)) deallocate (flv%colored)
    if (allocated (flv%charge)) deallocate (flv%charge)
  end subroutine flv_structure_final

@ %def flv_structure_final
@
<<FKS regions: types>>=
  type :: flv_perm_t
    integer, dimension(:,:), allocatable :: perms
  contains
  <<FKS regions: flavor permutation: TBP>>
  end type flv_perm_t

@ %def flv_perm_t
@
<<FKS regions: flavor permutation: TBP>>=
  procedure :: init => flv_perm_init
<<FKS regions: sub interfaces>>=
    module subroutine flv_perm_init &
         (perm, flv_in, flv_ref, n_first, n_last, with_tag)
      class(flv_perm_t), intent(out) :: perm
      type(flv_structure_t), intent(in) :: flv_in, flv_ref
      integer, intent(in) :: n_first, n_last
      logical, intent(in) :: with_tag
    end subroutine flv_perm_init
<<FKS regions: procedures>>=
  module subroutine flv_perm_init &
       (perm, flv_in, flv_ref, n_first, n_last, with_tag)
    class(flv_perm_t), intent(out) :: perm
    type(flv_structure_t), intent(in) :: flv_in, flv_ref
    integer, intent(in) :: n_first, n_last
    logical, intent(in) :: with_tag
    integer :: flv1, flv2, tmp
    integer :: tag1, tag2
    integer :: i, j, j_min, i_perm
    integer, dimension(:,:), allocatable :: perm_list_tmp
    type(flv_structure_t) :: flv_copy
    logical :: condition
    logical, dimension(:), allocatable :: already_correct
    flv_copy = flv_in
    allocate (perm_list_tmp (factorial (n_last - n_first - 1), 2))
    allocate (already_correct (flv_in%nlegs))
    already_correct = flv_in%flst == flv_ref%flst
    if (with_tag) &
         already_correct = already_correct .and. (flv_in%tag == flv_ref%tag)
    j_min = n_first + 1
    i_perm = 0
    do i = n_first + 1, n_last
       flv1 = flv_ref%flst(i)
       tag1 = flv_ref%tag(i)
       do j = j_min, n_last
          if (already_correct(i) .or. already_correct(j)) cycle
          flv2 = flv_copy%flst(j)
          tag2 = flv_copy%tag(j)
          condition = (flv1 == flv2) .and. i /= j
          if (with_tag) condition = condition .and. (tag1 == tag2)
          if (condition) then
             i_perm = i_perm + 1
             tmp = flv_copy%flst(i)
             flv_copy%flst(i) = flv2
             flv_copy%flst(j) = tmp
             tmp = flv_copy%tag(i)
             flv_copy%tag(i) = tag2
             flv_copy%tag(j) = tmp
             perm_list_tmp (i_perm, 1) = i
             perm_list_tmp (i_perm, 2) = j
             exit
          end if
       end do
       j_min = j_min + 1
    end do
    allocate (perm%perms (i_perm, 2))
    perm%perms = perm_list_tmp (1 : i_perm, :)
    deallocate (perm_list_tmp)
    call flv_copy%final ()
  end subroutine flv_perm_init

@ %def flv_perm_init
@
<<FKS regions: flavor permutation: TBP>>=
  procedure :: write => flv_perm_write
<<FKS regions: sub interfaces>>=
    module subroutine flv_perm_write (perm, unit)
      class(flv_perm_t), intent(in) :: perm
      integer, intent(in), optional :: unit
    end subroutine flv_perm_write
<<FKS regions: procedures>>=
  module subroutine flv_perm_write (perm, unit)
    class(flv_perm_t), intent(in) :: perm
    integer, intent(in), optional :: unit
    integer :: i, n, u
    u = given_output_unit (unit); if (u < 0) return
    write (u, "(A)") "Flavor permutation list: "
    n = size (perm%perms, dim = 1)
    if (n > 0) then
       do i = 1, n
          write (u, "(A1,I1,1X,I1,A1)", advance = "no") "[", &
               perm%perms(i,1), perm%perms(i,2), "]"
          if (i < n) write (u, "(A4)", advance = "no") " // "
       end do
       write (u, "(A)") ""
    else
       write (u, "(A)") "[Empty]"
    end if
  end subroutine flv_perm_write

@ %def flv_perm_write
@
<<FKS regions: flavor permutation: TBP>>=
  procedure :: reset => flv_perm_final
  procedure :: final => flv_perm_final
<<FKS regions: sub interfaces>>=
    module subroutine flv_perm_final (perm)
      class(flv_perm_t), intent(inout) :: perm
    end subroutine flv_perm_final
<<FKS regions: procedures>>=
  module subroutine flv_perm_final (perm)
    class(flv_perm_t), intent(inout) :: perm
    if (allocated (perm%perms)) deallocate (perm%perms)
  end subroutine flv_perm_final

@ %def flv_perm_final
@
<<FKS regions: flavor permutation: TBP>>=
  generic :: apply => &
         apply_flv_structure, apply_index, apply_ftuple
  procedure :: apply_flv_structure => flv_perm_apply_flv_structure
  procedure :: apply_index => flv_perm_apply_index
  procedure :: apply_ftuple => flv_perm_apply_ftuple
<<FKS regions: sub interfaces>>=
    elemental module function flv_perm_apply_flv_structure &
         (perm, flv_in, invert) result (flv_out)
      type(flv_structure_t) :: flv_out
      class(flv_perm_t), intent(in) :: perm
      type(flv_structure_t), intent(in) :: flv_in
      logical, intent(in), optional :: invert
    end function flv_perm_apply_flv_structure
<<FKS regions: procedures>>=
  elemental module function flv_perm_apply_flv_structure &
       (perm, flv_in, invert) result (flv_out)
    type(flv_structure_t) :: flv_out
    class(flv_perm_t), intent(in) :: perm
    type(flv_structure_t), intent(in) :: flv_in
    logical, intent(in), optional :: invert
    integer :: i, i1, i2
    integer :: p1, p2, incr
    integer :: flv_tmp, tag_tmp
    logical :: inv
    inv = .false.; if (present(invert)) inv = invert
    flv_out = flv_in
    if (inv) then
       p1 = 1
       p2 = size (perm%perms, dim = 1)
       incr = 1
    else
       p1 = size (perm%perms, dim = 1)
       p2 = 1
       incr = -1
    end if
    do i = p1, p2, incr
       i1 = perm%perms(i,1)
       i2 = perm%perms(i,2)
       flv_tmp = flv_out%flst(i1)
       tag_tmp = flv_out%tag(i1)
       flv_out%flst(i1) = flv_out%flst(i2)
       flv_out%flst(i2) = flv_tmp
       flv_out%tag(i1) = flv_out%tag(i2)
       flv_out%tag(i2) = tag_tmp
    end do
  end function flv_perm_apply_flv_structure

@ %def flv_perm_apply_flv_structure
@
<<FKS regions: sub interfaces>>=
    elemental module function flv_perm_apply_index &
         (perm, i_in) result (i_out)
      integer :: i_out
      class(flv_perm_t), intent(in) :: perm
      integer, intent(in) :: i_in
    end function flv_perm_apply_index
<<FKS regions: procedures>>=
  elemental module function flv_perm_apply_index &
       (perm, i_in) result (i_out)
    integer :: i_out
    class(flv_perm_t), intent(in) :: perm
    integer, intent(in) :: i_in
    integer :: i, i1, i2
    i_out = i_in
    do i = size (perm%perms(:,1)), 1, -1
       i1 = perm%perms(i,1)
       i2 = perm%perms(i,2)
       if (i_out == i1) then
          i_out = i2
       else if (i_out == i2) then
          i_out = i1
       end if
    end do
  end function flv_perm_apply_index

@ %def flv_perm_apply_index
@
<<FKS regions: sub interfaces>>=
    elemental module function flv_perm_apply_ftuple &
         (perm, f_in) result (f_out)
      type(ftuple_t) :: f_out
      class(flv_perm_t), intent(in) :: perm
      type(ftuple_t), intent(in) :: f_in
    end function flv_perm_apply_ftuple
<<FKS regions: procedures>>=
  elemental module function flv_perm_apply_ftuple &
       (perm, f_in) result (f_out)
    type(ftuple_t) :: f_out
    class(flv_perm_t), intent(in) :: perm
    type(ftuple_t), intent(in) :: f_in
    integer :: i, i1, i2
    f_out = f_in
    do i = size (perm%perms, dim = 1), 1, -1
       i1 = perm%perms(i,1)
       i2 = perm%perms(i,2)
       if (f_out%ireg(1) == i1) then
          f_out%ireg(1) = i2
       else if (f_out%ireg(1) == i2) then
          f_out%ireg(1) = i1
       end if
       if (f_out%ireg(2) == i1) then
          f_out%ireg(2) = i2
       else if (f_out%ireg(2) == i2) then
          f_out%ireg(2) = i1
       end if
    end do
    if (f_out%ireg(1) > f_out%ireg(2)) f_out%ireg = f_out%ireg([2,1])
  end function flv_perm_apply_ftuple

@ %def flv_perm_apply_ftuple
@
<<FKS regions: flavor permutation: TBP>>=
  procedure :: eqv => flv_perm_eqv
<<FKS regions: sub interfaces>>=
    module function flv_perm_eqv &
         (perm, flv1, flv2, with_tag) result (valid)
      logical :: valid
      class(flv_perm_t), intent(in) :: perm
      type(flv_structure_t), intent(in) :: flv1, flv2
      logical, intent(in) :: with_tag
    end function flv_perm_eqv
<<FKS regions: procedures>>=
  module function flv_perm_eqv &
       (perm, flv1, flv2, with_tag) result (valid)
    logical :: valid
    class(flv_perm_t), intent(in) :: perm
    type(flv_structure_t), intent(in) :: flv1, flv2
    logical, intent(in) :: with_tag
    type(flv_structure_t) :: flv_tmp
    flv_tmp = perm%apply (flv2, invert = .true.)
    valid = all (flv_tmp%flst == flv1%flst)
    if (with_tag) valid = valid .and. all (flv_tmp%tag == flv1%tag)
    call flv_tmp%final ()
  end function flv_perm_eqv

@ %def flv_perm_eqv
@ A singular region is a partition of phase space which is associated with
an individual emitter and, if relevant, resonance. It is associated with
an $\alpha_r$- and resonance-index, with a real flavor structure and
its underlying Born flavor structure. To compute the FKS weights, it is
relevant to know all the other particle indices which can result in a
divergenent phase space configuration, which are collected in the
[[ftuples]]-array.

Some singular regions might behave physically identical. E.g. a real
flavor structure associated with three-jet production is $[11,-11,2,-2,21,21]$.
Here, there are two possible [[ftuples]] which contribute to the same
$u \rightarrow u g$ splitting, namely $(3,5)$ and $(3,6)$. The resulting
singular regions will be identical. To avoid this, one singular region
is associated with the multiplicity factor [[mult]]. When computing the
subtraction terms for each singular region, the result is then simply
multiplied by this factor.\\
The [[double_fsr]]-flag indicates whether the singular region should
also be supplied by a symmetry factor, explained below.
<<FKS regions: public>>=
  public :: singular_region_t
<<FKS regions: types>>=
  type :: singular_region_t
    integer :: alr
    integer :: i_res
    type(flv_structure_t) :: flst_real
    type(flv_structure_t) :: flst_uborn
    integer :: mult
    integer :: emitter
    integer :: nregions
    integer :: real_index
    type(ftuple_t), dimension(:), allocatable :: ftuples
    integer :: uborn_index
    logical :: double_fsr = .false.
    logical :: soft_divergence = .false.
    logical :: coll_divergence = .false.
    type(string_t) :: nlo_correction_type
    integer, dimension(:), allocatable :: i_reg_to_i_con
    logical :: pseudo_isr = .false.
    logical :: sc_required = .false.
    integer :: eqv_index = 0
  contains
  <<FKS regions: singular region: TBP>>
  end type singular_region_t

@ %def singular_region_t
@
<<FKS regions: singular region: TBP>>=
  procedure :: init => singular_region_init
<<FKS regions: sub interfaces>>=
    module subroutine singular_region_init (sregion, alr, mult, i_res, &
         flst_real, flst_uborn, flv_born, emitter, ftuples, equivalences, &
         nlo_correction_type)
      class(singular_region_t), intent(out) :: sregion
      integer, intent(in) :: alr, mult, i_res
      type(flv_structure_t), intent(in) :: flst_real
      type(flv_structure_t), intent(in) :: flst_uborn
      type(flv_structure_t), dimension(:), intent(in) :: flv_born
      integer, intent(in) :: emitter
      type(ftuple_t), intent(inout), dimension(:) :: ftuples
      logical, intent(inout), dimension(:,:) :: equivalences
      type(string_t), intent(in) :: nlo_correction_type
    end subroutine singular_region_init
<<FKS regions: procedures>>=
  module subroutine singular_region_init (sregion, alr, mult, i_res, &
       flst_real, flst_uborn, flv_born, emitter, ftuples, equivalences, &
       nlo_correction_type)
    class(singular_region_t), intent(out) :: sregion
    integer, intent(in) :: alr, mult, i_res
    type(flv_structure_t), intent(in) :: flst_real
    type(flv_structure_t), intent(in) :: flst_uborn
    type(flv_structure_t), dimension(:), intent(in) :: flv_born
    integer, intent(in) :: emitter
    type(ftuple_t), intent(inout), dimension(:) :: ftuples
    logical, intent(inout), dimension(:,:) :: equivalences
    type(string_t), intent(in) :: nlo_correction_type
    integer :: i
    call debug_input_values ()
    sregion%alr = alr
    sregion%mult = mult
    sregion%i_res = i_res
    sregion%flst_real = flst_real
    sregion%flst_uborn = flst_uborn
    sregion%emitter = emitter
    sregion%nlo_correction_type = nlo_correction_type
    sregion%nregions = size (ftuples)
    allocate (sregion%ftuples (sregion%nregions))
    sregion%ftuples = ftuples
    do i = 1, size(flv_born)
       if (flv_born (i) .equiv. sregion%flst_uborn) then
          sregion%uborn_index = i
          exit
       end if
    end do
    sregion%sc_required = any (sregion%flst_uborn%flst == GLUON) .or. &
            any (sregion%flst_uborn%flst == PHOTON)
  contains
    subroutine debug_input_values()
      if (debug_on) call msg_debug2 (D_SUBTRACTION, "singular_region_init")
      if (debug2_active (D_SUBTRACTION)) then
         print *, 'alr =    ', alr
         print *, 'mult =    ', mult
         print *, 'i_res =    ', i_res
         call flst_real%write ()
         call flst_uborn%write ()
         print *, 'emitter =    ', emitter
         call print_equivalence_matrix (ftuples, equivalences)
      end if
    end subroutine debug_input_values
  end subroutine singular_region_init

@ %def singular_region_init
<<FKS regions: singular region: TBP>>=
  procedure :: write => singular_region_write
<<FKS regions: sub interfaces>>=
    module subroutine singular_region_write (sregion, unit, maxnregions)
      class(singular_region_t), intent(in) :: sregion
      integer, intent(in), optional :: unit
      integer, intent(in), optional :: maxnregions
    end subroutine singular_region_write
<<FKS regions: procedures>>=
  module subroutine singular_region_write (sregion, unit, maxnregions)
    class(singular_region_t), intent(in) :: sregion
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: maxnregions
    character(len=7), parameter :: flst_format = "(I3,A1)"
    character(len=7), parameter :: ireg_space_format = "(7X,A1)"
    integer :: nreal, nborn, i, u, mr
    integer :: nleft, nright, nreg, nreg_diff
    u = given_output_unit (unit); if (u < 0) return
    mr = sregion%nregions; if (present (maxnregions))  mr = maxnregions
    nreal = size (sregion%flst_real%flst)
    nborn = size (sregion%flst_uborn%flst)
    call write_vline (u)
    write (u, '(A1)', advance = 'no') '['
    do i = 1, nreal - 1
       write (u, flst_format, advance = 'no') sregion%flst_real%flst(i), ','
    end do
    write (u, flst_format, advance = 'no') sregion%flst_real%flst(nreal), ']'
    call write_vline (u)
    write (u, '(I6)', advance = 'no') sregion%real_index
    call write_vline (u)
    write (u, '(I3)', advance = 'no') sregion%emitter
    call write_vline (u)
    write (u, '(I3)', advance = 'no') sregion%mult
    call write_vline (u)
    write (u, '(I4)', advance = 'no') sregion%nregions
    call write_vline (u)
    if (sregion%i_res > 0) then
       write (u, '(I3)', advance = 'no') sregion%i_res
       call write_vline (u)
    end if
    nreg = sregion%nregions
    if (nreg == mr) then
       nleft = 0
       nright = 0
    else
       nreg_diff = mr - nreg
       nleft = nreg_diff / 2
       if (mod(nreg_diff , 2) == 0) then
          nright = nleft
       else
          nright = nleft + 1
       end if
    end if
    if (nleft > 0) then
       do i = 1, nleft
          write(u, ireg_space_format, advance='no') ' '
       end do
    end if
    write (u, '(A)', advance = 'no') char (ftuple_string (sregion%ftuples, .false.))
    call write_vline (u)
    write (u,'(A1)',advance = 'no') '['
    do i = 1, nborn - 1
       write(u, flst_format, advance = 'no') sregion%flst_uborn%flst(i), ','
    end do
    write (u, flst_format, advance = 'no') sregion%flst_uborn%flst(nborn), ']'
    call write_vline (u)
    write (u, '(I7)', advance = 'no') sregion%uborn_index
    call write_vline (u)
    if (sregion%nlo_correction_type == "EW") then
       write (u, '(A3)', advance = 'no') 'ew'
    else if (sregion%nlo_correction_type == "QCD") then
       write (u, '(A4)', advance = 'no') 'qcd'
    else
       write (u, '(A5)', advance = 'no') 'none'
    end if
    write (u, '(A)')
  end subroutine singular_region_write

@ %def singular_region_write
@
<<FKS regions: singular region: TBP>>=
  procedure :: write_latex => singular_region_write_latex
<<FKS regions: sub interfaces>>=
    module subroutine singular_region_write_latex (region, unit)
      class(singular_region_t), intent(in) :: region
      integer, intent(in), optional :: unit
    end subroutine singular_region_write_latex
<<FKS regions: procedures>>=
  module subroutine singular_region_write_latex (region, unit)
    class(singular_region_t), intent(in) :: region
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit); if (u < 0) return
    write (u, "(I2,A3,A,A3,I2,A3,I1,A3,I1,A3,A,A3,I2,A3,A,A3)") &
           region%alr, " & ", char (region%flst_real%to_string ()), &
           " & ", region%real_index, " & ", region%emitter, " & ", &
           region%mult, " & ", char (ftuple_string (region%ftuples, .true.)), &
           " & ", region%uborn_index, " & ",  char (region%flst_uborn%to_string ()), &
           " \\"
  end subroutine singular_region_write_latex

@ %def singular_region_write_latex
@ In case of a $g \rightarrow gg$ splitting, the factor
\begin{equation*}
  \frac{2E_{\rm{em}}}{E_{\rm{em}} + E_{\rm{rad}}}
\end{equation*}
is multiplied to the real matrix element. This way, the symmetry of
the splitting is used and only one singular region has to be taken
into account. However, the factor ensures that there is only a soft
singularity if the radiated parton becomes soft.
<<FKS regions: singular region: TBP>>=
  procedure :: set_splitting_info => singular_region_set_splitting_info
<<FKS regions: sub interfaces>>=
    module subroutine singular_region_set_splitting_info (region, n_in)
      class(singular_region_t), intent(inout) :: region
      integer, intent(in) :: n_in
    end subroutine singular_region_set_splitting_info
<<FKS regions: procedures>>=
  module subroutine singular_region_set_splitting_info (region, n_in)
    class(singular_region_t), intent(inout) :: region
    integer, intent(in) :: n_in
    integer :: i1, i2
    integer :: reg
    region%double_fsr = .false.
    region%soft_divergence = .false.
    associate (ftuple => region%ftuples)
       do reg = 1, region%nregions
          call ftuple(reg)%get (i1, i2)
          if (i1 /= region%emitter .or. i2 /= region%flst_real%nlegs) then
             cycle
          else
             if (ftuple(reg)%splitting_type == V_TO_VV .or.  &
                 ftuple(reg)%splitting_type == F_TO_FV ) then
                region%soft_divergence = .true.
             end if

             if (i1 == 0) then
                region%coll_divergence = &
                     .not. all (region%flst_real%massive(1:n_in))
             else
                region%coll_divergence = .not. region%flst_real%massive(i1)
             end if

             if (ftuple(reg)%splitting_type == V_TO_VV) then
                if (all (ftuple(reg)%ireg > n_in))  &
                     region%double_fsr = &
                     all (is_gluon (region%flst_real%flst(ftuple(reg)%ireg)))
                exit
             else if (ftuple(reg)%splitting_type == UNDEFINED_SPLITTING) then
                call msg_fatal ("All splittings should be defined!")
             end if
          end if
       end do
       if (.not. region%soft_divergence .and. .not. region%coll_divergence) &
            call msg_fatal ("Singular region defined without divergence!")
     end associate
  end subroutine singular_region_set_splitting_info

@ %def singular_region_set_splitting_info
@
<<FKS regions: singular region: TBP>>=
  procedure :: double_fsr_factor => singular_region_double_fsr_factor
<<FKS regions: sub interfaces>>=
    module function singular_region_double_fsr_factor (region, p) result (val)
      class(singular_region_t), intent(in) :: region
      type(vector4_t), intent(in), dimension(:) :: p
      real(default) :: val
    end function singular_region_double_fsr_factor
<<FKS regions: procedures>>=
  module function singular_region_double_fsr_factor (region, p) result (val)
    class(singular_region_t), intent(in) :: region
    type(vector4_t), intent(in), dimension(:) :: p
    real(default) :: val
    real(default) :: E_rad, E_em
    if (region%double_fsr) then
       E_em = energy (p(region%emitter))
       E_rad = energy (p(region%flst_real%nlegs))
       val = two * E_em / (E_em + E_rad)
    else
       val = one
    end if
  end function singular_region_double_fsr_factor

@ %def singular_region_double_fsr_factor
@
<<FKS regions: singular region: TBP>>=
  procedure :: has_soft_divergence => singular_region_has_soft_divergence
<<FKS regions: sub interfaces>>=
    module function singular_region_has_soft_divergence (region) result (div)
      logical :: div
      class(singular_region_t), intent(in) :: region
    end function singular_region_has_soft_divergence
<<FKS regions: procedures>>=
  module function singular_region_has_soft_divergence (region) result (div)
    logical :: div
    class(singular_region_t), intent(in) :: region
    div = region%soft_divergence
  end function singular_region_has_soft_divergence

@ %def singular_region_has_soft_divergence
@
<<FKS regions: singular region: TBP>>=
  procedure :: has_collinear_divergence => &
         singular_region_has_collinear_divergence
<<FKS regions: sub interfaces>>=
    module function singular_region_has_collinear_divergence &
         (region) result (div)
      logical :: div
      class(singular_region_t), intent(in) :: region
    end function singular_region_has_collinear_divergence
<<FKS regions: procedures>>=
  module function singular_region_has_collinear_divergence &
       (region) result (div)
    logical :: div
    class(singular_region_t), intent(in) :: region
    div = region%coll_divergence
  end function singular_region_has_collinear_divergence

@ %def singular_region_has_collinear_divergence
@
<<FKS regions: singular region: TBP>>=
  procedure :: has_identical_ftuples => singular_region_has_identical_ftuples
<<FKS regions: sub interfaces>>=
    elemental module function singular_region_has_identical_ftuples &
         (sregion) result (value)
      logical :: value
      class(singular_region_t), intent(in) :: sregion
    end function singular_region_has_identical_ftuples
<<FKS regions: procedures>>=
  elemental module function singular_region_has_identical_ftuples &
       (sregion) result (value)
    logical :: value
    class(singular_region_t), intent(in) :: sregion
    integer :: alr
    value = .false.
    do alr = 1, sregion%nregions
       value = value .or. (count (sregion%ftuples(alr) == sregion%ftuples) > 1)
    end do
  end function singular_region_has_identical_ftuples

@ %def singular_region_has_identical_ftuples
@
<<FKS regions: interfaces>>=
  interface assignment(=)
     module procedure singular_region_assign
  end interface

<<FKS regions: sub interfaces>>=
    module subroutine singular_region_assign (reg_out, reg_in)
      type(singular_region_t), intent(out) :: reg_out
      type(singular_region_t), intent(in) :: reg_in
    end subroutine singular_region_assign
<<FKS regions: procedures>>=
  module subroutine singular_region_assign (reg_out, reg_in)
    type(singular_region_t), intent(out) :: reg_out
    type(singular_region_t), intent(in) :: reg_in
    reg_out%alr = reg_in%alr
    reg_out%i_res = reg_in%i_res
    reg_out%flst_real = reg_in%flst_real
    reg_out%flst_uborn = reg_in%flst_uborn
    reg_out%mult = reg_in%mult
    reg_out%emitter = reg_in%emitter
    reg_out%nregions = reg_in%nregions
    reg_out%real_index = reg_in%real_index
    reg_out%uborn_index = reg_in%uborn_index
    reg_out%double_fsr = reg_in%double_fsr
    reg_out%soft_divergence = reg_in%soft_divergence
    reg_out%coll_divergence = reg_in%coll_divergence
    reg_out%nlo_correction_type = reg_in%nlo_correction_type
    if (allocated (reg_in%ftuples)) then
       allocate (reg_out%ftuples (size (reg_in%ftuples)))
       reg_out%ftuples = reg_in%ftuples
    else
       call msg_bug ("singular_region_assign: Trying to copy a " // &
            "singular region without allocated ftuples!")
    end if
  end subroutine singular_region_assign
@ %def singular_region_assign
@ Two singular regions match if they would produce the same amplitude.
For this we have to check that their real and underlying Born flavor
structures are equivalent, as determined by the [[prc_core]]. However,
since there are more aspects of a singular region that make it unique,
we have to check other attributes as well.
<<FKS regions: interfaces>>=
  interface operator(.match.)
     module procedure singular_region_match
  end interface

<<FKS regions: sub interfaces>>=
    module function singular_region_match (reg1, reg2) result (match)
      type(singular_region_t), intent(in) :: reg1, reg2
      logical :: match
    end function singular_region_match
<<FKS regions: procedures>>=
  module function singular_region_match (reg1, reg2) result (match)
    type(singular_region_t), intent(in) :: reg1, reg2
    logical :: match
    match = all ([reg1%flst_real%eqv_index, reg2%flst_real%eqv_index] > 0)
    match = match .and. (reg1%flst_real%eqv_index == reg2%flst_real%eqv_index)
    match = match .and. (reg1%flst_uborn%eqv_index == reg2%flst_uborn%eqv_index)
    match = match .and. (reg1%mult == reg2%mult)
    match = match .and. (reg1%emitter == reg2%emitter)
    match = match .and. (reg1%nregions == reg2%nregions)
    match = match .and. (reg1%double_fsr .eqv. reg2%double_fsr)
    match = match .and. (reg1%soft_divergence .eqv. reg2%soft_divergence)
    match = match .and. (reg1%coll_divergence .eqv. reg2%coll_divergence)
    match = match .and. (char (reg1%nlo_correction_type) == char (reg2%nlo_correction_type))
    if (match) match = match .and. (all (reg1%ftuples == reg2%ftuples))
  end function singular_region_match

@ %def singular_region_match
@
<<FKS regions: types>>=
  type :: resonance_mapping_t
    type(resonance_history_t), dimension(:), allocatable :: res_histories
    integer, dimension(:), allocatable :: alr_to_i_res
    integer, dimension(:,:), allocatable :: i_res_to_alr
    type(vector4_t), dimension(:), allocatable :: p_res
  contains
  <<FKS regions: resonance mapping: TBP>>
  end type resonance_mapping_t

@ %def resonance_mapping_t
@ Testing: Init resonance mapping for $\mu \mu b b$ final state.
<<FKS regions: resonance mapping: TBP>>=
  procedure :: init => resonance_mapping_init
<<FKS regions: sub interfaces>>=
    module subroutine resonance_mapping_init (res_map, res_hist)
      class(resonance_mapping_t), intent(inout) :: res_map
      type(resonance_history_t), intent(in), dimension(:) :: res_hist
    end subroutine resonance_mapping_init
<<FKS regions: procedures>>=
  module subroutine resonance_mapping_init (res_map, res_hist)
    class(resonance_mapping_t), intent(inout) :: res_map
    type(resonance_history_t), intent(in), dimension(:) :: res_hist
    integer :: n_hist, i_hist1, i_hist2, n_contributors
    n_contributors = 0
    n_hist = size (res_hist)
    allocate (res_map%res_histories (n_hist))
    do i_hist1 = 1, n_hist
       if (i_hist1 + 1 <= n_hist) then
          do i_hist2 = i_hist1 + 1, n_hist
             if (.not. (res_hist(i_hist1) .contains. res_hist(i_hist2))) &
                n_contributors = n_contributors + &
                                    res_hist(i_hist2)%n_resonances
          end do
       else
          n_contributors = n_contributors + res_hist(i_hist1)%n_resonances
       end if
    end do
    allocate (res_map%p_res (n_contributors))
    res_map%res_histories = res_hist
    res_map%p_res = vector4_null
  end subroutine resonance_mapping_init

@ %def resonance_mapping_init
@
<<FKS regions: resonance mapping: TBP>>=
  procedure :: set_alr_to_i_res => resonance_mapping_set_alr_to_i_res
<<FKS regions: sub interfaces>>=
    module subroutine resonance_mapping_set_alr_to_i_res &
         (res_map, regions, alr_new_to_old)
      class(resonance_mapping_t), intent(inout) :: res_map
      type(singular_region_t), intent(in), dimension(:) :: regions
      integer, intent(out), dimension(:), allocatable :: alr_new_to_old
    end subroutine resonance_mapping_set_alr_to_i_res
<<FKS regions: procedures>>=
  module subroutine resonance_mapping_set_alr_to_i_res &
       (res_map, regions, alr_new_to_old)
    class(resonance_mapping_t), intent(inout) :: res_map
    type(singular_region_t), intent(in), dimension(:) :: regions
    integer, intent(out), dimension(:), allocatable :: alr_new_to_old
    integer :: alr, i_res
    integer :: alr_new, n_alr_res
    integer :: k
    if (debug_on)  call msg_debug &
         (D_SUBTRACTION, "resonance_mapping_set_alr_to_i_res")
    n_alr_res = 0
    do alr = 1, size (regions)
       do i_res = 1, size (res_map%res_histories)
          if (res_map%res_histories(i_res)%contains_leg &
               (regions(alr)%emitter)) &
               n_alr_res = n_alr_res + 1
       end do
    end do

    allocate (res_map%alr_to_i_res (n_alr_res))
    allocate (res_map%i_res_to_alr (size (res_map%res_histories), 10))
    res_map%i_res_to_alr = 0
    allocate (alr_new_to_old (n_alr_res))
    alr_new = 1
    do alr = 1, size (regions)
       do i_res = 1, size (res_map%res_histories)
          if (res_map%res_histories(i_res)%contains_leg &
               (regions(alr)%emitter)) then
             res_map%alr_to_i_res (alr_new) = i_res
             alr_new_to_old (alr_new) = alr
             alr_new = alr_new  + 1
          end if
       end do
    end do

    do i_res = 1, size (res_map%res_histories)
       k = 1
       do alr = 1, size (regions)
          if (res_map%res_histories(i_res)%contains_leg &
               (regions(alr)%emitter)) then
             res_map%i_res_to_alr (i_res, k) = alr
             k = k + 1
          end if
       end do
    end do
    if (debug_active (D_SUBTRACTION)) then
       print *, 'i_res_to_alr:'
       do i_res = 1, size(res_map%i_res_to_alr, dim=1)
          print *, res_map%i_res_to_alr (i_res, :)
       end do
       print *, 'alr_new_to_old:', alr_new_to_old
    end if
  end subroutine resonance_mapping_set_alr_to_i_res

@ %def resonance_mapping_set_alr_to_i_res
@
<<FKS regions: resonance mapping: TBP>>=
  procedure :: get_resonance_history => resonance_mapping_get_resonance_history
<<FKS regions: sub interfaces>>=
    module function resonance_mapping_get_resonance_history &
         (res_map, alr) result (res_hist)
      type(resonance_history_t) :: res_hist
      class(resonance_mapping_t), intent(in) :: res_map
      integer, intent(in) :: alr
    end function resonance_mapping_get_resonance_history
<<FKS regions: procedures>>=
  module function resonance_mapping_get_resonance_history &
       (res_map, alr) result (res_hist)
    type(resonance_history_t) :: res_hist
    class(resonance_mapping_t), intent(in) :: res_map
    integer, intent(in) :: alr
    res_hist = res_map%res_histories(res_map%alr_to_i_res (alr))
  end function resonance_mapping_get_resonance_history

@ %def resonance_mapping_get_resonance_history
@
<<FKS regions: resonance mapping: TBP>>=
  procedure :: write => resonance_mapping_write
<<FKS regions: sub interfaces>>=
    module subroutine resonance_mapping_write (res_map)
      class(resonance_mapping_t), intent(in) :: res_map
    end subroutine resonance_mapping_write
<<FKS regions: procedures>>=
  module subroutine resonance_mapping_write (res_map)
    class(resonance_mapping_t), intent(in) :: res_map
    integer :: i_res
    do i_res = 1, size (res_map%res_histories)
       call res_map%res_histories(i_res)%write ()
    end do
  end subroutine resonance_mapping_write

@ %def resonance_mapping_write
@
<<FKS regions: resonance mapping: TBP>>=
  procedure :: get_resonance_value => resonance_mapping_get_resonance_value
<<FKS regions: sub interfaces>>=
    module function resonance_mapping_get_resonance_value &
         (res_map, i_res, p, i_gluon) result (p_map)
      real(default) :: p_map
      class(resonance_mapping_t), intent(in) :: res_map
      integer, intent(in) :: i_res
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in), optional :: i_gluon
    end function resonance_mapping_get_resonance_value
<<FKS regions: procedures>>=
  module function resonance_mapping_get_resonance_value &
       (res_map, i_res, p, i_gluon) result (p_map)
    real(default) :: p_map
    class(resonance_mapping_t), intent(in) :: res_map
    integer, intent(in) :: i_res
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in), optional :: i_gluon
    p_map = res_map%res_histories(i_res)%mapping (p, i_gluon)
  end function resonance_mapping_get_resonance_value

@ %def resonance_mapping_get_resonance_value
@
<<FKS regions: resonance mapping: TBP>>=
  procedure :: get_resonance_all => resonance_mapping_get_resonance_all
<<FKS regions: sub interfaces>>=
    module function resonance_mapping_get_resonance_all &
         (res_map, alr, p, i_gluon) result (p_map)
      real(default) :: p_map
      class(resonance_mapping_t), intent(in) :: res_map
      integer, intent(in) :: alr
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in), optional :: i_gluon
    end function resonance_mapping_get_resonance_all
<<FKS regions: procedures>>=
  module function resonance_mapping_get_resonance_all &
       (res_map, alr, p, i_gluon) result (p_map)
    real(default) :: p_map
    class(resonance_mapping_t), intent(in) :: res_map
    integer, intent(in) :: alr
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in), optional :: i_gluon
    integer :: i_res
    p_map = zero
    do i_res = 1, size (res_map%res_histories)
       associate (res => res_map%res_histories(i_res))
          if (any (res_map%i_res_to_alr (i_res, :) == alr)) &
             p_map = p_map + res%mapping (p, i_gluon)
       end associate
    end do
  end function resonance_mapping_get_resonance_all

@ %def resonance_mapping_get_resonance_all
@
<<FKS regions: resonance mapping: TBP>>=
  procedure :: get_weight => resonance_mapping_get_weight
<<FKS regions: sub interfaces>>=
    module function resonance_mapping_get_weight (res_map, alr, p) result (pfr)
      real(default) :: pfr
      class(resonance_mapping_t), intent(in) :: res_map
      integer, intent(in) :: alr
      type(vector4_t), intent(in), dimension(:) :: p
    end function resonance_mapping_get_weight
<<FKS regions: procedures>>=
  module function resonance_mapping_get_weight (res_map, alr, p) result (pfr)
    real(default) :: pfr
    class(resonance_mapping_t), intent(in) :: res_map
    integer, intent(in) :: alr
    type(vector4_t), intent(in), dimension(:) :: p
    real(default) :: sumpfr
    integer :: i_res
    sumpfr = zero
    do i_res = 1, size (res_map%res_histories)
       sumpfr = sumpfr + res_map%get_resonance_value (i_res, p)
    end do
    pfr = res_map%get_resonance_value (res_map%alr_to_i_res (alr), p) / sumpfr
  end function resonance_mapping_get_weight

@ %def resonance_mapping_get_weight
@
<<FKS regions: resonance mapping: TBP>>=
  procedure :: get_resonance_alr => resonance_mapping_get_resonance_alr
<<FKS regions: sub interfaces>>=
    module function resonance_mapping_get_resonance_alr &
         (res_map, alr, p, i_gluon) result (p_map)
      real(default) :: p_map
      class(resonance_mapping_t), intent(in) :: res_map
      integer, intent(in) :: alr
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in), optional :: i_gluon
    end function resonance_mapping_get_resonance_alr
<<FKS regions: procedures>>=
  module function resonance_mapping_get_resonance_alr &
       (res_map, alr, p, i_gluon) result (p_map)
    real(default) :: p_map
    class(resonance_mapping_t), intent(in) :: res_map
    integer, intent(in) :: alr
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in), optional :: i_gluon
    integer :: i_res
    i_res = res_map%alr_to_i_res (alr)
    p_map = res_map%res_histories(i_res)%mapping (p, i_gluon)
  end function resonance_mapping_get_resonance_alr

@ %def resonance_mapping_get_resonance_alr
@
<<FKS regions: interfaces>>=
  interface assignment(=)
     module procedure resonance_mapping_assign
  end interface

<<FKS regions: sub interfaces>>=
    module subroutine resonance_mapping_assign (res_map_out, res_map_in)
      type(resonance_mapping_t), intent(out) :: res_map_out
      type(resonance_mapping_t), intent(in) :: res_map_in
    end subroutine resonance_mapping_assign
<<FKS regions: procedures>>=
  module subroutine resonance_mapping_assign (res_map_out, res_map_in)
    type(resonance_mapping_t), intent(out) :: res_map_out
    type(resonance_mapping_t), intent(in) :: res_map_in
    if (allocated (res_map_in%res_histories)) then
       allocate (res_map_out%res_histories (size (res_map_in%res_histories)))
       res_map_out%res_histories = res_map_in%res_histories
    end if
    if (allocated (res_map_in%alr_to_i_res)) then
       allocate (res_map_out%alr_to_i_res (size (res_map_in%alr_to_i_res)))
       res_map_out%alr_to_i_res = res_map_in%alr_to_i_res
    end if
    if (allocated (res_map_in%i_res_to_alr)) then
       allocate (res_map_out%i_res_to_alr (size (res_map_in%i_res_to_alr, 1), &
            size (res_map_in%i_res_to_alr, 2)))
       res_map_out%i_res_to_alr = res_map_in%i_res_to_alr
    end if
    if (allocated (res_map_in%p_res)) then
       allocate (res_map_out%p_res (size (res_map_in%p_res)))
       res_map_out%p_res = res_map_in%p_res
    end if
  end subroutine resonance_mapping_assign

@ %def resonance_mapping_assign
@ Every FKS mapping should store the $\sum_\alpha d_{ij}^{-1}$ and
$\sum_\alpha d_{ij,\rm{soft}}^{-1}$.
Also we keep the option open to use a normlization factor, which ensures
$\sum_\alpha S_\alpha = 1$.
<<FKS regions: types>>=
  type, abstract :: fks_mapping_t
     real(default) :: sumdij
     real(default) :: sumdij_soft
     logical :: pseudo_isr = .false.
     real(default) :: normalization_factor = one
  contains
  <<FKS regions: fks mapping: TBP>>
  end type fks_mapping_t

@ %def fks_mapping_t
@
<<FKS regions: public>>=
  public :: fks_mapping_default_t
<<FKS regions: types>>=
  type, extends (fks_mapping_t) :: fks_mapping_default_t
    real(default) :: exp_1, exp_2
    integer :: n_in
  contains
  <<FKS regions: fks mapping default: TBP>>
  end type fks_mapping_default_t

@ %def fks_mapping_default_t
@
<<FKS regions: public>>=
  public :: fks_mapping_resonances_t
<<FKS regions: types>>=
  type, extends (fks_mapping_t) :: fks_mapping_resonances_t
    real(default) :: exp_1, exp_2
    type(resonance_mapping_t) :: res_map
    integer :: i_con = 0
  contains
  <<FKS regions: fks mapping resonances: TBP>>
  end type fks_mapping_resonances_t

@ %def fks_mapping_resonances_t
@
<<FKS regions: public>>=
  public :: operator(.equiv.)
  public :: operator(.equivtag.)
<<FKS regions: interfaces>>=
  interface operator(.equiv.)
    module procedure flv_structure_equivalent_no_tag
  end interface

  interface operator(.equivtag.)
    module procedure flv_structure_equivalent_with_tag
  end interface

  interface assignment(=)
    module procedure flv_structure_assign_flv
    module procedure flv_structure_assign_integer
  end interface

@ %def operator_equiv
@
<<FKS regions: public>>=
  public :: region_data_t
<<FKS regions: types>>=
  type :: region_data_t
    type(singular_region_t), dimension(:), allocatable :: regions
    type(flv_structure_t), dimension(:), allocatable :: flv_born
    type(flv_structure_t), dimension(:), allocatable :: flv_real
    integer, dimension(:), allocatable :: eqv_flv_index_born
    integer, dimension(:), allocatable :: eqv_flv_index_real
    integer, dimension(:), allocatable :: emitters
    integer :: n_regions = 0
    integer :: n_emitters = 0
    integer :: n_flv_born = 0
    integer :: n_flv_real = 0
    integer :: n_in = 0
    integer :: n_legs_born = 0
    integer :: n_legs_real = 0
    integer :: n_phs = 0
    integer :: alpha_power = 0
    integer :: alphas_power = 0
    type(string_t) :: nlo_correction_type
    class(fks_mapping_t), allocatable :: fks_mapping
    integer, dimension(:), allocatable :: resonances
    type(resonance_contributors_t), dimension(:), allocatable :: alr_contributors
    integer, dimension(:), allocatable :: alr_to_i_contributor
    integer, dimension(:), allocatable :: i_phs_to_i_con
  contains
  <<FKS regions: reg data: TBP>>
  end type region_data_t

@ %def region_data_t
@ Gfortran 7/8/9/ bug, has to remain in the main module:
<<FKS regions: reg data: TBP>>=
  procedure :: allocate_fks_mappings => region_data_allocate_fks_mappings
<<FKS regions: main procedures>>=
  subroutine region_data_allocate_fks_mappings (reg_data, mapping_type)
    class(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: mapping_type
    select case (mapping_type)
    case (FKS_DEFAULT)
       allocate (fks_mapping_default_t :: reg_data%fks_mapping)
    case (FKS_RESONANCES)
       allocate (fks_mapping_resonances_t :: reg_data%fks_mapping)
    case default
       call msg_fatal ("Init region_data: FKS mapping not implemented!")
    end select
  end subroutine region_data_allocate_fks_mappings

@ %def region_data_allocate_fks_mappings
@
<<FKS regions: reg data: TBP>>=
  procedure :: init => region_data_init
<<FKS regions: sub interfaces>>=
    module subroutine region_data_init (reg_data, n_in, model, flavor_born, &
         flavor_real, nlo_correction_type, alpha_pow, alphas_pow)
      class(region_data_t), intent(out) :: reg_data
      integer, intent(in) :: n_in, alpha_pow, alphas_pow
      type(model_t), intent(in) :: model
      integer, intent(in), dimension(:,:) :: flavor_born, flavor_real
      type(string_t), intent(in) :: nlo_correction_type
    end subroutine region_data_init
<<FKS regions: procedures>>=
  module subroutine region_data_init (reg_data, n_in, model, flavor_born, &
       flavor_real, nlo_correction_type, alpha_pow, alphas_pow)
    class(region_data_t), intent(out) :: reg_data
    integer, intent(in) :: n_in, alpha_pow, alphas_pow
    type(model_t), intent(in) :: model
    integer, intent(in), dimension(:,:) :: flavor_born, flavor_real
    type(string_t), intent(in) :: nlo_correction_type
    integer, dimension(:,:), allocatable ::  flv_real_tmp
    type(ftuple_list_t), dimension(:), allocatable :: ftuples
    integer, dimension(:), allocatable :: emitter
    type(flv_structure_t), dimension(:), allocatable :: flst_alr
    integer :: i, n_real
    integer :: n_flv_real_before_check
    reg_data%n_in = n_in
    reg_data%alpha_power = alpha_pow
    reg_data%alphas_power = alphas_pow
    reg_data%n_flv_born = size (flavor_born, dim = 2)
    reg_data%n_legs_born = size (flavor_born, dim = 1)
    reg_data%n_legs_real = reg_data%n_legs_born + 1
    reg_data%nlo_correction_type = nlo_correction_type
    n_flv_real_before_check = size (flavor_real, dim = 2)
    allocate (reg_data%flv_born (reg_data%n_flv_born))
    allocate (flv_real_tmp (reg_data%n_legs_real, n_flv_real_before_check))
    do i = 1, reg_data%n_flv_born
       call reg_data%flv_born(i)%init (flavor_born (:, i), n_in)
    end do
    n_real = 0
    do i = 1, n_flv_real_before_check
       if (nlo_correction_type == "EW") then
          if (.not. (query_coupling_powers &
              (flavor_real (:, i), reg_data%alpha_power + 1, &
               reg_data%alphas_power))) cycle
       end if
       n_real = n_real + 1
       flv_real_tmp (:, n_real) = flavor_real (:, i)
    end do
    allocate (reg_data%flv_real (n_real))
    do i = 1, n_real
       call reg_data%flv_real(i)%init (flv_real_tmp (:, i), n_in)
    end do

    call reg_data%find_regions (model, ftuples, emitter, flst_alr)
    call reg_data%init_singular_regions (ftuples, emitter, &
         flst_alr, nlo_correction_type)
    reg_data%n_flv_real = maxval (reg_data%regions%real_index)
    call reg_data%find_emitters ()
    call reg_data%set_mass_color_and_charge (model)
    call reg_data%set_splitting_info ()
  end subroutine region_data_init

@ %def region_data_init
@
<<FKS regions: reg data: TBP>>=
  procedure :: init_resonance_information => &
       region_data_init_resonance_information
<<FKS regions: sub interfaces>>=
    module subroutine region_data_init_resonance_information (reg_data)
      class(region_data_t), intent(inout) :: reg_data
    end subroutine region_data_init_resonance_information
<<FKS regions: procedures>>=
  module subroutine region_data_init_resonance_information (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    call reg_data%enlarge_singular_regions_with_resonances ()
    call reg_data%find_resonances ()
  end subroutine region_data_init_resonance_information

@ %def region_data_init_resonance_information
@
<<FKS regions: reg data: TBP>>=
  procedure :: set_resonance_mappings => region_data_set_resonance_mappings
<<FKS regions: sub interfaces>>=
    module subroutine region_data_set_resonance_mappings &
         (reg_data, resonance_histories)
      class(region_data_t), intent(inout) :: reg_data
      type(resonance_history_t), intent(in), dimension(:) :: resonance_histories
    end subroutine region_data_set_resonance_mappings
<<FKS regions: procedures>>=
  module subroutine region_data_set_resonance_mappings &
       (reg_data, resonance_histories)
    class(region_data_t), intent(inout) :: reg_data
    type(resonance_history_t), intent(in), dimension(:) :: resonance_histories
    select type (map => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       call map%res_map%init (resonance_histories)
    end select
  end subroutine region_data_set_resonance_mappings

@ %def region_data_set_resonance_mappings
@
<<FKS regions: reg data: TBP>>=
  procedure :: setup_fks_mappings => region_data_setup_fks_mappings
<<FKS regions: sub interfaces>>=
    module subroutine region_data_setup_fks_mappings (reg_data, template, n_in)
      class(region_data_t), intent(inout) :: reg_data
      type(fks_template_t), intent(in) :: template
      integer, intent(in) :: n_in
    end subroutine region_data_setup_fks_mappings
<<FKS regions: procedures>>=
  module subroutine region_data_setup_fks_mappings (reg_data, template, n_in)
    class(region_data_t), intent(inout) :: reg_data
    type(fks_template_t), intent(in) :: template
    integer, intent(in) :: n_in
    call reg_data%allocate_fks_mappings (template%mapping_type)
    select type (map => reg_data%fks_mapping)
    type is (fks_mapping_default_t)
       call map%set_parameter (n_in, template%fks_dij_exp1, &
            template%fks_dij_exp2)
    end select
  end subroutine region_data_setup_fks_mappings

@ %def region_data_setup_fks_mappings
@ So far, we have only created singular regions for a non-resonant case. When
resonance mappings are required, we have more singular regions, since they
must now be identified by their emitter-resonance pair index, where the emitter
must be compatible with the resonance.
<<FKS regions: reg data: TBP>>=
  procedure :: enlarge_singular_regions_with_resonances &
     => region_data_enlarge_singular_regions_with_resonances
<<FKS regions: sub interfaces>>=
    module subroutine region_data_enlarge_singular_regions_with_resonances &
         (reg_data)
      class(region_data_t), intent(inout) :: reg_data
    end subroutine region_data_enlarge_singular_regions_with_resonances
<<FKS regions: procedures>>=
  module subroutine region_data_enlarge_singular_regions_with_resonances &
       (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr
    integer, dimension(:), allocatable :: alr_new_to_old
    integer :: n_alr_new
    type(singular_region_t), dimension(:), allocatable :: save_regions
    if (debug_on)  call msg_debug &
         (D_SUBTRACTION, "region_data_enlarge_singular_regions_with_resonances")
    call debug_input_values ()
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_default_t)
       return
    type is (fks_mapping_resonances_t)
       allocate (save_regions (reg_data%n_regions))
       do alr = 1, reg_data%n_regions
          save_regions(alr) = reg_data%regions(alr)
       end do

       associate (res_map => fks_mapping%res_map)
          call res_map%set_alr_to_i_res (reg_data%regions, alr_new_to_old)
          deallocate (reg_data%regions)
          n_alr_new = size (alr_new_to_old)
          reg_data%n_regions = n_alr_new
          allocate (reg_data%regions (n_alr_new))
          do alr = 1, n_alr_new
             reg_data%regions(alr) = save_regions(alr_new_to_old (alr))
             reg_data%regions(alr)%i_res = res_map%alr_to_i_res (alr)
          end do
       end associate
    end select

  contains

    subroutine debug_input_values ()
      if (debug2_active (D_SUBTRACTION)) then
         call reg_data%write ()
      end if
    end subroutine debug_input_values

  end subroutine region_data_enlarge_singular_regions_with_resonances

@ %def region_data_enlarge_singular_regions_with_resonances
@
<<FKS regions: reg data: TBP>>=
  procedure :: set_isr_pseudo_regions => region_data_set_isr_pseudo_regions
<<FKS regions: sub interfaces>>=
    module subroutine region_data_set_isr_pseudo_regions (reg_data)
      class(region_data_t), intent(inout) :: reg_data
    end subroutine region_data_set_isr_pseudo_regions
<<FKS regions: procedures>>=
  module subroutine region_data_set_isr_pseudo_regions (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr
    integer :: n_alr_new
    !!! Subroutine called for threshold factorization ->
    !!! Size of singular regions at this point is fixed
    type(singular_region_t), dimension(2) :: save_regions
    integer, dimension(4) :: alr_new_to_old
    do alr = 1, reg_data%n_regions
       save_regions(alr) = reg_data%regions(alr)
    end do
    n_alr_new = reg_data%n_regions * 2
    alr_new_to_old = [1, 1, 2, 2]
    deallocate (reg_data%regions)
    allocate (reg_data%regions (n_alr_new))
    reg_data%n_regions = n_alr_new
    do alr = 1, n_alr_new
       reg_data%regions(alr) = save_regions(alr_new_to_old (alr))
       call add_pseudo_emitters (reg_data%regions(alr))
       if (mod (alr, 2) == 0) reg_data%regions(alr)%pseudo_isr = .true.
    end do
  contains
    subroutine add_pseudo_emitters (sregion)
      type(singular_region_t), intent(inout) :: sregion
      type(ftuple_t), dimension(2) :: ftuples_save
      integer :: alr
      do alr = 1, 2
         ftuples_save(alr) = sregion%ftuples(alr)
      end do
      deallocate (sregion%ftuples)
      sregion%nregions = sregion%nregions * 2
      allocate (sregion%ftuples (sregion%nregions))
      do alr = 1, sregion%nregions
         sregion%ftuples(alr) = ftuples_save (alr_new_to_old(alr))
         if (mod (alr, 2) == 0) sregion%ftuples(alr)%pseudo_isr = .true.
      end do
    end subroutine add_pseudo_emitters
  end subroutine region_data_set_isr_pseudo_regions

@ %def region_data_set_isr_pseudo_regions
@ This subroutine splits up the ftuple-list of the singular regions
into interference-free lists, i.e. lists which only contain the same
emitter. This is relevant for factorized NLO calculations. In the
current implementation, it is hand-tailored for the threshold
computation, but should be generalized further in the future.
<<FKS regions: reg data: TBP>>=
  procedure :: split_up_interference_regions_for_threshold => &
       region_data_split_up_interference_regions_for_threshold
<<FKS regions: sub interfaces>>=
    module subroutine region_data_split_up_interference_regions_for_threshold &
         (reg_data)
      class(region_data_t), intent(inout) :: reg_data
    end subroutine region_data_split_up_interference_regions_for_threshold
<<FKS regions: procedures>>=
  module subroutine region_data_split_up_interference_regions_for_threshold &
       (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr, i_ftuple
    integer :: current_emitter
    integer :: i1, i2
    integer :: n_new_reg
    type(ftuple_t), dimension(2) :: ftuples
    do alr = 1, reg_data%n_regions
       associate (region => reg_data%regions(alr))
          current_emitter = region%emitter
          n_new_reg = 0
          do i_ftuple = 1, region%nregions
             call region%ftuples(i_ftuple)%get (i1, i2)
             if (i1 == current_emitter) then
                n_new_reg = n_new_reg + 1
                ftuples(n_new_reg) = region%ftuples(i_ftuple)
             end if
          end do
          deallocate (region%ftuples)
          allocate (region%ftuples(n_new_reg))
          region%ftuples = ftuples (1 : n_new_reg)
          region%nregions = n_new_reg
       end associate
    end do
    reg_data%fks_mapping%normalization_factor = 0.5_default
  end subroutine region_data_split_up_interference_regions_for_threshold

@ %def region_data_split_up_interference_regions_for_threshold
@
<<FKS regions: reg data: TBP>>=
  procedure :: set_mass_color_and_charge => &
       region_data_set_mass_color_and_charge
<<FKS regions: sub interfaces>>=
    module subroutine region_data_set_mass_color_and_charge (reg_data, model)
      class(region_data_t), intent(inout) :: reg_data
      type(model_t), intent(in) :: model
    end subroutine region_data_set_mass_color_and_charge
<<FKS regions: procedures>>=
  module subroutine region_data_set_mass_color_and_charge (reg_data, model)
    class(region_data_t), intent(inout) :: reg_data
    type(model_t), intent(in) :: model
    integer :: i
    do i = 1, reg_data%n_regions
       associate (region => reg_data%regions(i))
          call region%flst_uborn%init_mass_color_and_charge (model)
          call region%flst_real%init_mass_color_and_charge (model)
       end associate
    end do
    do i = 1, reg_data%n_flv_born
       call reg_data%flv_born(i)%init_mass_color_and_charge (model)
    end do
    do i = 1, size (reg_data%flv_real)
       call reg_data%flv_real(i)%init_mass_color_and_charge (model)
    end do
  end subroutine region_data_set_mass_color_and_charge

@ %def region_data_set_mass_color_and_charge
@
<<FKS regions: reg data: TBP>>=
  procedure :: uses_resonances => region_data_uses_resonances
<<FKS regions: sub interfaces>>=
    module function region_data_uses_resonances (reg_data) result (val)
      logical :: val
      class(region_data_t), intent(in) :: reg_data
    end function region_data_uses_resonances
<<FKS regions: procedures>>=
  module function region_data_uses_resonances (reg_data) result (val)
    logical :: val
    class(region_data_t), intent(in) :: reg_data
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       val = .true.
    class default
       val = .false.
    end select
  end function region_data_uses_resonances

@ %def region_data_uses_resonances
@ Creates a list containing the emitter of each singular region.
<<FKS regions: reg data: TBP>>=
  procedure :: get_emitter_list => region_data_get_emitter_list
<<FKS regions: sub interfaces>>=
    pure module function region_data_get_emitter_list &
         (reg_data) result (emitters)
      class(region_data_t), intent(in) :: reg_data
      integer, dimension(:), allocatable :: emitters
    end function region_data_get_emitter_list
<<FKS regions: procedures>>=
  pure module function region_data_get_emitter_list (reg_data) result (emitters)
    class(region_data_t), intent(in) :: reg_data
    integer, dimension(:), allocatable :: emitters
    integer :: i
    allocate (emitters (reg_data%n_regions))
    do i = 1, reg_data%n_regions
       emitters(i) = reg_data%regions(i)%emitter
    end do
  end function region_data_get_emitter_list

@ %def region_data_get_emitter_list
@ Returns the number of emitters not equal to 0 to avoid double counting
between emitters 0, 1 and 2.
<<FKS regions: reg data: TBP>>=
  procedure :: get_n_emitters_sc => region_data_get_n_emitters_sc
<<FKS regions: sub interfaces>>=
    module function region_data_get_n_emitters_sc &
         (reg_data) result (n_emitters_sc)
      class(region_data_t), intent(in) :: reg_data
      integer :: n_emitters_sc
    end function region_data_get_n_emitters_sc
<<FKS regions: procedures>>=
  module function region_data_get_n_emitters_sc &
       (reg_data) result (n_emitters_sc)
    class(region_data_t), intent(in) :: reg_data
    integer :: n_emitters_sc
    n_emitters_sc = count (reg_data%emitters /= 0)
  end function region_data_get_n_emitters_sc

@ %def region_data_get_n_emitters_sc
@
<<FKS regions: reg data: TBP>>=
  procedure :: get_associated_resonances => &
       region_data_get_associated_resonances
<<FKS regions: sub interfaces>>=
    module function region_data_get_associated_resonances &
         (reg_data, emitter) result (res)
      integer, dimension(:), allocatable :: res
      class(region_data_t), intent(in) :: reg_data
      integer, intent(in) :: emitter
    end function region_data_get_associated_resonances
<<FKS regions: procedures>>=
  module function region_data_get_associated_resonances &
       (reg_data, emitter) result (res)
    integer, dimension(:), allocatable :: res
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: emitter
    integer :: alr, i
    integer :: n_res
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       n_res = 0

       do alr = 1, reg_data%n_regions
          if (reg_data%regions(alr)%emitter == emitter) &
             n_res = n_res + 1
       end do

       if (n_res > 0) then
          allocate (res (n_res))
       else
          return
       end if
       i = 1

       do alr = 1, reg_data%n_regions
          if (reg_data%regions(alr)%emitter == emitter) then
             res (i) = fks_mapping%res_map%alr_to_i_res (alr)
             i = i + 1
          end if
       end do
    end select
  end function region_data_get_associated_resonances

@ %def region_data_get_associated_resonances
@
<<FKS regions: reg data: TBP>>=
  procedure :: emitter_is_compatible_with_resonance => &
     region_data_emitter_is_compatible_with_resonance
<<FKS regions: sub interfaces>>=
    module function region_data_emitter_is_compatible_with_resonance &
         (reg_data, i_res, emitter) result (compatible)
      logical :: compatible
      class(region_data_t), intent(in) :: reg_data
      integer, intent(in) :: i_res, emitter
    end function region_data_emitter_is_compatible_with_resonance
<<FKS regions: procedures>>=
  module function region_data_emitter_is_compatible_with_resonance &
       (reg_data, i_res, emitter) result (compatible)
    logical :: compatible
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_res, emitter
    integer :: i_res_alr, alr
    compatible = .false.
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       do alr = 1, reg_data%n_regions
          i_res_alr = fks_mapping%res_map%alr_to_i_res (alr)
          if (i_res_alr == i_res .and. reg_data%get_emitter(alr) == emitter) then
             compatible = .true.
             exit
          end if
       end do
    end select
  end function region_data_emitter_is_compatible_with_resonance

@ %def region_data_emitter_is_compatible_with_resonance
@
<<FKS regions: reg data: TBP>>=
  procedure :: emitter_is_in_resonance => region_data_emitter_is_in_resonance
<<FKS regions: sub interfaces>>=
    module function region_data_emitter_is_in_resonance &
         (reg_data, i_res, emitter) result (exist)
      logical :: exist
      class(region_data_t), intent(in) :: reg_data
      integer, intent(in) :: i_res, emitter
    end function region_data_emitter_is_in_resonance
<<FKS regions: procedures>>=
  module function region_data_emitter_is_in_resonance &
       (reg_data, i_res, emitter) result (exist)
    logical :: exist
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_res, emitter
    integer :: i
    exist = .false.
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       associate (res_history => fks_mapping%res_map%res_histories(i_res))
          do i = 1, res_history%n_resonances
             exist = exist .or. &
                  any (res_history%resonances(i)%contributors%c == emitter)
          end do
      end associate
    end select
  end function region_data_emitter_is_in_resonance

@ %def region_data_emitter_is_in_resonance
@
<<FKS regions: reg data: TBP>>=
  procedure :: get_contributors => region_data_get_contributors
<<FKS regions: sub interfaces>>=
    module subroutine region_data_get_contributors &
         (reg_data, i_res, emitter, c, success)
      class(region_data_t), intent(in) :: reg_data
      integer, intent(in) :: i_res, emitter
      integer, intent(inout), dimension(:), allocatable :: c
      logical, intent(out) :: success
    end subroutine region_data_get_contributors
<<FKS regions: procedures>>=
  module subroutine region_data_get_contributors &
       (reg_data, i_res, emitter, c, success)
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_res, emitter
    integer, intent(inout), dimension(:), allocatable :: c
    logical, intent(out) :: success
    integer :: i
    success = .false.
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       associate (res_history => fks_mapping%res_map%res_histories (i_res))
          do i = 1, res_history%n_resonances
             if (any (res_history%resonances(i)%contributors%c == emitter)) then
                allocate (c (size (res_history%resonances(i)%contributors%c)))
                c = res_history%resonances(i)%contributors%c
                success = .true.
                exit
             end if
          end do
       end associate
    end select
  end subroutine region_data_get_contributors

@ %def region_data_get_contributors
@
<<FKS regions: reg data: TBP>>=
  procedure :: get_emitter => region_data_get_emitter
<<FKS regions: sub interfaces>>=
    pure module function region_data_get_emitter &
         (reg_data, alr) result (emitter)
      class(region_data_t), intent(in) :: reg_data
      integer, intent(in) :: alr
      integer :: emitter
    end function region_data_get_emitter
<<FKS regions: procedures>>=
  pure module function region_data_get_emitter (reg_data, alr) result (emitter)
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: alr
    integer :: emitter
    emitter = reg_data%regions(alr)%emitter
  end function region_data_get_emitter

@ %def region_data_get_emitter
@
<<FKS regions: reg data: TBP>>=
  procedure :: map_real_to_born_index => region_data_map_real_to_born_index
<<FKS regions: sub interfaces>>=
    module function region_data_map_real_to_born_index &
         (reg_data, real_index) result (uborn_index)
      integer :: uborn_index
      class(region_data_t), intent(in) :: reg_data
      integer, intent(in) :: real_index
    end function region_data_map_real_to_born_index
<<FKS regions: procedures>>=
  module function region_data_map_real_to_born_index &
       (reg_data, real_index) result (uborn_index)
    integer :: uborn_index
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: real_index
    integer :: alr
    uborn_index = 0
    do alr = 1, size (reg_data%regions)
       if (reg_data%regions(alr)%real_index == real_index) then
          uborn_index = reg_data%regions(alr)%uborn_index
          exit
       end if
    end do
  end function region_data_map_real_to_born_index

@ %def region_data_map_real_to_born_index
@
<<FKS regions: reg data: TBP>>=
  generic :: get_flv_states_born => get_flv_states_born_single, &
       get_flv_states_born_array
  procedure :: get_flv_states_born_single => &
       region_data_get_flv_states_born_single
  procedure :: get_flv_states_born_array => &
       region_data_get_flv_states_born_array
<<FKS regions: sub interfaces>>=
    module function region_data_get_flv_states_born_array &
         (reg_data) result (flv_states)
      integer, dimension(:,:), allocatable :: flv_states
      class(region_data_t), intent(in) :: reg_data
    end function region_data_get_flv_states_born_array
    module function region_data_get_flv_states_born_single &
         (reg_data, i_flv) result (flv_states)
      integer, dimension(:), allocatable :: flv_states
      class(region_data_t), intent(in) :: reg_data
      integer, intent(in) :: i_flv
    end function region_data_get_flv_states_born_single
<<FKS regions: procedures>>=
  module function region_data_get_flv_states_born_array &
       (reg_data) result (flv_states)
    integer, dimension(:,:), allocatable :: flv_states
    class(region_data_t), intent(in) :: reg_data
    integer :: i_flv
    allocate (flv_states (reg_data%n_legs_born, reg_data%n_flv_born))
    do i_flv = 1, reg_data%n_flv_born
       flv_states (:, i_flv) = reg_data%flv_born(i_flv)%flst
    end do
  end function region_data_get_flv_states_born_array

  module function region_data_get_flv_states_born_single &
       (reg_data, i_flv) result (flv_states)
    integer, dimension(:), allocatable :: flv_states
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_flv
    allocate (flv_states (reg_data%n_legs_born))
    flv_states = reg_data%flv_born(i_flv)%flst
  end function region_data_get_flv_states_born_single

@ %def region_data_get_flv_states_born
@
<<FKS regions: reg data: TBP>>=
  generic :: get_flv_states_real => &
       get_flv_states_real_single, get_flv_states_real_array
  procedure :: get_flv_states_real_single => &
       region_data_get_flv_states_real_single
  procedure :: get_flv_states_real_array => &
       region_data_get_flv_states_real_array
<<FKS regions: sub interfaces>>=
    module function region_data_get_flv_states_real_single &
         (reg_data, i_flv) result (flv_states)
      integer, dimension(:), allocatable :: flv_states
      class(region_data_t), intent(in) :: reg_data
      integer, intent(in) :: i_flv
    end function region_data_get_flv_states_real_single
    module function region_data_get_flv_states_real_array &
         (reg_data) result (flv_states)
      integer, dimension(:,:), allocatable :: flv_states
      class(region_data_t), intent(in) :: reg_data
    end function region_data_get_flv_states_real_array
<<FKS regions: procedures>>=
  module function region_data_get_flv_states_real_single &
       (reg_data, i_flv) result (flv_states)
    integer, dimension(:), allocatable :: flv_states
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_flv
    integer :: i_reg
    allocate (flv_states (reg_data%n_legs_real))
    do i_reg = 1, reg_data%n_regions
       if (i_flv == reg_data%regions(i_reg)%real_index) then
          flv_states = reg_data%regions(i_reg)%flst_real%flst
          exit
       end if
    end do
  end function region_data_get_flv_states_real_single

  module function region_data_get_flv_states_real_array &
       (reg_data) result (flv_states)
    integer, dimension(:,:), allocatable :: flv_states
    class(region_data_t), intent(in) :: reg_data
    integer :: i_flv
    allocate (flv_states (reg_data%n_legs_real, reg_data%n_flv_real))
    do i_flv = 1, reg_data%n_flv_real
       flv_states (:, i_flv) = reg_data%get_flv_states_real (i_flv)
    end do
  end function region_data_get_flv_states_real_array

@ %def region_data_get_flv_states_real
@
<<FKS regions: reg data: TBP>>=
  procedure :: get_all_flv_states => region_data_get_all_flv_states
<<FKS regions: sub interfaces>>=
    module subroutine region_data_get_all_flv_states &
         (reg_data, flv_born, flv_real)
      class(region_data_t), intent(in) :: reg_data
      integer, dimension(:,:), allocatable, intent(out) :: flv_born, flv_real
    end subroutine region_data_get_all_flv_states
<<FKS regions: procedures>>=
  module subroutine region_data_get_all_flv_states &
       (reg_data, flv_born, flv_real)
    class(region_data_t), intent(in) :: reg_data
    integer, dimension(:,:), allocatable, intent(out) :: flv_born, flv_real
    allocate (flv_born (reg_data%n_legs_born, reg_data%n_flv_born))
    flv_born = reg_data%get_flv_states_born ()
    allocate (flv_real (reg_data%n_legs_real, reg_data%n_flv_real))
    flv_real = reg_data%get_flv_states_real ()
  end subroutine region_data_get_all_flv_states

@ %def region_data_get_all_flv_states
@
<<FKS regions: reg data: TBP>>=
  procedure :: get_n_in => region_data_get_n_in
<<FKS regions: sub interfaces>>=
    module function region_data_get_n_in (reg_data) result (n_in)
      integer :: n_in
      class(region_data_t), intent(in) :: reg_data
    end function region_data_get_n_in
<<FKS regions: procedures>>=
  module function region_data_get_n_in (reg_data) result (n_in)
    integer :: n_in
    class(region_data_t), intent(in) :: reg_data
    n_in = reg_data%n_in
  end function region_data_get_n_in

@ %def region_data_get_n_in
@
<<FKS regions: reg data: TBP>>=
  procedure :: get_n_legs_real => region_data_get_n_legs_real
<<FKS regions: sub interfaces>>=
    module function region_data_get_n_legs_real (reg_data) result (n_legs)
      integer :: n_legs
      class(region_data_t), intent(in) :: reg_data
    end function region_data_get_n_legs_real
<<FKS regions: procedures>>=
  module function region_data_get_n_legs_real (reg_data) result (n_legs)
    integer :: n_legs
    class(region_data_t), intent(in) :: reg_data
    n_legs = reg_data%n_legs_real
  end function region_data_get_n_legs_real

@ %def region_data_get_n_legs_real
<<FKS regions: reg data: TBP>>=
  procedure :: get_n_legs_born => region_data_get_n_legs_born
<<FKS regions: sub interfaces>>=
    module function region_data_get_n_legs_born (reg_data) result (n_legs)
      integer :: n_legs
      class(region_data_t), intent(in) :: reg_data
    end function region_data_get_n_legs_born
<<FKS regions: procedures>>=
  module function region_data_get_n_legs_born (reg_data) result (n_legs)
    integer :: n_legs
    class(region_data_t), intent(in) :: reg_data
    n_legs = reg_data%n_legs_born
  end function region_data_get_n_legs_born

@ %def region_data_get_n_legs_born
<<FKS regions: reg data: TBP>>=
  procedure :: get_n_flv_real => region_data_get_n_flv_real
<<FKS regions: sub interfaces>>=
    module function region_data_get_n_flv_real (reg_data) result (n_flv)
      integer :: n_flv
      class(region_data_t), intent(in) :: reg_data
    end function region_data_get_n_flv_real
<<FKS regions: procedures>>=
  module function region_data_get_n_flv_real (reg_data) result (n_flv)
    integer :: n_flv
    class(region_data_t), intent(in) :: reg_data
    n_flv = reg_data%n_flv_real
  end function region_data_get_n_flv_real

@ %def region_data_get_n_flv_real
<<FKS regions: reg data: TBP>>=
  procedure :: get_n_flv_born => region_data_get_n_flv_born
<<FKS regions: sub interfaces>>=
    module function region_data_get_n_flv_born (reg_data) result (n_flv)
      integer :: n_flv
      class(region_data_t), intent(in) :: reg_data
    end function region_data_get_n_flv_born
<<FKS regions: procedures>>=
  module function region_data_get_n_flv_born (reg_data) result (n_flv)
    integer :: n_flv
    class(region_data_t), intent(in) :: reg_data
    n_flv = reg_data%n_flv_born
  end function region_data_get_n_flv_born

@ %def region_data_get_n_flv_born

@ Returns $S_i = \frac{1}{\mathcal{D}d_i}$ or $S_{ij} =
\frac{1}{\mathcal{D}d_{ij}}$ for one particular singular region.  At
this point, the flavor array should be rearranged in such a way that
the emitted particle is at the last position of
the flavor structure list.
<<FKS regions: reg data: TBP>>=
  generic :: get_svalue => get_svalue_last_pos, get_svalue_ij
  procedure :: get_svalue_last_pos => region_data_get_svalue_last_pos
  procedure :: get_svalue_ij => region_data_get_svalue_ij
<<FKS regions: sub interfaces>>=
    module function region_data_get_svalue_ij &
         (reg_data, p_real, alr, i, j, i_res) result (sval)
      class(region_data_t), intent(inout) :: reg_data
      type(vector4_t), intent(in), dimension(:) :: p_real
      integer, intent(in) :: alr, i, j
      integer, intent(in) :: i_res
      real(default) :: sval
    end function region_data_get_svalue_ij
    module function region_data_get_svalue_last_pos &
         (reg_data, p, alr, emitter, i_res) result (sval)
      class(region_data_t), intent(inout) :: reg_data
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: alr, emitter
      integer, intent(in) :: i_res
      real(default) :: sval
    end function region_data_get_svalue_last_pos
<<FKS regions: procedures>>=
  module function region_data_get_svalue_ij &
       (reg_data, p_real, alr, i, j, i_res) result (sval)
    class(region_data_t), intent(inout) :: reg_data
    type(vector4_t), intent(in), dimension(:) :: p_real
    integer, intent(in) :: alr, i, j
    integer, intent(in) :: i_res
    real(default) :: sval
    associate (map => reg_data%fks_mapping)
       call map%compute_sumdij (reg_data%regions(alr), p_real)
       select type (map)
       type is (fks_mapping_resonances_t)
          map%i_con = reg_data%alr_to_i_contributor (alr)
       end select
       map%pseudo_isr = reg_data%regions(alr)%pseudo_isr
       sval = map%svalue (p_real, i, j, i_res) * map%normalization_factor
    end associate
  end function region_data_get_svalue_ij

  module function region_data_get_svalue_last_pos &
       (reg_data, p, alr, emitter, i_res) result (sval)
    class(region_data_t), intent(inout) :: reg_data
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: alr, emitter
    integer, intent(in) :: i_res
    real(default) :: sval
    sval = reg_data%get_svalue (p, alr, emitter, reg_data%n_legs_real, i_res)
  end function region_data_get_svalue_last_pos

@ %def region_data_get_svalue
@ The same as above, but for the soft limit.
<<FKS regions: reg data: TBP>>=
  procedure :: get_svalue_soft => region_data_get_svalue_soft
<<FKS regions: sub interfaces>>=
    module function region_data_get_svalue_soft &
         (reg_data, p_born, p_soft, alr, emitter, i_res) result (sval)
      class(region_data_t), intent(inout) :: reg_data
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: alr, emitter, i_res
      real(default) :: sval
    end function region_data_get_svalue_soft
<<FKS regions: procedures>>=
  module function region_data_get_svalue_soft &
       (reg_data, p_born, p_soft, alr, emitter, i_res) result (sval)
    class(region_data_t), intent(inout) :: reg_data
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: alr, emitter, i_res
    real(default) :: sval
    associate (map => reg_data%fks_mapping)
       call map%compute_sumdij_soft (reg_data%regions(alr), p_born, p_soft)
       select type (map)
       type is (fks_mapping_resonances_t)
          map%i_con = reg_data%alr_to_i_contributor (alr)
       end select
       map%pseudo_isr = reg_data%regions(alr)%pseudo_isr
       sval = map%svalue_soft (p_born, p_soft, emitter, i_res) * &
            map%normalization_factor
    end associate
  end function region_data_get_svalue_soft

@ %def region_data_get_svalue_soft
@ This subroutine starts with a specification of $N$- and
$N+1$-particle configurations, [[flst_born]] and [[flst_real]], saved
in [[reg_data]]. From these, it creates a list of fundamental tuples,
a list of emitters and a list containing the $N+1$-particle
configuration, rearranged  in such a way that the emitter-radiation
pair is last ([[flst_alr]]). For the $e^+ \, e^- \, \rightarrow u \,
\bar{u} \, g$- example, the generated objects are shown in table
\ref{table:ftuples and flavors}. Note that at this point, [[flst_alr]]
is arranged in such a way that the emitter can only be equal to
$n_{legs}-1$ for final-state radiation or 0, 1, or 2 for initial-state
radiation. Further, it occurs that regions can be equivalent. For
example in table \ref{table:ftuples and flavors} the regions
corresponding to \texttt{alr} = 1 and \texttt{alr} = 3 as well as
\texttt{alr} = 2 and \texttt{alr} = 4 describe the same physics and
are therefore equivalent.
@
<<FKS regions: reg data: TBP>>=
  procedure :: find_regions => region_data_find_regions
<<FKS regions: sub interfaces>>=
    module subroutine region_data_find_regions &
         (reg_data, model, ftuples, emitters, flst_alr)
      class(region_data_t), intent(in) :: reg_data
      type(model_t), intent(in) :: model
      type(ftuple_list_t), intent(out), dimension(:), allocatable :: ftuples
      integer, intent(out), dimension(:), allocatable :: emitters
      type(flv_structure_t), intent(out), dimension(:), allocatable :: flst_alr
    end subroutine region_data_find_regions
<<FKS regions: procedures>>=
  module subroutine region_data_find_regions &
       (reg_data, model, ftuples, emitters, flst_alr)
    class(region_data_t), intent(in) :: reg_data
    type(model_t), intent(in) :: model
    type(ftuple_list_t), intent(out), dimension(:), allocatable :: ftuples
    integer, intent(out), dimension(:), allocatable :: emitters
    type(flv_structure_t), intent(out), dimension(:), allocatable :: flst_alr
    type(ftuple_list_t), dimension(:,:), allocatable :: ftuples_tmp
    integer, dimension(:,:), allocatable :: ftuple_index
    integer :: n_born, n_real
    integer :: n_legreal
    integer :: i_born, i_real, i_ftuple
    integer :: last_registered_i_born, last_registered_i_real

    n_born = size (reg_data%flv_born)
    n_real = size (reg_data%flv_real)
    n_legreal = size (reg_data%flv_real(1)%flst)
    allocate (emitters (0))
    allocate (flst_alr (0))
    allocate (ftuples (0))
    i_ftuple = 0
    last_registered_i_born = 0; last_registered_i_real = 0

    do i_real = 1, n_real
       do i_born = 1, n_born
          call setup_flsts_emitters_and_ftuples_fsr &
               (i_real, i_born, i_ftuple, flst_alr, emitters, ftuples)
          call setup_flsts_emitters_and_ftuples_isr &
               (i_real, i_born, i_ftuple, flst_alr, emitters, ftuples)
       end do
    end do

  contains
    function incr_i_ftuple_if_required (i_born, i_real, i_ftuple_in) result (i_ftuple)
      integer :: i_ftuple
      integer, intent(in) :: i_born, i_real, i_ftuple_in
      if (last_registered_i_born /= i_born .or. last_registered_i_real /= i_real) then
         last_registered_i_born = i_born
         last_registered_i_real = i_real
         i_ftuple = i_ftuple_in + 1
      else
         i_ftuple = i_ftuple_in
      end if
    end function incr_i_ftuple_if_required

    subroutine setup_flsts_emitters_and_ftuples_fsr &
           (i_real, i_born, i_ftuple, flst_alr, emitters, ftuples)
      integer, intent(in) :: i_real, i_born
      integer, intent(inout) :: i_ftuple
      type(flv_structure_t), intent(inout), dimension(:), allocatable :: flst_alr
      integer, intent(inout), dimension(:), allocatable :: emitters
      type(ftuple_list_t), intent(inout), dimension(:), allocatable :: ftuples
      type(ftuple_list_t) :: ftuples_tmp
      type(flv_structure_t) :: flst_alr_tmp
      type(ftuple_t) :: current_ftuple
      integer :: leg1, leg2
      logical :: valid
      associate (flv_born => reg_data%flv_born(i_born), &
              flv_real => reg_data%flv_real(i_real))
         do leg1 = reg_data%n_in + 1, n_legreal
            do leg2 = leg1 + 1, n_legreal
               valid = flv_real%valid_pair(leg1, leg2, flv_born, model)
               if (valid) then
                  if (is_vector(flv_real%flst(leg1)) .and. &
                     is_fermion(flv_real%flst(leg2))) then
                     flst_alr_tmp = create_alr (flv_real, &
                          reg_data%n_in, leg2, leg1)
                  else
                     flst_alr_tmp = create_alr (flv_real, &
                          reg_data%n_in, leg1, leg2)
                  end if
                  flst_alr = [flst_alr, flst_alr_tmp]
                  emitters = [emitters, n_legreal - 1]
                  call current_ftuple%set (leg1, leg2)
                  call current_ftuple%determine_splitting_type_fsr &
                       (flv_real, leg1, leg2)
                  call current_ftuple%determine_sub_correction_type &
                       (flv_born, flv_real, leg1, leg2)
                  i_ftuple = incr_i_ftuple_if_required (i_born, i_real, i_ftuple)
                  if (i_ftuple > size (ftuples)) then
                     call ftuples_tmp%append (current_ftuple)
                     ftuples = [ftuples, ftuples_tmp]
                  else
                     call ftuples(i_ftuple)%append (current_ftuple)
                  end if
               end if
            end do
         end do
      end associate
    end subroutine setup_flsts_emitters_and_ftuples_fsr

    subroutine setup_flsts_emitters_and_ftuples_isr &
           (i_real, i_born, i_ftuple, flst_alr, emitters, ftuples)
      integer, intent(in) :: i_real, i_born
      integer, intent(inout) :: i_ftuple
      type(flv_structure_t), intent(inout), dimension(:), allocatable :: flst_alr
      integer, intent(inout), dimension(:), allocatable :: emitters
      type(ftuple_list_t), intent(inout), dimension(:), allocatable :: ftuples
      type(ftuple_list_t) :: ftuples_tmp
      type(flv_structure_t) :: flst_alr_tmp
      type(ftuple_t) :: current_ftuple
      integer :: leg, emitter
      logical :: valid1, valid2
      associate (flv_born => reg_data%flv_born(i_born), &
              flv_real => reg_data%flv_real(i_real))
         do leg = reg_data%n_in + 1, n_legreal
            valid1 = flv_real%valid_pair(1, leg, flv_born, model)
            if (reg_data%n_in > 1) then
               valid2 = flv_real%valid_pair(2, leg, flv_born, model)
            else
               valid2 = .false.
            end if
            if (valid1 .and. valid2) then
               emitter = 0
            else if (valid1 .and. .not. valid2) then
               emitter = 1
            else if (.not. valid1 .and. valid2) then
               emitter = 2
            else
               emitter = -1
            end if
            if (valid1 .or. valid2) then
               flst_alr_tmp = create_alr (flv_real, reg_data%n_in, emitter, leg)
               flst_alr = [flst_alr, flst_alr_tmp]
               emitters = [emitters, emitter]
               call current_ftuple%set(emitter, leg)
               call current_ftuple%determine_splitting_type_isr &
                    (flv_real, emitter, leg)
               call current_ftuple%determine_sub_correction_type &
                    (flv_born, flv_real, emitter, leg)
               i_ftuple = incr_i_ftuple_if_required (i_born, i_real, i_ftuple)
               if (i_ftuple > size (ftuples)) then
                  call ftuples_tmp%append (current_ftuple)
                  ftuples = [ftuples, ftuples_tmp]
               else
                  call ftuples(i_ftuple)%append (current_ftuple)
               end if
            end if
         end do
      end associate
    end subroutine setup_flsts_emitters_and_ftuples_isr

  end subroutine region_data_find_regions

@ %def region_data_find_regions
@ We transfer the mapping of flavor structures that lead to the same amplitude
(with structure functions already accounted for!) to the Born and real
[[flv_structure]] of each [[singular_region]].
We then use this information, besides other data of each [[singular_region]],
to determine which produce the same amplitude for the non-subtracted real
and real subtraction terms and set up the equivalence index mapping for
each region.
<<FKS regions: reg data: TBP>>=
  procedure :: find_eqv_regions => region_data_find_eqv_regions
<<FKS regions: sub interfaces>>=
    module subroutine region_data_find_eqv_regions (reg_data, optimize)
      class(region_data_t), intent(inout) :: reg_data
      logical, intent(in) :: optimize
    end subroutine region_data_find_eqv_regions
<<FKS regions: procedures>>=
  module subroutine region_data_find_eqv_regions (reg_data, optimize)
    class(region_data_t), intent(inout) :: reg_data
    logical, intent(in) :: optimize
    integer :: n_reg, alr1, alr2
    n_reg = reg_data%n_regions
    if (optimize) then
       do alr1 = 1, n_reg
          reg_data%regions(alr1)%flst_uborn%eqv_index = &
               reg_data%eqv_flv_index_born(reg_data%regions(alr1)%uborn_index)
          reg_data%regions(alr1)%flst_real%eqv_index = &
               reg_data%eqv_flv_index_real(reg_data%regions(alr1)%real_index)
       end do
       do alr1 = 1, n_reg
          do alr2 = 1, alr1
             if (reg_data%regions(alr2) .match. reg_data%regions(alr1)) then
                reg_data%regions(alr1)%eqv_index = alr2
                exit
             end if
          end do
       end do
    else
       do alr1 = 1, n_reg
          reg_data%regions(alr1)%eqv_index = alr1
       end do
    end if
  end subroutine region_data_find_eqv_regions

@ %def region_data_find_eqv_regions
@ Creates singular regions according to table \ref{table:singular
regions}. It scans all regions in table \ref{table:ftuples and
flavors} and records the real flavor structures. If they are
equivalent, the flavor structure is not recorded, but the multiplicity
of the present one is increased.
<<FKS regions: reg data: TBP>>=
  procedure :: init_singular_regions => region_data_init_singular_regions
<<FKS regions: sub interfaces>>=
    module subroutine region_data_init_singular_regions &
         (reg_data, ftuples, emitter, flv_alr, nlo_correction_type)
      class(region_data_t), intent(inout) :: reg_data
      type(ftuple_list_t), intent(inout), dimension(:), allocatable :: ftuples
      type(string_t), intent(in) :: nlo_correction_type
      integer, intent(in), dimension(:) :: emitter
      type(flv_structure_t), intent(in), dimension(:) :: flv_alr
    end subroutine region_data_init_singular_regions
<<FKS regions: procedures>>=
  module subroutine region_data_init_singular_regions &
       (reg_data, ftuples, emitter, flv_alr, nlo_correction_type)
    class(region_data_t), intent(inout) :: reg_data
    type(ftuple_list_t), intent(inout), dimension(:), allocatable :: ftuples
    type(string_t), intent(in) :: nlo_correction_type
    type(string_t), dimension(:), allocatable :: nlo_correction_type_dyn
    integer, intent(in), dimension(:) :: emitter
    integer :: n_independent_flv
    type(flv_structure_t), intent(in), dimension(:) :: flv_alr
    type(flv_structure_t), dimension(:), allocatable :: flv_uborn, &
         flv_alr_registered
    integer, dimension(:), allocatable :: mult
    integer, dimension(:), allocatable :: flst_emitter
    integer :: n_regions, maxregions
    integer, dimension(:), allocatable :: index
    integer :: i, i_flv, n_legs
    logical :: equiv, valid_fs_splitting, pure_corr_type, &
         corr_type_valid, non_singular_reg
    integer :: i_first, i_reg, i_reg_prev
    integer, dimension(:), allocatable :: region_to_ftuple, alr_limits
    integer, dimension(:), allocatable :: equiv_index

    maxregions = size (emitter)
    n_legs = flv_alr(1)%nlegs

    allocate (flv_uborn (maxregions))
    allocate (flv_alr_registered (maxregions))
    allocate (mult (maxregions))
    mult = 0
    allocate (flst_emitter (maxregions))
    allocate (index (0))
    allocate (region_to_ftuple (maxregions))
    allocate (equiv_index (maxregions))
    allocate (nlo_correction_type_dyn (maxregions))

    call setup_region_mappings (n_independent_flv, alr_limits, region_to_ftuple)
    nlo_correction_type_dyn = nlo_correction_type
    i_first = 1
    i_reg = 1
    SCAN_FLAVORS: do i_flv = 1, n_independent_flv
       SCAN_FTUPLES: do i = i_first, i_first + alr_limits (i_flv) - 1
          equiv = .false.
          corr_type_valid = .true.
          non_singular_reg = .false.
          if (i == i_first) then
             flv_alr_registered(i_reg) = flv_alr(i)
             if (nlo_correction_type == "EW" .and. &
                  reg_data%alphas_power > 0) then
                nlo_correction_type_dyn (i_reg) = &
                     set_dynamic_correction_type (i)
             end if
             flv_uborn(i_reg) = flv_alr(i)%create_uborn (emitter(i), &
                                     nlo_correction_type_dyn (i_reg))
             flst_emitter(i_reg) = emitter(i)
             equiv_index(i_reg) = region_to_ftuple(i)
             if (nlo_correction_type == "EW" .and. reg_data%alphas_power > 0) then
                corr_type_valid = (nlo_correction_type_dyn (i_reg) == "EW" .and. &
                                  query_coupling_powers (flv_uborn(i_reg)%flst, &
                                  reg_data%alpha_power, reg_data%alphas_power)) &
                                  .or. (nlo_correction_type_dyn (i_reg) == "QCD" .and. &
                                  query_coupling_powers (flv_uborn(i_reg)%flst, &
                                  reg_data%alpha_power + 1, reg_data%alphas_power - 1))
                non_singular_reg = .not. corr_type_valid .and. &
                                   qcd_ew_interferences (flv_alr_registered(i_reg)%flst) &
                                   .and. query_coupling_powers (flv_alr_registered(i_reg)%flst, &
                                   reg_data%alpha_power+2, reg_data%alphas_power-1) &
                                   .and. .not. qcd_ew_interferences (flv_uborn(i_reg)%flst) &
                                   .and. nlo_correction_type_dyn (i_reg) == "QCD"
                if (non_singular_reg) nlo_correction_type_dyn (i_reg) = "none"
             end if
             if (corr_type_valid .or. non_singular_reg) then
                mult(i_reg) = mult(i_reg) + 1
                index = [index, region_to_real_index(ftuples, i)]
                i_reg = i_reg + 1
             end if
          else
             !!! Check for equivalent flavor structures
             do i_reg_prev = 1, i_reg - 1
                if (emitter(i) == flst_emitter(i_reg_prev) .and. emitter(i) > reg_data%n_in) then
                   valid_fs_splitting = check_fs_splitting &
                         (flv_alr(i)%get_last_two(n_legs), &
                          flv_alr_registered(i_reg_prev)%get_last_two(n_legs), &
                          flv_alr(i)%tag(n_legs - 1), &
                          flv_alr_registered(i_reg_prev)%tag(n_legs - 1))
                   if (nlo_correction_type == "EW" .and. reg_data%alphas_power > 0) then
                      nlo_correction_type_dyn (i_reg) = set_dynamic_correction_type (i)
                   end if
                   pure_corr_type = nlo_correction_type_dyn (i_reg) &
                                     == nlo_correction_type_dyn (i_reg_prev)
                   if ((flv_alr(i) .equiv. flv_alr_registered(i_reg_prev)) &
                        .and. valid_fs_splitting .and. pure_corr_type) then
                      mult(i_reg_prev) = mult(i_reg_prev) + 1
                      equiv = .true.
                      call ftuples(region_to_real_index(ftuples, i))%set_equiv &
                           (equiv_index(i_reg_prev), region_to_ftuple(i))
                      exit
                   end if
                else if (emitter(i) == flst_emitter(i_reg_prev) .and. emitter(i) <= reg_data%n_in) then
                   if (nlo_correction_type == "EW" .and. reg_data%alphas_power > 0) then
                      nlo_correction_type_dyn (i_reg) = set_dynamic_correction_type (i)
                   end if
                   pure_corr_type = nlo_correction_type_dyn (i_reg) &
                                     == nlo_correction_type_dyn (i_reg_prev)
                   if ((flv_alr(i) .equiv. flv_alr_registered(i_reg_prev)) &
                        .and. pure_corr_type) then
                      mult(i_reg_prev) = mult(i_reg_prev) + 1
                      equiv = .true.
                      call ftuples(region_to_real_index(ftuples, i))%set_equiv &
                           (equiv_index(i_reg_prev), region_to_ftuple(i))
                      exit
                   end if
                end if
             end do
             if (.not. equiv) then
                flv_alr_registered(i_reg) = flv_alr(i)
                if (nlo_correction_type == "EW" .and. reg_data%alphas_power > 0) then
                   nlo_correction_type_dyn (i_reg) = set_dynamic_correction_type (i)
                end if
                flv_uborn(i_reg) = flv_alr(i)%create_uborn (emitter(i), &
                                       nlo_correction_type_dyn (i_reg))
                flst_emitter(i_reg) = emitter(i)
                equiv_index (i_reg) = region_to_ftuple(i)
                if (nlo_correction_type == "EW" .and. reg_data%alphas_power > 0) then
                   corr_type_valid = (nlo_correction_type_dyn (i_reg) == "EW" .and. &
                                query_coupling_powers (flv_uborn(i_reg)%flst, &
                                reg_data%alpha_power, reg_data%alphas_power)) &
                                .or. (nlo_correction_type_dyn (i_reg) == "QCD" .and. &
                                query_coupling_powers (flv_uborn(i_reg)%flst, &
                                reg_data%alpha_power + 1, reg_data%alphas_power - 1))
                   non_singular_reg = .not. corr_type_valid .and. &
                                 qcd_ew_interferences (flv_alr_registered(i_reg)%flst) &
                                 .and. query_coupling_powers (flv_alr_registered(i_reg)%flst, &
                                 reg_data%alpha_power+2, reg_data%alphas_power-1) &
                                 .and. .not. qcd_ew_interferences (flv_uborn(i_reg)%flst) &
                                 .and. nlo_correction_type_dyn (i_reg) == "QCD"
                   if (non_singular_reg) nlo_correction_type_dyn (i_reg) = "none"
                end if
                if (corr_type_valid .or. non_singular_reg) then
                   mult(i_reg) = mult(i_reg) + 1
                   index = [index, region_to_real_index(ftuples, i)]
                   i_reg = i_reg + 1
                end if
             end if
          end if
       end do SCAN_FTUPLES
       i_first = i_first + alr_limits(i_flv)
    end do SCAN_FLAVORS
    n_regions = i_reg - 1

    allocate (reg_data%regions (n_regions))
    reg_data%n_regions = n_regions
    call account_for_regions_from_other_uborns (ftuples)
    call init_regions_with_permuted_flavors ()
    call assign_real_indices ()

    deallocate (flv_uborn)
    deallocate (flv_alr_registered)
    deallocate (mult)
    deallocate (flst_emitter)
    deallocate (index)
    deallocate (region_to_ftuple)
    deallocate (equiv_index)

  contains

    subroutine account_for_regions_from_other_uborns (ftuples)
      type(ftuple_list_t), intent(inout), dimension(:), allocatable :: ftuples
      integer :: alr1, alr2, i
      type(ftuple_t), dimension(:), allocatable :: ftuples_alr1, ftuples_alr2
      logical, dimension(:,:), allocatable :: equivalences
      do alr1 = 1, n_regions
         do alr2 = 1, n_regions
            if (index(alr1) == index(alr2)) cycle
            if (flv_alr_registered(alr1) .equiv. flv_alr_registered(alr2)) then
               call ftuples(index(alr1))%to_array (ftuples_alr1, equivalences, .false.)
               call ftuples(index(alr2))%to_array (ftuples_alr2, equivalences, .false.)
               do i = 1, size (ftuples_alr2)
                  if (.not. any (ftuple_equal_ireg (ftuples_alr1, ftuples_alr2(i)))) then
                     call ftuples(index(alr1))%append (ftuples_alr2(i))
                  end if
               end do
            end if
         end do
      end do
    end subroutine account_for_regions_from_other_uborns

    subroutine setup_region_mappings (n_independent_flv, &
           alr_limits, region_to_ftuple)
       integer, intent(inout) :: n_independent_flv
       integer, intent(inout), dimension(:), allocatable :: alr_limits
       integer, intent(inout), dimension(:), allocatable :: region_to_ftuple
       integer :: i, j, i_flv
       if (any (ftuples%get_n_tuples() == 0)) &
            call msg_fatal ("Inconsistent collection of FKS pairs!")
       n_independent_flv = size (ftuples)
       alr_limits = ftuples%get_n_tuples()
       if (.not. (sum (alr_limits) == maxregions)) &
            call msg_fatal ("Too many regions!")
       j = 1
       do i_flv = 1, n_independent_flv
          do i = 1, alr_limits(i_flv)
             region_to_ftuple(j) = i
             j = j + 1
          end do
       end do
    end subroutine setup_region_mappings

    subroutine check_permutation (perm, flv_perm, flv_orig, i_reg)
      type(flv_perm_t), intent(in) :: perm
      type(flv_structure_t), intent(in) :: flv_perm, flv_orig
      integer, intent(in) :: i_reg
      type(flv_structure_t) :: flv_tmp
      flv_tmp = perm%apply (flv_orig, invert = .true.)
      if (.not. all (flv_tmp%flst == flv_perm%flst)) then
         print *, 'Fail at: ', i_reg
         print *, 'Original flavor structure: ', flv_orig%flst
         call perm%write ()
         print *, 'Permuted flavor: ', flv_perm%flst
         print *, 'Should be: ', flv_tmp%flst
         call msg_fatal ("Permutation does not reproduce original flavor!")
      end if
    end subroutine check_permutation

    subroutine init_regions_with_permuted_flavors ()
       type(flv_perm_t) :: perm_list
       type(ftuple_t), dimension(:), allocatable :: ftuple_array
       logical, dimension(:,:), allocatable :: equivalences
       integer :: i, j
       do j = 1, n_regions
          do i = 1, reg_data%n_flv_born
             if (reg_data%flv_born (i) .equiv. flv_uborn (j)) then
                call perm_list%reset ()
                call perm_list%init (reg_data%flv_born(i), flv_uborn(j), &
                     reg_data%n_in, reg_data%n_legs_born, .true.)
                flv_uborn(j) = perm_list%apply (flv_uborn(j))
                flv_alr_registered(j) = perm_list%apply (flv_alr_registered(j))
                flst_emitter(j) = perm_list%apply (flst_emitter(j))
             end if
          end do
          call ftuples(index(j))%to_array (ftuple_array, equivalences, .false.)
          do i = 1, size (reg_data%flv_real)
             if (reg_data%flv_real(i) .equiv. flv_alr_registered(j)) then
                call perm_list%reset ()
                call perm_list%init (flv_alr_registered(j), reg_data%flv_real(i), &
                     reg_data%n_in, reg_data%n_legs_real, .false.)
                if (debug_active (D_SUBTRACTION)) call check_permutation &
                     (perm_list, reg_data%flv_real(i), flv_alr_registered(j), j)
                ftuple_array = perm_list%apply (ftuple_array)
                call ftuple_sort_array (ftuple_array, equivalences)
             end if
          end do
          call reg_data%regions(j)%init (j, mult(j), 0, flv_alr_registered(j), &
               flv_uborn(j), reg_data%flv_born, flst_emitter(j), ftuple_array, &
               equivalences, nlo_correction_type_dyn (j))
          if (allocated (ftuple_array)) deallocate (ftuple_array)
          if (allocated (equivalences)) deallocate (equivalences)
       end do
    end subroutine init_regions_with_permuted_flavors

    subroutine assign_real_indices ()
      type(flv_structure_t) :: current_flv_real
      type(flv_structure_t), dimension(:), allocatable :: these_flv
      integer :: i_real, current_uborn_index
      integer :: i, j, this_i_real
      allocate (these_flv (size (flv_alr_registered)))
      i_real = 1
      associate (regions => reg_data%regions)
         do i = 1, reg_data%n_regions
            do j = 1, size (these_flv)
               if (.not. allocated (these_flv(j)%flst)) then
                  this_i_real = i_real
                  call these_flv(i_real)%init (flv_alr_registered(i)%flst, reg_data%n_in)
                  i_real = i_real + 1
                  exit
               else if (all (these_flv(j)%flst == flv_alr_registered(i)%flst)) then
                  this_i_real = j
                  exit
               end if
            end do
            regions(i)%real_index = this_i_real
         end do
      end associate
      deallocate (these_flv)
    end subroutine assign_real_indices

    function check_fs_splitting (flv1, flv2, tag1, tag2) result (valid)
      logical :: valid
      integer, intent(in), dimension(2) :: flv1, flv2
      integer, intent(in) :: tag1, tag2
      if (flv1(1) + flv1(2) == 0) then
         valid = abs(flv1(1)) == abs(flv2(1)) .and. abs(flv1(2)) == abs(flv2(2))
      else
         valid = flv1(1) == flv2(1) .and. flv1(2) == flv2(2) .and. tag1 == tag2
      end if
    end function check_fs_splitting

    function set_dynamic_correction_type (i_flv_alr) result (nlo_corr_type_dyn)
       type(string_t) :: nlo_corr_type_dyn
       type(ftuple_t) :: ftuple_tmp
       integer, intent(in) :: i_flv_alr
       ftuple_tmp = ftuples (region_to_real_index(ftuples, i_flv_alr))%get_ftuple &
                         (region_to_ftuple(i_flv_alr))
       if (ftuple_tmp%qcd_split) then
          nlo_corr_type_dyn = var_str ("QCD")
       else
          nlo_corr_type_dyn = var_str ("EW")
       end if
    end function set_dynamic_correction_type
  end subroutine region_data_init_singular_regions

@ %def region_data_init_singular_regions
@ Create an array containing all emitters and resonances of [[region_data]].
<<FKS regions: reg data: TBP>>=
  procedure :: find_emitters => region_data_find_emitters
<<FKS regions: sub interfaces>>=
    module subroutine region_data_find_emitters (reg_data)
      class(region_data_t), intent(inout) :: reg_data
    end subroutine region_data_find_emitters
<<FKS regions: procedures>>=
  module subroutine region_data_find_emitters (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr, j, n_em, em
    integer, dimension(:), allocatable :: em_count
    allocate (em_count(reg_data%n_regions))
    em_count = -1
    n_em = 0

    !!!Count the number of different emitters
    do alr = 1, reg_data%n_regions
       em = reg_data%regions(alr)%emitter
       if (.not. any (em_count == em)) then
          n_em = n_em + 1
          em_count(alr) = em
       end if
    end do

    if (n_em < 1) call msg_fatal ("region_data_find_emitters: No emitters found!")
    reg_data%n_emitters = n_em
    allocate (reg_data%emitters (reg_data%n_emitters))
    reg_data%emitters = -1

    j = 1
    do alr = 1, size (reg_data%regions)
       em = reg_data%regions(alr)%emitter
       if (.not. any (reg_data%emitters == em)) then
          reg_data%emitters(j) = em
          j = j + 1
       end if
    end do
  end subroutine region_data_find_emitters

@ %def region_data_find_emitters
@
<<FKS regions: reg data: TBP>>=
  procedure :: find_resonances => region_data_find_resonances
<<FKS regions: sub interfaces>>=
    module subroutine region_data_find_resonances (reg_data)
      class(region_data_t), intent(inout) :: reg_data
    end subroutine region_data_find_resonances
<<FKS regions: procedures>>=
  module subroutine region_data_find_resonances (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr, j, k, n_res, n_contr
    integer :: res
    integer, dimension(10) :: res_count
    type(resonance_contributors_t), dimension(10) :: contributors_count
    type(resonance_contributors_t) :: contributors
    integer :: i_res, emitter
    logical :: share_emitter
    res_count = -1
    n_res = 0; n_contr = 0

    !!! Count the number of different resonances
    do alr = 1, reg_data%n_regions
       select type (fks_mapping => reg_data%fks_mapping)
       type is (fks_mapping_resonances_t)
          res = fks_mapping%res_map%alr_to_i_res (alr)
          if (.not. any (res_count == res)) then
             n_res = n_res + 1
             res_count(alr) = res
          end if
       end select
    end do

    if (n_res > 0) allocate (reg_data%resonances (n_res))

    j = 1
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       do alr = 1, size (reg_data%regions)
          res = fks_mapping%res_map%alr_to_i_res (alr)
          if (.not. any (reg_data%resonances == res)) then
             reg_data%resonances(j) = res
             j = j + 1
          end if
       end do

       allocate (reg_data%alr_to_i_contributor (size (reg_data%regions)))
       do alr = 1, size (reg_data%regions)
          i_res = fks_mapping%res_map%alr_to_i_res (alr)
          emitter = reg_data%regions(alr)%emitter
          call reg_data%get_contributors (i_res, emitter, contributors%c, share_emitter)
          if (.not. share_emitter) cycle
          if (.not. any (contributors_count == contributors)) then
             n_contr = n_contr + 1
             contributors_count(alr) = contributors
          end if
          if (allocated (contributors%c)) deallocate (contributors%c)
       end do
       allocate (reg_data%alr_contributors (n_contr))
       j = 1
       do alr = 1, size (reg_data%regions)
          i_res = fks_mapping%res_map%alr_to_i_res (alr)
          emitter = reg_data%regions(alr)%emitter
          call reg_data%get_contributors (i_res, emitter, contributors%c, share_emitter)
          if (.not. share_emitter) cycle
          if (.not. any (reg_data%alr_contributors == contributors)) then
             reg_data%alr_contributors(j) = contributors
             reg_data%alr_to_i_contributor (alr) = j
             j = j + 1
          else
             do k = 1, size (reg_data%alr_contributors)
                if (reg_data%alr_contributors(k) == contributors) exit
             end do
             reg_data%alr_to_i_contributor (alr) = k
          end if
          if (allocated (contributors%c)) deallocate (contributors%c)
       end do
    end select
    call reg_data%extend_ftuples (n_res)
    call reg_data%set_contributors ()

  end subroutine region_data_find_resonances

@ %def region_data_find_resonances
@
<<FKS regions: reg data: TBP>>=
  procedure :: set_i_phs_to_i_con => region_data_set_i_phs_to_i_con
<<FKS regions: sub interfaces>>=
    module subroutine region_data_set_i_phs_to_i_con (reg_data)
      class(region_data_t), intent(inout) :: reg_data
    end subroutine region_data_set_i_phs_to_i_con
<<FKS regions: procedures>>=
  module subroutine region_data_set_i_phs_to_i_con (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr
    integer :: i_res, emitter, i_con, i_phs, i_em
    type(phs_identifier_t), dimension(:), allocatable :: phs_id_tmp
    logical :: share_emitter, phs_exist
    type(resonance_contributors_t) :: contributors
    allocate (phs_id_tmp (reg_data%n_phs))
    if (allocated (reg_data%resonances)) then
       allocate (reg_data%i_phs_to_i_con (reg_data%n_phs))
       do i_em = 1, size (reg_data%emitters)
          emitter = reg_data%emitters(i_em)
          do i_res = 1, size (reg_data%resonances)
             if (reg_data%emitter_is_compatible_with_resonance (i_res, emitter)) then
                alr = find_alr (emitter, i_res)
                if (alr == 0) call msg_fatal ("Could not find requested alpha region!")
                i_con = reg_data%alr_to_i_contributor (alr)
                call reg_data%get_contributors (i_res, emitter, contributors%c, share_emitter)
                if (.not. share_emitter) cycle
                call check_for_phs_identifier &
                   (phs_id_tmp, reg_data%n_in, emitter, contributors%c, phs_exist, i_phs)
                if (phs_id_tmp(i_phs)%emitter < 0) then
                   phs_id_tmp(i_phs)%emitter = emitter
                   allocate (phs_id_tmp(i_phs)%contributors (size (contributors%c)))
                   phs_id_tmp(i_phs)%contributors = contributors%c
                end if
                reg_data%i_phs_to_i_con (i_phs) = i_con
             end if
             if (allocated (contributors%c)) deallocate (contributors%c)
          end do
       end do
    end if
  contains
    function find_alr (emitter, i_res) result (alr)
       integer :: alr
       integer, intent(in) :: emitter, i_res
       integer :: i
       do i = 1, reg_data%n_regions
          if (reg_data%regions(i)%emitter == emitter .and. &
              reg_data%regions(i)%i_res == i_res) then
             alr = i
             return
          end if
       end do
       alr = 0
    end function find_alr
  end subroutine region_data_set_i_phs_to_i_con

@ %def region_data_set_i_phs_to_i_con
@
<<FKS regions: reg data: TBP>>=
  procedure :: set_alr_to_i_phs => region_data_set_alr_to_i_phs
<<FKS regions: sub interfaces>>=
    module subroutine region_data_set_alr_to_i_phs &
         (reg_data, phs_identifiers, alr_to_i_phs)
      class(region_data_t), intent(inout) :: reg_data
      type(phs_identifier_t), intent(in), dimension(:) :: phs_identifiers
      integer, intent(out), dimension(:) :: alr_to_i_phs
    end subroutine region_data_set_alr_to_i_phs
<<FKS regions: procedures>>=
  module subroutine region_data_set_alr_to_i_phs &
       (reg_data, phs_identifiers, alr_to_i_phs)
    class(region_data_t), intent(inout) :: reg_data
    type(phs_identifier_t), intent(in), dimension(:) :: phs_identifiers
    integer, intent(out), dimension(:) :: alr_to_i_phs
    integer :: alr, i_phs
    integer :: emitter, i_res
    type(resonance_contributors_t) :: contributors
    logical :: share_emitter, phs_exist
    do alr = 1, reg_data%n_regions
       associate (region => reg_data%regions(alr))
          emitter = region%emitter
          i_res = region%i_res
          if (i_res /= 0) then
             call reg_data%get_contributors (i_res, emitter, &
                contributors%c, share_emitter)
             if (.not. share_emitter) cycle
          end if
          if (allocated (contributors%c)) then
             call check_for_phs_identifier (phs_identifiers, reg_data%n_in, &
                emitter, contributors%c, phs_exist = phs_exist, i_phs = i_phs)
          else
             call check_for_phs_identifier (phs_identifiers, reg_data%n_in, &
                emitter, phs_exist = phs_exist, i_phs = i_phs)
          end if
          if (.not. phs_exist) &
             call msg_fatal ("phs identifiers are not set up correctly!")
          alr_to_i_phs(alr) = i_phs
       end associate
       if (allocated (contributors%c)) deallocate (contributors%c)
    end do
  end subroutine region_data_set_alr_to_i_phs

@ %def region_data_set_alr_to_i_phs
@
<<FKS regions: reg data: TBP>>=
  procedure :: set_contributors => region_data_set_contributors
<<FKS regions: sub interfaces>>=
    module subroutine region_data_set_contributors (reg_data)
      class(region_data_t), intent(inout) :: reg_data
    end subroutine region_data_set_contributors
<<FKS regions: procedures>>=
  module subroutine region_data_set_contributors (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr, i_res, i_reg, i_con
    integer :: i1, i2, i_em
    integer, dimension(:), allocatable :: contributors
    logical :: share_emitter
    do alr = 1, size (reg_data%regions)
       associate (sregion => reg_data%regions(alr))
         allocate (sregion%i_reg_to_i_con (sregion%nregions))
         do i_reg = 1, sregion%nregions
            call sregion%ftuples(i_reg)%get (i1, i2)
            i_em = get_emitter_index (i1, i2, reg_data%n_legs_real)
            i_res = sregion%ftuples(i_reg)%i_res
            call reg_data%get_contributors &
                 (i_res, i_em, contributors, share_emitter)
            !!! Lookup contributor index
            do i_con = 1, size (reg_data%alr_contributors)
               if (all (reg_data%alr_contributors(i_con)%c == contributors)) &
                    then
                  sregion%i_reg_to_i_con (i_reg) = i_con
                  exit
               end if
            end do
            deallocate (contributors)
         end do
       end associate
    end do
  contains
    function get_emitter_index (i1, i2, n) result (i_em)
      integer :: i_em
      integer, intent(in) :: i1, i2, n
      if (i1 == n) then
         i_em = i2
      else
         i_em = i1
      end if
    end function get_emitter_index
  end subroutine region_data_set_contributors

@ %def region_data_set_contributors
@ This extension of the ftuples is still too naive as it assumes that the same
resonances are possible for all ftuples
<<FKS regions: reg data: TBP>>=
  procedure :: extend_ftuples => region_data_extend_ftuples
<<FKS regions: sub interfaces>>=
    module subroutine region_data_extend_ftuples (reg_data, n_res)
      class(region_data_t), intent(inout) :: reg_data
      integer, intent(in) :: n_res
    end subroutine region_data_extend_ftuples
<<FKS regions: procedures>>=
  module subroutine region_data_extend_ftuples (reg_data, n_res)
    class(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: n_res
    integer :: alr, n_reg_save
    integer :: i_reg, i_res, i_em, k
    type(ftuple_t), dimension(:), allocatable :: ftuple_save
    integer :: n_new
    do alr = 1, size (reg_data%regions)
       associate (sregion => reg_data%regions(alr))
          n_reg_save = sregion%nregions
          allocate (ftuple_save (n_reg_save))
          ftuple_save = sregion%ftuples
          n_new = count_n_new_ftuples (sregion, n_res)
          deallocate (sregion%ftuples)
          sregion%nregions = n_new
          allocate (sregion%ftuples (n_new))
          k = 1
          do i_res = 1, n_res
             do i_reg = 1, n_reg_save
                associate (ftuple_new => sregion%ftuples(k))
                   i_em = ftuple_save(i_reg)%ireg(1)
                   if (reg_data%emitter_is_in_resonance (i_res, i_em)) then
                      call ftuple_new%set (i_em, ftuple_save(i_reg)%ireg(2))
                      ftuple_new%i_res = i_res
                      ftuple_new%splitting_type = ftuple_save(i_reg)%splitting_type
                      k = k + 1
                   end if
                end associate
             end do
          end do
       end associate
       deallocate (ftuple_save)
    end do
  contains
    function count_n_new_ftuples (sregion, n_res) result (n_new)
      integer :: n_new
      type(singular_region_t), intent(in) :: sregion
      integer, intent(in) :: n_res
      integer :: i_reg, i_res, i_em
      n_new = 0
      do i_reg = 1, sregion%nregions
         do i_res = 1, n_res
            i_em = sregion%ftuples(i_reg)%ireg(1)
            if (reg_data%emitter_is_in_resonance (i_res, i_em)) &
               n_new = n_new + 1
         end do
      end do
    end function count_n_new_ftuples
  end subroutine region_data_extend_ftuples

@ %def region_data_extend_ftuples
@
<<FKS regions: reg data: TBP>>=
  procedure :: get_flavor_indices => region_data_get_flavor_indices
<<FKS regions: sub interfaces>>=
    module function region_data_get_flavor_indices &
         (reg_data, born) result (i_flv)
      integer, dimension(:), allocatable :: i_flv
      class(region_data_t), intent(in) :: reg_data
      logical, intent(in) :: born
    end function region_data_get_flavor_indices
<<FKS regions: procedures>>=
  module function region_data_get_flavor_indices (reg_data, born) result (i_flv)
    integer, dimension(:), allocatable :: i_flv
    class(region_data_t), intent(in) :: reg_data
    logical, intent(in) :: born
    allocate (i_flv (reg_data%n_regions))
    if (born) then
       i_flv = reg_data%regions%uborn_index
    else
       i_flv = reg_data%regions%real_index
    end if
  end function region_data_get_flavor_indices

@ %def region_data_get_flavor_indices
@
<<FKS regions: reg data: TBP>>=
  procedure :: get_matrix_element_index => region_data_get_matrix_element_index
<<FKS regions: sub interfaces>>=
    module function region_data_get_matrix_element_index &
         (reg_data, i_reg) result (i_me)
      integer :: i_me
      class(region_data_t), intent(in) :: reg_data
      integer, intent(in) :: i_reg
    end function region_data_get_matrix_element_index
<<FKS regions: procedures>>=
  module function region_data_get_matrix_element_index &
       (reg_data, i_reg) result (i_me)
    integer :: i_me
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_reg
    i_me = reg_data%regions(i_reg)%real_index
  end function region_data_get_matrix_element_index

@ %def region_data_get_matrix_element_index
@
<<FKS regions: reg data: TBP>>=
  procedure :: compute_number_of_phase_spaces &
     => region_data_compute_number_of_phase_spaces
<<FKS regions: sub interfaces>>=
    module subroutine region_data_compute_number_of_phase_spaces (reg_data)
      class(region_data_t), intent(inout) :: reg_data
    end subroutine region_data_compute_number_of_phase_spaces
<<FKS regions: procedures>>=
  module subroutine region_data_compute_number_of_phase_spaces (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: i_em, i_res, i_phs
    integer :: emitter
    type(resonance_contributors_t) :: contributors
    integer, parameter :: n_max_phs = 10
    type(phs_identifier_t), dimension(n_max_phs) :: phs_id_tmp
    logical :: share_emitter, phs_exist
    if (allocated (reg_data%resonances)) then
       reg_data%n_phs = 0
       do i_em = 1, size (reg_data%emitters)
          emitter = reg_data%emitters(i_em)
          do i_res = 1, size (reg_data%resonances)
             if (reg_data%emitter_is_compatible_with_resonance (i_res, emitter)) then
                call reg_data%get_contributors &
                     (i_res, emitter, contributors%c, share_emitter)
                if (.not. share_emitter) cycle
                call check_for_phs_identifier (phs_id_tmp, reg_data%n_in, &
                     emitter, contributors%c, phs_exist, i_phs)
                if (.not. phs_exist) then
                   reg_data%n_phs = reg_data%n_phs + 1
                   if (reg_data%n_phs > n_max_phs) call msg_fatal &
                      ("Buffer of phase space identifieres: Too much phase spaces!")
                   call phs_id_tmp(i_phs)%init (emitter, contributors%c)
                end if
             end if
             if (allocated (contributors%c)) deallocate (contributors%c)
          end do
       end do
    else
       reg_data%n_phs = size (remove_duplicates_from_int_array &
            (reg_data%emitters))
    end if
  end subroutine region_data_compute_number_of_phase_spaces

@ %def region_data_compute_number_of_phase_spaces
@
<<FKS regions: reg data: TBP>>=
  procedure :: get_n_phs => region_data_get_n_phs
<<FKS regions: sub interfaces>>=
    module function region_data_get_n_phs (reg_data) result (n_phs)
      integer :: n_phs
      class(region_data_t), intent(in) :: reg_data
    end function region_data_get_n_phs
<<FKS regions: procedures>>=
  module function region_data_get_n_phs (reg_data) result (n_phs)
    integer :: n_phs
    class(region_data_t), intent(in) :: reg_data
    n_phs = reg_data%n_phs
  end function region_data_get_n_phs

@ %def region_data_get_n_phs
@
<<FKS regions: reg data: TBP>>=
  procedure :: set_splitting_info => region_data_set_splitting_info
<<FKS regions: sub interfaces>>=
    module subroutine region_data_set_splitting_info (reg_data)
      class(region_data_t), intent(inout) :: reg_data
    end subroutine region_data_set_splitting_info
<<FKS regions: procedures>>=
  module subroutine region_data_set_splitting_info (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr
    do alr = 1, reg_data%n_regions
       call reg_data%regions(alr)%set_splitting_info (reg_data%n_in)
    end do
  end subroutine region_data_set_splitting_info

@ %def region_data_set_splitting_info
@
<<FKS regions: reg data: TBP>>=
  procedure :: init_phs_identifiers => region_data_init_phs_identifiers
<<FKS regions: sub interfaces>>=
    module subroutine region_data_init_phs_identifiers (reg_data, phs_id)
      class(region_data_t), intent(in) :: reg_data
      type(phs_identifier_t), intent(out), dimension(:), allocatable :: phs_id
    end subroutine region_data_init_phs_identifiers
<<FKS regions: procedures>>=
  module subroutine region_data_init_phs_identifiers (reg_data, phs_id)
    class(region_data_t), intent(in) :: reg_data
    type(phs_identifier_t), intent(out), dimension(:), allocatable :: phs_id
    integer :: i_em, i_res, i_phs
    integer :: emitter
    type(resonance_contributors_t) :: contributors
    logical :: share_emitter, phs_exist
    allocate (phs_id (reg_data%n_phs))
    do i_em = 1, size (reg_data%emitters)
       emitter = reg_data%emitters(i_em)
       if (allocated (reg_data%resonances)) then
          do i_res = 1, size (reg_data%resonances)
             call reg_data%get_contributors (i_res, emitter, &
                  contributors%c, share_emitter)
             if (.not. share_emitter) cycle
             call check_for_phs_identifier &
                (phs_id, reg_data%n_in, emitter, contributors%c, &
                phs_exist, i_phs)
             if (.not. phs_exist) &
                call phs_id(i_phs)%init (emitter, contributors%c)
             if (allocated (contributors%c)) deallocate (contributors%c)
          end do
       else
          call check_for_phs_identifier (phs_id, reg_data%n_in, emitter, &
             phs_exist = phs_exist, i_phs = i_phs)
          if (.not. phs_exist) call phs_id(i_phs)%init (emitter)
       end if
    end do
  end subroutine region_data_init_phs_identifiers

@ %def region_data_init_phs_identifiers
@ Gathers all ftuples from all ALRs.
There are at most $n \cdot (n-1)$ ftuples with $i$ and $j$ in the final state
and up to $3n$ ftuples with $i$ in the initial state.
<<FKS regions: reg data: TBP>>=
  procedure :: get_all_ftuples => region_data_get_all_ftuples
<<FKS regions: sub interfaces>>=
    module subroutine region_data_get_all_ftuples (reg_data, ftuples)
      class(region_data_t), intent(in) :: reg_data
      type(ftuple_t), intent(inout), dimension(:), allocatable :: ftuples
    end subroutine region_data_get_all_ftuples
<<FKS regions: procedures>>=
  module subroutine region_data_get_all_ftuples (reg_data, ftuples)
    class(region_data_t), intent(in) :: reg_data
    type(ftuple_t), intent(inout), dimension(:), allocatable :: ftuples
    type(ftuple_t), dimension(:), allocatable :: ftuple_tmp
    integer :: i, j, alr, n_fs
    j = 0
    n_fs = reg_data%n_legs_real - reg_data%n_in
    allocate (ftuple_tmp (n_fs * (n_fs - 1) + 3 * n_fs))
    do i = 1, reg_data%n_regions
       associate (region => reg_data%regions(i))
          do alr = 1, region%nregions
             if (.not. any &
                  (ftuple_equal_ireg (region%ftuples(alr), ftuple_tmp))) then
                j = j + 1
                ftuple_tmp(j) = region%ftuples(alr)
             end if
          end do
       end associate
    end do
    allocate (ftuples (j))
    ftuples = ftuple_tmp(1:j)
    deallocate (ftuple_tmp)
  end subroutine region_data_get_all_ftuples

@ %def region_data_get_all_ftuples
@
<<FKS regions: reg data: TBP>>=
  procedure :: write_to_file => region_data_write_to_file
<<FKS regions: sub interfaces>>=
    module subroutine region_data_write_to_file &
         (reg_data, proc_id, latex, os_data)
      class(region_data_t), intent(inout) :: reg_data
      type(string_t), intent(in) :: proc_id
      logical, intent(in) :: latex
      type(os_data_t), intent(in) :: os_data
    end subroutine region_data_write_to_file
<<FKS regions: procedures>>=
  module subroutine region_data_write_to_file &
       (reg_data, proc_id, latex, os_data)
    class(region_data_t), intent(inout) :: reg_data
    type(string_t), intent(in) :: proc_id
    logical, intent(in) :: latex
    type(os_data_t), intent(in) :: os_data
    type(string_t) :: filename
    integer :: u
    integer :: status

    if (latex) then
       filename = proc_id // "_fks_regions.tex"
    else
       filename = proc_id // "_fks_regions.out"
    end if
    u = free_unit ()
    open (u, file=char(filename), action = "write", status="replace")
    if (latex) then
       call reg_data%write_latex (u)
       close (u)
       call os_data%build_latex_file &
            (proc_id // "_fks_regions", stat_out = status)
       if (status /= 0) &
            call msg_error (char ("Failed to compile " // filename))
    else
       call reg_data%write (u)
       close (u)
    end if
  end subroutine region_data_write_to_file

@ %def region_data_write_to_file
@
<<FKS regions: reg data: TBP>>=
  procedure :: write_latex => region_data_write_latex
<<FKS regions: sub interfaces>>=
    module subroutine region_data_write_latex (reg_data, unit)
      class(region_data_t), intent(in) :: reg_data
      integer, intent(in), optional :: unit
    end subroutine region_data_write_latex
<<FKS regions: procedures>>=
  module subroutine region_data_write_latex (reg_data, unit)
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in), optional :: unit
    integer :: i, u
    u = given_output_unit (); if (present (unit)) u = unit
    write (u, "(A)") "\documentclass{article}"
    write (u, "(A)") "\begin{document}"
    write (u, "(A)") "%FKS region data, automatically created by WHIZARD"
    write (u, "(A)") "\begin{table}"
    write (u, "(A)") "\begin{center}"
    write (u, "(A)") "\begin{tabular} {|c|c|c|c|c|c|c|c|}"
    write (u, "(A)") "\hline"
    write (u, "(A)") "$\alpha_r$ & $f_r$ & $i_r$ & $\varepsilon$ & " // &
         "$\varsigma$ & $\mathcal{P}_{\rm{FKS}}$ & $i_b$ & $f_b$ \\"
    write (u, "(A)") "\hline"
    do i = 1, reg_data%n_regions
       call reg_data%regions(i)%write_latex (u)
    end do
    write (u, "(A)") "\hline"
    write (u, "(A)") "\end{tabular}"
    write (u, "(A)") "\caption{List of singular regions}"
    write (u, "(A)") "\begin{description}"
    write (u, "(A)") "\item[$\alpha_r$] Index of the singular region"
    write (u, "(A)") "\item[$f_r$] Real flavor structure"
    write (u, "(A)") "\item[$i_r$] Index of the associated real flavor structure"
    write (u, "(A)") "\item[$\varepsilon$] Emitter"
    write (u, "(A)") "\item[$\varsigma$] Multiplicity"
                          !!! The symbol used by 0908.4272 for multiplicities
    write (u, "(A)") "\item[$\mathcal{P}_{\rm{FKS}}$] The set of singular FKS-pairs"
    write (u, "(A)") "\item[$i_b$] Underlying Born index"
    write (u, "(A)") "\item[$f_b$] Underlying Born flavor structure"
    write (u, "(A)") "\end{description}"
    write (u, "(A)") "\end{center}"
    write (u, "(A)") "\end{table}"
    write (u, "(A)") "\end{document}"
  end subroutine region_data_write_latex

@ %def region_data_write_latex
@ Creates a table with information about all singular regions and
writes it to a file.
<<FKS regions: reg data: TBP>>=
  procedure :: write => region_data_write
<<FKS regions: sub interfaces>>=
    module subroutine region_data_write (reg_data, unit)
      class(region_data_t), intent(in) :: reg_data
      integer, intent(in), optional :: unit
    end subroutine region_data_write
<<FKS regions: procedures>>=
  module subroutine region_data_write (reg_data, unit)
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in), optional :: unit
    integer :: j
    integer :: maxnregions, i_reg_max
    type(string_t) :: flst_title, ftuple_title
    integer :: n_res, u
    u = given_output_unit (unit); if (u < 0) return
    maxnregions = 1; i_reg_max = 1
    do j = 1, reg_data%n_regions
       if (size (reg_data%regions(j)%ftuples) > maxnregions) then
          maxnregions = reg_data%regions(j)%nregions
          i_reg_max = j
       end if
    end do
    flst_title = '(A' // flst_title_format(reg_data%n_legs_real) // ')'
    ftuple_title = '(A' // ftuple_title_format() // ')'
    write (u,'(A,1X,I4)') 'Total number of regions: ', size(reg_data%regions)
    write (u, '(A4)', advance = 'no') ' alr'
    call write_vline (u)
    write (u, char (flst_title), advance = 'no') 'flst_real'
    call write_vline (u)
    write (u, '(A6)', advance = 'no') 'i_real'
    call write_vline (u)
    write (u, '(A3)', advance = 'no') 'em'
    call write_vline (u)
    write (u, '(A3)', advance = 'no') 'mult'
    call write_vline (u)
    write (u, '(A4)', advance = 'no') 'nreg'
    call write_vline (u)
    if (allocated (reg_data%fks_mapping)) then
       select type (fks_mapping => reg_data%fks_mapping)
       type is (fks_mapping_resonances_t)
          write (u, '(A3)', advance = 'no') 'res'
          call write_vline (u)
       end select
    end if
    write (u, char (ftuple_title), advance = 'no') 'ftuples'
    call write_vline (u)
    flst_title = '(A' // flst_title_format(reg_data%n_legs_born) // ')'
    write (u, char (flst_title), advance = 'no') 'flst_born'
    call write_vline (u)
    write (u, '(A7)', advance = 'no') 'i_born'
    call write_vline (u)
    write (u, '(A4)') 'corr'
    do j = 1, reg_data%n_regions
       write (u, '(I4)', advance = 'no') j
       call reg_data%regions(j)%write (u, maxnregions)
    end do
    call write_separator (u)
    if (allocated (reg_data%fks_mapping)) then
       select type (fks_mapping => reg_data%fks_mapping)
       type is (fks_mapping_resonances_t)
          write (u, '(A)')
          write (u, '(A)') &
               "The FKS regions are combined with resonance information: "
          n_res = size (fks_mapping%res_map%res_histories)
          write (u, '(A,1X,I1)') "Number of QCD resonance histories: ", n_res
          do j = 1, n_res
             write (u, '(A,1X,I1)') "i_res = ", j
             call fks_mapping%res_map%res_histories(j)%write (u)
             call write_separator (u)
          end do
       end select
    end if

  contains

    function flst_title_format (n) result (frmt)
      integer, intent(in) :: n
      type(string_t) :: frmt
      character(len=2) :: frmt_char
      write (frmt_char, '(I2)') 4 * n + 1
      frmt = var_str (frmt_char)
    end function flst_title_format

    function ftuple_title_format () result (frmt)
      type(string_t) :: frmt
      integer :: n_ftuple_char
      !!! An ftuple (x,x) consists of five characters. In the string, they
      !!! are separated by maxregions - 1 commas. In total these are
      !!! 5 * maxnregions + maxnregions - 1 = 6 * maxnregions - 1 characters.
      !!! The {} brackets at add two additional characters.
      n_ftuple_char = 6 * maxnregions + 1
      !!! If there are resonances, each ftuple with a resonance adds a ";x"
      !!! to the ftuple
      n_ftuple_char = n_ftuple_char + &
           2 * count (reg_data%regions(i_reg_max)%ftuples%i_res > 0)
      !!! Pseudo-ISR regions are denoted with a * at the end
      n_ftuple_char = n_ftuple_char + &
           count (reg_data%regions(i_reg_max)%ftuples%pseudo_isr)
      frmt = str (n_ftuple_char)
    end function ftuple_title_format

  end subroutine region_data_write

@ %def region_data_write
@
<<FKS regions: procedures>>=
  subroutine write_vline (u)
    integer, intent(in) :: u
    character(len=10), parameter :: sep_format = "(1X,A2,1X)"
    write (u, sep_format, advance = 'no') '||'
  end subroutine write_vline

@ %def write_vline
@
<<FKS regions: public>>=
  public :: assignment(=)
<<FKS regions: interfaces>>=
  interface assignment(=)
     module procedure region_data_assign
  end interface

<<FKS regions: sub interfaces>>=
    module subroutine region_data_assign (reg_data_out, reg_data_in)
      type(region_data_t), intent(out) :: reg_data_out
      type(region_data_t), intent(in) :: reg_data_in
    end subroutine region_data_assign
<<FKS regions: procedures>>=
  module subroutine region_data_assign (reg_data_out, reg_data_in)
    type(region_data_t), intent(out) :: reg_data_out
    type(region_data_t), intent(in) :: reg_data_in
    integer :: i
    if (allocated (reg_data_in%regions)) then
       allocate (reg_data_out%regions (size (reg_data_in%regions)))
       do i = 1, size (reg_data_in%regions)
          reg_data_out%regions(i) = reg_data_in%regions(i)
       end do
    else
       call msg_warning &
            ("Copying region data without allocated singular regions!")
    end if
    if (allocated (reg_data_in%flv_born)) then
       allocate (reg_data_out%flv_born (size (reg_data_in%flv_born)))
       do i = 1, size (reg_data_in%flv_born)
          reg_data_out%flv_born(i) = reg_data_in%flv_born(i)
       end do
    else
       call msg_warning &
            ("Copying region data without allocated born flavor structure!")
    end if
    if (allocated (reg_data_in%flv_real)) then
       allocate (reg_data_out%flv_real (size (reg_data_in%flv_real)))
       do i = 1, size (reg_data_in%flv_real)
          reg_data_out%flv_real(i) = reg_data_in%flv_real(i)
       end do
    else
       call msg_warning ("Copying region data without allocated real flavor structure!")
    end if
    if (allocated (reg_data_in%emitters)) then
       allocate (reg_data_out%emitters (size (reg_data_in%emitters)))
       do i = 1, size (reg_data_in%emitters)
          reg_data_out%emitters(i) = reg_data_in%emitters(i)
       end do
    else
       call msg_warning ("Copying region data without allocated emitters!")
    end if
    reg_data_out%n_regions = reg_data_in%n_regions
    reg_data_out%n_emitters = reg_data_in%n_emitters
    reg_data_out%n_flv_born = reg_data_in%n_flv_born
    reg_data_out%n_flv_real = reg_data_in%n_flv_real
    reg_data_out%n_in = reg_data_in%n_in
    reg_data_out%n_legs_born = reg_data_in%n_legs_born
    reg_data_out%n_legs_real = reg_data_in%n_legs_real
    if (allocated (reg_data_in%fks_mapping)) then
       select type (fks_mapping_in => reg_data_in%fks_mapping)
       type is (fks_mapping_default_t)
          allocate (fks_mapping_default_t :: reg_data_out%fks_mapping)
          select type (fks_mapping_out => reg_data_out%fks_mapping)
          type is (fks_mapping_default_t)
             fks_mapping_out = fks_mapping_in
          end select
       type is (fks_mapping_resonances_t)
          allocate (fks_mapping_resonances_t :: reg_data_out%fks_mapping)
          select type (fks_mapping_out => reg_data_out%fks_mapping)
          type is (fks_mapping_resonances_t)
             fks_mapping_out = fks_mapping_in
          end select
       end select
    else
       call msg_warning ("Copying region data without allocated FKS regions!")
    end if
    if (allocated (reg_data_in%resonances)) then
       allocate (reg_data_out%resonances (size (reg_data_in%resonances)))
       reg_data_out%resonances = reg_data_in%resonances
    end if
    reg_data_out%n_phs = reg_data_in%n_phs
    if (allocated (reg_data_in%alr_contributors)) then
       allocate (reg_data_out%alr_contributors (size (reg_data_in%alr_contributors)))
       reg_data_out%alr_contributors = reg_data_in%alr_contributors
    end if
    if (allocated (reg_data_in%alr_to_i_contributor)) then
       allocate (reg_data_out%alr_to_i_contributor &
          (size (reg_data_in%alr_to_i_contributor)))
       reg_data_out%alr_to_i_contributor = reg_data_in%alr_to_i_contributor
    end if
  end subroutine region_data_assign

@ %def region_data_assign
@ Returns the index of the real flavor structure an ftuple belogs to.
<<FKS regions: procedures>>=
  function region_to_real_index (list, i) result(index)
    type(ftuple_list_t), intent(in), dimension(:), allocatable :: list
    integer, intent(in) :: i
    integer, dimension(:), allocatable :: nreg
    integer :: index, j
    allocate (nreg (0))
    index = 0
    do j = 1, size (list)
       nreg = [nreg, sum (list(:j)%get_n_tuples ())]
       if (j == 1) then
          if (i <= nreg(j)) then
             index = j
             exit
          end if
       else
          if (i > nreg(j - 1) .and. i <= nreg(j)) then
             index = j
             exit
          end if
       end if
    end do
  end function region_to_real_index

@ %def region_to_real_index
@ Final state emission: Rearrange the flavor array in such a way that
the emitted particle is last and the emitter is second last. [[i1]] is
the index of the emitter, [[i2]] is the index of the emitted particle.

Initial state emission: Just put the emitted particle to the last
position.
<<FKS regions: procedures>>=
  function create_alr (flv1, n_in, i_em, i_rad) result(flv2)
    type(flv_structure_t), intent(in) :: flv1
    integer, intent(in) :: n_in
    integer, intent(in) :: i_em, i_rad
    type(flv_structure_t) :: flv2
    integer :: n
    n = size (flv1%flst)
    allocate (flv2%flst (n), flv2%tag (n))
    flv2%nlegs = n
    flv2%n_in = n_in
    if (i_em > n_in) then
       flv2%flst(1 : n_in) = flv1%flst(1 : n_in)
       flv2%flst(n - 1) = flv1%flst(i_em)
       flv2%flst(n) = flv1%flst(i_rad)
       flv2%tag(1 : n_in) = flv1%tag(1 : n_in)
       flv2%tag(n - 1) = flv1%tag(i_em)
       flv2%tag(n) = flv1%tag(i_rad)
       call fill_remaining_flavors (n_in, .true.)
    else
       flv2%flst(1 : n_in) = flv1%flst(1 : n_in)
       flv2%flst(n) = flv1%flst(i_rad)
       flv2%tag(1 : n_in) = flv1%tag(1 : n_in)
       flv2%tag(n) = flv1%tag(i_rad)
       call fill_remaining_flavors (n_in, .false.)
    end if
    call flv2%compute_prt_symm_fs (flv2%n_in)
  contains
@ Order remaining particles according to their original position
<<FKS regions: procedures>>=
    subroutine fill_remaining_flavors (n_in, final_final)
      integer, intent(in) :: n_in
      logical, intent(in) :: final_final
      integer :: i, j
      logical :: check
      j = n_in + 1
      do i = n_in + 1, n
         if (final_final) then
            check = (i /= i_em .and. i /= i_rad)
         else
            check = (i /= i_rad)
         end if
         if (check) then
            flv2%flst(j) = flv1%flst(i)
            flv2%tag(j) = flv1%tag(i)
            j = j + 1
         end if
      end do
    end subroutine fill_remaining_flavors
  end function create_alr

@ %def create_alr
@
<<FKS regions: reg data: TBP>>=
  procedure :: has_pseudo_isr => region_data_has_pseudo_isr
<<FKS regions: sub interfaces>>=
    module function region_data_has_pseudo_isr (reg_data) result (flag)
      logical :: flag
      class(region_data_t), intent(in) :: reg_data
    end function region_data_has_pseudo_isr
<<FKS regions: procedures>>=
  module function region_data_has_pseudo_isr (reg_data) result (flag)
    logical :: flag
    class(region_data_t), intent(in) :: reg_data
    flag = any (reg_data%regions%pseudo_isr)
  end function region_data_has_pseudo_isr

@ %def region_data_has_pseudo_isr
@ Performs consistency checks on [[region_data]]. Up to now only
checks that no [[ftuple]] appears more than once.
<<FKS regions: reg data: TBP>>=
  procedure :: check_consistency => region_data_check_consistency
<<FKS regions: sub interfaces>>=
    module subroutine region_data_check_consistency (reg_data, fail_fatal, unit)
      class(region_data_t), intent(in) :: reg_data
      logical, intent(in) :: fail_fatal
      integer, intent(in), optional :: unit
    end subroutine region_data_check_consistency
<<FKS regions: procedures>>=
  module subroutine region_data_check_consistency (reg_data, fail_fatal, unit)
    class(region_data_t), intent(in) :: reg_data
    logical, intent(in) :: fail_fatal
    integer, intent(in), optional :: unit
    integer :: u
    integer :: i_reg, alr
    integer :: i1, f1, f2
    logical :: undefined_ftuples, same_ftuple_indices, valid_splitting
    logical, dimension(4) :: no_fail
    u = given_output_unit(unit); if (u < 0) return
    no_fail = .true.
    call msg_message ("Check that no negative ftuple indices occur", unit = u)
    do i_reg = 1, reg_data%n_regions
       if (any (reg_data%regions(i_reg)%ftuples%has_negative_elements ())) then
          !!! This error is so severe that we stop immediately
          call msg_fatal ("Negative ftuple indices!")
       end if
    end do
    call msg_message ("Success!", unit = u)
    call msg_message ("Check that there is no ftuple with identical elements", unit = u)
    do i_reg = 1, reg_data%n_regions
       if (any (reg_data%regions(i_reg)%ftuples%has_identical_elements ())) then
          !!! This error is so severe that we stop immediately
          call msg_fatal ("Identical ftuple indices!")
       end if
    end do
    call msg_message ("Success!", unit = u)
    call msg_message ("Check that there are no duplicate ftuples in a region", unit = u)
    do i_reg = 1, reg_data%n_regions
       if (reg_data%regions(i_reg)%has_identical_ftuples ()) then
          if (no_fail(1)) then
             call msg_error ("FAIL: ", unit = u)
             no_fail(1) = .false.
          end if
          write (u, '(A,1x,I3)') 'i_reg:', i_reg
       end if
    end do
    if (no_fail(1)) call msg_message ("Success!", unit = u)
    call msg_message ("Check that ftuples add up to a valid splitting", unit = u)
    do i_reg = 1, reg_data%n_regions
       do alr = 1, reg_data%regions(i_reg)%nregions
          associate (region => reg_data%regions(i_reg))
             i1 = region%ftuples(alr)%ireg(1)
             if (i1 == 0) i1 = 1 !!! Gluon emission from both initial-state particles
             f1 = region%flst_real%flst(i1)
             f2 = region%flst_real%flst(region%ftuples(alr)%ireg(2))
             ! Flip PDG sign of IS fermions to allow a q -> g q splitting
             ! in which the ftuple has the flavors (q,q).
             if (i1 <= reg_data%n_in .and. is_fermion(f1)) then
                f1 = -f1
             end if
             valid_splitting = f1 + f2 == 0 &
                  .or. (is_gluon(f1) .and. is_gluon(f2)) &
                  .or. (is_massive_vector(f1) .and. is_photon(f2)) &
                  .or. is_fermion_vector_splitting (f1, f2)
             if (.not. valid_splitting) then
                if (no_fail(2)) then
                   call msg_error ("FAIL: ", unit = u)
                   no_fail(2) = .false.
                end if
                write (u, '(A,1x,I3)') 'i_reg:', i_reg
                exit
             end if
          end associate
       end do
    end do
    if (no_fail(2)) call msg_message ("Success!", unit = u)
    call msg_message ("Check that at least one ftuple contains the emitter", unit = u)
    do i_reg = 1, reg_data%n_regions
       associate (region => reg_data%regions(i_reg))
          if (.not. any (region%emitter == region%ftuples%ireg(1))) then
             if (no_fail(3)) then
                call msg_error ("FAIL: ", unit = u)
                no_fail(3) = .false.
             end if
             write (u, '(A,1x,I3)') 'i_reg:', i_reg
          end if
       end associate
    end do
    if (no_fail(3)) call msg_message ("Success!", unit = u)
    call msg_message ("Check that each region has at least one ftuple &
         &with index n + 1", unit = u)
    do i_reg = 1, reg_data%n_regions
       if (.not. any (reg_data%regions(i_reg)%ftuples%ireg(2) == reg_data%n_legs_real)) then
          if (no_fail(4)) then
             call msg_error ("FAIL: ", unit = u)
             no_fail(4) = .false.
          end if
          write (u, '(A,1x,I3)') 'i_reg:', i_reg
       end if
    end do
    if (no_fail(4)) call msg_message ("Success!", unit = u)
    if (.not. all (no_fail)) &
         call abort_with_message ("Stop due to inconsistent region data!")

  contains
    subroutine abort_with_message (msg)
      character(len=*), intent(in) :: msg
      if (fail_fatal) then
         call msg_fatal (msg)
      else
         call msg_error (msg, unit = u)
      end if
    end subroutine abort_with_message

    function is_fermion_vector_splitting (pdg_1, pdg_2) result (value)
      logical :: value
      integer, intent(in) :: pdg_1, pdg_2
      value = (is_fermion (pdg_1) .and. is_massless_vector (pdg_2)) .or. &
           (is_fermion (pdg_2) .and. is_massless_vector (pdg_1))
    end function
  end subroutine region_data_check_consistency

@ %def region_data_check_consistency
@
<<FKS regions: reg data: TBP>>=
  procedure :: requires_spin_correlations => &
       region_data_requires_spin_correlations
<<FKS regions: sub interfaces>>=
    module function region_data_requires_spin_correlations &
         (reg_data) result (flag)
      class(region_data_t), intent(in) :: reg_data
      logical :: flag
    end function region_data_requires_spin_correlations
<<FKS regions: procedures>>=
  module function region_data_requires_spin_correlations &
       (reg_data) result (flag)
    class(region_data_t), intent(in) :: reg_data
    logical :: flag
    integer :: alr
    flag = .false.
    do alr = 1, reg_data%n_regions
       flag = reg_data%regions(alr)%sc_required
       if (flag) return
    end do
  end function region_data_requires_spin_correlations

@ %def region_data_requires_spin_correlations
@ We have to apply the symmetry factor for identical particles of the
real flavor structure to the born squared matrix element. The corresponding
factor from the born flavor structure has to be cancelled.
<<FKS regions: reg data: TBP>>=
  procedure :: born_to_real_symm_factor_fs => &
       region_data_born_to_real_symm_factor_fs
<<FKS regions: sub interfaces>>=
    module function region_data_born_to_real_symm_factor_fs &
         (reg_data, alr) result (factor)
      class(region_data_t), intent(in) :: reg_data
      integer, intent(in) :: alr
      real(default) :: factor
    end function region_data_born_to_real_symm_factor_fs
<<FKS regions: procedures>>=
  module function region_data_born_to_real_symm_factor_fs &
       (reg_data, alr) result (factor)
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: alr
    real(default) :: factor
    associate (flv_real => reg_data%regions(alr)%flst_real, &
            flv_uborn => reg_data%regions(alr)%flst_uborn)
       factor = flv_real%prt_symm_fs / flv_uborn%prt_symm_fs
    end associate
  end function region_data_born_to_real_symm_factor_fs

@ %def region_data_born_to_real_symm_factor_fs
@
<<FKS regions: reg data: TBP>>=
  procedure :: final => region_data_final
<<FKS regions: sub interfaces>>=
    module subroutine region_data_final (reg_data)
      class(region_data_t), intent(inout) :: reg_data
    end subroutine region_data_final
<<FKS regions: procedures>>=
  module subroutine region_data_final (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    if (allocated (reg_data%regions)) deallocate (reg_data%regions)
    if (allocated (reg_data%flv_born)) deallocate (reg_data%flv_born)
    if (allocated (reg_data%flv_real)) deallocate (reg_data%flv_real)
    if (allocated (reg_data%emitters)) deallocate (reg_data%emitters)
    if (allocated (reg_data%fks_mapping)) deallocate (reg_data%fks_mapping)
    if (allocated (reg_data%resonances)) deallocate (reg_data%resonances)
    if (allocated (reg_data%alr_contributors)) &
         deallocate (reg_data%alr_contributors)
    if (allocated (reg_data%alr_to_i_contributor)) &
         deallocate (reg_data%alr_to_i_contributor)
  end subroutine region_data_final

@ %def region_data_final
@
<<FKS regions: fks mapping: TBP>>=
  procedure (fks_mapping_dij), deferred :: dij
<<FKS regions: interfaces>>=
  abstract interface
    function fks_mapping_dij (map, p, i, j, i_con) result (d)
      import
      real(default) :: d
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: i, j
      integer, intent(in), optional :: i_con
    end function fks_mapping_dij
  end interface

@ %def fks_mapping_dij
@
<<FKS regions: fks mapping: TBP>>=
  procedure (fks_mapping_compute_sumdij), deferred :: compute_sumdij
<<FKS regions: interfaces>>=
  abstract interface
    subroutine fks_mapping_compute_sumdij (map, sregion, p_real)
      import
      class(fks_mapping_t), intent(inout) :: map
      type(singular_region_t), intent(in) :: sregion
      type(vector4_t), intent(in), dimension(:) :: p_real
    end subroutine fks_mapping_compute_sumdij
  end interface

@ %def fks_mapping_compute_sumdij
@
<<FKS regions: fks mapping: TBP>>=
  procedure (fks_mapping_svalue), deferred :: svalue
<<FKS regions: interfaces>>=
  abstract interface
    function fks_mapping_svalue (map, p, i, j, i_res) result (value)
      import
      real(default) :: value
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: i, j
      integer, intent(in), optional :: i_res
    end function fks_mapping_svalue
  end interface

@ %def fks_mapping_svalue
<<FKS regions: fks mapping: TBP>>=
  procedure (fks_mapping_dij_soft), deferred :: dij_soft
<<FKS regions: interfaces>>=
  abstract interface
    function fks_mapping_dij_soft (map, p_born, p_soft, em, i_con) result (d)
      import
      real(default) :: d
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: em
      integer, intent(in), optional :: i_con
    end function fks_mapping_dij_soft
  end interface

@ %def fks_mapping_dij_soft
@
<<FKS regions: fks mapping: TBP>>=
  procedure (fks_mapping_compute_sumdij_soft), deferred :: compute_sumdij_soft
<<FKS regions: interfaces>>=
  abstract interface
    subroutine fks_mapping_compute_sumdij_soft (map, sregion, p_born, p_soft)
      import
      class(fks_mapping_t), intent(inout) :: map
      type(singular_region_t), intent(in) :: sregion
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
    end subroutine fks_mapping_compute_sumdij_soft
  end interface
@ %def fks_mapping_compute_sumdij_soft
@
<<FKS regions: fks mapping: TBP>>=
  procedure (fks_mapping_svalue_soft), deferred :: svalue_soft
<<FKS regions: interfaces>>=
  abstract interface
    function fks_mapping_svalue_soft (map, p_born, p_soft, em, i_res) result (value)
      import
      real(default) :: value
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: em
      integer, intent(in), optional :: i_res
    end function fks_mapping_svalue_soft
  end interface

@ %def fks_mapping_svalue_soft
@
<<FKS regions: fks mapping default: TBP>>=
  procedure :: set_parameter => fks_mapping_default_set_parameter
<<FKS regions: sub interfaces>>=
    module subroutine fks_mapping_default_set_parameter &
         (map, n_in, dij_exp1, dij_exp2)
      class(fks_mapping_default_t), intent(inout) :: map
      integer, intent(in) :: n_in
      real(default), intent(in) :: dij_exp1, dij_exp2
    end subroutine fks_mapping_default_set_parameter
<<FKS regions: procedures>>=
  module subroutine fks_mapping_default_set_parameter &
       (map, n_in, dij_exp1, dij_exp2)
    class(fks_mapping_default_t), intent(inout) :: map
    integer, intent(in) :: n_in
    real(default), intent(in) :: dij_exp1, dij_exp2
    map%n_in = n_in
    map%exp_1 = dij_exp1
    map%exp_2 = dij_exp2
  end subroutine fks_mapping_default_set_parameter

@ %def fks_mapping_default_set_parameter
@ Computes the $d_{ij}$-quantities defined als follows:
\begin{align*}
  d_{0i} &= \left[E_i^2\left(1-y_i\right)\right]^{p_2}\\,
  d_{1i} &= \left[2E_i^2\left(1-y_i\right)\right]^{p_2}\\,
  d_{2i} &= \left[2E_i^2\left(1+y_i\right)\right]^{p_2}\\,
\end{align*}
for initial state regions and
\begin{align*}
  d_{ij} = \left[2(k_i \cdot k_j) \frac{E_i E_j}{(E_i+E_j)^2}\right]^{p_1}
\end{align*}
for final state regions, c.f. [1002.2581, Eq. 4.23f].
The exponents $p_1$ and $p_2$ can be used for
tuning the efficiency of the mapping and are set to $1$ per default.
<<FKS regions: fks mapping default: TBP>>=
  procedure :: dij => fks_mapping_default_dij
<<FKS regions: sub interfaces>>=
    module function fks_mapping_default_dij (map, p, i, j, i_con) result (d)
      real(default) :: d
      class(fks_mapping_default_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: i, j
      integer, intent(in), optional :: i_con
    end function fks_mapping_default_dij
<<FKS regions: procedures>>=
  module function fks_mapping_default_dij (map, p, i, j, i_con) result (d)
    real(default) :: d
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    integer, intent(in), optional :: i_con
    d = zero
    if (map%pseudo_isr) then
       d = dij_threshold_gluon_from_top (i, j, p, map%exp_1)
    else if (i > map%n_in .and. j > map%n_in) then
       d = dij_fsr (p(i), p(j), map%exp_1)
    else
       d = dij_isr (map%n_in, i, j, p, map%exp_2)
    end if
  contains

    function dij_fsr (p1, p2, expo) result (d_ij)
      real(default) :: d_ij
      type(vector4_t), intent(in) :: p1, p2
      real(default), intent(in) :: expo
      real(default) :: E1, E2
      E1 = p1%p(0); E2 = p2%p(0)
      d_ij = (two * p1 * p2 * E1 * E2 / (E1 + E2)**2)**expo
    end function dij_fsr

    function dij_threshold_gluon_from_top (i, j, p, expo) result (d_ij)
      real(default) :: d_ij
      integer, intent(in) :: i, j
      type(vector4_t), intent(in), dimension(:) :: p
      real(default), intent(in) :: expo
      type(vector4_t) :: p_top
      if (i == THR_POS_B) then
         p_top = p(THR_POS_WP) + p(THR_POS_B)
      else
         p_top = p(THR_POS_WM) + p(THR_POS_BBAR)
      end if
      d_ij = dij_fsr (p_top, p(j), expo)
    end function dij_threshold_gluon_from_top

    function dij_isr (n_in, i, j, p, expo) result (d_ij)
      real(default) :: d_ij
      integer, intent(in) :: n_in, i, j
      type(vector4_t), intent(in), dimension(:) :: p
      real(default), intent(in) :: expo
      real(default) :: E, y
      select case (n_in)
      case (1)
         call get_emitter_variables (1, i, j, p, E, y)
         d_ij = (E**2 * (one - y**2))**expo
      case (2)
         if ((i == 0 .and. j > 2) .or. (j == 0 .and. i > 2)) then
            call get_emitter_variables (0, i, j, p, E, y)
            d_ij = (E**2 * (one - y**2))**expo
         else if ((i == 1 .and. j > 2) .or. (j == 1 .and. i > 2)) then
            call get_emitter_variables (1, i, j, p, E, y)
            d_ij = (two * E**2 * (one - y))**expo
         else if ((i == 2 .and. j > 2) .or. (j == 2 .and. i > 2)) then
            call get_emitter_variables (2, i, j, p, E, y)
            d_ij = (two * E**2 * (one + y))**expo
         end if
      end select
    end function dij_isr

    subroutine get_emitter_variables (i_check, i, j, p, E, y)
       integer, intent(in) :: i_check, i, j
       type(vector4_t), intent(in), dimension(:) :: p
       real(default), intent(out) :: E, y
       if (j == i_check) then
           E = energy (p(i))
           y = polar_angle_ct (p(i))
       else
           E = energy (p(j))
           y = polar_angle_ct(p(j))
       end if
    end subroutine get_emitter_variables

  end function fks_mapping_default_dij

@  %def fks_mapping_default_dij
@ Computes the quantity
\begin{equation*}
  \mathcal{D} = \sum_k \frac{1}{d_{0k}} + \sum_{kl} \frac{1}{d_{kl}}.
\end{equation*}
where the sum goes over all ftuples of a single singular region.
<<FKS regions: fks mapping default: TBP>>=
  procedure :: compute_sumdij => fks_mapping_default_compute_sumdij
<<FKS regions: sub interfaces>>=
    module subroutine fks_mapping_default_compute_sumdij (map, sregion, p_real)
      class(fks_mapping_default_t), intent(inout) :: map
      type(singular_region_t), intent(in) :: sregion
      type(vector4_t), intent(in), dimension(:) :: p_real
    end subroutine fks_mapping_default_compute_sumdij
<<FKS regions: procedures>>=
  module subroutine fks_mapping_default_compute_sumdij (map, sregion, p_real)
    class(fks_mapping_default_t), intent(inout) :: map
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_real
    real(default) :: d
    integer :: i_ftuple, i, j

    associate (ftuples => sregion%ftuples)
      d = zero
      do i_ftuple = 1, sregion%nregions
         call ftuples(i_ftuple)%get (i, j)
         map%pseudo_isr = ftuples(i_ftuple)%pseudo_isr
         d = d + one / map%dij (p_real, i, j)
      end do
    end associate
    map%sumdij = d
  end subroutine fks_mapping_default_compute_sumdij

@ %def fks_mapping_default_compute_sumdij
@ Computes
\begin{equation*}
  S_i = \frac{1}{\mathcal{D} d_{0i}}
\end{equation*}
or
\begin{equation*}
  S_{ij} = \frac{1}{\mathcal{D} d_{ij}},
\end{equation*}
respectively.
<<FKS regions: fks mapping default: TBP>>=
  procedure :: svalue => fks_mapping_default_svalue
<<FKS regions: sub interfaces>>=
    module function fks_mapping_default_svalue &
         (map, p, i, j, i_res) result (value)
      real(default) :: value
      class(fks_mapping_default_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: i, j
      integer, intent(in), optional :: i_res
    end function fks_mapping_default_svalue
<<FKS regions: procedures>>=
  module function fks_mapping_default_svalue &
       (map, p, i, j, i_res) result (value)
    real(default) :: value
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    integer, intent(in), optional :: i_res
    value = one / (map%dij (p, i, j) * map%sumdij)
  end function fks_mapping_default_svalue

@ %def fks_mapping_default_svalue
@ In the soft limit, our treatment of the divergencies requires a
modification of the mapping functions. Recall that there, the ratios of
the $d$-functions must approach either $1$ or $0$. This means
\begin{equation*}
  \frac{d_{lm}}{d_{0m}} = \frac{(2k_l \cdot k_m) \left[E_lE_m /(E_l +
      E_m)^2\right]}{E_m^2 (1-y^2)}
    \overset {k_m = E_m \hat{k}} {=} \frac{E_l E_m^2}{(E_l + E_m)^2}
    \frac{2k_l \cdot \hat{k}}{E_m^2 (1-y^2)}
    \overset {E_m \to 0}{=} \frac{2k_l \cdot \hat{k}}{E_l}{(1-y^2)},
\end{equation*}
where we have written the gluon momentum in terms of the soft momentum
$\hat{k}$. In the same limit
\begin{equation*}
  \frac{d_{lm}}{d_{nm}} = \frac{k_l \cdot \hat{k}}{k_n \cdot \hat{k}}
  \frac{E_n}{E_l}.
\end{equation*}
From these equations we can deduce the soft limit of $d$:
\begin{align*}
  d_0^{\rm{soft}} &= 1 - y^2,\\
  d_1^{\rm{soft}} &= 2(1-y),\\
  d_2^{\rm{soft}} &= 2(1+y),\\
  d_i^{\rm{soft}} &= \frac{2 k_i \cdot \hat{k}}{E_i}.
\end{align*}
<<FKS regions: fks mapping default: TBP>>=
  procedure :: dij_soft => fks_mapping_default_dij_soft
<<FKS regions: sub interfaces>>=
    module function fks_mapping_default_dij_soft &
         (map, p_born, p_soft, em, i_con) result (d)
      real(default) :: d
      class(fks_mapping_default_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: em
      integer, intent(in), optional :: i_con
    end function fks_mapping_default_dij_soft
<<FKS regions: procedures>>=
  module function fks_mapping_default_dij_soft &
       (map, p_born, p_soft, em, i_con) result (d)
    real(default) :: d
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: em
    integer, intent(in), optional :: i_con
    if (map%pseudo_isr) then
       d = dij_soft_threshold_gluon_from_top (em, p_born, p_soft, map%exp_1)
    else if (em <= map%n_in) then
       d = dij_soft_isr (map%n_in, p_soft, map%exp_2)
    else
       d = dij_soft_fsr (p_born(em), p_soft, map%exp_1)
    end if
  contains

    function dij_soft_threshold_gluon_from_top &
         (em, p_born, p_soft, expo) result (dij_soft)
      real(default) :: dij_soft
      integer, intent(in) :: em
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      real(default), intent(in) :: expo
      type(vector4_t) :: p_top
      if (em == THR_POS_B) then
         p_top = p_born(THR_POS_WP) + p_born(THR_POS_B)
      else
         p_top = p_born(THR_POS_WM) + p_born(THR_POS_BBAR)
      end if
      dij_soft = dij_soft_fsr (p_top, p_soft, expo)
    end function dij_soft_threshold_gluon_from_top

    function dij_soft_fsr (p_em, p_soft, expo) result (dij_soft)
      real(default) :: dij_soft
      type(vector4_t), intent(in) :: p_em, p_soft
      real(default), intent(in) :: expo
      dij_soft = (two * p_em * p_soft / p_em%p(0))**expo
    end function dij_soft_fsr

    function dij_soft_isr (n_in, p_soft, expo) result (dij_soft)
       real(default) :: dij_soft
       integer, intent(in) :: n_in
       type(vector4_t), intent(in) :: p_soft
       real(default), intent(in) :: expo
       real(default) :: y
       y = polar_angle_ct (p_soft)
       select case (n_in)
       case (1)
          dij_soft = one - y**2
       case (2)
          select case (em)
          case (0)
             dij_soft = one - y**2
          case (1)
             dij_soft = two * (one - y)
          case (2)
             dij_soft = two * (one + y)
          case default
             dij_soft = zero
             call msg_fatal ("fks_mappings_default_dij_soft: n_in > 2")
          end select
       case default
          dij_soft = zero
          call msg_fatal ("fks_mappings_default_dij_soft: n_in > 2")
       end select
       dij_soft = dij_soft**expo
    end function dij_soft_isr
  end function fks_mapping_default_dij_soft

@ %def fks_mapping_default_dij_soft
@ Computes the sum of all soft [[dij]]s required to normalize the soft
$S$ functions [[s_alpha_soft]] similar to
[[fks_mapping_default_compute_sumdij]].  In the soft limit however, we
need to skip all ftuples $(i,j)$ in which $j$ does not correspond to
the emitted particle because those $d_{ij}$s are finite and thus their
contribution to the soft S function vanishes in the limit of soft
radiation. Technically, they would not vanish if computed here because
the fixed [[p_soft]] at this point would not fit their actual
emitter.
<<FKS regions: fks mapping default: TBP>>=
  procedure :: compute_sumdij_soft => fks_mapping_default_compute_sumdij_soft
<<FKS regions: sub interfaces>>=
    module subroutine fks_mapping_default_compute_sumdij_soft &
         (map, sregion, p_born, p_soft)
      class(fks_mapping_default_t), intent(inout) :: map
      type(singular_region_t), intent(in) :: sregion
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
    end subroutine fks_mapping_default_compute_sumdij_soft
<<FKS regions: procedures>>=
  module subroutine fks_mapping_default_compute_sumdij_soft &
       (map, sregion, p_born, p_soft)
    class(fks_mapping_default_t), intent(inout) :: map
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    real(default) :: d
    integer :: i_ftuple, i, j
    integer :: nlegs
    d = zero
    nlegs = size (sregion%flst_real%flst)
    associate (ftuples => sregion%ftuples)
      do i_ftuple = 1, sregion%nregions
         call ftuples(i_ftuple)%get (i ,j)
         if (j == nlegs) then
            map%pseudo_isr = ftuples(i_ftuple)%pseudo_isr
            d = d + one / map%dij_soft (p_born, p_soft, i)
         end if
      end do
    end associate
    map%sumdij_soft = d
  end subroutine fks_mapping_default_compute_sumdij_soft

@ %def fks_mapping_default_compute_sumdij_soft
@
<<FKS regions: fks mapping default: TBP>>=
  procedure :: svalue_soft => fks_mapping_default_svalue_soft
<<FKS regions: sub interfaces>>=
    module function fks_mapping_default_svalue_soft &
         (map, p_born, p_soft, em, i_res) result (value)
      real(default) :: value
      class(fks_mapping_default_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: em
      integer, intent(in), optional :: i_res
    end function fks_mapping_default_svalue_soft
<<FKS regions: procedures>>=
  module function fks_mapping_default_svalue_soft &
       (map, p_born, p_soft, em, i_res) result (value)
    real(default) :: value
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: em
    integer, intent(in), optional :: i_res
    value = one / (map%sumdij_soft * map%dij_soft (p_born, p_soft, em))
  end function fks_mapping_default_svalue_soft

@ %def fks_mapping_default_svalue_soft
@
<<FKS regions: interfaces>>=
  interface assignment(=)
     module procedure fks_mapping_default_assign
  end interface

<<FKS regions: sub interfaces>>=
    module subroutine fks_mapping_default_assign (fks_map_out, fks_map_in)
      type(fks_mapping_default_t), intent(out) :: fks_map_out
      type(fks_mapping_default_t), intent(in) :: fks_map_in
    end subroutine fks_mapping_default_assign
<<FKS regions: procedures>>=
  module subroutine fks_mapping_default_assign (fks_map_out, fks_map_in)
    type(fks_mapping_default_t), intent(out) :: fks_map_out
    type(fks_mapping_default_t), intent(in) :: fks_map_in
    fks_map_out%exp_1 = fks_map_in%exp_1
    fks_map_out%exp_2 = fks_map_in%exp_2
    fks_map_out%n_in = fks_map_in%n_in
  end subroutine fks_mapping_default_assign

@ %def fks_mapping_default_assign
@ The $d_{ij,k}$-functions for the resonance mapping are basically the same
as in the default case, but the kinematical values here must be evaluated
in the resonance frame of reference. The energy of parton $i$ in a given
resonance frame with momentum $p_{res}$ is
\begin{equation*}
   E_i = \frac{p_i^0 \cdot p_{res}}{m_{res}}.
\end{equation*}
However, since the expressions only depend on ratios of four-momenta, we
leave out the denominator because it will cancel out anyway.
<<FKS regions: fks mapping resonances: TBP>>=
  procedure :: dij => fks_mapping_resonances_dij
<<FKS regions: sub interfaces>>=
    module function fks_mapping_resonances_dij (map, p, i, j, i_con) result (d)
      real(default) :: d
      class(fks_mapping_resonances_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: i, j
      integer, intent(in), optional :: i_con
    end function fks_mapping_resonances_dij
<<FKS regions: procedures>>=
  module function fks_mapping_resonances_dij (map, p, i, j, i_con) result (d)
    real(default) :: d
    class(fks_mapping_resonances_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    integer, intent(in), optional :: i_con
    real(default) :: E1, E2
    integer :: ii_con
    if (present (i_con)) then
       ii_con = i_con
    else
       call msg_fatal ("Resonance mappings require resonance index as input!")
    end if
    d = 0
    if (i /= j) then
       if (i > 2 .and. j > 2) then
          associate (p_res => map%res_map%p_res (ii_con))
             E1 = p(i) * p_res
             E2 = p(j) * p_res
             d = two * p(i) * p(j) * E1 * E2 / (E1 + E2)**2
          end associate
       else
          call msg_fatal ("Resonance mappings are not implemented for ISR")
       end if
    end if
  end function fks_mapping_resonances_dij

@ %def fks_mapping_resonances_dij
@ Computes
\begin{equation*}
  S_\alpha = \frac{P^{f_r(\alpha)}d^{-1}(\alpha)}
  {\sum_{f_r' \in T(F_r(\alpha))}P^{f_r'}\sum_{\alpha' \in Sr(f_r')}d^{-1}(\alpha)}.
\end{equation*}
<<FKS regions: fks mapping resonances: TBP>>=
  procedure :: compute_sumdij => fks_mapping_resonances_compute_sumdij
<<FKS regions: sub interfaces>>=
    module subroutine fks_mapping_resonances_compute_sumdij &
         (map, sregion, p_real)
      class(fks_mapping_resonances_t), intent(inout) :: map
      type(singular_region_t), intent(in) :: sregion
      type(vector4_t), intent(in), dimension(:) :: p_real
    end subroutine fks_mapping_resonances_compute_sumdij
<<FKS regions: procedures>>=
  module subroutine fks_mapping_resonances_compute_sumdij (map, sregion, p_real)
    class(fks_mapping_resonances_t), intent(inout) :: map
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_real
    real(default) :: d, pfr
    integer :: i_res, i_reg, i, j, i_con
    integer :: nlegreal

    nlegreal = size (p_real)
    d = zero
    do i_reg = 1, sregion%nregions
       associate (ftuple => sregion%ftuples(i_reg))
          call ftuple%get (i, j)
          i_res = ftuple%i_res
       end associate
       pfr = map%res_map%get_resonance_value (i_res, p_real, nlegreal)
       i_con = sregion%i_reg_to_i_con (i_reg)
       d = d + pfr / map%dij (p_real, i, j, i_con)
    end do
    map%sumdij = d
  end subroutine fks_mapping_resonances_compute_sumdij

@ %def fks_mapping_resonances_compute_sumdij
@
<<FKS regions: fks mapping resonances: TBP>>=
  procedure :: svalue => fks_mapping_resonances_svalue
<<FKS regions: sub interfaces>>=
    module function fks_mapping_resonances_svalue &
         (map, p, i, j, i_res) result (value)
      real(default) :: value
      class(fks_mapping_resonances_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: i, j
      integer, intent(in), optional :: i_res
    end function fks_mapping_resonances_svalue
<<FKS regions: procedures>>=
  module function fks_mapping_resonances_svalue &
       (map, p, i, j, i_res) result (value)
    real(default) :: value
    class(fks_mapping_resonances_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    integer, intent(in), optional :: i_res
    real(default) :: pfr
    integer :: i_gluon
    i_gluon = size (p)
    pfr = map%res_map%get_resonance_value (i_res, p, i_gluon)
    value = pfr / (map%dij (p, i, j, map%i_con) * map%sumdij)
  end function fks_mapping_resonances_svalue

@ %def fks_mapping_resonances_svalue
@
<<FKS regions: fks mapping resonances: TBP>>=
  procedure :: get_resonance_weight => &
       fks_mapping_resonances_get_resonance_weight
<<FKS regions: sub interfaces>>=
    module function fks_mapping_resonances_get_resonance_weight &
         (map, alr, p) result (pfr)
      real(default) :: pfr
      class(fks_mapping_resonances_t), intent(in) :: map
      integer, intent(in) :: alr
      type(vector4_t), intent(in), dimension(:) :: p
    end function fks_mapping_resonances_get_resonance_weight
<<FKS regions: procedures>>=
  module function fks_mapping_resonances_get_resonance_weight &
       (map, alr, p) result (pfr)
    real(default) :: pfr
    class(fks_mapping_resonances_t), intent(in) :: map
    integer, intent(in) :: alr
    type(vector4_t), intent(in), dimension(:) :: p
    pfr = map%res_map%get_weight (alr, p)
  end function fks_mapping_resonances_get_resonance_weight

@ %def fks_mapping_resonances_get_resonance_weight
@ As above, the soft limit of $d_{ij,k}$ must be computed in the resonance frame of
reference.
<<FKS regions: fks mapping resonances: TBP>>=
  procedure :: dij_soft => fks_mapping_resonances_dij_soft
<<FKS regions: sub interfaces>>=
    module function fks_mapping_resonances_dij_soft &
         (map, p_born, p_soft, em, i_con) result (d)
      real(default) :: d
      class(fks_mapping_resonances_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: em
      integer, intent(in), optional :: i_con
    end function fks_mapping_resonances_dij_soft
<<FKS regions: procedures>>=
  module function fks_mapping_resonances_dij_soft &
       (map, p_born, p_soft, em, i_con) result (d)
    real(default) :: d
    class(fks_mapping_resonances_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: em
    integer, intent(in), optional :: i_con
    real(default) :: E1, E2
    integer :: ii_con
    type(vector4_t) :: pb
    if (present (i_con)) then
       ii_con = i_con
    else
       call msg_fatal ("fks_mapping_resonances requires resonance index")
    end if
    associate (p_res => map%res_map%p_res(ii_con))
      pb = p_born(em)
      E1 = pb * p_res
      E2 = p_soft * p_res
      d = two * pb * p_soft * E1 * E2 / E1**2
    end associate
  end function fks_mapping_resonances_dij_soft

@ %def fks_mapping_resonances_dij_soft
@
<<FKS regions: fks mapping resonances: TBP>>=
  procedure :: compute_sumdij_soft => fks_mapping_resonances_compute_sumdij_soft
<<FKS regions: sub interfaces>>=
    module subroutine fks_mapping_resonances_compute_sumdij_soft &
         (map, sregion, p_born, p_soft)
      class(fks_mapping_resonances_t), intent(inout) :: map
      type(singular_region_t), intent(in) :: sregion
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
    end subroutine fks_mapping_resonances_compute_sumdij_soft
<<FKS regions: procedures>>=
  module subroutine fks_mapping_resonances_compute_sumdij_soft &
       (map, sregion, p_born, p_soft)
    class(fks_mapping_resonances_t), intent(inout) :: map
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    real(default) :: d
    real(default) :: pfr
    integer :: i_res, i, j, i_reg, i_con
    integer :: nlegs

    d = zero
    nlegs = size (sregion%flst_real%flst)
    do i_reg = 1, sregion%nregions
       associate (ftuple => sregion%ftuples(i_reg))
          call ftuple%get(i, j)
          i_res = ftuple%i_res
       end associate
       pfr = map%res_map%get_resonance_value (i_res, p_born)
       i_con = sregion%i_reg_to_i_con (i_reg)
       if (j == nlegs) d = d + pfr / map%dij_soft (p_born, p_soft, i, i_con)
    end do
    map%sumdij_soft = d
  end subroutine fks_mapping_resonances_compute_sumdij_soft

@ %def fks_mapping_resonances_ompute_sumdij_soft
@
<<FKS regions: fks mapping resonances: TBP>>=
  procedure :: svalue_soft => fks_mapping_resonances_svalue_soft
<<FKS regions: sub interfaces>>=
    module function fks_mapping_resonances_svalue_soft &
         (map, p_born, p_soft, em, i_res) result (value)
      real(default) :: value
      class(fks_mapping_resonances_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: em
      integer, intent(in), optional :: i_res
    end function fks_mapping_resonances_svalue_soft
<<FKS regions: procedures>>=
  module function fks_mapping_resonances_svalue_soft &
       (map, p_born, p_soft, em, i_res) result (value)
    real(default) :: value
    class(fks_mapping_resonances_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: em
    integer, intent(in), optional :: i_res
    real(default) :: pfr
    pfr = map%res_map%get_resonance_value (i_res, p_born)
    value = pfr / (map%sumdij_soft * map%dij_soft &
         (p_born, p_soft, em, map%i_con))
  end function fks_mapping_resonances_svalue_soft

@ %def fks_mapping_resonances_svalue_soft
@
<<FKS regions: fks mapping resonances: TBP>>=
  procedure :: set_resonance_momentum => &
       fks_mapping_resonances_set_resonance_momentum
<<FKS regions: sub interfaces>>=
    module subroutine fks_mapping_resonances_set_resonance_momentum (map, p)
      class(fks_mapping_resonances_t), intent(inout) :: map
      type(vector4_t), intent(in) :: p
    end subroutine fks_mapping_resonances_set_resonance_momentum
<<FKS regions: procedures>>=
  module subroutine fks_mapping_resonances_set_resonance_momentum (map, p)
    class(fks_mapping_resonances_t), intent(inout) :: map
    type(vector4_t), intent(in) :: p
    map%res_map%p_res = p
  end subroutine fks_mapping_resonances_set_resonance_momentum

@ %def fks_mapping_resonances_set_resonance_momentum
@
<<FKS regions: fks mapping resonances: TBP>>=
  procedure :: set_resonance_momenta => &
       fks_mapping_resonances_set_resonance_momenta
<<FKS regions: sub interfaces>>=
    module subroutine fks_mapping_resonances_set_resonance_momenta (map, p)
      class(fks_mapping_resonances_t), intent(inout) :: map
      type(vector4_t), intent(in), dimension(:) :: p
    end subroutine fks_mapping_resonances_set_resonance_momenta
<<FKS regions: procedures>>=
  module subroutine fks_mapping_resonances_set_resonance_momenta (map, p)
    class(fks_mapping_resonances_t), intent(inout) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    map%res_map%p_res = p
  end subroutine fks_mapping_resonances_set_resonance_momenta

@ %def fks_mapping_resonances_set_resonance_momenta
@
<<FKS regions: interfaces>>=
  interface assignment(=)
     module procedure fks_mapping_resonances_assign
  end interface

<<FKS regions: sub interfaces>>=
    module subroutine fks_mapping_resonances_assign (fks_map_out, fks_map_in)
      type(fks_mapping_resonances_t), intent(out) :: fks_map_out
      type(fks_mapping_resonances_t), intent(in) :: fks_map_in
    end subroutine fks_mapping_resonances_assign
<<FKS regions: procedures>>=
  module subroutine fks_mapping_resonances_assign (fks_map_out, fks_map_in)
    type(fks_mapping_resonances_t), intent(out) :: fks_map_out
    type(fks_mapping_resonances_t), intent(in) :: fks_map_in
    fks_map_out%exp_1 = fks_map_in%exp_1
    fks_map_out%exp_2 = fks_map_in%exp_2
    fks_map_out%res_map = fks_map_in%res_map
  end subroutine fks_mapping_resonances_assign

@ %def fks_mapping_resonances_assign
@
<<FKS regions: public>>=
  public :: create_resonance_histories_for_threshold
<<FKS regions: sub interfaces>>=
    module function create_resonance_histories_for_threshold &
         () result (res_history)
      type(resonance_history_t) :: res_history
    end function create_resonance_histories_for_threshold
<<FKS regions: procedures>>=
  module function create_resonance_histories_for_threshold &
       () result (res_history)
    type(resonance_history_t) :: res_history
    res_history%n_resonances = 2
    allocate (res_history%resonances (2))
    allocate (res_history%resonances(1)%contributors%c(2))
    allocate (res_history%resonances(2)%contributors%c(2))
    res_history%resonances(1)%contributors%c = [THR_POS_WP, THR_POS_B]
    res_history%resonances(2)%contributors%c = [THR_POS_WM, THR_POS_BBAR]
  end function create_resonance_histories_for_threshold

@ %def create_resonance_histories_for_threshold
@
<<FKS regions: public>>=
  public :: setup_region_data_for_test
<<FKS regions: sub interfaces>>=
    module subroutine setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, &
         nlo_corr_type, alpha_pow, alphas_pow)
      integer, intent(in) :: n_in, alpha_pow, alphas_pow
      integer, intent(in), dimension(:,:) :: flv_born, flv_real
      type(string_t), intent(in) :: nlo_corr_type
      type(region_data_t), intent(out) :: reg_data
    end subroutine setup_region_data_for_test
<<FKS regions: procedures>>=
  module subroutine setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, &
       nlo_corr_type, alpha_pow, alphas_pow)
    integer, intent(in) :: n_in, alpha_pow, alphas_pow
    integer, intent(in), dimension(:,:) :: flv_born, flv_real
    type(string_t), intent(in) :: nlo_corr_type
    type(region_data_t), intent(out) :: reg_data
    type(model_t), pointer :: test_model => null ()
    call create_test_model (var_str ("SM"), test_model)
    call test_model%set_real (var_str ("me"), 0._default)
    call test_model%set_real (var_str ("mmu"), 0._default)
    call test_model%set_real (var_str ("mtau"), 0._default)
    call test_model%set_real (var_str ("ms"), 0._default)
    call test_model%set_real (var_str ("mc"), 0._default)
    call test_model%set_real (var_str ("mb"), 0._default)
    call reg_data%init (n_in, test_model, flv_born, flv_real, nlo_corr_type, alpha_pow, &
         alphas_pow)
  end subroutine setup_region_data_for_test

@ %def setup_region_data_for_test
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Unit tests}
\clearpage
<<[[fks_regions_ut.f90]]>>=
<<File header>>

module fks_regions_ut
  use unit_tests
  use fks_regions_uti

<<Standard module head>>

<<FKS regions: public test>>

contains

<<FKS regions: test driver>>

end module fks_regions_ut
@ %def fks_regions_ut
@
<<[[fks_regions_uti.f90]]>>=
<<File header>>

module fks_regions_uti

<<Use strings>>
  use format_utils, only: write_separator
  use os_interface
  use models

  use fks_regions

<<Standard module head>>

<<FKS regions: test declarations>>

contains

<<FKS regions: tests>>

end module fks_regions_uti
@ %def fks_regions_uti
@
<<FKS regions: public test>>=
  public :: fks_regions_test
<<FKS regions: test driver>>=
  subroutine fks_regions_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
    call test(fks_regions_1, "fks_regions_1", &
         "Test flavor structure utilities", u, results)
    call test(fks_regions_2, "fks_regions_2", &
         "Test singular regions for final-state radiation for n = 2", &
         u, results)
    call test(fks_regions_3, "fks_regions_3", &
         "Test singular regions for final-state radiation for n = 3", &
         u, results)
    call test(fks_regions_4, "fks_regions_4", &
         "Test singular regions for final-state radiation for n = 4", &
         u, results)
    call test(fks_regions_5, "fks_regions_5", &
         "Test singular regions for final-state radiation for n = 5", &
         u, results)
    call test(fks_regions_6, "fks_regions_6", &
         "Test singular regions for initial-state radiation", &
         u, results)
    call test(fks_regions_7, "fks_regions_7", &
         "Check Latex output", u, results)
    call test(fks_regions_8, "fks_regions_8", &
         "Test singular regions for initial-state photon contributions", &
         u, results)
  end subroutine fks_regions_test

@ %def fks_regions_test
@
<<FKS regions: test declarations>>=
  public :: fks_regions_1
<<FKS regions: tests>>=
  subroutine fks_regions_1 (u)
    integer, intent(in) :: u
    type(flv_structure_t) :: flv_born, flv_real
    type(model_t), pointer :: test_model => null ()
    write (u, "(A)") "* Test output: fks_regions_1"
    write (u, "(A)") "* Purpose: Test utilities of flavor structure manipulation"
    write (u, "(A)")

    call create_test_model (var_str ("SM"), test_model)

    flv_born = [11, -11, 2, -2]
    flv_real = [11, -11, 2, -2, 21]
    flv_born%n_in = 2; flv_real%n_in = 2
    write (u, "(A)") "* Valid splittings of ee -> uu"
    write (u, "(A)") "Born Flavors: "
    call flv_born%write (u)
    write (u, "(A)") "Real Flavors: "
    call flv_real%write (u)
    write (u, "(A,L1)") "3, 4 (2, -2) : ", flv_real%valid_pair (3, 4, flv_born, test_model)
    write (u, "(A,L1)") "4, 3 (-2, 2) : ", flv_real%valid_pair (4, 3, flv_born, test_model)
    write (u, "(A,L1)") "3, 5 (2, 21) : ", flv_real%valid_pair (3, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 3 (21, 2) : ", flv_real%valid_pair (5, 3, flv_born, test_model)
    write (u, "(A,L1)") "4, 5 (-2, 21): ", flv_real%valid_pair (4, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 4 (21, -2): ", flv_real%valid_pair (5, 4, flv_born, test_model)
    call write_separator (u)

    call flv_born%final ()
    call flv_real%final ()

    flv_born = [2, -2, 11, -11]
    flv_real = [2, -2, 11, -11, 21]
    flv_born%n_in = 2; flv_real%n_in = 2
    write (u, "(A)") "* Valid splittings of uu -> ee"
    write (u, "(A)") "Born Flavors: "
    call flv_born%write (u)
    write (u, "(A)") "Real Flavors: "
    call flv_real%write (u)
    write (u, "(A,L1)") "1, 2 (2, -2) : " , flv_real%valid_pair (1, 2, flv_born, test_model)
    write (u, "(A,L1)") "2, 1 (-2, 2) : " , flv_real%valid_pair (2, 1, flv_born, test_model)
    write (u, "(A,L1)") "5, 2 (21, -2): " , flv_real%valid_pair (5, 2, flv_born, test_model)
    write (u, "(A,L1)") "2, 5 (-2, 21): " , flv_real%valid_pair (2, 5, flv_born, test_model)
    write (u, "(A,L1)") "1, 5 (21, 2) : " , flv_real%valid_pair (5, 1, flv_born, test_model)
    write (u, "(A,L1)") "5, 1 (2, 21) : " , flv_real%valid_pair (1, 5, flv_born, test_model)
    call flv_real%final ()
    flv_real = [21, -2, 11, -11, -2]
    flv_real%n_in = 2
    write (u, "(A)") "Real Flavors: "
    call flv_real%write (u)
    write (u, "(A,L1)") "1, 2 (21, -2): " , flv_real%valid_pair (1, 2, flv_born, test_model)
    write (u, "(A,L1)") "2, 1 (-2, 21): " , flv_real%valid_pair (2, 1, flv_born, test_model)
    write (u, "(A,L1)") "5, 2 (-2, -2): " , flv_real%valid_pair (5, 2, flv_born, test_model)
    write (u, "(A,L1)") "2, 5 (-2, -2): " , flv_real%valid_pair (2, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 1 (-2, 21): " , flv_real%valid_pair (5, 1, flv_born, test_model)
    write (u, "(A,L1)") "1, 5 (21, -2): " , flv_real%valid_pair (1, 5, flv_born, test_model)
    call flv_real%final ()
    flv_real = [2, 21, 11, -11, 2]
    flv_real%n_in = 2
    write (u, "(A)") "Real Flavors: "
    call flv_real%write (u)
    write (u, "(A,L1)") "1, 2 (2, 21) : " , flv_real%valid_pair (1, 2, flv_born, test_model)
    write (u, "(A,L1)") "2, 1 (21, 2) : " , flv_real%valid_pair (2, 1, flv_born, test_model)
    write (u, "(A,L1)") "5, 2 (2, 21) : " , flv_real%valid_pair (5, 2, flv_born, test_model)
    write (u, "(A,L1)") "2, 5 (21, 2) : " , flv_real%valid_pair (2, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 1 (2, 2)  : " , flv_real%valid_pair (5, 1, flv_born, test_model)
    write (u, "(A,L1)") "1, 5 (2, 2)  : " , flv_real%valid_pair (1, 5, flv_born, test_model)
    call write_separator (u)

    call flv_born%final ()
    call flv_real%final ()

    flv_born = [11, -11, 2, -2, 21]
    flv_real = [11, -11, 2, -2, 21, 21]
    flv_born%n_in = 2; flv_real%n_in = 2
    write (u, "(A)") "* Valid splittings of ee -> uug"
    write (u, "(A)") "Born Flavors: "
    call flv_born%write (u)
    write (u, "(A)") "Real Flavors: "
    call flv_real%write (u)
    write (u, "(A,L1)") "3, 4 (2, -2) : " , flv_real%valid_pair (3, 4, flv_born, test_model)
    write (u, "(A,L1)") "4, 3 (-2, 2) : " , flv_real%valid_pair (4, 3, flv_born, test_model)
    write (u, "(A,L1)") "3, 5 (2, 21) : " , flv_real%valid_pair (3, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 3 (21, 2) : " , flv_real%valid_pair (5, 3, flv_born, test_model)
    write (u, "(A,L1)") "4, 5 (-2, 21): " , flv_real%valid_pair (4, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 4 (21, -2): " , flv_real%valid_pair (5, 4, flv_born, test_model)
    write (u, "(A,L1)") "3, 6 (2, 21) : " , flv_real%valid_pair (3, 6, flv_born, test_model)
    write (u, "(A,L1)") "6, 3 (21, 2) : " , flv_real%valid_pair (6, 3, flv_born, test_model)
    write (u, "(A,L1)") "4, 6 (-2, 21): " , flv_real%valid_pair (4, 6, flv_born, test_model)
    write (u, "(A,L1)") "6, 4 (21, -2): " , flv_real%valid_pair (6, 4, flv_born, test_model)
    write (u, "(A,L1)") "5, 6 (21, 21): " , flv_real%valid_pair (5, 6, flv_born, test_model)
    write (u, "(A,L1)") "6, 5 (21, 21): " , flv_real%valid_pair (6, 5, flv_born, test_model)
    call flv_real%final ()
    flv_real = [11, -11, 2, -2, 1, -1]
    flv_real%n_in = 2
    write (u, "(A)") "Real Flavors (exemplary g -> dd splitting): "
    call flv_real%write (u)
    write (u, "(A,L1)") "3, 4 (2, -2) : " , flv_real%valid_pair (3, 4, flv_born, test_model)
    write (u, "(A,L1)") "4, 3 (-2, 2) : " , flv_real%valid_pair (4, 3, flv_born, test_model)
    write (u, "(A,L1)") "3, 5 (2, 1)  : " , flv_real%valid_pair (3, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 3 (1, 2)  : " , flv_real%valid_pair (5, 3, flv_born, test_model)
    write (u, "(A,L1)") "4, 5 (-2, 1) : " , flv_real%valid_pair (4, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 4 (1, -2) : " , flv_real%valid_pair (5, 4, flv_born, test_model)
    write (u, "(A,L1)") "3, 6 (2, -1) : " , flv_real%valid_pair (3, 6, flv_born, test_model)
    write (u, "(A,L1)") "6, 3 (-1, 2) : " , flv_real%valid_pair (6, 3, flv_born, test_model)
    write (u, "(A,L1)") "4, 6 (-2, -1): " , flv_real%valid_pair (4, 6, flv_born, test_model)
    write (u, "(A,L1)") "6, 4 (-1, -2): " , flv_real%valid_pair (6, 4, flv_born, test_model)
    write (u, "(A,L1)") "5, 6 (1, -1) : " , flv_real%valid_pair (5, 6, flv_born, test_model)
    write (u, "(A,L1)") "6, 5 (-1, 1) : " , flv_real%valid_pair (6, 5, flv_born, test_model)
    call write_separator (u)

    call flv_born%final ()
    call flv_real%final ()

    flv_born = [6, -5, 2, -1 ]
    flv_real = [6, -5, 2, -1, 21]
    flv_born%n_in = 1; flv_real%n_in = 1
    write (u, "(A)") "* Valid splittings of t -> b u d~"
    write (u, "(A)") "Born Flavors: "
    call flv_born%write (u)
    write (u, "(A)") "Real Flavors: "
    call flv_real%write (u)
    write (u, "(A,L1)") "1, 2 (6, -5) : " , flv_real%valid_pair (1, 2, flv_born, test_model)
    write (u, "(A,L1)") "1, 3 (6, 2)  : " , flv_real%valid_pair (1, 3, flv_born, test_model)
    write (u, "(A,L1)") "1, 4 (6, -1) : " , flv_real%valid_pair (1, 4, flv_born, test_model)
    write (u, "(A,L1)") "2, 1 (-5, 6) : " , flv_real%valid_pair (2, 1, flv_born, test_model)
    write (u, "(A,L1)") "3, 1 (2, 6)  : " , flv_real%valid_pair (3, 1, flv_born, test_model)
    write (u, "(A,L1)") "4, 1 (-1, 6) : " , flv_real%valid_pair (4, 1, flv_born, test_model)
    write (u, "(A,L1)") "2, 3 (-5, 2) : " , flv_real%valid_pair (2, 3, flv_born, test_model)
    write (u, "(A,L1)") "2, 4 (-5, -1): " , flv_real%valid_pair (2, 4, flv_born, test_model)
    write (u, "(A,L1)") "3, 2 (2, -5) : " , flv_real%valid_pair (3, 2, flv_born, test_model)
    write (u, "(A,L1)") "4, 2 (-1, -5): " , flv_real%valid_pair (4, 2, flv_born, test_model)
    write (u, "(A,L1)") "3, 4 (2, -1) : " , flv_real%valid_pair (3, 4, flv_born, test_model)
    write (u, "(A,L1)") "4, 3 (-1, 2) : " , flv_real%valid_pair (4, 3, flv_born, test_model)
    write (u, "(A,L1)") "1, 5 (6, 21) : " , flv_real%valid_pair (1, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 1 (21, 6) : " , flv_real%valid_pair (5, 1, flv_born, test_model)
    write (u, "(A,L1)") "2, 5 (-5, 21): " , flv_real%valid_pair (2, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 2 (21, 5) : " , flv_real%valid_pair (5, 2, flv_born, test_model)
    write (u, "(A,L1)") "3, 5 (2, 21) : " , flv_real%valid_pair (3, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 3 (21, 2) : " , flv_real%valid_pair (5, 3, flv_born, test_model)
    write (u, "(A,L1)") "4, 5 (-1, 21): " , flv_real%valid_pair (4, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 4 (21, -1): " , flv_real%valid_pair (5, 4, flv_born, test_model)

    call flv_born%final ()
    call flv_real%final ()

  end subroutine fks_regions_1

@ %def fks_regions_1
@
<<FKS regions: test declarations>>=
  public :: fks_regions_2
<<FKS regions: tests>>=
  subroutine fks_regions_2 (u)
    integer, intent(in) :: u
    integer :: n_flv_born, n_flv_real
    integer :: n_legs_born, n_legs_real
    integer :: n_in
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(region_data_t) :: reg_data
    write (u, "(A)") "* Test output: fks_regions_2"
    write (u, "(A)") "* Create singular regions for processes with up to four singular regions"
    write (u, "(A)") "* ee -> qq with QCD corrections"
    write (u, "(A)")

    n_flv_born = 1; n_flv_real = 1
    n_legs_born = 4; n_legs_real = 5
    n_in = 2

    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))
    flv_born (:, 1) = [11, -11, 2, -2]
    flv_real (:, 1) = [11, -11, 2, -2, 21]
    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("QCD"), 2, 0)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()
    call write_separator (u)

    write (u, "(A)") "* ee -> qq with EW corrections"
    write (u, "(A)")

    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))
    flv_born (:, 1) = [11, -11, 2, -2]
    flv_real (:, 1) = [11, -11, 2, -2, 22]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("EW"), 2, 0)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()
    call write_separator (u)

    write (u, "(A)") "* ee -> tt"
    write (u, "(A)")
    write (u, "(A)") "* This process has four singular regions because they are not equivalent."

    n_flv_born = 1; n_flv_real = 1
    n_legs_born = 6; n_legs_real = 7
    n_in = 2

    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))
    flv_born (:, 1) = [11, -11, 6, -6, 6, -6]
    flv_real (:, 1) = [11, -11, 6, -6, 6, -6, 21]
    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("QCD"), 4, 0)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()
  end subroutine fks_regions_2

@ %def fks_regions_2
@
<<FKS regions: test declarations>>=
  public :: fks_regions_3
<<FKS regions: tests>>=
  subroutine fks_regions_3 (u)
    integer, intent(in) :: u
    integer :: n_flv_born, n_flv_real
    integer :: n_legs_born, n_legs_real
    integer :: n_in, i, j
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(region_data_t) :: reg_data
    write (u, "(A)") "* Test output: fks_regions_3"
    write (u, "(A)") "* Create singular regions for processes with three final-state particles"

    write (u, "(A)") "* ee -> qqg"
    write (u, "(A)")
    n_flv_born = 1; n_flv_real = 2
    n_legs_born = 5; n_legs_real = 6
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))

    flv_born (:, 1) = [11, -11, 2, -2, 21]
    flv_real (:, 1) = [11, -11, 2, -2, 21, 21]
    flv_real (:, 2) = [11, -11, 2, -2, 1, -1]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("QCD"), 2, 1)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()
    call write_separator (u)

    write (u, "(A)") "* ee -> qqA"
    write (u, "(A)")
    n_flv_born = 1; n_flv_real = 2
    n_legs_born = 5; n_legs_real = 6
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))

    flv_born (:, 1) = [11, -11, 2, -2, 22]
    flv_real (:, 1) = [11, -11, 2, -2, 22, 22]
    flv_real (:, 2) = [11, -11, 2, -2, 11, -11]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("EW"), 3, 0)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()
    call write_separator (u)

    write (u, "(A)") "* ee -> jet jet jet"
    write (u, "(A)") "* with jet = u:U:d:D:s:S:c:C:b:B:gl"
    write (u, "(A)")
    n_flv_born = 5; n_flv_real = 22
    n_legs_born = 5; n_legs_real = 6
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))

    flv_born (:, 1)  = [11, -11, -4, 4, 21]
    flv_born (:, 2)  = [11, -11, -2, 2, 21]
    flv_born (:, 3)  = [11, -11, -5, 5, 21]
    flv_born (:, 4)  = [11, -11, -3, 3, 21]
    flv_born (:, 5)  = [11, -11, -1, 1, 21]
    flv_real (:, 1)  = [11, -11, -4, -4, 4, 4]
    flv_real (:, 2)  = [11, -11, -4, -2, 2, 4]
    flv_real (:, 3)  = [11, -11, -4, 4, 21, 21]
    flv_real (:, 4)  = [11, -11, -4, -5, 4, 5]
    flv_real (:, 5)  = [11, -11, -4, -3, 4, 3]
    flv_real (:, 6)  = [11, -11, -4, -1, 2, 3]
    flv_real (:, 7)  = [11, -11, -4, -1, 4, 1]
    flv_real (:, 8)  = [11, -11, -2, -2, 2, 2]
    flv_real (:, 9)  = [11, -11, -2, 2, 21, 21]
    flv_real (:, 10) = [11, -11, -2, -5, 2, 5]
    flv_real (:, 11) = [11, -11, -2, -3, 2, 3]
    flv_real (:, 12) = [11, -11, -2, -3, 4, 1]
    flv_real (:, 13) = [11, -11, -2, -1, 2, 1]
    flv_real (:, 14) = [11, -11, -5, -5, 5, 5]
    flv_real (:, 15) = [11, -11, -5, -3, 3, 5]
    flv_real (:, 16) = [11, -11, -5, -1, 1, 5]
    flv_real (:, 17) = [11, -11, -5, 5, 21, 21]
    flv_real (:, 18) = [11, -11, -3, -3, 3, 3]
    flv_real (:, 19) = [11, -11, -3, -1, 1, 3]
    flv_real (:, 20) = [11, -11, -3, 3, 21, 21]
    flv_real (:, 21) = [11, -11, -1, -1, 1, 1]
    flv_real (:, 22) = [11, -11, -1, 1, 21, 21]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("QCD"), 2, 1)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()
    call write_separator (u)

    write (u, "(A)") "* ee -> L L A"
    write (u, "(A)") "* with L = e2:E2:e3:E3"
    write (u, "(A)")
    n_flv_born = 2; n_flv_real = 6
    n_legs_born = 5; n_legs_real = 6
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))

    flv_born (:, 1) = [11, -11, -15, 15, 22]
    flv_born (:, 2) = [11, -11, -13, 13, 22]

    flv_real (:, 1) = [11, -11, -15, -15, 15, 15]
    flv_real (:, 2) = [11, -11, -15, -13, 13, 13]
    flv_real (:, 3) = [11, -11, -13, -15, 13, 15]
    flv_real (:, 4) = [11, -11, -15, 15, 22, 22]
    flv_real (:, 5) = [11, -11, -13, -13, 13, 13]
    flv_real (:, 6) = [11, -11, -13, 13, 22, 22]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("EW"), 3, 0)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()

  end subroutine fks_regions_3

@ %def fks_regions_3
@
<<FKS regions: test declarations>>=
  public :: fks_regions_4
<<FKS regions: tests>>=
  subroutine fks_regions_4 (u)
    integer, intent(in) :: u
    integer :: n_flv_born, n_flv_real
    integer :: n_legs_born, n_legs_real
    integer :: n_in
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(region_data_t) :: reg_data
    write (u, "(A)") "* Test output: fks_regions_4"
    write (u, "(A)") "* Create singular regions for processes with four final-state particles"
    write (u, "(A)") "* ee -> 4 jet"
    write (u, "(A)") "* with jet = u:U:d:D:s:S:c:C:b:B:gl"
    write (u, "(A)")
    n_flv_born = 22; n_flv_real = 22
    n_legs_born = 6; n_legs_real = 7
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))

    flv_born (:, 1)   = [11, -11, -4, -4, 4, 4]
    flv_born (:, 2)   = [11, -11, -4, -2, 2, 4]
    flv_born (:, 3)   = [11, -11, -4, 4, 21, 21]
    flv_born (:, 4)   = [11, -11, -4, -5, 4, 5]
    flv_born (:, 5)   = [11, -11, -4, -3, 4, 3]
    flv_born (:, 6)   = [11, -11, -4, -1, 2, 3]
    flv_born (:, 7)   = [11, -11, -4, -1, 4, 1]
    flv_born (:, 8)   = [11, -11, -2, -2, 2, 2]
    flv_born (:, 9)   = [11, -11, -2, 2, 21, 21]
    flv_born (:, 10)  = [11, -11, -2, -5, 2, 5]
    flv_born (:, 11)  = [11, -11, -2, -3, 2, 3]
    flv_born (:, 12)  = [11, -11, -2, -3, 4, 1]
    flv_born (:, 13)  = [11, -11, -2, -1, 2, 1]
    flv_born (:, 14)  = [11, -11, -5, -5, 5, 5]
    flv_born (:, 15)  = [11, -11, -5, -3, 3, 5]
    flv_born (:, 16)  = [11, -11, -5, -1, 1, 5]
    flv_born (:, 17)  = [11, -11, -5, 5, 21, 21]
    flv_born (:, 18)  = [11, -11, -3, -3, 3, 3]
    flv_born (:, 19)  = [11, -11, -3, -1, 1, 3]
    flv_born (:, 20)  = [11, -11, -3, -3, 21, 21]
    flv_born (:, 21)  = [11, -11, -1, -1, 1, 1]
    flv_born (:, 22)  = [11, -11, -1, 1, 21, 21]
    flv_real (:, 1)   = [11, -11, -4, -4, 4, 4, 21]
    flv_real (:, 2)   = [11, -11, -4, -2, 2, 4, 21]
    flv_real (:, 3)   = [11, -11, -4, 4, 21, 21, 21]
    flv_real (:, 4)   = [11, -11, -4, -5, 4, 5, 21]
    flv_real (:, 5)   = [11, -11, -4, -3, 4, 3, 21]
    flv_real (:, 6)   = [11, -11, -4, -1, 2, 3, 21]
    flv_real (:, 7)   = [11, -11, -4, -1, 4, 1, 21]
    flv_real (:, 8)   = [11, -11, -2, -2, 2, 2, 21]
    flv_real (:, 9)   = [11, -11, -2, 2, 21, 21, 21]
    flv_real (:, 10)  = [11, -11, -2, -5, 2, 5, 21]
    flv_real (:, 11)  = [11, -11, -2, -3, 2, 3, 21]
    flv_real (:, 12)  = [11, -11, -2, -3, 4, 1, 21]
    flv_real (:, 13)  = [11, -11, -2, -1, 2, 1, 21]
    flv_real (:, 14)  = [11, -11, -5, -5, 5, 5, 21]
    flv_real (:, 15)  = [11, -11, -5, -3, 3, 5, 21]
    flv_real (:, 16)  = [11, -11, -5, -1, 1, 5, 21]
    flv_real (:, 17)  = [11, -11, -5, 5, 21, 21, 21]
    flv_real (:, 18)  = [11, -11, -3, -3, 3, 3, 21]
    flv_real (:, 19)  = [11, -11, -3, -1, 1, 3, 21]
    flv_real (:, 20)  = [11, -11, -3, 3, 21, 21, 21]
    flv_real (:, 21)  = [11, -11, -1, -1, 1, 1, 21]
    flv_real (:, 22)  = [11, -11, -1, 1, 21, 21, 21]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("QCD"), 2, 2)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()
    call write_separator (u)

    write (u, "(A)") "* ee -> bbmumu with QCD corrections"
    write (u, "(A)")
    n_flv_born = 1; n_flv_real = 1
    n_legs_born = 6; n_legs_real = 7
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))

    flv_born (:, 1)   = [11, -11, -5, 5, -13, 13]
    flv_real (:, 1)   = [11, -11, -5, 5, -13, 13, 21]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("QCD"), 4, 0)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()
    call write_separator (u)

    write (u, "(A)") "* ee -> bbmumu with EW corrections"
    write (u, "(A)")
    n_flv_born = 1; n_flv_real = 1
    n_legs_born = 6; n_legs_real = 7
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))

    flv_born (:, 1)   = [11, -11, -5, 5, -13, 13]
    flv_real (:, 1)   = [11, -11, -5, 5, -13, 13, 22]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("QCD"), 4, 0)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()

  end subroutine fks_regions_4

@ %def fks_regions_4
@
<<FKS regions: test declarations>>=
  public :: fks_regions_5
<<FKS regions: tests>>=
  subroutine fks_regions_5 (u)
    integer, intent(in) :: u
    integer :: n_flv_born, n_flv_real
    integer :: n_legs_born, n_legs_real
    integer :: n_in
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(region_data_t) :: reg_data
    write (u, "(A)") "* Test output: fks_regions_5"
    write (u, "(A)") "* Create singular regions for processes with five final-state particles"
    write (u, "(A)") "* ee -> 5 jet"
    write (u, "(A)") "* with jet = u:U:d:D:s:S:c:C:b:B:gl"
    write (u, "(A)")
    n_flv_born = 22; n_flv_real = 67
    n_legs_born = 7; n_legs_real = 8
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))


    flv_born (:,1)  = [11,-11,-4,-4,4,4,21]
    flv_born (:,2)  = [11,-11,-4,-2,2,4,21]
    flv_born (:,3)  = [11,-11,-4,4,21,21,21]
    flv_born (:,4)  = [11,-11,-4,-5,4,5,21]
    flv_born (:,5)  = [11,-11,-4,-3,4,3,21]
    flv_born (:,6)  = [11,-11,-4,-1,2,3,21]
    flv_born (:,7)  = [11,-11,-4,-1,4,1,21]
    flv_born (:,8)  = [11,-11,-2,-2,2,2,21]
    flv_born (:,9)  = [11,-11,-2,2,21,21,21]
    flv_born (:,10) = [11,-11,-2,-5,2,5,21]
    flv_born (:,11) = [11,-11,-2,-3,2,3,21]
    flv_born (:,12) = [11,-11,-2,-3,4,1,21]
    flv_born (:,13) = [11,-11,-2,-1,2,1,21]
    flv_born (:,14) = [11,-11,-5,-5,5,5,21]
    flv_born (:,15) = [11,-11,-5,-3,3,5,21]
    flv_born (:,16) = [11,-11,-5,-1,1,5,21]
    flv_born (:,17) = [11,-11,-5,5,21,21,21]
    flv_born (:,18) = [11,-11,-3,-3,3,3,21]
    flv_born (:,19) = [11,-11,-3,-1,1,3,21]
    flv_born (:,20) = [11,-11,-3,3,21,21,21]
    flv_born (:,21) = [11,-11,-1,-1,1,1,21]
    flv_born (:,22) = [11,-11,-1,1,21,21,21]

    flv_real (:,1)  = [11,-11,-4,-4,-4,4,4,4]
    flv_real (:,2)  = [11,-11,-4,-4,-2,2,4,4]
    flv_real (:,3)  = [11,-11,-4,-4,4,4,21,21]
    flv_real (:,4)  = [11,-11,-4,-4,-5,4,4,5]
    flv_real (:,5)  = [11,-11,-4,-4,-3,4,4,3]
    flv_real (:,6)  = [11,-11,-4,-4,-1,2,4,3]
    flv_real (:,7)  = [11,-11,-4,-4,-1,4,4,1]
    flv_real (:,8)  = [11,-11,-4,-2,-2,2,2,4]
    flv_real (:,9)  = [11,-11,-4,-2,2,4,21,21]
    flv_real (:,10) = [11,-11,-4,-2,-5,2,4,5]
    flv_real (:,11) = [11,-11,-4,-2,-3,2,4,3]
    flv_real (:,12) = [11,-11,-4,-2,-3,4,4,1]
    flv_real (:,13) = [11,-11,-4,-2,-1,2,2,3]
    flv_real (:,14) = [11,-11,-4,-2,-1,2,4,1]
    flv_real (:,15) = [11,-11,-4,4,21,21,21,21]
    flv_real (:,16) = [11,-11,-4,-5,4,5,21,21]
    flv_real (:,17) = [11,-11,-4,-5,-5,4,5,5]
    flv_real (:,18) = [11,-11,-4,-5,-3,4,3,5]
    flv_real (:,19) = [11,-11,-4,-5,-1,2,3,5]
    flv_real (:,20) = [11,-11,-4,-5,-1,4,1,5]
    flv_real (:,21) = [11,-11,-4,-3,4,3,21,21]
    flv_real (:,22) = [11,-11,-4,-3,-3,4,3,3]
    flv_real (:,23) = [11,-11,-4,-3,-1,2,3,3]
    flv_real (:,24) = [11,-11,-4,-3,-1,4,1,3]
    flv_real (:,25) = [11,-11,-4,-1,2,3,21,21]
    flv_real (:,26) = [11,-11,-4,-1,4,1,21,21]
    flv_real (:,27) = [11,-11,-4,-1,-1,2,1,3]
    flv_real (:,28) = [11,-11,-4,-1,-1,4,1,1]
    flv_real (:,29) = [11,-11,-2,-2,-2,2,2,2]
    flv_real (:,30) = [11,-11,-2,-2,2,2,21,21]
    flv_real (:,31) = [11,-11,-2,-2,-5,2,2,5]
    flv_real (:,32) = [11,-11,-2,-2,-3,2,2,3]
    flv_real (:,33) = [11,-11,-2,-2,-3,2,4,1]
    flv_real (:,34) = [11,-11,-2,-2,-1,2,2,1]
    flv_real (:,35) = [11,-11,-2,2,21,21,21,21]
    flv_real (:,36) = [11,-11,-2,-5,2,5,21,21]
    flv_real (:,37) = [11,-11,-2,-5,-5,2,5,5]
    flv_real (:,38) = [11,-11,-2,-5,-3,2,3,5]
    flv_real (:,39) = [11,-11,-2,-5,-3,4,1,5]
    flv_real (:,40) = [11,-11,-2,-5,-1,2,1,5]
    flv_real (:,41) = [11,-11,-2,-3,2,3,21,21]
    flv_real (:,42) = [11,-11,-2,-3,4,1,21,21]
    flv_real (:,43) = [11,-11,-2,-3,-3,2,3,3]
    flv_real (:,44) = [11,-11,-2,-3,-3,4,1,3]
    flv_real (:,45) = [11,-11,-2,-3,-1,2,1,3]
    flv_real (:,46) = [11,-11,-2,-3,-1,4,1,1]
    flv_real (:,47) = [11,-11,-2,-1,2,1,21,21]
    flv_real (:,48) = [11,-11,-2,-1,-1,2,1,1]
    flv_real (:,49) = [11,-11,-5,-5,-5,5,5,5]
    flv_real (:,50) = [11,-11,-5,-5,-3,3,5,5]
    flv_real (:,51) = [11,-11,-5,-5,-1,1,5,5]
    flv_real (:,52) = [11,-11,-5,-5,5,5,21,21]
    flv_real (:,53) = [11,-11,-5,-3,-3,3,3,5]
    flv_real (:,54) = [11,-11,-5,-3,-1,1,3,5]
    flv_real (:,55) = [11,-11,-5,-3,3,5,21,21]
    flv_real (:,56) = [11,-11,-5,-1,-1,1,1,5]
    flv_real (:,57) = [11,-11,-5,-1,1,5,21,21]
    flv_real (:,58) = [11,-11,-5,5,21,21,21,21]
    flv_real (:,59) = [11,-11,-3,-3,-3,3,3,3]
    flv_real (:,60) = [11,-11,-3,-3,-1,1,3,3]
    flv_real (:,61) = [11,-11,-3,-3,3,3,21,21]
    flv_real (:,62) = [11,-11,-3,-1,-1,1,1,3]
    flv_real (:,63) = [11,-11,-3,-1,1,3,21,21]
    flv_real (:,64) = [11,-11,-3,3,21,21,21,21]
    flv_real (:,65) = [11,-11,-1,-1,-1,1,1,1]
    flv_real (:,66) = [11,-11,-1,-1,1,1,21,21]
    flv_real (:,67) = [11,-11,-1,1,21,21,21,21]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("QCD"), 2, 3)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()

  end subroutine fks_regions_5

@ %def fks_regions_5
@
<<FKS regions: test declarations>>=
  public :: fks_regions_6
<<FKS regions: tests>>=
  subroutine fks_regions_6 (u)
    integer, intent(in) :: u
    integer :: n_flv_born, n_flv_real
    integer :: n_legs_born, n_legs_real
    integer :: n_in
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(region_data_t) :: reg_data
    integer :: i, j
    integer, dimension(10) :: flavors
    write (u, "(A)") "* Test output: fks_regions_6"
    write (u, "(A)") "* Create table of singular regions for Drell Yan"
    write (u, "(A)")

    n_flv_born = 10; n_flv_real = 30
    n_legs_born = 4; n_legs_real = 5
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))
    flavors = [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5]
    do i = 1, n_flv_born
       flv_born (3:4, i) = [11, -11]
    end do
    do j = 1, n_flv_born
       flv_born (1, j) = flavors (j)
       flv_born (2, j) = -flavors (j)
    end do

    do i = 1, n_flv_real
       flv_real (3:4, i) = [11, -11]
    end do
    i = 1
    do j = 1, n_flv_real
       if (mod (j, 3) == 1) then
          flv_real (1, j) = flavors (i)
          flv_real (2, j) = -flavors (i)
          flv_real (5, j) = 21
       else if (mod (j, 3) == 2) then
          flv_real (1, j) = flavors (i)
          flv_real (2, j) = 21
          flv_real (5, j) = flavors (i)
       else
          flv_real (1, j) = 21
          flv_real (2, j) = -flavors (i)
          flv_real (5, j) = -flavors (i)
          i = i + 1
       end if
    end do

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("QCD"), 2, 0)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    call write_separator (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()

    write (u, "(A)") "* Create table of singular regions for hadronic top decay"
    write (u, "(A)")
    n_flv_born = 1; n_flv_real = 1
    n_legs_born = 4; n_legs_real = 5
    n_in = 1
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))

    flv_born (:, 1) = [6, -5, 2, -1]
    flv_real (:, 1) = [6, -5, 2, -1, 21]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("QCD"), 0, 2)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)

    call write_separator (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()

    write (u, "(A)") "* Create table of singular regions for dijet s sbar -> jet jet"
    write (u, "(A)") "* With jet = u:d:gl"
    write (u, "(A)")

    n_flv_born = 3; n_flv_real = 3
    n_legs_born = 4; n_legs_real = 5
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))
    do i = 1, n_flv_born
       flv_born (1:2, i) = [3, -3]
    end do
    flv_born (3, :) = [1, 2, 21]
    flv_born (4, :) = [-1, -2, 21]

    do i = 1, n_flv_real
       flv_real (1:2, i) = [3, -3]
    end do
    flv_real (3, :) = [1, 2, 21]
    flv_real (4, :) = [-1, -2, 21]
    flv_real (5, :) = [21, 21, 21]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("QCD"), 0, 2)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)
    call reg_data%final ()

  end subroutine fks_regions_6

@ %def fks_regions_6
@
<<FKS regions: test declarations>>=
  public :: fks_regions_7
<<FKS regions: tests>>=
  subroutine fks_regions_7 (u)
    integer, intent(in) :: u
    integer :: n_flv_born, n_flv_real
    integer :: n_legs_born, n_legs_real
    integer :: n_in
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(region_data_t) :: reg_data
    write (u, "(A)") "* Test output: fks_regions_7"
    write (u, "(A)") "* Create table of singular regions for ee -> qq"
    write (u, "(A)")

    n_flv_born = 1; n_flv_real = 1
    n_legs_born = 4; n_legs_real = 5
    n_in = 2

    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))
    flv_born (:, 1) = [11, -11, 2, -2]
    flv_real (:, 1) = [11, -11, 2, -2, 21]
    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("QCD"), 2, 0)
    call reg_data%write_latex (u)
    call reg_data%final ()

  end subroutine fks_regions_7

@ %def fks_regions_7
@
<<FKS regions: test declarations>>=
  public :: fks_regions_8
<<FKS regions: tests>>=
  subroutine fks_regions_8 (u)
    integer, intent(in) :: u
    integer :: n_flv_born, n_flv_real
    integer :: n_legs_born, n_legs_real
    integer :: n_in
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(region_data_t) :: reg_data
    integer :: i, j
    integer, dimension(10) :: flavors
    write (u, "(A)") "* Test output: fks_regions_8"
    write (u, "(A)") "* Create table of singular regions for ee -> ee"
    write (u, "(A)")

    n_flv_born = 1; n_flv_real = 3
    n_legs_born = 4; n_legs_real = 5
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))
    flv_born (:, 1) = [11, -11, -11, 11]

    flv_real (:, 1) = [11, -11, -11, 11, 22]
    flv_real (:, 2) = [11, 22, -11, 11, 11]
    flv_real (:, 3) = [22, -11, 11, -11, -11]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data, var_str ("EW"), 2, 0)
    call reg_data%check_consistency (.false., u)
    call reg_data%write (u)
    call reg_data%final ()

  end subroutine fks_regions_8

@ %def fks_regions_8
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{NLO infrastructure and data}

This module contains the settings and data infrastructure.
<<[[nlo_data.f90]]>>=
<<File header>>

module nlo_data

<<Use kinds>>
<<Use strings>>
  use constants, only: zero
  use lorentz
  use variables, only: var_list_t
  use physics_defs, only: NO_FACTORIZATION, FACTORIZATION_THRESHOLD

<<Standard module head>>

<<NLO data: public>>

<<NLO data: parameters>>

<<NLO data: types>>

  interface
<<NLO data: sub interfaces>>
  end interface

end module nlo_data

@ %def nlo_data
@
<<[[nlo_data_sub.f90]]>>=
<<File header>>

submodule (nlo_data) nlo_data_s

  use diagnostics
  use string_utils, only: split_string, read_ival, string_contains_word
  use io_units
  use format_defs, only: FMT_15
  use physics_defs, only: THR_POS_WP, THR_POS_WM
  use physics_defs, only: THR_POS_B, THR_POS_BBAR

  implicit none

contains

<<NLO data: procedures>>

end submodule nlo_data_s

@ %def nlo_data_s
@
<<NLO data: parameters>>=
  integer, parameter, public :: FKS_DEFAULT = 1
  integer, parameter, public :: FKS_RESONANCES = 2

  integer, dimension(2), parameter, public :: ASSOCIATED_LEG_PAIR = [1, 3]

@ %def parameters
@
<<NLO data: public>>=
  public :: fks_template_t
<<NLO data: types>>=
  type :: fks_template_t
    logical :: subtraction_disabled = .false.
    integer :: mapping_type = FKS_DEFAULT
    logical :: count_kinematics = .false.
    real(default) :: fks_dij_exp1
    real(default) :: fks_dij_exp2
    real(default) :: xi_min
    real(default) :: y_max
    real(default) :: xi_cut, delta_o, delta_i
    type(string_t), dimension(:), allocatable :: excluded_resonances
    integer :: n_f
  contains
  <<NLO data: fks template: TBP>>
  end type fks_template_t

@ %def fks_template_t
@
<<NLO data: fks template: TBP>>=
  procedure :: write => fks_template_write
<<NLO data: sub interfaces>>=
    module subroutine fks_template_write (template, unit)
      class(fks_template_t), intent(in) :: template
      integer, intent(in), optional :: unit
    end subroutine fks_template_write
<<NLO data: procedures>>=
  module subroutine fks_template_write (template, unit)
    class(fks_template_t), intent(in) :: template
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u,'(1x,A)') 'FKS Template: '
    write (u,'(1x,A)', advance = 'no') 'Mapping Type: '
    select case (template%mapping_type)
    case (FKS_DEFAULT)
       write (u,'(A)') 'Default'
    case (FKS_RESONANCES)
       write (u,'(A)') 'Resonances'
    case default
       write (u,'(A)') 'Unkown'
    end select
    write (u,'(1x,A,ES4.3,ES4.3)') 'd_ij exponentials: ', &
       template%fks_dij_exp1, template%fks_dij_exp2
    write (u, '(1x,A,ES4.3,ES4.3)') 'xi_cut: ', &
       template%xi_cut
    write (u, '(1x,A,ES4.3,ES4.3)') 'delta_o: ', &
       template%delta_o
    write (u, '(1x,A,ES4.3,ES4.3)') 'delta_i: ', &
         template%delta_i
  end subroutine fks_template_write

@ %def fks_template_write
@ Set FKS parameters. $\xi_{\text{cut}}, \delta_o$ and
$\delta_{\mathrm{I}}$ steer the ratio of the integrated and real
subtraction.
<<NLO data: fks template: TBP>>=
  procedure :: set_parameters => fks_template_set_parameters
<<NLO data: sub interfaces>>=
    module subroutine fks_template_set_parameters (template, &
         exp1, exp2, xi_min, y_max, xi_cut, delta_o, delta_i)
      class(fks_template_t), intent(inout) :: template
      real(default), intent(in) :: exp1, exp2
      real(default), intent(in) :: xi_min, y_max, &
           xi_cut, delta_o, delta_i
    end subroutine fks_template_set_parameters
<<NLO data: procedures>>=
  module subroutine fks_template_set_parameters (template, &
       exp1, exp2, xi_min, y_max, xi_cut, delta_o, delta_i)
    class(fks_template_t), intent(inout) :: template
    real(default), intent(in) :: exp1, exp2
    real(default), intent(in) :: xi_min, y_max, &
         xi_cut, delta_o, delta_i
    template%fks_dij_exp1 = exp1
    template%fks_dij_exp2 = exp2
    template%xi_min = xi_min
    template%y_max = y_max
    template%xi_cut = xi_cut
    template%delta_o = delta_o
    template%delta_i = delta_i
  end subroutine fks_template_set_parameters

@ %def fks_template_set_parameters
<<NLO data: fks template: TBP>>=
  procedure :: set_mapping_type => fks_template_set_mapping_type
<<NLO data: sub interfaces>>=
    module subroutine fks_template_set_mapping_type (template, val)
      class(fks_template_t), intent(inout) :: template
      integer, intent(in) :: val
    end subroutine fks_template_set_mapping_type
<<NLO data: procedures>>=
  module subroutine fks_template_set_mapping_type (template, val)
    class(fks_template_t), intent(inout) :: template
    integer, intent(in) :: val
    template%mapping_type = val
  end subroutine fks_template_set_mapping_type

@ %def fks_template_set_mapping_type
@
<<NLO data: fks template: TBP>>=
  procedure :: set_counter => fks_template_set_counter
<<NLO data: sub interfaces>>=
    module subroutine fks_template_set_counter (template)
      class(fks_template_t), intent(inout) :: template
    end subroutine fks_template_set_counter
<<NLO data: procedures>>=
  module subroutine fks_template_set_counter (template)
    class(fks_template_t), intent(inout) :: template
    template%count_kinematics = .true.
  end subroutine fks_template_set_counter

@ %def fks_template_set_counter
@
<<NLO data: public>>=
  public :: get_threshold_momenta
<<NLO data: sub interfaces>>=
    module function get_threshold_momenta (p) result (p_thr)
      type(vector4_t), dimension(4) :: p_thr
      type(vector4_t), intent(in), dimension(:) :: p
    end function get_threshold_momenta
<<NLO data: procedures>>=
  module function get_threshold_momenta (p) result (p_thr)
    type(vector4_t), dimension(4) :: p_thr
    type(vector4_t), intent(in), dimension(:) :: p
    p_thr(1) = p(THR_POS_WP) + p(THR_POS_B)
    p_thr(2) = p(THR_POS_B)
    p_thr(3) = p(THR_POS_WM) + p(THR_POS_BBAR)
    p_thr(4) = p(THR_POS_BBAR)
  end function get_threshold_momenta

@ %def get_threshold_momenta
@
\subsection{NLO settings and steering}
<<NLO data: public>>=
  public :: nlo_settings_t
<<NLO data: types>>=
  type :: nlo_settings_t
     logical :: use_internal_color_correlations = .true.
     logical :: use_internal_spin_correlations = .false.
     logical :: use_resonance_mappings = .false.
     logical :: combined_integration = .false.
     logical :: fixed_order_nlo = .false.
     logical :: test_soft_limit = .false.
     logical :: test_coll_limit = .false.
     logical :: test_anti_coll_limit = .false.
     integer, dimension(:), allocatable :: selected_alr
     integer :: factorization_mode = NO_FACTORIZATION
     !!! Probably not the right place for this. Revisit after refactoring
     real(default) :: powheg_damping_scale = zero
     type(fks_template_t) :: fks_template
     type(string_t) :: virtual_selection
     logical :: virtual_resonance_aware_collinear = .true.
     logical :: use_born_scale = .false.
     logical :: cut_all_real_sqmes = .false.
     type(string_t) :: nlo_correction_type
     logical :: reuse_amplitudes_fks = .false.
  contains
  <<NLO data: nlo settings: TBP>>
  end type nlo_settings_t

@ %def nlo_settings_t
@
<<NLO data: nlo settings: TBP>>=
  procedure :: init => nlo_settings_init
<<NLO data: sub interfaces>>=
    module subroutine nlo_settings_init (nlo_settings, var_list, fks_template)
      class(nlo_settings_t), intent(inout) :: nlo_settings
      type(var_list_t), intent(in) :: var_list
      type(fks_template_t), intent(in), optional :: fks_template
    end subroutine nlo_settings_init
<<NLO data: procedures>>=
  module subroutine nlo_settings_init (nlo_settings, var_list, fks_template)
    class(nlo_settings_t), intent(inout) :: nlo_settings
    type(var_list_t), intent(in) :: var_list
    type(fks_template_t), intent(in), optional :: fks_template
    type(string_t) :: color_method
    if (present (fks_template)) nlo_settings%fks_template = fks_template
    color_method = var_list%get_sval (var_str ('$correlation_me_method'))
    if (color_method == "")  &
         color_method = var_list%get_sval (var_str ('$method'))
    nlo_settings%use_internal_color_correlations = color_method == 'omega' &
           .or. color_method == 'threshold'
    nlo_settings%combined_integration = var_list%get_lval &
           (var_str ("?combined_nlo_integration"))
    nlo_settings%fixed_order_nlo = var_list%get_lval &
           (var_str ("?fixed_order_nlo_events"))
    nlo_settings%test_soft_limit = &
         var_list%get_lval (var_str ('?test_soft_limit'))
    nlo_settings%test_coll_limit = &
         var_list%get_lval (var_str ('?test_coll_limit'))
    nlo_settings%test_anti_coll_limit = &
         var_list%get_lval (var_str ('?test_anti_coll_limit'))
    call setup_alr_selection ()
    nlo_settings%virtual_selection = &
         var_list%get_sval (var_str ('$virtual_selection'))
    nlo_settings%virtual_resonance_aware_collinear = &
         var_list%get_lval (var_str ('?virtual_collinear_resonance_aware'))
    nlo_settings%powheg_damping_scale = &
         var_list%get_rval (var_str ('powheg_damping_scale'))
    nlo_settings%use_born_scale = &
         var_list%get_lval (var_str ("?nlo_use_born_scale"))
    nlo_settings%cut_all_real_sqmes = &
         var_list%get_lval (var_str ("?nlo_cut_all_real_sqmes"))
    nlo_settings%nlo_correction_type = &
         var_list%get_sval (var_str ('$nlo_correction_type'))
    nlo_settings%reuse_amplitudes_fks = &
         var_list%get_lval (var_str ('?nlo_reuse_amplitudes_fks'))
  contains
    subroutine setup_alr_selection ()
      type(string_t) :: alr_selection
      type(string_t), dimension(:), allocatable :: alr_split
      integer :: i, i1, i2
      alr_selection = var_list%get_sval (var_str ('$select_alpha_regions'))
      if (string_contains_word (alr_selection, var_str (","))) then
         call split_string (alr_selection, var_str (","), alr_split)
         allocate (nlo_settings%selected_alr (size (alr_split)))
         do i = 1, size (alr_split)
            nlo_settings%selected_alr(i) = read_ival(alr_split(i))
         end do
      else if (string_contains_word (alr_selection, var_str (":"))) then
         call split_string (alr_selection, var_str (":"), alr_split)
         if (size (alr_split) == 2) then
            i1 = read_ival (alr_split(1))
            i2 = read_ival (alr_split(2))
            allocate (nlo_settings%selected_alr (i2 - i1 + 1))
            do i = 1, i2 - i1 + 1
               nlo_settings%selected_alr(i) = read_ival (alr_split(i))
            end do
         else
            call msg_fatal ("select_alpha_regions: ':' specifies a range!")
         end if
      else if (len(alr_selection) == 1) then
         allocate (nlo_settings%selected_alr (1))
         nlo_settings%selected_alr(1) = read_ival (alr_selection)
      end if
      if (allocated (alr_split)) deallocate (alr_split)
    end subroutine setup_alr_selection
  end subroutine nlo_settings_init

@ %def nlo_settings_init
@
<<NLO data: nlo settings: TBP>>=
  procedure :: write => nlo_settings_write
<<NLO data: sub interfaces>>=
    module subroutine nlo_settings_write (nlo_settings, unit)
      class(nlo_settings_t), intent(in) :: nlo_settings
      integer, intent(in), optional :: unit
    end subroutine nlo_settings_write
<<NLO data: procedures>>=
  module subroutine nlo_settings_write (nlo_settings, unit)
    class(nlo_settings_t), intent(in) :: nlo_settings
    integer, intent(in), optional :: unit
    integer :: i, u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, '(A)') 'nlo_settings:'
    write (u, '(3X,A,L1)') 'internal_color_correlations = ', &
         nlo_settings%use_internal_color_correlations
    write (u, '(3X,A,L1)') 'internal_spin_correlations = ', &
         nlo_settings%use_internal_spin_correlations
    write (u, '(3X,A,L1)') 'use_resonance_mappings = ', &
         nlo_settings%use_resonance_mappings
    write (u, '(3X,A,L1)') 'combined_integration = ', &
         nlo_settings%combined_integration
    write (u, '(3X,A,L1)') 'test_soft_limit = ', &
         nlo_settings%test_soft_limit
    write (u, '(3X,A,L1)') 'test_coll_limit = ', &
         nlo_settings%test_coll_limit
    write (u, '(3X,A,L1)') 'test_anti_coll_limit = ', &
         nlo_settings%test_anti_coll_limit
    if (allocated (nlo_settings%selected_alr)) then
       write (u, '(3x,A)', advance = "no") 'selected alpha regions = ['
       do i = 1, size (nlo_settings%selected_alr)
          write (u, '(A,I0)', advance = "no") ",", &
               nlo_settings%selected_alr(i)
       end do
       write (u, '(A)') "]"
    end if
    write (u, '(3X,A,' // FMT_15 // ')') 'powheg_damping_scale = ', &
         nlo_settings%powheg_damping_scale
    write (u, '(3X,A,A)') 'virtual_selection = ', &
         char (nlo_settings%virtual_selection)
    write (u, '(3X,A,A)') 'Real factorization mode = ', &
         char (factorization_mode (nlo_settings%factorization_mode))
  contains
    function factorization_mode (fm)
      type(string_t) :: factorization_mode
      integer, intent(in) :: fm
      select case (fm)
      case (NO_FACTORIZATION)
         factorization_mode = var_str ("None")
      case (FACTORIZATION_THRESHOLD)
         factorization_mode = var_str ("Threshold")
      case default
         factorization_mode = var_str ("Undefined!")
      end select
    end function factorization_mode
  end subroutine nlo_settings_write

@ %def nlo_settings_write
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Virtual contribution to the cross section}

This module implements the UV-finite virtual contribution of an NLO
calculation together with the integrated (FKS) subtraction terms.
<<[[virtual.f90]]>>=
<<File header>>

module virtual

<<Use kinds>>
<<Use strings>>
  use pdg_arrays
  use models
  use model_data, only: model_data_t, field_data_t
  use lorentz
  use nlo_data, only: nlo_settings_t
  use fks_regions

<<Standard module head>>

<<Virtual: public>>

<<Virtual: types>>

  interface
<<Virtual: sub interfaces>>
  end interface

end module virtual
@ %def virtual
@
<<[[virtual_sub.f90]]>>=
<<File header>>

submodule (virtual) virtual_s

<<Use debug>>
  use constants
  use numeric_utils
  use diagnostics
  use physics_defs
  use sm_physics
  use flavors
  use nlo_data, only: ASSOCIATED_LEG_PAIR, get_threshold_momenta

  implicit none

contains

<<Virtual: procedures>>

end submodule virtual_s

@ %def virtual_s
@
<<Virtual: public>>=
  public :: virtual_t
<<Virtual: types>>=
  type :: virtual_t
     type(nlo_settings_t) :: settings
     real(default), dimension(:,:,:), allocatable :: gamma_0, gamma_p, c_flv
     real(default) :: fac_scale
     real(default), allocatable :: ren_scale
     real(default), allocatable :: es_scale2
     integer, dimension(:), allocatable :: n_is_neutrinos
     integer :: n_in, n_legs, n_flv
     logical :: bad_point = .false.
     type(string_t) :: selection
     real(default), dimension(:), allocatable :: sqme_born
     real(default), dimension(:), allocatable :: sqme_virt_fin
     real(default), dimension(:,:,:), allocatable :: sqme_color_c
     real(default), dimension(:,:,:), allocatable :: sqme_charge_c
     logical :: has_pdfs = .false.
   contains
   <<Virtual: virtual: TBP>>
  end type virtual_t

@ %def virtual_t
@
<<Virtual: virtual: TBP>>=
  procedure :: init => virtual_init
<<Virtual: sub interfaces>>=
    module subroutine virtual_init &
         (virt, flv_born, n_in, settings, model, has_pdfs)
      class(virtual_t), intent(inout) :: virt
      integer, intent(in), dimension(:,:) :: flv_born
      integer, intent(in) :: n_in
      type(nlo_settings_t), intent(in) :: settings
      class(model_data_t), intent(in) :: model
      logical, intent(in) :: has_pdfs
    end subroutine virtual_init
<<Virtual: procedures>>=
  module subroutine virtual_init &
       (virt, flv_born, n_in, settings, model, has_pdfs)
    class(virtual_t), intent(inout) :: virt
    integer, intent(in), dimension(:,:) :: flv_born
    integer, intent(in) :: n_in
    type(nlo_settings_t), intent(in) :: settings
    class(model_data_t), intent(in) :: model
    logical, intent(in) :: has_pdfs
    integer :: i_flv, n_corr
    n_corr = 2
    virt%n_legs = size (flv_born, 1); virt%n_flv = size (flv_born, 2)
    virt%n_in = n_in
    allocate (virt%sqme_born (virt%n_flv))
    allocate (virt%sqme_virt_fin (virt%n_flv))
    allocate (virt%sqme_color_c (virt%n_legs, virt%n_legs, virt%n_flv))
    allocate (virt%sqme_charge_c (virt%n_legs, virt%n_legs, virt%n_flv))
    allocate (virt%gamma_0 (virt%n_legs, virt%n_flv, n_corr), &
       virt%gamma_p (virt%n_legs, virt%n_flv, n_corr), &
       virt%c_flv (virt%n_legs, virt%n_flv, n_corr))
    call virt%init_constants (flv_born, settings%fks_template%n_f, model)
    allocate (virt%n_is_neutrinos (virt%n_flv))
    virt%n_is_neutrinos = 0
    do i_flv = 1, virt%n_flv
       if (is_neutrino (flv_born(1, i_flv))) &
          virt%n_is_neutrinos(i_flv) = virt%n_is_neutrinos(i_flv) + 1
       if (is_neutrino (flv_born(2, i_flv))) &
          virt%n_is_neutrinos(i_flv) = virt%n_is_neutrinos(i_flv) + 1
    end do
    select case (char (settings%virtual_selection))
    case ("Full", "OLP", "Subtraction")
       virt%selection = settings%virtual_selection
    case default
       call msg_fatal ('Virtual selection: Possible values are "Full", "OLP" or "Subtraction')
    end select
    virt%settings = settings
    virt%has_pdfs = has_pdfs
  contains

    function is_neutrino (flv) result (neutrino)
      integer, intent(in) :: flv
      logical :: neutrino
      neutrino = (abs(flv) == 12 .or. abs(flv) == 14 .or. abs(flv) == 16)
    end function is_neutrino

  end subroutine virtual_init

@ %def virtual_init
@ The virtual subtraction terms contain Casimir operators and derived
constants, listed below:
\begin{align}
  \label{eqn:C(q)}
  C(q) = C(\bar{q}) &= C_F, \\
  \label{eqn:C(g)}
  C(g) &= C_A,\\
  \label{eqn:gamma(q)}
  \gamma(q) = \gamma(\bar{q}) &= \frac{3}{2} C_F,\\
  \label{eqn:gamma(g)}
  \gamma(g) &= \frac{11}{6} C_A - \frac{2}{3} T_F N_f,\\
  \label{eqn:gammap(q)}
  \gamma'(q) = \gamma'(\bar{q}) &= \left(\frac{13}{2} -
  \frac{2\pi^2}{3}\right) C_F, \\
  \label{eqn:gammap(g)}
  \gamma'(g) &= \left(\frac{67}{9} - \frac{2\pi^2}{3}\right) C_A -
  \frac{23}{9} T_F N_f.
\end{align}
For uncolored particles, [[virtual_init_constants]] sets $C$, $\gamma$ and $\gamma'$ to zero.
<<Virtual: virtual: TBP>>=
  procedure :: init_constants => virtual_init_constants
<<Virtual: sub interfaces>>=
    module subroutine virtual_init_constants (virt, flv_born, nf_input, model)
      class(virtual_t), intent(inout) :: virt
      integer, intent(in), dimension(:,:) :: flv_born
      integer, intent(in) :: nf_input
      type(string_t), dimension(2) :: corr_type
      class(model_data_t), intent(in) :: model
    end subroutine virtual_init_constants
<<Virtual: procedures>>=
  module subroutine virtual_init_constants (virt, flv_born, nf_input, model)
    class(virtual_t), intent(inout) :: virt
    integer, intent(in), dimension(:,:) :: flv_born
    integer, intent(in) :: nf_input
    type(string_t), dimension(2) :: corr_type
    class(model_data_t), intent(in) :: model
    type(field_data_t), pointer :: field
    integer :: i_part, i_flv, pdg, i_corr
    real(default) :: nf, CA_factor, TR_sum
    real(default), dimension(:,:), allocatable :: CF_factor, TR_factor
    type(flavor_t) :: flv
    allocate (CF_factor (size (flv_born, 1), size (flv_born, 2)), &
         TR_factor (size (flv_born, 1), size (flv_born, 2)))
    corr_type (1) = "QCD"; corr_type (2) = "EW"
    do i_corr = 1, 2
       TR_sum = 0
       if (i_corr == 1) then
          CA_factor = CA; CF_factor = CF; TR_factor = TR
          nf = real(nf_input, default)
          TR_sum = nf * TR
       else
          CA_factor = zero
          do i_flv = 1, size (flv_born, 2)
             do i_part = 1, size (flv_born, 1)
                call flv%init (flv_born(i_part, i_flv), model)
                CF_factor(i_part, i_flv) = (flv%get_charge ())**2
                TR_factor(i_part, i_flv) = (flv%get_charge ())**2
                if (is_quark (flv_born (i_part, i_flv))) &
                     TR_factor(i_part, i_flv) = NC * TR_factor(i_part, i_flv)
             end do
          end do
          do pdg = 1, nf_input
             field => model%get_field_ptr (pdg)
             TR_sum = TR_sum + NC*field%get_charge()**2
          end do
          do pdg = 11, 15, 2
             field => model%get_field_ptr (pdg)
             if (field%get_mass() > 0) exit
             TR_sum = TR_sum + field%get_charge()**2
          end do
       end if
       do i_flv = 1, size (flv_born, 2)
          do i_part = 1, size (flv_born, 1)
             if (is_massless_vectorboson (flv_born(i_part, i_flv), corr_type (i_corr))) then
                virt%gamma_0(i_part, i_flv, i_corr) = 11._default / 6._default * CA_factor &
                     - two / three * TR_sum
                virt%gamma_p(i_part, i_flv, i_corr) = (67._default / 9._default &
                     - two * pi**2 / three) * CA_factor &
                     - 23._default / 9._default * TR_sum
                virt%c_flv(i_part, i_flv, i_corr) = CA_factor
             else if (is_corresponding_fermion (flv_born(i_part, i_flv), corr_type (i_corr))) then
                virt%gamma_0(i_part, i_flv, i_corr) = 1.5_default * CF_factor(i_part, i_flv)
                virt%gamma_p(i_part, i_flv, i_corr) = (6.5_default - two * pi**2 / three) * CF_factor(i_part, i_flv)
                virt%c_flv(i_part, i_flv, i_corr) = CF_factor(i_part, i_flv)
             else if (is_massive_vectorboson (flv_born(i_part, i_flv), corr_type (i_corr))) then
                virt%gamma_0(i_part, i_flv, i_corr) = zero
                virt%gamma_p(i_part, i_flv, i_corr) = zero
                virt%c_flv(i_part, i_flv, i_corr) = CF_factor(i_part, i_flv)
             else
                virt%gamma_0(i_part, i_flv, i_corr) = zero
                virt%gamma_p(i_part, i_flv, i_corr) = zero
                virt%c_flv(i_part, i_flv, i_corr) = zero
             end if
          end do
       end do
    end do
  contains
    function is_massless_vectorboson (pdg_nr, nlo_corr_type)
      logical :: is_massless_vectorboson
      integer, intent(in) :: pdg_nr
      type(string_t), intent(in) :: nlo_corr_type
      is_massless_vectorboson = .false.
      if (nlo_corr_type == "QCD") then
         is_massless_vectorboson = is_gluon (pdg_nr)
      else if (nlo_corr_type == "EW") then
         is_massless_vectorboson = is_photon (pdg_nr)
      end if
    end function is_massless_vectorboson
    function is_corresponding_fermion (pdg_nr, nlo_corr_type)
      logical :: is_corresponding_fermion
      integer, intent(in) :: pdg_nr
      type(string_t), intent(in) :: nlo_corr_type
      is_corresponding_fermion = .false.
      if (nlo_corr_type == "QCD") then
         is_corresponding_fermion = is_quark (pdg_nr)
      else if (nlo_corr_type == "EW") then
         is_corresponding_fermion = is_fermion (pdg_nr)
      end if
    end function is_corresponding_fermion
    function is_massive_vectorboson (pdg_nr, nlo_corr_type)
      logical :: is_massive_vectorboson
      integer, intent(in) :: pdg_nr
      type(string_t), intent(in) :: nlo_corr_type
      is_massive_vectorboson = .false.
      if (nlo_corr_type == "EW") then
         is_massive_vectorboson = is_massive_vector (pdg_nr)
      end if
    end function is_massive_vectorboson
  end subroutine virtual_init_constants

@ %def virtual_init_constants
@ Set the renormalization scale. If the input is zero, use the
center-of-mass energy.
<<Virtual: virtual: TBP>>=
  procedure :: set_ren_scale => virtual_set_ren_scale
<<Virtual: sub interfaces>>=
    module subroutine virtual_set_ren_scale (virt, ren_scale)
      class(virtual_t), intent(inout) :: virt
      real(default), allocatable, intent(in) :: ren_scale
    end subroutine virtual_set_ren_scale
<<Virtual: procedures>>=
  module subroutine virtual_set_ren_scale (virt, ren_scale)
    class(virtual_t), intent(inout) :: virt
    real(default), allocatable, intent(in) :: ren_scale
    if (allocated (ren_scale)) then
       if (allocated (virt%ren_scale)) then
          virt%ren_scale = ren_scale
       else
          allocate (virt%ren_scale, source=ren_scale)
       end if
    end if
  end subroutine virtual_set_ren_scale

@ %def virtual_set_ren_scale
@
<<Virtual: virtual: TBP>>=
  procedure :: set_fac_scale => virtual_set_fac_scale
<<Virtual: sub interfaces>>=
    module subroutine virtual_set_fac_scale (virt, p, fac_scale)
      class(virtual_t), intent(inout) :: virt
      type(vector4_t), dimension(:), intent(in) :: p
      real(default), intent(in), optional :: fac_scale
    end subroutine virtual_set_fac_scale
<<Virtual: procedures>>=
  module subroutine virtual_set_fac_scale (virt, p, fac_scale)
    class(virtual_t), intent(inout) :: virt
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), intent(in), optional :: fac_scale
    if (present (fac_scale)) then
       virt%fac_scale = fac_scale
    else
       virt%fac_scale = (p(1) + p(2))**1
    end if
  end subroutine virtual_set_fac_scale

@ %def virtual_set_fac_scale
<<Virtual: virtual: TBP>>=
  procedure :: set_ellis_sexton_scale => virtual_set_ellis_sexton_scale
<<Virtual: sub interfaces>>=
    module subroutine virtual_set_ellis_sexton_scale (virt, Q)
      class(virtual_t), intent(inout) :: virt
      real(default), allocatable, intent(in) :: Q
    end subroutine virtual_set_ellis_sexton_scale
<<Virtual: procedures>>=
  module subroutine virtual_set_ellis_sexton_scale (virt, Q)
    class(virtual_t), intent(inout) :: virt
    real(default), allocatable, intent(in) :: Q
    if (allocated (Q)) then
       if (allocated (virt%es_scale2)) then
          virt%es_scale2 = Q * Q
       else
          allocate (virt%es_scale2, source=Q*Q)
       end if
    end if
  end subroutine virtual_set_ellis_sexton_scale

@ %def virtual_set_ellis_sexton_scale
@ The virtual-subtracted matrix element is given by the equation
\begin{equation}
  \label{eqn:virt_sub}
  \mathcal{V} = \frac{\alpha_s}{2\pi}\left(\mathcal{Q}\mathcal{B} +
  \sum \mathcal{I}_{ij}\mathcal{B}_{ij} + \mathcal{V}_{fin}\right),
\end{equation}
The expressions for $\mathcal{Q}$ can be found in equations
\ref{eqn:virt_Q_isr} and \ref{eqn:virt_Q_fsr}.
The expressions for $\mathcal{I}_{ij}$ can be found in equations
(\ref{I_00}), (\ref{I_mm}), (\ref{I_0m}), depending on whether the
particles involved in the radiation process are massive or massless.

If two or more flavor structures would produce the same amplitude we
only compute one and use the [[eqv_index]] to copy the result to the
others (if [[reuse_amplitudes_fks]] is true).

The Ellis-Sexton scale is set when explicitly allocated; if not it
first is set to the renormalization scale; if that it is not set it
will be set to the factorization scale which is the scale used for the
virtual corrections.
<<Virtual: virtual: TBP>>=
  procedure :: evaluate => virtual_evaluate
<<Virtual: sub interfaces>>=
    module subroutine virtual_evaluate (virt, reg_data, alpha_coupling, &
         p_born, separate_uborns, sqme_virt)
      class(virtual_t), intent(inout) :: virt
      type(region_data_t), intent(in) :: reg_data
      real(default), dimension(2), intent(in) :: alpha_coupling
      type(vector4_t), intent(in), dimension(:)  :: p_born
      logical, intent(in) :: separate_uborns
      real(default), dimension(:), intent(inout) :: sqme_virt
    end subroutine virtual_evaluate
<<Virtual: procedures>>=
  module subroutine virtual_evaluate (virt, reg_data, alpha_coupling, &
       p_born, separate_uborns, sqme_virt)
    class(virtual_t), intent(inout) :: virt
    type(region_data_t), intent(in) :: reg_data
    real(default), dimension(2), intent(in) :: alpha_coupling
    type(vector4_t), intent(in), dimension(:)  :: p_born
    logical, intent(in) :: separate_uborns
    real(default), dimension(:), intent(inout) :: sqme_virt
    integer, dimension(:), allocatable :: eqv_flv_index
    real(default), dimension(:), allocatable :: sqme_virt_arr
    real(default) :: s, s_o_Q2, es_scale2
    real(default), dimension(reg_data%n_flv_born) :: QB, BI
    integer :: i_flv, ii_flv, alr, i_corr
    logical, dimension(:), allocatable :: flv_evaluated
    integer, dimension(:), allocatable :: corr_index
    logical :: alr_qcd, alr_ew
    allocate (flv_evaluated(reg_data%n_flv_born))
    allocate (sqme_virt_arr(reg_data%n_flv_born))
    sqme_virt_arr = zero
    flv_evaluated = .false.
    if (virt%bad_point) return
    if (allocated (virt%es_scale2)) then
       es_scale2 = virt%es_scale2
    else
       if (allocated (virt%ren_scale)) then
          es_scale2 = virt%ren_scale**2
       else
          es_scale2 = virt%fac_scale**2
       end if
    end if
    if (debug2_active (D_VIRTUAL)) then
       print *, 'Compute virtual component using alpha = ', alpha_coupling
       print *, 'Virtual selection: ', char (virt%selection)
       print *, 'virt%es_scale2 =    ', es_scale2 !!! Debugging
    end if
    s = sum (p_born(1 : virt%n_in))**2
    if (virt%settings%factorization_mode == FACTORIZATION_THRESHOLD) &
         call set_s_for_threshold ()
    s_o_Q2 = s / es_scale2 * virt%settings%fks_template%xi_cut**2
    eqv_flv_index = reg_data%eqv_flv_index_born
    do i_flv = 1, reg_data%n_flv_born
       alr_qcd = .false.; alr_ew = .false.
       do alr = 1, reg_data%n_regions
          if (i_flv == reg_data%regions(alr)%uborn_index) then
             if (reg_data%regions(alr)%nlo_correction_type == "QCD") then
                alr_qcd = .true.
             else if (reg_data%regions(alr)%nlo_correction_type == "EW") then
                alr_ew = .true.
             end if
          end if
       end do
       if (alr_qcd .and. alr_ew) then
          allocate (corr_index (2))
          corr_index (1) = 1; corr_index (2) = 2
       else
          allocate (corr_index (1))
          corr_index (1) = 0
          if (alr_qcd) then
             corr_index (1) = 1
          else if (alr_ew) then
             corr_index (1) = 2
          end if
       end if
       if (.not. flv_evaluated(eqv_flv_index(i_flv)) .and. corr_index(1) > 0) then
          if (virt%selection == var_str ("Full") .or. virt%selection == var_str ("OLP")) then
             !!! A factor of alpha_coupling/twopi is assumed to be included in vfin
             sqme_virt_arr(i_flv) = sqme_virt_arr(i_flv) + virt%sqme_virt_fin(i_flv)
          end if
          do i_corr = 1, size (corr_index)
             QB = zero; BI = zero
             if (virt%selection == var_str ("Full") .or. &
                  virt%selection == var_str ("Subtraction")) then
                call virt%evaluate_initial_state (i_flv, corr_index (i_corr), reg_data, QB)
                call virt%compute_collinear_contribution &
                     (i_flv, corr_index (i_corr), p_born, sqrt(s), reg_data, QB)
                select case (virt%settings%factorization_mode)
                case (FACTORIZATION_THRESHOLD)
                   call virt%compute_eikonals_threshold (i_flv, p_born, s_o_Q2, QB, BI)
                case default
                   call virt%compute_massive_self_eikonals &
                        (i_flv, corr_index (i_corr), p_born, s_o_Q2, reg_data, QB)
                   call virt%compute_eikonals &
                        (i_flv, corr_index (i_corr), p_born, s_o_Q2, reg_data, BI)
                end select
                if (debug2_active (D_VIRTUAL)) then
                   if (corr_index (i_corr) == 1) then
                      print *, 'Correction type: QCD'
                   else
                      print *, 'Correction type: EW'
                   end if
                   print *, 'Evaluate i_flv: ', i_flv
                   print *, 'sqme_born: ', virt%sqme_born (i_flv)
                   print *, 'Q * sqme_born: ', alpha_coupling / twopi * QB(i_flv)
                   print *, 'BI: ', alpha_coupling / twopi * BI(i_flv)
                   print *, 'vfin: ', virt%sqme_virt_fin (i_flv)
                end if
                sqme_virt_arr(i_flv) = sqme_virt_arr(i_flv) &
                      + alpha_coupling (corr_index (i_corr))/ twopi * (QB(i_flv) + BI(i_flv))
             end if
          end do
          if (.not. (debug_active (D_VIRTUAL) .or. &
               debug2_active (D_VIRTUAL))) flv_evaluated(eqv_flv_index(i_flv)) = .true.
       else
          sqme_virt_arr(i_flv) = sqme_virt_arr(eqv_flv_index(i_flv))
       end if
       if (separate_uborns) then
          sqme_virt(i_flv) = sqme_virt(i_flv) + sqme_virt_arr(i_flv)
       else
          sqme_virt(1) = sqme_virt(1) + sqme_virt_arr(i_flv)
       end if
       deallocate (corr_index)
    end do
    if (debug2_active (D_VIRTUAL)) then
       call msg_debug2 (D_VIRTUAL, "virtual-subtracted matrix element(s): ")
       print *, sqme_virt
    end if
    do i_flv = 1, reg_data%n_flv_born
       if (virt%n_is_neutrinos(i_flv) > 0) &
            sqme_virt = sqme_virt * virt%n_is_neutrinos(i_flv) * two
    end do
  contains
    subroutine set_s_for_threshold ()
      use ttv_formfactors, only: m1s_to_mpole
      real(default) :: mtop2
      mtop2 = m1s_to_mpole (sqrt(s))**2
      if (s < four * mtop2) s = four * mtop2
    end subroutine set_s_for_threshold

  end subroutine virtual_evaluate

@ %def virtual_evaluate
@
<<Virtual: virtual: TBP>>=
  procedure :: compute_eikonals => virtual_compute_eikonals
<<Virtual: sub interfaces>>=
    module subroutine virtual_compute_eikonals (virtual, i_flv, i_corr, &
         p_born, s_o_Q2, reg_data, BI)
      class(virtual_t), intent(inout) :: virtual
      integer, intent(in) :: i_flv, i_corr
      type(vector4_t), intent(in), dimension(:)  :: p_born
      real(default), intent(in) :: s_o_Q2
      type(region_data_t), intent(in) :: reg_data
      real(default), intent(inout), dimension(:) :: BI
    end subroutine virtual_compute_eikonals
<<Virtual: procedures>>=
  module subroutine virtual_compute_eikonals (virtual, i_flv, i_corr, &
       p_born, s_o_Q2, reg_data, BI)
    class(virtual_t), intent(inout) :: virtual
    integer, intent(in) :: i_flv, i_corr
    type(vector4_t), intent(in), dimension(:)  :: p_born
    real(default), intent(in) :: s_o_Q2
    type(region_data_t), intent(in) :: reg_data
    real(default), intent(inout), dimension(:) :: BI
    integer :: i, j
    real(default) :: I_ij, BI_tmp
    BI_tmp = zero
    ! TODO vincent_r: Split the procedure into one computing QCD eikonals
    ! and one computing QED eikonals.
    ! TODO vincent_r: In the best case, remove the dependency on
    ! reg_data completely.
    associate (flst_born => reg_data%flv_born(i_flv))
       do i = 1, virtual%n_legs
          do j = 1, virtual%n_legs
             if (i /= j) then
                if (i_corr == 1) then
                   if (flst_born%colored(i) .and. flst_born%colored(j)) then
                      I_ij = compute_eikonal_factor &
                           (p_born, flst_born%massive, i, j, s_o_Q2)
                      BI_tmp = BI_tmp + &
                           virtual%sqme_color_c (i, j, i_flv) * I_ij
                      if (debug2_active (D_VIRTUAL)) &
                           print *, 'b_ij: ', i, j, &
                           virtual%sqme_color_c (i, j, i_flv), 'I_ij: ', I_ij
                   end if
                else if (i_corr == 2) then
                   if (flst_born%charge (i) /= 0 .and. flst_born%charge(j) /= 0) then
                      I_ij = compute_eikonal_factor (p_born, flst_born%massive, &
                           i, j, s_o_Q2)
                      BI_tmp = BI_tmp + virtual%sqme_charge_c (i, j, i_flv) * I_ij
                      if (debug2_active (D_VIRTUAL)) &
                           print *, 'b_ij: ', &
                           virtual%sqme_charge_c (i, j, i_flv), 'I_ij: ', I_ij
                   end if
                end if
             else if (debug2_active (D_VIRTUAL)) then
                if (i_corr == 1) then
                   print *, 'b_ij: ', i, j, &
                        virtual%sqme_color_c (i, j, i_flv), 'I_ij: ', I_ij
                else if (i_corr == 2) then
                   print *, 'b_ij: ', i, j, &
                        virtual%sqme_charge_c (i, j, i_flv), 'I_ij: ', I_ij
                end if
             end if
          end do
       end do
       if (virtual%settings%use_internal_color_correlations .or. i_corr == 2) &
            BI_tmp = BI_tmp * virtual%sqme_born (i_flv)
    end associate
    BI(i_flv) = BI(i_flv) + BI_tmp
  end subroutine virtual_compute_eikonals

@ %def virtual_compute_eikonals
@
<<Virtual: virtual: TBP>>=
  procedure :: compute_eikonals_threshold => virtual_compute_eikonals_threshold
<<Virtual: sub interfaces>>=
    module subroutine virtual_compute_eikonals_threshold (virtual, i_flv, &
           p_born, s_o_Q2, QB, BI)
      class(virtual_t), intent(in) :: virtual
      integer, intent(in) :: i_flv
      type(vector4_t), intent(in), dimension(:) :: p_born
      real(default), intent(in) :: s_o_Q2
      real(default), intent(inout), dimension(:) :: QB
      real(default), intent(inout), dimension(:) :: BI
    end subroutine virtual_compute_eikonals_threshold
<<Virtual: procedures>>=
  module subroutine virtual_compute_eikonals_threshold (virtual, i_flv, &
         p_born, s_o_Q2, QB, BI)
    class(virtual_t), intent(in) :: virtual
    integer, intent(in) :: i_flv
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: s_o_Q2
    real(default), intent(inout), dimension(:) :: QB
    real(default), intent(inout), dimension(:) :: BI
    type(vector4_t), dimension(4) :: p_thr
    integer :: leg
    BI = zero; p_thr = get_threshold_momenta (p_born)
    call compute_massive_self_eikonals (virtual%sqme_born(i_flv), QB(i_flv))
    do leg = 1, 2
       BI(i_flv) = BI(i_flv) + evaluate_leg_pair (ASSOCIATED_LEG_PAIR(leg), i_flv)
    end do
  contains
    subroutine compute_massive_self_eikonals (sqme_born, QB)
      real(default), intent(in) :: sqme_born
      real(default), intent(inout) :: QB
      integer :: i
      if (debug_on) call msg_debug2 (D_VIRTUAL, "compute_massive_self_eikonals")
      if (debug_on) call msg_debug2 (D_VIRTUAL, "s_o_Q2", s_o_Q2)
      if (debug_on) call msg_debug2 (D_VIRTUAL, "log (s_o_Q2)", log (s_o_Q2))
      do i = 1, 4
         QB = QB - (cf * (log (s_o_Q2) - 0.5_default * I_m_eps (p_thr(i)))) &
              * sqme_born
      end do
    end subroutine compute_massive_self_eikonals

    function evaluate_leg_pair (i_start, i_flv) result (b_ij_times_I)
      real(default) :: b_ij_times_I
      integer, intent(in) :: i_start, i_flv
      real(default) :: I_ij
      integer :: i, j
      b_ij_times_I = zero
      do i = i_start, i_start + 1
         do j = i_start, i_start + 1
            if (i /= j) then
               I_ij = compute_eikonal_factor &
                    (p_thr, [.true., .true., .true., .true.], i, j, s_o_Q2)
               b_ij_times_I = b_ij_times_I + &
                    virtual%sqme_color_c (i, j, i_flv) * I_ij
               if (debug2_active (D_VIRTUAL)) &
                  print *, 'b_ij: ', virtual%sqme_color_c (i, j, i_flv), 'I_ij: ', I_ij
            end if
         end do
      end do
      if (virtual%settings%use_internal_color_correlations) &
           b_ij_times_I = b_ij_times_I * virtual%sqme_born (i_flv)
      if (debug2_active (D_VIRTUAL)) then
         print *, 'internal color: ', virtual%settings%use_internal_color_correlations
         print *, 'b_ij_times_I =    ', b_ij_times_I
         print *, 'QB           =    ', QB
      end if
    end function evaluate_leg_pair
  end subroutine virtual_compute_eikonals_threshold

@ %def virtual_compute_eikonals_threshold
@
<<Virtual: virtual: TBP>>=
  procedure :: set_bad_point => virtual_set_bad_point
<<Virtual: sub interfaces>>=
    module subroutine virtual_set_bad_point (virt, value)
      class(virtual_t), intent(inout) :: virt
      logical, intent(in) :: value
    end subroutine virtual_set_bad_point
<<Virtual: procedures>>=
  module subroutine virtual_set_bad_point (virt, value)
    class(virtual_t), intent(inout) :: virt
    logical, intent(in) :: value
    virt%bad_point = value
  end subroutine virtual_set_bad_point

@  %def virtual_set_bad_point
@ The collinear limit of $\tilde{\mathcal{R}}$ can be integrated over
the radiation degrees of freedom, giving the collinear contribution to
the virtual component. Its general structure is $\mathcal{Q} \cdot
\mathcal{B}$. The initial-state contribution to $\mathcal{Q}$ is
simply given by
\begin{equation}
  \label{eqn:virt_Q_isr}
  \mathcal{Q} = -\log\frac{\mu_F^2}{Q^2} \left(\gamma(\mathcal{I}_1) + 2 C
  (\mathcal{I}_1) \log(\xi_{\text{cut}}) + \gamma(\mathcal{I}_2) + 2 C (\mathcal{I}_2)
  \log(\xi_{\text{cut}}) \right),
\end{equation}
where $Q^2$ is the Ellis-Sexton scale and $\gamma$ is as in eqns. \ref{eqn:gamma(q)}
and \ref{eqn:gamma(g)}.\\
[[virtual_evaluate_initial_state]] computes this quantity. The loop over the
initial-state particles is only executed if we are
dealing with a scattering process, because for decays there are no virtual
initial-initial interactions.
<<Virtual: virtual: TBP>>=
  procedure :: evaluate_initial_state => virtual_evaluate_initial_state
<<Virtual: sub interfaces>>=
    module subroutine virtual_evaluate_initial_state &
         (virt, i_flv, i_corr, reg_data, QB)
      class(virtual_t), intent(inout) :: virt
      type(region_data_t), intent(in) :: reg_data
      integer, intent(in) :: i_flv, i_corr
      real(default), intent(inout), dimension(:) :: QB
    end subroutine virtual_evaluate_initial_state
<<Virtual: procedures>>=
  module subroutine virtual_evaluate_initial_state &
       (virt, i_flv, i_corr, reg_data, QB)
    class(virtual_t), intent(inout) :: virt
    type(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_flv, i_corr
    real(default), intent(inout), dimension(:) :: QB
    real(default) :: sqme_born_virt, es_scale2
    integer :: i
    if (allocated (virt%es_scale2)) then
       es_scale2 = virt%es_scale2
    else
       if (allocated (virt%ren_scale)) then
          es_scale2 = virt%ren_scale**2
       else
          es_scale2 = virt%fac_scale**2
       end if
    end if
    sqme_born_virt = zero
    if (reg_data%nlo_correction_type == "EW" .and. i_corr == 1 &
       .and. qcd_ew_interferences (reg_data%flv_born(i_flv)%flst)) then
       do i = 1, size (reg_data%flv_born(i_flv)%flst)
          if (is_quark (reg_data%flv_born(i_flv)%flst (i))) then
             sqme_born_virt = -virt%sqme_color_c (i, i, i_flv)/CF
             exit
          end if
       end do
    else
       sqme_born_virt = virt%sqme_born (i_flv)
    end if
    if (virt%n_in == 2) then
       do i = 1, virt%n_in
          QB(i_flv) = QB(i_flv) - (virt%gamma_0 (i, i_flv, i_corr) &
               + two * virt%c_flv(i, i_flv, i_corr) &
               * log (virt%settings%fks_template%xi_cut)) &
               * log(virt%fac_scale**2 / es_scale2) * sqme_born_virt
       end do
    end if
  end subroutine virtual_evaluate_initial_state

@ %def virtual_evaluate_initial_state
@ Same as above, but for final-state particles. The collinear limit
for final-state particles follows from the integral
\begin{equation*}
  I_{+,\alpha_r} = \int d\Phi_{n+1}
  \frac{\xi_+^{-1-2\epsilon}}{\xi^{-1-2\epsilon}}
  \mathcal{R}_{\alpha_r}.
\end{equation*}
We can distinguish three situations:
\begin{enumerate}
  \item $\alpha_r$ contains a massive emitter. In this case, no
    collinear subtraction term is required and the integral above is
    irrelevant.
  \item $\alpha_r$ contains a massless emitter, but resonances are not
    taken into account in the subtraction. Here, $\xi_{max} =
    \frac{2E_{em}}{\sqrt{s}}$ is the upper bound on $\xi$.
  \item $\alpha_r$ contains a massless emitter and resonance-aware
    subtraction is used. Here, $\xi_{max} =
    \frac{2E_{em}}{\sqrt{k_{res}^2}}$.
\end{enumerate}
Before version 2.4, only situations 1 and 2 were covered. The
difference between situation 2 and 3 comes from the expansion of the
plus-distribution in the integral above,
\begin{equation*}
  \xi_+^{-1-2\epsilon} = \xi^{-1-2\epsilon} +
  \frac{1}{2\epsilon}\delta(\xi) =
  \xi_{max}^{-1-2\epsilon}\left[(1-z)^{-1-2\epsilon} +
    \frac{\xi_{max}^{2\epsilon}}{2\epsilon}\delta(1-z)\right].
\end{equation*}
The expression from the standard FKS literature is given by
$\mathcal{Q}$ is given by
\begin{equation}
  \label{eqn:virt_Q_fsr_old}
  \begin{split}
   \mathcal{Q} = \sum_{k=n_{in}}^{n_L^{(B)}} \left[\gamma'(\mathcal{I}_k)
     - \log\frac{s\delta_o}{2Q^2}\left(\gamma(\mathcal{I}_k)
     - 2C(\mathcal{I}_k)
     \log\frac{2E_k}{\xi_{\text{cut}}\sqrt{s}}\right) \right.\\
     + \left. 2C(\mathcal{I}_k) \left( \log^2\frac{2E_k}{\sqrt{s}} -
     \log^2 \xi_{\text{cut}} \right)
     - 2\gamma(\mathcal{I}_k)\log\frac{2E_k}{\sqrt{s}}\right].
  \end{split}
\end{equation}
$n_L^{(B)}$ is the number of legs at Born level. Here, $\xi_{max}$ is
implicitly present in the ratios in the logarithms. Using the
resonance-aware $\xi_{max}$ yields
\begin{equation}
  \label{eqn:virt_Q_fsr}
  \begin{split}
    \mathcal{Q} = \sum_{k=n_{in}}^{n_L^{(B)}} \left[\gamma'(\mathcal{I}_k)
      + 2\left(\log\frac{\sqrt{s}}{2E_{em}} + \log\xi_{max}\right)
      \left(\log\frac{\sqrt{s}}{2E_{em}} + \log\xi_{max} +
      \log\frac{Q^2}{s}\right) C(\mathcal{I}_k) \right.\\
      + \left. 2 \log\xi_{max} \left(\log\xi_{max} -
      \log\frac{Q^2}{k_{res}^2}\right) C(\mathcal{I}_k)
      + \left(\log\frac{Q^2}{k_{res}^2} - 2 \log\xi_{max}\right)
      \gamma(\mathcal{I}_k)\right].
  \end{split}
\end{equation}
Equation \ref{eqn:virt_Q_fsr} leads to \ref{eqn:virt_Q_fsr_old} with
the substitutions $\xi_{max} \rightarrow \frac{2E_{em}}{\sqrt{s}}$ and
$k_{res}^2 \rightarrow s$. [[virtual_compute_collinear_contribution]]
only implements the second one.
<<Virtual: virtual: TBP>>=
  procedure :: compute_collinear_contribution &
     => virtual_compute_collinear_contribution
<<Virtual: sub interfaces>>=
    module subroutine virtual_compute_collinear_contribution &
         (virt, i_flv, i_corr, p_born, sqrts, reg_data, QB)
      class(virtual_t), intent(inout) :: virt
      integer, intent(in) :: i_flv, i_corr
      type(vector4_t), dimension(:), intent(in) :: p_born
      real(default), intent(in) :: sqrts
      type(region_data_t), intent(in) :: reg_data
      real(default), intent(inout), dimension(:) :: QB
    end subroutine virtual_compute_collinear_contribution
<<Virtual: procedures>>=
  module subroutine virtual_compute_collinear_contribution &
       (virt, i_flv, i_corr, p_born, sqrts, reg_data, QB)
    class(virtual_t), intent(inout) :: virt
    integer, intent(in) :: i_flv, i_corr
    type(vector4_t), dimension(:), intent(in) :: p_born
    real(default), intent(in) :: sqrts
    type(region_data_t), intent(in) :: reg_data
    real(default), intent(inout), dimension(:) :: QB
    real(default) :: s1, s2, s3, s4, s5
    real(default) :: sqme_born_virt
    integer :: alr, em, i
    real(default) :: E_em, xi_max, log_xi_max, E_tot2, es_scale2
    logical, dimension(virt%n_flv, virt%n_legs) :: evaluated
    integer :: i_contr
    type(vector4_t) :: k_res
    type(lorentz_transformation_t) :: L_to_resonance
    evaluated = .false.
    if (allocated (virt%es_scale2)) then
       es_scale2 = virt%es_scale2
    else
       if (allocated (virt%ren_scale)) then
          es_scale2 = virt%ren_scale**2
       else
          es_scale2 = virt%fac_scale**2
       end if
    end if
    sqme_born_virt = zero
    if (reg_data%nlo_correction_type == "EW" .and. i_corr == 1 &
       .and. qcd_ew_interferences (reg_data%flv_born(i_flv)%flst)) then
       do i = 1, size (reg_data%flv_born(i_flv)%flst)
          if (is_quark (reg_data%flv_born(i_flv)%flst (i))) then
             sqme_born_virt = -virt%sqme_color_c (i, i, i_flv)/CF
             exit
          end if
       end do
    else
       sqme_born_virt = virt%sqme_born (i_flv)
    end if
    do alr = 1, reg_data%n_regions
       if (i_flv /= reg_data%regions(alr)%uborn_index) cycle
       em = reg_data%regions(alr)%emitter
       if (em <= virt%n_in) cycle
       if (evaluated(i_flv, em)) cycle
       !!! Collinear terms only for massless particles
       if (reg_data%regions(alr)%flst_uborn%massive(em)) cycle
       E_em = p_born(em)%p(0)
       if (allocated (reg_data%alr_contributors)) then
          i_contr = reg_data%alr_to_i_contributor (alr)
          k_res = get_resonance_momentum (p_born, reg_data%alr_contributors(i_contr)%c)
          E_tot2 = k_res%p(0)**2
          L_to_resonance = inverse (boost (k_res, k_res**1))
          xi_max = two * space_part_norm (L_to_resonance * p_born(em)) / k_res%p(0)
       else
          E_tot2 = sqrts**2
          xi_max = two * E_em / sqrts
       end if
       log_xi_max = log (xi_max)
       associate (xi_cut => virt%settings%fks_template%xi_cut, delta_o => virt%settings%fks_template%delta_o)
         if (virt%settings%virtual_resonance_aware_collinear) then
            if (debug_active (D_VIRTUAL)) &
                 call msg_debug (D_VIRTUAL, "Using resonance-aware collinear subtraction")
            s1 = virt%gamma_p(em, i_flv, i_corr)
            s2 = two * (log (sqrts / (two * E_em)) + log_xi_max) * &
                 (log (sqrts / (two * E_em)) + log_xi_max + log (es_scale2 / sqrts**2)) &
                 * virt%c_flv(em, i_flv, i_corr)
            s3 = two * log_xi_max * &
                 (log_xi_max - log (es_scale2 / E_tot2)) * virt%c_flv(em, i_flv, i_corr)
            s4 = (log (es_scale2 / E_tot2) - two * log_xi_max) &
                 * virt%gamma_0(em, i_flv, i_corr)
            QB(i_flv) = QB(i_flv) + (s1 + s2 + s3 + s4) * sqme_born_virt
         else
            if (debug_active (D_VIRTUAL)) &
                 call msg_debug (D_VIRTUAL, "Using old-fashioned collinear subtraction")
            s1 = virt%gamma_p(em, i_flv, i_corr)
            s2 = log (delta_o * sqrts**2 / (two * es_scale2)) &
                 * virt%gamma_0(em,i_flv, i_corr)
            s3 = log (delta_o * sqrts**2 / (two * es_scale2)) * two &
                 * virt%c_flv(em,i_flv, i_corr) * log (two * E_em / (xi_cut * sqrts))
            ! s4 = two * virt%c_flv(em,i_flv, i_corr) * (log (two * E_em / sqrts)**2 - log (xi_cut)**2)
            s4 = two * virt%c_flv(em,i_flv, i_corr) * & ! a**2 - b**2 = (a - b) * (a + b), for better numerical performance
                 (log (two * E_em / sqrts) + log (xi_cut)) * (log (two * E_em / sqrts) - log (xi_cut))
            s5 = two * virt%gamma_0(em,i_flv, i_corr) * log (two * E_em / sqrts)
            QB(i_flv) = QB(i_flv) + (s1 - s2 + s3 + s4 - s5) * sqme_born_virt
         end if
       end associate
       evaluated(i_flv, em) = .true.
    end do
  end subroutine virtual_compute_collinear_contribution

@ %def virtual_compute_collinear_contribution
@ For the massless-massive case and $i = j$ we get the massive
self-eikonal of (A.10) in arXiv:0908.4272, given as
\begin{equation}
  \mathcal{I}_{ii} = \log \frac{\xi^2_{\text{cut}}s}{Q^2} -
  \frac{1}{\beta} \log \frac{1 + \beta}{1 - \beta}.
\end{equation}
<<Virtual: virtual: TBP>>=
  procedure :: compute_massive_self_eikonals => &
       virtual_compute_massive_self_eikonals
<<Virtual: sub interfaces>>=
    module subroutine virtual_compute_massive_self_eikonals (virt, &
         i_flv, i_corr, p_born, s_over_Q2, reg_data,  QB)
      class(virtual_t), intent(inout) :: virt
      integer, intent(in) :: i_flv, i_corr
      type(vector4_t), intent(in), dimension(:) :: p_born
      real(default), intent(in) :: s_over_Q2
      type(region_data_t), intent(in) :: reg_data
      real(default), intent(inout), dimension(:) :: QB
    end subroutine virtual_compute_massive_self_eikonals
<<Virtual: procedures>>=
  module subroutine virtual_compute_massive_self_eikonals (virt, &
       i_flv, i_corr, p_born, s_over_Q2, reg_data,  QB)
    class(virtual_t), intent(inout) :: virt
    integer, intent(in) :: i_flv, i_corr
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: s_over_Q2
    type(region_data_t), intent(in) :: reg_data
    real(default), intent(inout), dimension(:) :: QB
    real(default) :: sqme_born_virt
    integer :: i
    logical :: massive
    sqme_born_virt = zero
    if (reg_data%nlo_correction_type == "EW" .and. i_corr == 1 &
       .and. qcd_ew_interferences (reg_data%flv_born(i_flv)%flst)) then
       do i = 1, size (reg_data%flv_born(i_flv)%flst)
          if (is_quark (reg_data%flv_born(i_flv)%flst (i))) then
             sqme_born_virt = -virt%sqme_color_c (i, i, i_flv)/CF
             exit
          end if
       end do
    else
       sqme_born_virt = virt%sqme_born (i_flv)
    end if
    do i = 1, virt%n_legs
       massive = reg_data%flv_born(i_flv)%massive(i)
       if (massive) then
          if (virt%c_flv (i, i_flv, i_corr) /= 0) then
             QB(i_flv) = QB(i_flv) - (virt%c_flv (i, i_flv, i_corr) &
                  * (log (s_over_Q2) - 0.5_default * I_m_eps (p_born(i)))) &
                  * sqme_born_virt
          end if
       end if
    end do
  end subroutine virtual_compute_massive_self_eikonals

@ %def virtual_compute_massive_self_eikonals
@ The following code implements the $\mathcal{I}_{ij}$-function.
The complete formulas can be found in arXiv:0908.4272 (A.1-A.17) and are also discussed in arXiv:1002.2581 in Appendix A.
The implementation may differ in the detail from the formulas presented in the above paper.
The parameter $\xi_{\text{cut}}$ is unphysically and cancels with appropriate factors in the real subtraction.
We keep the additional parameter for debug usage.
The implemented formulas are then defined as follows:
\begin{itemize}
\item[massless-massless case]
  $p^2 = 0, k^2 = 0,$
  \begin{equation}
    \begin{split}
    \mathcal{I}_{ij} &= \frac{1}{2}\log^2\frac{\xi^2_{\text{cut}}s}{Q^2} + \log\frac{\xi^2_{\text{cut}}s}{Q^2}\log\frac{k_ik_j}{2E_iE_j} - \rm{Li}_2\left(\frac{k_ik_j}{2E_iE_j}\right) \\
                     &+ \frac{1}{2}\log^2\frac{k_ik_j}{2E_iE_j} - \log\left(1-\frac{k_ik_j}{2E_iE_j}\right) \log\frac{k_ik_j}{2E_iE_j}.
    \end{split}
    \label{I_00}
  \end{equation}
\item[massive-massive case]
  $p^2 \neq 0, k^2 \neq 0,$
  \begin{equation}
     \mathcal{I}_{ij} = \frac{1}{2}I_0(k_i, k_j)\log\frac{\xi^2_{\text{cut}}s}{Q^2} - \frac{1}{2}I_\epsilon(k_i,k_j)
     \label{I_mm}
  \end{equation}
  with
  \begin{equation}
    I_0(k_i, k_j) = \frac{1}{\beta}\log\frac{1+\beta}{1-\beta}, \qquad \beta = \sqrt{1-\frac{k_i^2k_j^2}{(k_i \cdot k_j)^2}}
  \end{equation}
  and a rather involved expression for $I_\epsilon$:
  \begin{align}
    \allowdisplaybreaks
    I_\epsilon(k_i, k_j) &= \left(K(z_j)-K(z_i)\right) \frac{1-\vec{\beta_i}\cdot\vec{\beta_j}}{\sqrt{a(1-b)}}, \\
    \vec{\beta_i} &= \frac{\vec{k}_i}{k_i^0}, \\
    a &= \beta_i^2 + \beta_j^2 - 2\vec{\beta}_i \cdot \vec{\beta}_j, \\
    x_i &= \frac{\beta_i^2 -\vec{\beta}_i \cdot \vec{\beta}_j}{a}, \\
    x_j &= \frac{\beta_j^2 -\vec{\beta}_i \cdot \vec{\beta}_j}{a} = 1-x_j, \\
    b &= \frac{\beta_i^2\beta_j^2 - (\vec{\beta}_i\cdot\vec{\beta}_j)^2}{a}, \\
    c &= \sqrt{\frac{b}{4a}}, \\
    z_+ &= \frac{1+\sqrt{1-b}}{\sqrt{b}}, \\
    z_- &= \frac{1-\sqrt{1-b}}{\sqrt{b}}, \\
    z_i &= \frac{\sqrt{x_i^2 + 4c^2} - x_i}{2c}, \\
    z_j &= \frac{\sqrt{x_j^2 + 4c^2} + x_j}{2c}, \\
    K(z) = &-\frac{1}{2}\log^2\frac{(z-z_-)(z_+-z)}{(z_++z)(z_-+z)} - 2Li_2\left(\frac{2z_-(z_+-z)}{(z_+-z_-)(z_-+z)}\right) \\
           &-2Li_2\left(-\frac{2z_+(z_-+z)}{(z_+-z_-)(z_+-z)}\right)
  \end{align}

\item[massless-massive case]
  $p^2 = 0, k^2 \neq 0,$
  \begin{equation}
     \mathcal{I}_{ij} = \frac{1}{2}\left[\frac{1}{2}\log^2\frac{\xi^2_{\text{cut}}s}{Q^2} - \frac{\pi^2}{6}\right] + \frac{1}{2}I_0(k_i,k_j)\log\frac{\xi^2_{\text{cut}}s}{Q^2} - \frac{1}{2}I_\epsilon(k_i,k_j)
     \label{I_0m}
  \end{equation}
  with
  \begin{align}
     I_0(p,k) &= \log\frac{(\hat{p}\cdot\hat{k})^2}{\hat{k}^2}, \\
     I_\varepsilon(p,k) &= -2\left[\frac{1}{4}\log^2\frac{1-\beta}{1+\beta} + \log\frac{\hat{p}\cdot\hat{k}}{1+\beta}\log\frac{\hat{p}\cdot\hat{k}}{1-\beta} + \rm{Li}_2\left(1-\frac{\hat{p}\cdot\hat{k}}{1+\beta}\right) + \rm{Li}_2\left(1-\frac{\hat{p}\cdot\hat{k}}{1-\beta}\right)\right],
  \end{align}
  using
  \begin{align}
    \hat{p} = \frac{p}{p^0}, \quad \hat{k} = \frac{k}{k^0}, \quad \beta = \frac{|\vec{k}|}{k_0}, \\
    \rm{Li}_2(1 - x) + \rm{Li}_2(1 - x^{-1}) = -\frac{1}{2} \log^2 x.
  \end{align}

\end{itemize}

<<Virtual: procedures>>=
  function compute_eikonal_factor (p_born, massive, i, j, s_o_Q2) result (I_ij)
    real(default) :: I_ij
    type(vector4_t), intent(in), dimension(:) :: p_born
    logical, dimension(:), intent(in) :: massive
    integer, intent(in) :: i, j
    real(default), intent(in) :: s_o_Q2
    if (massive(i) .and. massive(j)) then
       I_ij = compute_Imm (p_born(i), p_born(j), s_o_Q2)
    else if (.not. massive(i) .and. massive(j)) then
       I_ij = compute_I0m (p_born(i), p_born(j), s_o_Q2)
    else if (massive(i) .and. .not. massive(j)) then
       I_ij = compute_I0m (p_born(j), p_born(i), s_o_Q2)
    else
       I_ij = compute_I00 (p_born(i), p_born(j), s_o_Q2)
    end if
  end function compute_eikonal_factor

  function compute_I00 (pi, pj, s_o_Q2) result (I)
    type(vector4_t), intent(in) :: pi, pj
    real(default), intent(in) :: s_o_Q2
    real(default) :: I
    real(default) :: Ei, Ej
    real(default) :: pij, Eij
    real(default) :: s1, s2, s3, s4, s5
    real(default) :: arglog
    real(default), parameter :: tiny_value = epsilon(1.0)
    s1 = 0; s2 = 0; s3 = 0; s4 = 0; s5 = 0
    Ei = pi%p(0); Ej = pj%p(0)
    pij = pi * pj; Eij = Ei * Ej
    s1 = 0.5_default * log(s_o_Q2)**2
    s2 = log(s_o_Q2) * log(pij / (two * Eij))
    s3 = Li2 (pij / (two * Eij))
    s4 = 0.5_default * log (pij / (two * Eij))**2
    arglog = one - pij / (two * Eij)
    if (arglog > tiny_value) then
      s5 = log(arglog) * log(pij / (two * Eij))
    else
      s5 = zero
    end if
    I = s1 + s2 - s3 + s4 - s5
  end function compute_I00

  function compute_I0m (ki, kj, s_o_Q2) result (I)
    type(vector4_t), intent(in) :: ki, kj
    real(default), intent(in) :: s_o_Q2
    real(default) :: I
    real(default) :: logsomu
    real(default) :: s1, s2, s3
    s1 = 0; s2 = 0; s3 = 0
    logsomu = log(s_o_Q2)
    s1 = 0.5 * (0.5 * logsomu**2 - pi**2 / 6)
    s2 = 0.5 * I_0m_0 (ki, kj) * logsomu
    s3 = 0.5 * I_0m_eps (ki, kj)
    I = s1 + s2 - s3
  end function compute_I0m

  function compute_Imm (pi, pj, s_o_Q2) result (I)
    type(vector4_t), intent(in) :: pi, pj
    real(default), intent(in) :: s_o_Q2
    real(default) :: I
    real(default) :: s1, s2
    s1 = 0.5 * log(s_o_Q2) * I_mm_0(pi, pj)
    s2 = 0.5 * I_mm_eps(pi, pj)
    I = s1 - s2
  end function compute_Imm

  function I_m_eps (p) result (I)
    type(vector4_t), intent(in) :: p
    real(default) :: I
    real(default) :: beta
    beta = space_part_norm (p)/p%p(0)
    if (beta < tiny_07) then
       I = four * (one + beta**2/3 + beta**4/5 + beta**6/7)
    else
       I = two * log((one + beta) / (one - beta)) / beta
    end if
  end function I_m_eps

  function I_0m_eps (p, k) result (I)
    type(vector4_t), intent(in) :: p, k
    real(default) :: I
    type(vector4_t) :: pp, kp
    real(default) :: beta

    pp = p / p%p(0); kp = k / k%p(0)

    beta = sqrt (one - kp*kp)
    I = -2*(log((one - beta) / (one + beta))**2/4 + log((pp*kp) / (one + beta))*log((pp*kp) / (one - beta)) &
        + Li2(one - (pp*kp) / (one + beta)) + Li2(one - (pp*kp) / (one - beta)))
  end function I_0m_eps

  function I_0m_0 (p, k) result (I)
    type(vector4_t), intent(in) :: p, k
    real(default) :: I
    type(vector4_t) :: pp, kp

    pp = p / p%p(0); kp = k / k%p(0)
    I = log((pp*kp)**2 / kp**2)
  end function I_0m_0

  function I_mm_eps (p1, p2) result (I)
    type(vector4_t), intent(in) :: p1, p2
    real(default) :: I
    type(vector4_t) :: q1, q2
    type(vector3_t) :: beta1, beta2
    real(default) :: a, b
    real(default) :: zp, zm, z1, z2, x1, x2
    real(default) :: zmb, z1b
    real(default) :: K1, K2, b1, b2
    real(default) :: nu, a_kl, m12, m22
    beta1 = space_part (p1) / energy(p1)
    beta2 = space_part (p2) / energy(p2)
    if (min (one - beta1**1, one - beta2**1) < tiny_07) then
       if (beta1**1 < beta2**1) then
          call switch_beta (beta1, beta2)
          q1 = p2
          q2 = p1
       else
          q1 = p1
          q2 = p2
       end if
       b1 = beta1**1
       b2 = beta2**1
       m12 = q1**2
       m22 = q2**2
       a_kl = ((q1*q2) + sqrt((q1*q2)**2 - q1**2*q2**2))/m12
       nu = (a_kl**2 * m12 - m22) / two / (a_kl * p1%p(0) - q2%p(0))
       K1 =   0.5_default * log ((one - b1) / (one + b1))**2 &
            + two * Li2 (one - (one - b1)*(a_kl*q1%p(0)/nu)) &
            + two * Li2 (one - (one + b1)*(a_kl*q1%p(0)/nu))
       K2 =   0.5_default * log((one - b2) / (one + b2))**2 &
            + two * Li2 (one - (one - b2)*(q2%p(0)/nu)) &
            + two * Li2 (one - (one + b2)*(q2%p(0)/nu))
       I = (K2 - K1) / sqrt(one - m12*m22/(q1*q2)**2)
    else
       a = beta1**2 + beta2**2 - 2 * beta1 * beta2
       b = beta1**2 * beta2**2 - (beta1 * beta2)**2
       if (beta1**1 > beta2**1) call switch_beta (beta1, beta2)
       b2 = beta2**1
       if (beta1 == vector3_null) then
          I = (-0.5 * log ((one - b2) / (one + b2))**2 - two * Li2 (-two * b2 / (one - b2))) &
               * one / sqrt (a - b)
          return
       end if
       x1 = beta1**2 - beta1 * beta2
       x2 = beta2**2 - beta1 * beta2
       zp = sqrt (a) + sqrt (a - b)
       zm = sqrt (a) - sqrt (a - b)
       zmb = one  / zp
       z1 = sqrt (x1**2 + b) - x1
       z2 = sqrt (x2**2 + b) + x2
       z1b = one / (sqrt (x1**2 + b) + x1)
       K1 = - 0.5_default * log (((z1b - zmb) * (zp - z1)) / ((zp + z1) * (z1b + zmb)))**2 &
            - two * Li2 ((two * zmb * (zp - z1)) / ((zp - zm) * (zmb + z1b))) &
            - two * Li2 ((-two * zp * (zm + z1)) / ((zp - zm) * (zp - z1)))
       K2 = - 0.5_default * log ((( z2 - zm) * (zp - z2)) / ((zp + z2) * (z2 + zm)))**2 &
            - two * Li2 ((two * zm * (zp - z2)) / ((zp - zm) * (zm + z2))) &
            - two * Li2 ((-two * zp * (zm + z2)) / ((zp - zm) * (zp - z2)))
       I = (K2 - K1) * (one - beta1 * beta2) / sqrt (a - b)
    end if
  contains
    subroutine switch_beta (beta1, beta2)
      type(vector3_t), intent(inout) :: beta1, beta2
      type(vector3_t) :: beta_tmp
      beta_tmp = beta1
      beta1 = beta2
      beta2 = beta_tmp
    end subroutine switch_beta
  end function I_mm_eps

  function I_mm_0 (k1, k2) result (I)
    type(vector4_t), intent(in) :: k1, k2
    real(default) :: I
    real(default) :: beta, kquotient
    kquotient = k1**2 * k2**2 / (k1 * k2)**2
    if (kquotient > tiny_13) then
       beta = sqrt (one - kquotient)
       I = log ((one + beta) / (one - beta)) / beta
    else
       beta = one - kquotient / two
       I = log (two * (one + beta) / kquotient) / beta
    end if
  end function I_mm_0

@ %def I_mm_0
@
<<Virtual: virtual: TBP>>=
  procedure :: final => virtual_final
<<Virtual: sub interfaces>>=
    module subroutine virtual_final (virtual)
      class(virtual_t), intent(inout) :: virtual
    end subroutine virtual_final
<<Virtual: procedures>>=
  module subroutine virtual_final (virtual)
    class(virtual_t), intent(inout) :: virtual
    if (allocated (virtual%gamma_0)) deallocate (virtual%gamma_0)
    if (allocated (virtual%gamma_p)) deallocate (virtual%gamma_p)
    if (allocated (virtual%c_flv)) deallocate (virtual%c_flv)
    if (allocated (virtual%n_is_neutrinos)) deallocate (virtual%n_is_neutrinos)
  end subroutine virtual_final

@ %def virtual_final
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Real Subtraction}
<<[[real_subtraction.f90]]>>=
<<File header>>

module real_subtraction

<<Use kinds with double>>
<<Use strings>>
  use physics_defs
  use lorentz
  use flavors
  use phs_fks, only: real_kinematics_t, isr_kinematics_t
  use phs_fks, only: I_PLUS, I_MINUS
  use phs_fks, only: SQRTS_VAR, SQRTS_FIXED
  use phs_fks, only: phs_point_set_t

  use fks_regions
  use nlo_data

<<Standard module head>>

<<Real subtraction: public>>

<<Real subtraction: parameters>>

<<Real subtraction: types>>

<<Real subtraction: interfaces>>

  interface
<<Real subtraction: sub interfaces>>
  end interface

end module real_subtraction
@ %def real_subtraction
@
<<[[real_subtraction_sub.f90]]>>=
<<File header>>

submodule (real_subtraction) real_subtraction_s

<<Use debug>>
  use io_units
  use format_defs, only: FMT_15
  use string_utils
  use constants
  use numeric_utils
  use diagnostics
  use pdg_arrays
  use sm_physics
  use models
  use ttv_formfactors, only: m1s_to_mpole

  implicit none

contains

<<Real subtraction: procedures>>

end submodule real_subtraction_s

@ %def real_subtraction_s
@
\subsubsection{Soft subtraction terms}
<<Real subtraction: parameters>>=
  integer, parameter, public :: INTEGRATION = 0
  integer, parameter, public :: FIXED_ORDER_EVENTS = 1

@ %def real subtraction parameters
@ Translates the NLO purpose into a string. However, this purpose is
never set and this routine is nowhere used.
<<Real subtraction: procedures>>=
  function nlo_purpose (purpose) result (of_purpose)
    type(string_t) :: of_purpose
    integer, intent(in) :: purpose
    select case (purpose)
    case (INTEGRATION)
       of_purpose = var_str ("Integration")
    case (FIXED_ORDER_EVENTS)
       of_purpose = var_str ("Fixed order NLO events")
    case default
       of_purpose = var_str ("Undefined!")
    end select
  end function nlo_purpose

@ %def nlo_purpose
@
In the soft limit, the real matrix element behaves as
\begin{equation*}
  \mathcal{R}_{\rm{soft}} = 4\pi\alpha_s \left[\sum_{i \neq j}
  \mathcal{B}_{ij} \frac{k_i \cdot k_j}{(k_i \cdot k)(k_j \cdot k)}
   - \mathcal{B} \sum_{i} \frac{k_i^2}{(k_i \cdot k)^2}C_i\right],
\end{equation*}
where $k$ denotes the momentum of the emitted parton. The quantity $\mathcal{B}_{ij}$ is called the color-correlated Born matrix element defined as
\begin{equation*}
  \mathcal{B}_{ij} = \frac{1}{2s} \sum_{\stackrel{colors}{spins}} \mathcal{M}_{\{c_k\}}\left(\mathcal{M}^\dagger_{\{c_k\}}\right)_{\stackrel{c_i \rightarrow c_i'}{c_j \rightarrow c_j'}} T^a_{c_i,c_i'} T^a_{c_j,c_j'}.
\end{equation*}
<<Real subtraction: types>>=
  type :: soft_subtraction_t
    type(region_data_t), pointer :: reg_data => null ()
    real(default), dimension(:,:), allocatable :: momentum_matrix
    logical :: use_resonance_mappings = .false.
    type(vector4_t) :: p_soft = vector4_null
    logical :: use_internal_color_correlations = .true.
    logical :: use_internal_spin_correlations = .false.
    logical :: xi2_expanded = .true.
    integer :: factorization_mode = NO_FACTORIZATION
  contains
  <<Real subtraction: soft sub: TBP>>
  end type soft_subtraction_t

@ %def soft_subtraction_t
@
<<Real subtraction: soft sub: TBP>>=
  procedure :: init => soft_subtraction_init
<<Real subtraction: sub interfaces>>=
    module subroutine soft_subtraction_init (sub_soft, reg_data)
      class(soft_subtraction_t), intent(inout) :: sub_soft
      type(region_data_t), intent(in), target :: reg_data
    end subroutine soft_subtraction_init
<<Real subtraction: procedures>>=
  module subroutine soft_subtraction_init (sub_soft, reg_data)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(region_data_t), intent(in), target :: reg_data
    sub_soft%reg_data => reg_data
    allocate (sub_soft%momentum_matrix (reg_data%n_legs_born, &
         reg_data%n_legs_born))
  end subroutine soft_subtraction_init

@ %def soft_subtraction_init
@
<<Real subtraction: soft sub: TBP>>=
  procedure :: requires_boost => soft_subtraction_requires_boost
<<Real subtraction: sub interfaces>>=
    module function soft_subtraction_requires_boost &
         (sub_soft, sqrts) result (requires_boost)
      logical :: requires_boost
      class(soft_subtraction_t), intent(in) :: sub_soft
      real(default), intent(in) :: sqrts
    end function soft_subtraction_requires_boost
<<Real subtraction: procedures>>=
  module function soft_subtraction_requires_boost &
       (sub_soft, sqrts) result (requires_boost)
    logical :: requires_boost
    class(soft_subtraction_t), intent(in) :: sub_soft
    real(default), intent(in) :: sqrts
    real(default) :: mtop
    logical :: above_threshold
    if (sub_soft%factorization_mode == FACTORIZATION_THRESHOLD) then
       mtop = m1s_to_mpole (sqrts)
       above_threshold = sqrts**2 - four * mtop**2 > zero
    else
       above_threshold = .false.
    end if
    requires_boost = sub_soft%use_resonance_mappings .or. above_threshold
  end function soft_subtraction_requires_boost

@ %def soft_subtraction_requires_boost
@ The treatment of the momentum $k$ follows the discussion about the
soft limit of the partition functions (see [1002.2581], p. 29 and
C. Weiss' PhD Thesis, p. 24).  The parton momentum is
pulled out, $k = E \hat{k}$. In fact, we will substitute $\hat{k}$ for
$k$ throughout the code, because the energy will factor out of the
equation when the soft $\mathcal{S}$-function is multiplied.  The
momentum [[p_soft]] represents the soft limit of the radiated particle
divided by its energy. It is a unit vector, because
$k^2 = \left(k^0\right)^2 - \left(k^0\right)^2\hat{\vec{k}}^2 = 0$.

The soft momentum is constructed by first creating a unit vector
parallel to the emitter's Born momentum. This unit vector is then
rotated about the corresponding angles $y$ and $\phi$ to match
the direction of the real radiation in the soft limit.
<<Real subtraction: soft sub: TBP>>=
  procedure :: create_softvec_fsr => soft_subtraction_create_softvec_fsr
<<Real subtraction: sub interfaces>>=
    module subroutine soft_subtraction_create_softvec_fsr &
         (sub_soft, p_born, y, phi, emitter, xi_ref_momentum)
      class(soft_subtraction_t), intent(inout) :: sub_soft
      type(vector4_t), intent(in), dimension(:) :: p_born
      real(default), intent(in) :: y, phi
      integer, intent(in) :: emitter
      type(vector4_t), intent(in) :: xi_ref_momentum
    end subroutine soft_subtraction_create_softvec_fsr
<<Real subtraction: procedures>>=
  module subroutine soft_subtraction_create_softvec_fsr &
       (sub_soft, p_born, y, phi, emitter, xi_ref_momentum)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: y, phi
    integer, intent(in) :: emitter
    type(vector4_t), intent(in) :: xi_ref_momentum
    type(vector3_t) :: dir
    type(vector4_t) :: p_em
    type(lorentz_transformation_t) :: rot
    type(lorentz_transformation_t) :: boost_to_rest_frame
    logical :: requires_boost
    associate (p_soft => sub_soft%p_soft)
       p_soft%p(0) = one
       requires_boost = sub_soft%requires_boost (two * p_born(1)%p(0))
       if (requires_boost) then
          boost_to_rest_frame = inverse (boost (xi_ref_momentum, xi_ref_momentum**1))
          p_em = boost_to_rest_frame * p_born(emitter)
       else
          p_em = p_born(emitter)
       end if
       p_soft%p(1:3) = p_em%p(1:3) / space_part_norm (p_em)
       dir = create_orthogonal (space_part (p_em))
       rot = rotation (y, sqrt(one - y**2), dir)
       p_soft = rot * p_soft
       if (.not. vanishes (phi)) then
         dir = space_part (p_em) / space_part_norm (p_em)
         rot = rotation (cos(phi), sin(phi), dir)
         p_soft = rot * p_soft
       end if
       if (requires_boost) p_soft = inverse (boost_to_rest_frame) * p_soft
    end associate
  end subroutine soft_subtraction_create_softvec_fsr

@ %def soft_subtraction_create_softvec_fsr
@ For initial-state emissions, the soft vector is just a unit vector
with the same direction as the radiated particle.
As $y$ for ISR is defined independently of the emitter, also [[p_soft]]
is the same for all initial state emitters.
<<Real subtraction: soft sub: TBP>>=
  procedure :: create_softvec_isr => soft_subtraction_create_softvec_isr
<<Real subtraction: sub interfaces>>=
    module subroutine soft_subtraction_create_softvec_isr (sub_soft, y, phi)
      class(soft_subtraction_t), intent(inout) :: sub_soft
      real(default), intent(in) :: y, phi
    end subroutine soft_subtraction_create_softvec_isr
<<Real subtraction: procedures>>=
  module subroutine soft_subtraction_create_softvec_isr (sub_soft, y, phi)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    real(default), intent(in) :: y, phi
    real(default) :: sin_theta
    sin_theta = sqrt(one - y**2)
    associate (p => sub_soft%p_soft%p)
       p(0) = one
       p(1) = sin_theta * sin(phi)
       p(2) = sin_theta * cos(phi)
       p(3) = y
    end associate
  end subroutine soft_subtraction_create_softvec_isr

@ %def soft_subtraction_create_softvec_isr
@ The soft vector for the real mismatch is basically the same as for
usual FSR, except for the scaling with the total gluon
energy. Moreover, the resulting vector is rotated into the frame where
the 3-axis points along the direction of the emitter. This is
necessary because in the collinear limit, the approximation
\begin{equation*}
  k_i = \frac{k_i^0}{\bar{k}_j^0} \bar{k}_j =
  \frac{\xi\sqrt{s}}{2\bar{k}_j^0}\bar{k}_j
\end{equation*}
is used. The collinear limit is not included in the soft mismatch yet,
but we keep the rotation for future usage here already (the
performance loss is negligible).
<<Real subtraction: soft sub: TBP>>=
  procedure :: create_softvec_mismatch => &
     soft_subtraction_create_softvec_mismatch
<<Real subtraction: sub interfaces>>=
    module subroutine soft_subtraction_create_softvec_mismatch &
         (sub_soft, E, y, phi, p_em)
      class(soft_subtraction_t), intent(inout) :: sub_soft
      real(default), intent(in) :: E, phi, y
      type(vector4_t), intent(in) :: p_em
    end subroutine soft_subtraction_create_softvec_mismatch
<<Real subtraction: procedures>>=
  module subroutine soft_subtraction_create_softvec_mismatch &
       (sub_soft, E, y, phi, p_em)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    real(default), intent(in) :: E, phi, y
    type(vector4_t), intent(in) :: p_em
    real(default) :: sin_theta
    type(lorentz_transformation_t) :: rot_em_off_3_axis
    sin_theta = sqrt (one - y**2)
    associate (p => sub_soft%p_soft%p)
       p(0) = E
       p(1) = E * sin_theta * sin(phi)
       p(2) = E * sin_theta * cos(phi)
       p(3) = E * y
    end associate
    rot_em_off_3_axis = rotation_to_2nd (3, space_part (p_em))
    sub_soft%p_soft = rot_em_off_3_axis * sub_soft%p_soft
  end subroutine soft_subtraction_create_softvec_mismatch

@ %def soft_subtraction_create_softvec_mismatch
@ Computation of the soft limit of $R_\alpha$. Note that what we are
actually integrating (in the case of final-state radiation) is the
quantity $f(0,y) / \xi$, where
\begin{equation*}
  f(\xi,y) = \frac{J(\xi,y,\phi)}{\xi} \xi^2 R_\alpha.
\end{equation*}
$J/\xi$ is computed by the phase space generator. The additional factor
of $\xi^{-1}$ is supplied in the [[evaluate_region_fsr]]-routine. Thus,
we are left with a factor of $\xi^2$. A look on the expression for the
soft limit of $R_\alpha$ below reveals that we are factoring out the gluon
energy $E_i$ in the denominator. Therefore, we have a factor
$\xi^2 / E_i^2 = 4 / q^2$.

Note that the same routine is used also for the computation of the soft
mismatch. There, the gluon energy is not factored out from the soft vector,
so that we are left with the $\xi^2$-factor, which will eventually be
cancelled out again. So, we just multiply with 1. Both cases are
distinguished by the flag [[xi2_expanded]].

Note that for the soft subtraction term, also the S functions are
computed in the soft limit. The input momenta are thus the real
momenta in the soft limit, i.e. the Born momenta given by [[p_born]].
<<Real subtraction: soft sub: TBP>>=
  procedure :: compute => soft_subtraction_compute
<<Real subtraction: sub interfaces>>=
    module function soft_subtraction_compute (sub_soft, p_born, &
         born_ij, y, q2, alpha_coupling, alr, emitter, i_res) result (sqme)
      real(default) :: sqme
      class(soft_subtraction_t), intent(inout) :: sub_soft
      type(vector4_t), intent(in), dimension(:) :: p_born
      real(default), intent(in), dimension(:,:) :: born_ij
      real(default), intent(in) :: y
      real(default), intent(in) :: q2, alpha_coupling
      integer, intent(in) :: alr, emitter, i_res
    end function soft_subtraction_compute
<<Real subtraction: procedures>>=
  module function soft_subtraction_compute (sub_soft, p_born, &
       born_ij, y, q2, alpha_coupling, alr, emitter, i_res) result (sqme)
    real(default) :: sqme
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in), dimension(:,:) :: born_ij
    real(default), intent(in) :: y
    real(default), intent(in) :: q2, alpha_coupling
    integer, intent(in) :: alr, emitter, i_res
    real(default) :: s_alpha_soft
    real(default) :: kb
    real(default) :: xi2_factor

    if (.not. vector_set_is_cms (p_born, sub_soft%reg_data%n_in)) then
       call vector4_write_set (p_born, show_mass = .true., &
              check_conservation = .true.)
       call msg_fatal ("Soft subtraction: phase space point must be in CMS")
    end if
    if (debug2_active (D_SUBTRACTION)) then
       select case (char (sub_soft%reg_data%regions(alr)%nlo_correction_type))
       case ("QCD")
          print *, 'Compute soft subtraction using alpha_s = ', alpha_coupling
       case ("EW")
          print *, 'Compute soft subtraction using alpha_qed = ', alpha_coupling
       end select
    end if

    s_alpha_soft = sub_soft%reg_data%get_svalue_soft (p_born, &
         sub_soft%p_soft, alr, emitter, i_res)
    if (s_alpha_soft > one + tiny_07) call msg_fatal ("s_alpha_soft > 1!")
    if (debug2_active (D_SUBTRACTION)) &
         call msg_print_color ('s_alpha_soft', s_alpha_soft, COL_YELLOW)
    select case (sub_soft%factorization_mode)
    case (NO_FACTORIZATION)
       kb = sub_soft%evaluate_factorization_default (p_born, born_ij)
    case (FACTORIZATION_THRESHOLD)
       kb = sub_soft%evaluate_factorization_threshold (thr_leg(emitter), p_born, born_ij)
    end select
    if (debug_on) call msg_debug2 (D_SUBTRACTION, 'KB', kb)
    sqme = four * pi * alpha_coupling * s_alpha_soft * kb
    if (sub_soft%xi2_expanded) then
       xi2_factor = four / q2
    else
       xi2_factor = one
    end if
    if (emitter <= sub_soft%reg_data%n_in) then
       sqme = xi2_factor * (one - y**2) * sqme
    else
       sqme = xi2_factor * (one - y) * sqme
    end if
    if (sub_soft%reg_data%regions(alr)%double_fsr) sqme = sqme * two
  end function soft_subtraction_compute

@ %def soft_subtraction_compute
@ We loop over all external legs and do not take care to leave out non-colored
ones because [[born_ij]] is constructed in such a way that it is only
non-zero for colored entries.
<<Real subtraction: soft sub: TBP>>=
  procedure :: evaluate_factorization_default => &
     soft_subtraction_evaluate_factorization_default
<<Real subtraction: sub interfaces>>=
    module function soft_subtraction_evaluate_factorization_default &
         (sub_soft, p, born_ij) result (kb)
      real(default) :: kb
      class(soft_subtraction_t), intent(inout) :: sub_soft
      type(vector4_t), intent(in), dimension(:) :: p
      real(default), intent(in), dimension(:,:) :: born_ij
    end function soft_subtraction_evaluate_factorization_default
<<Real subtraction: procedures>>=
  module function soft_subtraction_evaluate_factorization_default &
       (sub_soft, p, born_ij) result (kb)
    real(default) :: kb
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in), dimension(:,:) :: born_ij
    integer :: i, j
    kb = zero
    call sub_soft%compute_momentum_matrix (p)
    do i = 1, size (p)
       do j = 1, size (p)
          kb = kb + sub_soft%momentum_matrix (i, j) * born_ij (i, j)
       end do
    end do
  end function soft_subtraction_evaluate_factorization_default

@ %def soft_subtraction_evaluate_factorization_default
@ We have to multiply this with $\xi^2(1-y)$. Further, when applying
the soft $\mathcal{S}$-function, the energy of the radiated particle
is factored out. Thus we have $\xi^2/E_{em}^2(1-y) = 4/q_0^2(1-y)$.
Computes the quantity $\mathcal{K}_{ij} = \frac{k_i \cdot
k_j}{(k_i\cdot k)(k_j\cdot k)}$.
<<Real subtraction: soft sub: TBP>>=
  procedure :: compute_momentum_matrix => &
       soft_subtraction_compute_momentum_matrix
<<Real subtraction: sub interfaces>>=
    module subroutine soft_subtraction_compute_momentum_matrix &
         (sub_soft, p_born)
      class(soft_subtraction_t), intent(inout) :: sub_soft
      type(vector4_t), intent(in), dimension(:) :: p_born
    end subroutine soft_subtraction_compute_momentum_matrix
<<Real subtraction: procedures>>=
  module subroutine soft_subtraction_compute_momentum_matrix &
       (sub_soft, p_born)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default) :: num, deno1, deno2
    integer :: i, j
    do i = 1, sub_soft%reg_data%n_legs_born
       do j = 1, sub_soft%reg_data%n_legs_born
          if (i <= j) then
             num = p_born(i) * p_born(j)
             deno1 = p_born(i) * sub_soft%p_soft
             deno2 = p_born(j) * sub_soft%p_soft
             sub_soft%momentum_matrix(i, j) = num / (deno1 * deno2)
          else
             !!! momentum matrix is symmetric.
            sub_soft%momentum_matrix(i, j) = sub_soft%momentum_matrix(j, i)
          end if
       end do
    end do
  end subroutine soft_subtraction_compute_momentum_matrix

@ %def soft_subtraction_compute_momentum_matrx
@
<<Real subtraction: soft sub: TBP>>=
  procedure :: evaluate_factorization_threshold => &
     soft_subtraction_evaluate_factorization_threshold
<<Real subtraction: sub interfaces>>=
    module function soft_subtraction_evaluate_factorization_threshold &
         (sub_soft, leg, p_born, born_ij) result (kb)
      real(default) :: kb
      class(soft_subtraction_t), intent(inout) :: sub_soft
      integer, intent(in) :: leg
      type(vector4_t), intent(in), dimension(:) :: p_born
      real(default), intent(in), dimension(:,:) :: born_ij
    end function soft_subtraction_evaluate_factorization_threshold
<<Real subtraction: procedures>>=
  module function soft_subtraction_evaluate_factorization_threshold &
       (sub_soft, leg, p_born, born_ij) result (kb)
    real(default) :: kb
    class(soft_subtraction_t), intent(inout) :: sub_soft
    integer, intent(in) :: leg
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in), dimension(:,:) :: born_ij
    type(vector4_t), dimension(4) :: p
    p = get_threshold_momenta (p_born)
    kb = evaluate_leg_pair (ASSOCIATED_LEG_PAIR (leg))
    if (debug2_active (D_SUBTRACTION))  call show_debug ()

  contains

    function evaluate_leg_pair (i_start) result (kbb)
      real(default) :: kbb
      integer, intent(in) :: i_start
      integer :: i1, i2
      real(default) :: numerator, deno1, deno2
      kbb = zero
      do i1 = i_start, i_start + 1
         do i2 = i_start, i_start + 1
            numerator = p(i1) * p(i2)
            deno1 = p(i1) * sub_soft%p_soft
            deno2 = p(i2) * sub_soft%p_soft
            kbb = kbb +  numerator * born_ij (i1, i2) / deno1 / deno2
         end do
      end do
      if (debug2_active (D_SUBTRACTION)) then
         do i1 = i_start, i_start + 1
            do i2 = i_start, i_start + 1
               call msg_print_color('i1', i1, COL_PEACH)
               call msg_print_color('i2', i2, COL_PEACH)
               call msg_print_color('born_ij (i1,i2)', born_ij (i1,i2), &
                    COL_PINK)
               print *, 'Top momentum: ', p(1)%p
            end do
         end do
      end if
    end function evaluate_leg_pair

    subroutine show_debug ()
      integer :: i
      call msg_print_color &
           ('soft_subtraction_evaluate_factorization_threshold', COL_GREEN)
      do i = 1, 4
         print *, 'sqrt(p(i)**2) =    ', sqrt(p(i)**2)
      end do
    end subroutine show_debug

  end function soft_subtraction_evaluate_factorization_threshold

@ %def soft_subtraction_evaluate_factorization_threshold
@
<<Real subtraction: soft sub: TBP>>=
  procedure :: i_xi_ref => soft_subtraction_i_xi_ref
<<Real subtraction: sub interfaces>>=
    module function soft_subtraction_i_xi_ref &
         (sub_soft, alr, i_phs) result (i_xi_ref)
      integer :: i_xi_ref
      class(soft_subtraction_t), intent(in) :: sub_soft
      integer, intent(in) :: alr, i_phs
    end function soft_subtraction_i_xi_ref
<<Real subtraction: procedures>>=
  module function soft_subtraction_i_xi_ref &
       (sub_soft, alr, i_phs) result (i_xi_ref)
    integer :: i_xi_ref
    class(soft_subtraction_t), intent(in) :: sub_soft
    integer, intent(in) :: alr, i_phs
    if (sub_soft%use_resonance_mappings) then
       i_xi_ref = sub_soft%reg_data%alr_to_i_contributor (alr)
    else if (sub_soft%factorization_mode == FACTORIZATION_THRESHOLD) then
       i_xi_ref = i_phs
    else
       i_xi_ref = 1
    end if
  end function soft_subtraction_i_xi_ref

@ %def soft_subtraction_i_xi_ref
@
<<Real subtraction: soft sub: TBP>>=
  procedure :: final => soft_subtraction_final
<<Real subtraction: sub interfaces>>=
    module subroutine soft_subtraction_final (sub_soft)
      class(soft_subtraction_t), intent(inout) :: sub_soft
    end subroutine soft_subtraction_final
<<Real subtraction: procedures>>=
  module subroutine soft_subtraction_final (sub_soft)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    if (associated (sub_soft%reg_data)) nullify (sub_soft%reg_data)
    if (allocated (sub_soft%momentum_matrix)) &
         deallocate (sub_soft%momentum_matrix)
  end subroutine soft_subtraction_final

@ %def soft_subtraction_final
@
\subsection{Soft mismatch}
<<Real subtraction: public>>=
  public :: soft_mismatch_t
<<Real subtraction: types>>=
  type :: soft_mismatch_t
    type(region_data_t), pointer :: reg_data => null ()
    real(default), dimension(:), allocatable :: sqme_born
    real(default), dimension(:,:,:), allocatable :: sqme_born_color_c
    real(default), dimension(:,:,:), allocatable :: sqme_born_charge_c
    type(real_kinematics_t), pointer :: real_kinematics => null ()
    type(soft_subtraction_t) :: sub_soft
  contains
  <<Real subtraction: soft mismatch: TBP>>
  end type soft_mismatch_t

@ %def soft_mismatch_t
@
<<Real subtraction: soft mismatch: TBP>>=
  procedure :: init => soft_mismatch_init
<<Real subtraction: sub interfaces>>=
    module subroutine soft_mismatch_init (soft_mismatch, reg_data, &
         real_kinematics, factorization_mode)
      class(soft_mismatch_t), intent(inout) :: soft_mismatch
      type(region_data_t), intent(in), target :: reg_data
      type(real_kinematics_t), intent(in), target :: real_kinematics
      integer, intent(in) :: factorization_mode
    end subroutine soft_mismatch_init
<<Real subtraction: procedures>>=
  module subroutine soft_mismatch_init (soft_mismatch, reg_data, &
       real_kinematics, factorization_mode)
    class(soft_mismatch_t), intent(inout) :: soft_mismatch
    type(region_data_t), intent(in), target :: reg_data
    type(real_kinematics_t), intent(in), target :: real_kinematics
    integer, intent(in) :: factorization_mode
    soft_mismatch%reg_data => reg_data
    allocate (soft_mismatch%sqme_born (reg_data%n_flv_born))
    allocate (soft_mismatch%sqme_born_color_c (reg_data%n_legs_born, &
         reg_data%n_legs_born, reg_data%n_flv_born))
    allocate (soft_mismatch%sqme_born_charge_c (reg_data%n_legs_born, &
         reg_data%n_legs_born, reg_data%n_flv_born))
    call soft_mismatch%sub_soft%init (reg_data)
    soft_mismatch%sub_soft%xi2_expanded = .false.
    soft_mismatch%real_kinematics => real_kinematics
    soft_mismatch%sub_soft%factorization_mode = factorization_mode
  end subroutine soft_mismatch_init

@ %def soft_mismatch_init
@ Main routine to compute the soft mismatch. Loops over all singular
regions. There, it first creates the soft vector, then the necessary
soft real matrix element. These inputs are then used to get the
numerical value of the soft mismatch.
<<Real subtraction: soft mismatch: TBP>>=
  procedure :: evaluate => soft_mismatch_evaluate
<<Real subtraction: sub interfaces>>=
    module function soft_mismatch_evaluate &
         (soft_mismatch, alpha_s) result (sqme_mismatch)
      real(default) :: sqme_mismatch
      class(soft_mismatch_t), intent(inout) :: soft_mismatch
      real(default), intent(in) :: alpha_s
    end function soft_mismatch_evaluate
<<Real subtraction: procedures>>=
  module function soft_mismatch_evaluate &
       (soft_mismatch, alpha_s) result (sqme_mismatch)
    real(default) :: sqme_mismatch
    class(soft_mismatch_t), intent(inout) :: soft_mismatch
    real(default), intent(in) :: alpha_s
    integer :: alr, i_born, emitter, i_res, i_phs, i_con
    real(default) :: xi, y, q2, s
    real(default) :: E_gluon
    type(vector4_t) :: p_em
    real(default) :: sqme_alr, sqme_soft
    type(vector4_t), dimension(:), allocatable :: p_born
    sqme_mismatch = zero
    associate (real_kinematics => soft_mismatch%real_kinematics)
       xi = real_kinematics%xi_mismatch
       y = real_kinematics%y_mismatch
       s = real_kinematics%cms_energy2
       E_gluon = sqrt (s) * xi / two

       if (debug_active (D_MISMATCH)) then
          print *, 'Evaluating soft mismatch: '
          print *, 'Phase space: '
          call vector4_write_set (real_kinematics%p_born_cms%get_momenta(1), &
               show_mass = .true.)
          print *, 'xi: ', xi, 'y: ', y, 's: ', s, 'E_gluon: ', E_gluon
       end if

       allocate (p_born (soft_mismatch%reg_data%n_legs_born))

       do alr = 1, soft_mismatch%reg_data%n_regions

           i_phs = real_kinematics%alr_to_i_phs (alr)
           if (soft_mismatch%reg_data%has_pseudo_isr ()) then
              i_con = 1
              p_born = &
                   soft_mismatch%real_kinematics%p_born_onshell%get_momenta(1)
           else
              i_con = soft_mismatch%reg_data%alr_to_i_contributor (alr)
              p_born = soft_mismatch%real_kinematics%p_born_cms%get_momenta(1)
           end if
           q2 = real_kinematics%xi_ref_momenta(i_con)**2
           emitter = soft_mismatch%reg_data%regions(alr)%emitter
           p_em = p_born (emitter)
           i_res = soft_mismatch%reg_data%regions(alr)%i_res
           i_born = soft_mismatch%reg_data%regions(alr)%uborn_index

           call print_debug_alr ()

           call soft_mismatch%sub_soft%create_softvec_mismatch &
                (E_gluon, y, real_kinematics%phi, p_em)
           if (debug_active (D_MISMATCH)) &
                print *, 'Created soft vector: ', &
                soft_mismatch%sub_soft%p_soft%p

           select type (fks_mapping => soft_mismatch%reg_data%fks_mapping)
           type is (fks_mapping_resonances_t)
              call fks_mapping%set_resonance_momentum &
                   (real_kinematics%xi_ref_momenta(i_con))
           end select

           sqme_soft = soft_mismatch%sub_soft%compute &
                (p_born, soft_mismatch%sqme_born_color_c(:,:,i_born), y, &
                q2, alpha_s, alr, emitter, i_res)

           sqme_alr = soft_mismatch%compute (alr, xi, y, p_em, &
                real_kinematics%xi_ref_momenta(i_con), &
                soft_mismatch%sub_soft%p_soft, &
                soft_mismatch%sqme_born(i_born), sqme_soft, &
                alpha_s, s)

           if (debug_on) call msg_debug (D_MISMATCH, 'sqme_alr: ', sqme_alr)
           sqme_mismatch = sqme_mismatch + sqme_alr

       end do
    end associate
  contains
    subroutine print_debug_alr ()
      if (debug_active (D_MISMATCH)) then
         print *, 'alr: ', alr
         print *, 'i_phs: ', i_phs, 'i_con: ', i_con, 'i_res: ', i_res
         print *, 'emitter: ', emitter, 'i_born: ', i_born
         print *, 'emitter momentum: ', p_em%p
         print *, 'resonance momentum: ', &
            soft_mismatch%real_kinematics%xi_ref_momenta(i_con)%p
         print *, 'q2: ', q2
      end if
    end subroutine print_debug_alr
  end function soft_mismatch_evaluate

@ %def soft_mismatch_evaluate
@ Computes the soft mismatch in a given $\alpha_r$,
\begin{align*}
  I_{s+,\alpha_r} &= \int d\Phi_B \int_0^\infty d\xi \int_{-1}^1 dy
  \int_0^{2\pi} d\phi
  \frac{s\xi}{(4\pi)^3} \\
  &\times \left\lbrace\tilde{R}_{\alpha_r}
  \left(e^{-\frac{2k_\gamma \cdot k_{res}}{k_{res}}^2} - e^{-\xi}\right)
  - \frac{32 \pi \alpha_s C_{em}}{s\xi^2} B_{f_b(\alpha_r)} (1-y)^{-1}
    \left[e^{-\frac{2\bar{k}_{em} \cdot k_{res}}{k_{res}^2}
        \frac{k_\gamma^0}{k_{em}^0}} - e^{-\xi}\right]\right\rbrace.
\end{align*}
<<Real subtraction: soft mismatch: TBP>>=
  procedure :: compute => soft_mismatch_compute
<<Real subtraction: sub interfaces>>=
    module function soft_mismatch_compute &
         (soft_mismatch, alr, xi, y, p_em, p_res, p_soft, &
       sqme_born, sqme_soft, alpha_s, s) result (sqme_mismatch)
      real(default) :: sqme_mismatch
      class(soft_mismatch_t), intent(in) :: soft_mismatch
      integer, intent(in) :: alr
      real(default), intent(in) :: xi, y
      type(vector4_t), intent(in) :: p_em, p_res, p_soft
      real(default), intent(in) :: sqme_born, sqme_soft
      real(default), intent(in) :: alpha_s, s
    end function soft_mismatch_compute
<<Real subtraction: procedures>>=
  module function soft_mismatch_compute &
       (soft_mismatch, alr, xi, y, p_em, p_res, p_soft, &
     sqme_born, sqme_soft, alpha_s, s) result (sqme_mismatch)
    real(default) :: sqme_mismatch
    class(soft_mismatch_t), intent(in) :: soft_mismatch
    integer, intent(in) :: alr
    real(default), intent(in) :: xi, y
    type(vector4_t), intent(in) :: p_em, p_res, p_soft
    real(default), intent(in) :: sqme_born, sqme_soft
    real(default), intent(in) :: alpha_s, s
    real(default) :: q2, expo, sm1, sm2, jacobian

    q2 = p_res**2
    expo = - two * p_soft * p_res / q2
    !!! Divide by 1 - y to factor out the corresponding
    !!! factor in the soft matrix element
    sm1 = sqme_soft / (one - y) * ( exp(expo) - exp(- xi) )
    if (debug_on)  call msg_debug2 &
         (D_MISMATCH, 'sqme_soft in mismatch ', sqme_soft)

    sm2 = zero
    if (soft_mismatch%reg_data%regions(alr)%has_collinear_divergence ()) then
       expo = - two * p_em * p_res / q2 * &
          p_soft%p(0) / p_em%p(0)
       sm2 = 32 * pi * alpha_s * cf / (s * xi**2) * sqme_born * &
          ( exp(expo) - exp(- xi) ) / (one - y)
    end if

    jacobian = soft_mismatch%real_kinematics%jac_mismatch * &
         s * xi / (8 * twopi3)
    sqme_mismatch = (sm1 - sm2) * jacobian

  end function soft_mismatch_compute

@ %def soft_mismatch_compute
@
<<Real subtraction: soft mismatch: TBP>>=
  procedure :: final => soft_mismatch_final
<<Real subtraction: sub interfaces>>=
    module subroutine soft_mismatch_final (soft_mismatch)
      class(soft_mismatch_t), intent(inout) :: soft_mismatch
    end subroutine soft_mismatch_final
<<Real subtraction: procedures>>=
  module subroutine soft_mismatch_final (soft_mismatch)
    class(soft_mismatch_t), intent(inout) :: soft_mismatch
    call soft_mismatch%sub_soft%final ()
    if (associated (soft_mismatch%reg_data)) nullify (soft_mismatch%reg_data)
    if (allocated (soft_mismatch%sqme_born)) &
         deallocate (soft_mismatch%sqme_born)
    if (allocated (soft_mismatch%sqme_born_color_c)) &
         deallocate (soft_mismatch%sqme_born_color_c)
    if (allocated (soft_mismatch%sqme_born_charge_c)) &
         deallocate (soft_mismatch%sqme_born_charge_c)
    if (associated (soft_mismatch%real_kinematics)) &
         nullify (soft_mismatch%real_kinematics)
  end subroutine soft_mismatch_final

@ %def soft_mismatch_final
@
\subsection{Collinear and soft-collinear subtraction terms}
This data type deals with the calculation of the collinear and
soft-collinear contribution to the cross section.
<<Real subtraction: public>>=
  public :: coll_subtraction_t
<<Real subtraction: types>>=
  type :: coll_subtraction_t
    integer :: n_in, n_alr
    logical :: use_resonance_mappings = .false.
    real(default) :: CA = 0, CF = 0, TR = 0
  contains
  <<Real subtraction: coll sub: TBP>>
  end type coll_subtraction_t

@ %def coll_subtraction_t
@
<<Real subtraction: coll sub: TBP>>=
  procedure :: init => coll_subtraction_init
<<Real subtraction: sub interfaces>>=
    module subroutine coll_subtraction_init (coll_sub, n_alr, n_in)
      class(coll_subtraction_t), intent(inout) :: coll_sub
      integer, intent(in) :: n_alr, n_in
    end subroutine coll_subtraction_init
<<Real subtraction: procedures>>=
  module subroutine coll_subtraction_init (coll_sub, n_alr, n_in)
    class(coll_subtraction_t), intent(inout) :: coll_sub
    integer, intent(in) :: n_alr, n_in
    coll_sub%n_in = n_in
    coll_sub%n_alr = n_alr
  end subroutine coll_subtraction_init

@ %def coll_subtraction_init
@ Set the corresponding algebra parameters of the underlying gauge group of the correction.
<<Real subtraction: coll sub: TBP>>=
  procedure :: set_parameters => coll_subtraction_set_parameters
<<Real subtraction: sub interfaces>>=
    module subroutine coll_subtraction_set_parameters (coll_sub, CA, CF, TR)
      class(coll_subtraction_t), intent(inout) :: coll_sub
      real(default), intent(in) :: CA, CF, TR
    end subroutine coll_subtraction_set_parameters
<<Real subtraction: procedures>>=
  module subroutine coll_subtraction_set_parameters (coll_sub, CA, CF, TR)
    class(coll_subtraction_t), intent(inout) :: coll_sub
    real(default), intent(in) :: CA, CF, TR
    coll_sub%CA = CA
    coll_sub%CF = CF
    coll_sub%TR = TR
  end subroutine coll_subtraction_set_parameters

@ %def coll_subtraction_set_parameters
@ This subroutine computes the collinear limit of $g^\alpha(\xi,y)$ introduced
in eq.~\ref{fks: sub: real}. Care is given to also enable the usage for
the soft-collinear limit. This, we write all formulas in terms of soft-finite
quantities.

We have to compute
\begin{equation*}
  \frac{J(\Phi_n,\xi,y,\phi)}{\xi}
  \left[(1-y)\xi^2\mathcal{R}^\alpha(\Phi_{n+1})\right]|_{y = 1}.
\end{equation*}
The Jacobian $J$ is proportional to $\xi$, due to the $d^3 k_{n+1} /
k_{n+1}^0$ factor in the integration measure. It cancels the factor of
$\xi$ in the denominator. The remaining part of the Jacobian is
multiplied in [[evaluate_region_fsr]] and is not relevant here.
Inserting the splitting functions exemplarily for $q \to qg$ yields
\begin{equation*}
  g^\alpha = \frac{8\pi\alpha_s}{k_{\mathrm{em}}^2} C_F (1-y) \xi^2
  \frac{1+(1-z)^2}{z} \mathcal{B},
\end{equation*}
where we have chosen $z = E_\mathrm{rad} / \bar{E}_\mathrm{em}$ and
$\bar{E}_\mathrm{em}$ denotes the emitter energy in the Born frame.
The collinear final state imposes $\bar{k}_n = k_{n} + k_{n + 1}$ for the
connection between $\Phi_n$- and $\Phi_{n+1}$-phasepace and we get $1
- z = E_\mathrm{em} / \bar{E}_\mathrm{em}$. The denominator can be
rewritten by the constraint $\bar{k}_n^2 = (k_n + k_{n+1})^2 = 0$ to
\begin{equation*}
  k_{\mathrm{em}}^2 = 2 E_\mathrm{rad} E_\mathrm{em} (1-y)
\end{equation*}
which cancels the $(1-y)$ factor in the numerator, thus showing that
the whole expression is indeed collinear-finite. We can further transform
\begin{equation*}
  E_\mathrm{rad} E_\mathrm{em} = z (1-z) \bar{E}_\mathrm{em}^2
\end{equation*}
so that in total we have
\begin{equation*}
  g^\alpha = \frac{4\pi\alpha_s}{1-z} \frac{1}{\bar{k}_{\text{em}}^2}
  C_F \left(\frac{\xi}{z}\right)^2
  (1 + (1-z)^2) \mathcal{B}
\end{equation*}
Follow up calculations give us
\begin{align*}
  g^{\alpha, g \rightarrow gg} & =
  \frac{4\pi\alpha_s}{1-z}\frac{1}{\bar{k}_{\text{em}}^2}
  C_{\mathrm{A}} \frac{\xi}{z} \left\lbrace 2 \left( \frac{z}{1 - z}
  \xi + \frac{1 - z}{\frac{z}{\xi}} \right) \mathcal{B} + 4\xi z(1 -
  z) \hat{k}_{\perp}^{\mu} \hat{k}_{\perp}^{\nu} \mathcal{B}_{\mu\nu}
  \right\rbrace, \\
  g^{\alpha, g \rightarrow qq} & = \frac{4\pi\alpha_s}{1-z}
  \frac{1}{\bar{k}_{\text{em}}^2} T_{\mathrm{R}}
  \frac{\xi}{z} \left\lbrace \xi
  \mathcal{B} - 4\xi z(1 - z)
  \hat{k}_{\perp}^{\mu}
  \hat{k}_{\perp}^{\nu}
  \mathcal{B}_{\mu\nu} \right\rbrace.
\end{align*}
The ratio $z / \xi$ is finite in the soft limit
\begin{equation*}
  \frac{z}{\xi} = \frac{q^0}{2\bar{E}_\mathrm{em}}
\end{equation*}
so that $\xi$ does not appear explicitly in the computation.

The argumentation above is valid for $q \to qg$--splittings, but the
general factorization is valid for general splittings, also for those
involving spin correlations and QED splittings. Note that care has to
be given to the definition of $z$. Further, we have factored out a
factor of $z$ to include in the ratio $z/\xi$, which has to be taken
into account in the implementation of the splitting functions.
<<Real subtraction: coll sub: TBP>>=
  procedure :: compute_fsr => coll_subtraction_compute_fsr
<<Real subtraction: sub interfaces>>=
    module function coll_subtraction_compute_fsr (coll_sub, emitter, &
         flst, p_res, p_born, sqme_born, mom_times_sqme_spin_c, &
         xi, alpha_coupling, double_fsr) result (sqme)
      real(default) :: sqme
      class(coll_subtraction_t), intent(in) :: coll_sub
      integer, intent(in) :: emitter
      integer, dimension(:), intent(in) :: flst
      type(vector4_t), intent(in) :: p_res
      type(vector4_t), intent(in), dimension(:) :: p_born
      real(default), intent(in) :: sqme_born, mom_times_sqme_spin_c
      real(default), intent(in) :: xi, alpha_coupling
      logical, intent(in) :: double_fsr
    end function coll_subtraction_compute_fsr
<<Real subtraction: procedures>>=
  module function coll_subtraction_compute_fsr (coll_sub, emitter, &
       flst, p_res, p_born, sqme_born, mom_times_sqme_spin_c, &
       xi, alpha_coupling, double_fsr) result (sqme)
    real(default) :: sqme
    class(coll_subtraction_t), intent(in) :: coll_sub
    integer, intent(in) :: emitter
    integer, dimension(:), intent(in) :: flst
    type(vector4_t), intent(in) :: p_res
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: sqme_born, mom_times_sqme_spin_c
    real(default), intent(in) :: xi, alpha_coupling
    logical, intent(in) :: double_fsr
    real(default) :: q0, z, p0, z_o_xi, onemz
    integer :: nlegs, flv_em, flv_rad
    nlegs = size (flst)
    flv_rad = flst(nlegs); flv_em = flst(emitter)
    q0 = p_res**1
    p0 = p_res * p_born(emitter) / q0
    !!! Here, z corresponds to 1-z in the formulas of arXiv:1002.2581;
    !!! the integrand is symmetric under this variable change
    z_o_xi = q0 / (two * p0)
    z = xi * z_o_xi; onemz = one - z
    if (is_gluon (flv_em) .and. is_gluon (flv_rad)) then
       sqme = coll_sub%CA * ( two * ( z / onemz * xi + onemz / z_o_xi ) * sqme_born &
            + four * xi * z * onemz * mom_times_sqme_spin_c )
    else if (is_fermion (flv_em) .and. is_fermion (flv_rad)) then
       sqme = coll_sub%TR * xi * (sqme_born - four * z * onemz * mom_times_sqme_spin_c)
    else if (is_fermion (flv_em) .and. is_massless_vector (flv_rad)) then
       sqme = sqme_born * coll_sub%CF * (one + onemz**2) / z_o_xi
    else
       sqme = zero
    end if
    sqme = sqme / (p0**2 * onemz * z_o_xi)
    sqme = sqme * four * pi * alpha_coupling
    if (double_fsr) sqme = sqme * onemz * two
  end function coll_subtraction_compute_fsr

@ %def coll_subtraction_compute_fsr
@ Like in the context of [[coll_subtraction_compute_fsr]] we compute
the quantity
\begin{equation*}
  \lim_{y\to\pm1}{\left\{\frac{J(\Phi_n,\xi,y,\phi)}{\xi}
  \left[(1-y^2)\xi^2\mathcal{R}^\alpha(\Phi_{n+1})\right]\right\}},
\end{equation*}
where the $(1-y^2)$ accounts for both $y=\pm1$. Again, the Jacobian is proportional to $\xi$, so we
drop the $J / \xi$ factor. Note that it is important to take into account this missing
factor of $\xi$ in the computation of the Jacobian during phase-space generation
both for fixed-beam and structure ISR. We consider only a $q \to qg$ splitting
arguing that other splittings are identical in terms of the
factors which cancel. It is given by
\begin{equation*}
  g^\alpha = \frac{8\pi\alpha_s}{-k_{\mathrm{em}}^2} C_F (1-y^2) \xi^2
             \frac{1+z^2}{1-z} \mathcal{B},
\end{equation*}
where $g^\alpha$ is defined akin to the one for FSR in eq.~\ref{fks: sub: real}.
Note the negative sign of $k_\mathrm{em}^2$ to compensate the negative
virtuality of the initial-state emitter. For ISR, $z$ is defined with
respect to the emitter energy entering the hard interaction, i.e.
\begin{equation*}
  z = \frac{E_\mathrm{beam} - E_\mathrm{rad}}{E_\mathrm{beam}} =
  1 - \frac{E_\mathrm{rad}}{E_\mathrm{beam}}.
\end{equation*}
Because $E_\mathrm{rad} = E_\mathrm{beam} \cdot \xi$, it is
$z = 1 - \xi$, thus one factor of $\xi$ is cancelled by $(1-z)$ in the
denominator of $g^\alpha$. The factor $k_\mathrm{em}^2$ in the
denominator is rewritten as
\begin{equation*}
  k_\mathrm{em}^2 = \left(p_\mathrm{beam} - p_\mathrm{rad}\right)^2
                  = - 2 p_\mathrm{beam} \cdot p_\mathrm{rad}
                  = - 2 E_\mathrm{beam} E_\mathrm{rad} (1\pm y)
                  = - 2 E_\mathrm{beam}^2 (1-z) (1\pm y),
\end{equation*}
where we used
\begin{equation*}
  E_\mathrm{beam} E_\mathrm{rad} = E_\mathrm{beam}^2 (1-z).
\end{equation*}
This leads to the cancellation of the corresponding $(1\pm y)$ factor in
$(1-y^2)$, with the other factor becoming a simple factor of $2$, and
the remaining factor of $\xi$ in the numerator. We thus end up with
\begin{equation*}
  g^\alpha = \frac{8\pi\alpha_s}{E_\mathrm{beam}^2} C_F \left(1 +
  z^2\right)\mathcal{B},
\end{equation*}
which is soft-finite.

Note that here in [[compute_isr]], [[sqme_born]] is supposed to be
the squared Born matrix element convoluted with the real PDF.
<<Real subtraction: coll sub: TBP>>=
  procedure :: compute_isr => coll_subtraction_compute_isr
<<Real subtraction: sub interfaces>>=
    module function coll_subtraction_compute_isr &
       (coll_sub, emitter, flst, p_born, sqme_born, mom_times_sqme_spin_c, &
       xi, alpha_coupling, isr_mode) result (sqme)
      real(default) :: sqme
      class(coll_subtraction_t), intent(in) :: coll_sub
      integer, intent(in) :: emitter
      integer, dimension(:), intent(in) :: flst
      type(vector4_t), intent(in), dimension(:) :: p_born
      real(default), intent(in) :: sqme_born
      real(default), intent(in) :: mom_times_sqme_spin_c
      real(default), intent(in) :: xi, alpha_coupling
      integer, intent(in) :: isr_mode
    end function coll_subtraction_compute_isr
<<Real subtraction: procedures>>=
  module function coll_subtraction_compute_isr &
     (coll_sub, emitter, flst, p_born, sqme_born, mom_times_sqme_spin_c, &
     xi, alpha_coupling, isr_mode) result (sqme)
    real(default) :: sqme
    class(coll_subtraction_t), intent(in) :: coll_sub
    integer, intent(in) :: emitter
    integer, dimension(:), intent(in) :: flst
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: sqme_born
    real(default), intent(in) :: mom_times_sqme_spin_c
    real(default), intent(in) :: xi, alpha_coupling
    integer, intent(in) :: isr_mode
    real(default) :: z, onemz, p02
    integer :: nlegs, flv_em, flv_rad
    !!! p_born must be in lab frame.
    nlegs = size (flst)
    flv_rad = flst(nlegs); flv_em = flst(emitter)
    !!! No need to pay attention to n_in = 1, because this case always has a
    !!! massive initial-state particle and thus no collinear divergence.
    p02 = p_born(1)%p(0) * p_born(2)%p(0) / two
    z = one - xi; onemz = xi
    if (is_massless_vector (flv_em) .and. is_massless_vector (flv_rad)) then
       sqme = coll_sub%CA * (two * (z + z * onemz**2) * sqme_born + four * onemz**2 &
          / z * mom_times_sqme_spin_c)
    else if (is_fermion (flv_em) .and. is_massless_vector (flv_rad)) then
       sqme = coll_sub%CF * (one + z**2) * sqme_born
    else if (is_fermion (flv_em) .and. is_fermion (flv_rad)) then
       sqme = coll_sub%CF * (z * onemz * sqme_born + four * onemz**2 / z * mom_times_sqme_spin_c)
    else if (is_massless_vector (flv_em) .and. is_fermion (flv_rad)) then
       sqme = coll_sub%TR * (z**2 + onemz**2) * onemz * sqme_born
    else
       sqme = zero
    end if
    if (isr_mode == SQRTS_VAR) then
       sqme = sqme / p02 * z
    else
       !!! We have no idea why this seems to work as there should be no factor
       !!! of z for the fixed-beam settings. This should definitely be understood in the
       !!! future!
       sqme = sqme / p02 / z
    end if
    sqme = sqme * four * pi * alpha_coupling
  end function coll_subtraction_compute_isr

@ %def coll_subtraction_compute_isr
@
<<Real subtraction: coll sub: TBP>>=
  procedure :: final => coll_subtraction_final
<<Real subtraction: sub interfaces>>=
    module subroutine coll_subtraction_final (sub_coll)
      class(coll_subtraction_t), intent(inout) :: sub_coll
    end subroutine coll_subtraction_final
<<Real subtraction: procedures>>=
  module subroutine coll_subtraction_final (sub_coll)
    class(coll_subtraction_t), intent(inout) :: sub_coll
    sub_coll%use_resonance_mappings = .false.
  end subroutine coll_subtraction_final

@ %def coll_subtraction_final
@
\subsection{Real Subtraction}

We store a pointer to the [[nlo_settings_t]] object which holds tuning parameters, e.g. cutoffs for the subtraction terms.
<<Real subtraction: public>>=
  public :: real_subtraction_t
<<Real subtraction: types>>=
  type :: real_subtraction_t
     type(nlo_settings_t), pointer :: settings => null ()
     type(region_data_t), pointer :: reg_data => null ()
     type(real_kinematics_t), pointer :: real_kinematics => null ()
     type(isr_kinematics_t), pointer :: isr_kinematics => null ()
     real(default), dimension(:,:), allocatable :: sqme_real_non_sub
     real(default), dimension(:), allocatable :: sqme_born
     real(default), dimension(:,:), allocatable :: sf_factors
     real(default), dimension(:), allocatable :: sqme_real_arr
     real(default), dimension(:,:,:), allocatable :: sqme_born_color_c
     real(default), dimension(:,:,:), allocatable :: sqme_born_charge_c
     real(default), dimension(:,:,:,:), allocatable :: sqme_born_spin_c
     type(soft_subtraction_t) :: sub_soft
     type(coll_subtraction_t) :: sub_coll
     logical, dimension(:), allocatable :: sc_required
     logical :: subtraction_deactivated = .false.
     integer :: purpose = INTEGRATION
     logical :: radiation_event = .true.
     logical :: subtraction_event = .false.
     integer, dimension(:), allocatable :: selected_alr
  contains
  <<Real subtraction: real subtraction: TBP>>
  end type real_subtraction_t

@ %def real_subtraction_t
@ Initializer
<<Real subtraction: real subtraction: TBP>>=
  procedure :: init => real_subtraction_init
<<Real subtraction: sub interfaces>>=
    module subroutine real_subtraction_init (rsub, reg_data, settings)
      class(real_subtraction_t), intent(inout), target :: rsub
      type(region_data_t), intent(in), target :: reg_data
      type(nlo_settings_t), intent(in), target :: settings
    end subroutine real_subtraction_init
<<Real subtraction: procedures>>=
  module subroutine real_subtraction_init (rsub, reg_data, settings)
    class(real_subtraction_t), intent(inout), target :: rsub
    type(region_data_t), intent(in), target :: reg_data
    type(nlo_settings_t), intent(in), target :: settings
    integer :: alr
    if (debug_on) call msg_debug (D_SUBTRACTION, "real_subtraction_init")
    if (debug_on) call msg_debug (D_SUBTRACTION, "n_in", reg_data%n_in)
    if (debug_on) call msg_debug &
         (D_SUBTRACTION, "nlegs_born", reg_data%n_legs_born)
    if (debug_on) call msg_debug &
         (D_SUBTRACTION, "nlegs_real", reg_data%n_legs_real)
    if (debug_on) call msg_debug &
         (D_SUBTRACTION, "reg_data%n_regions", reg_data%n_regions)
    if (debug2_active (D_SUBTRACTION))  call reg_data%write ()
    rsub%reg_data => reg_data
    allocate (rsub%sqme_born (reg_data%n_flv_born))
    rsub%sqme_born = zero
    allocate (rsub%sf_factors (reg_data%n_regions, 0:reg_data%n_in))
    rsub%sf_factors = zero
    allocate (rsub%sqme_real_arr (reg_data%n_regions))
    rsub%sqme_real_arr = zero
    allocate (rsub%sqme_born_color_c &
         (reg_data%n_legs_born, reg_data%n_legs_born, reg_data%n_flv_born))
    rsub%sqme_born_color_c = zero
    allocate (rsub%sqme_born_charge_c &
         (reg_data%n_legs_born, reg_data%n_legs_born, reg_data%n_flv_born))
    rsub%sqme_born_charge_c = zero
    allocate (rsub%sqme_real_non_sub (reg_data%n_flv_real, reg_data%n_phs))
    rsub%sqme_real_non_sub = zero
    allocate (rsub%sc_required (reg_data%n_regions))
    do alr = 1, reg_data%n_regions
       rsub%sc_required(alr) = reg_data%regions(alr)%sc_required
    end do
    if (rsub%requires_spin_correlations ()) then
       allocate (rsub%sqme_born_spin_c &
            (1:3, 1:3, reg_data%n_legs_born, reg_data%n_flv_born))
       rsub%sqme_born_spin_c = zero
    end if
    call rsub%sub_soft%init (reg_data)
    call rsub%sub_coll%init (reg_data%n_regions, reg_data%n_in)
    rsub%settings => settings
    rsub%sub_soft%use_resonance_mappings = settings%use_resonance_mappings
    rsub%sub_coll%use_resonance_mappings = settings%use_resonance_mappings
    rsub%sub_soft%factorization_mode = settings%factorization_mode
  end subroutine real_subtraction_init

@ %def real_subtraction_init
@
<<Real subtraction: real subtraction: TBP>>=
  procedure :: set_real_kinematics => real_subtraction_set_real_kinematics
<<Real subtraction: sub interfaces>>=
    module subroutine real_subtraction_set_real_kinematics &
         (rsub, real_kinematics)
      class(real_subtraction_t), intent(inout) :: rsub
      type(real_kinematics_t), intent(in), target :: real_kinematics
    end subroutine real_subtraction_set_real_kinematics
<<Real subtraction: procedures>>=
  module subroutine real_subtraction_set_real_kinematics (rsub, real_kinematics)
    class(real_subtraction_t), intent(inout) :: rsub
    type(real_kinematics_t), intent(in), target :: real_kinematics
    rsub%real_kinematics => real_kinematics
  end subroutine real_subtraction_set_real_kinematics

@ %def real_subtraction_set_real_kinematics
@
<<Real subtraction: real subtraction: TBP>>=
  procedure :: set_isr_kinematics => real_subtraction_set_isr_kinematics
<<Real subtraction: sub interfaces>>=
    module subroutine real_subtraction_set_isr_kinematics (rsub, fractions)
      class(real_subtraction_t), intent(inout) :: rsub
      type(isr_kinematics_t), intent(in), target :: fractions
    end subroutine real_subtraction_set_isr_kinematics
<<Real subtraction: procedures>>=
  module subroutine real_subtraction_set_isr_kinematics (rsub, fractions)
    class(real_subtraction_t), intent(inout) :: rsub
    type(isr_kinematics_t), intent(in), target :: fractions
    rsub%isr_kinematics => fractions
  end subroutine real_subtraction_set_isr_kinematics

@ %def real_subtraction_set_isr_kinematics
@
<<Real subtraction: real subtraction: TBP>>=
  procedure :: get_i_res => real_subtraction_get_i_res
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_get_i_res (rsub, alr) result (i_res)
      integer :: i_res
      class(real_subtraction_t), intent(inout) :: rsub
      integer, intent(in) :: alr
    end function real_subtraction_get_i_res
<<Real subtraction: procedures>>=
  module function real_subtraction_get_i_res (rsub, alr) result (i_res)
    integer :: i_res
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr
    select type (fks_mapping => rsub%reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       i_res = fks_mapping%res_map%alr_to_i_res (alr)
    class default
       i_res = 0
    end select
  end function real_subtraction_get_i_res

@ %def real_subtraction_get_i_res
@
\subsection{The real contribution to the cross section}
In each singular region $\alpha$, the real contribution to $\sigma$ is
given by the second summand of eqn. \ref{fks: sub: complete},
\begin{equation}
  \label{fks: sub: real}
  \sigma^\alpha_{\text{real}} = \int d\Phi_n \int_0^{2\pi} d\phi
  \int_{-1}^1 dy \int_0^{\xi_{\text{max}}} d\xi
  \left(\frac{1}{\xi}\right)_+ \left(\frac{1}{1-y}\right)_+
  \underbrace{\frac{J(\Phi_n, \xi, y, \phi)}{\xi}
    \left[(1-y)\xi^2\mathcal{R}^\alpha(\Phi_{n+1})\right]}_{g^\alpha(\xi,y)}.
\end{equation}
Writing out the plus-distribution and introducing $\tilde{\xi} =
\xi/\xi_{\text{max}}$ to set the upper integration limit to 1,  this
turns out to be equal to
\begin{equation}
  \begin{split}
    \sigma^\alpha_{\rm{real}} &= \int d\Phi_n \int_0^{2\pi}d\phi
    \int_{-1}^1 \frac{dy}{1-y} \Bigg\{\int_0^1
    d\tilde{\xi}\Bigg[\frac{g^\alpha(\tilde{\xi}\xi_{\rm{max}},y)}{\tilde{\xi}}
    - \underbrace{\frac{g^\alpha(0,y)}{\tilde{\xi}}}_{\text{soft}} -
    \underbrace{\frac{g^\alpha(\tilde{\xi}\xi_{\rm{max}},1)}{\tilde{\xi}}}_{\text{coll.}}
    +
    \underbrace{\frac{g^\alpha(0,1)}{\tilde{\xi}}}_{\text{coll.+soft}}\Bigg]
    \\
&+ \left[\log\xi_{\rm{max}}(y)g^\alpha(0,y) - \log\xi_{\rm{max}}(1)g^\alpha(0,1)\right]\Bigg\}.
  \end{split}
\end{equation}
This formula is implemented in \texttt{compute\_sqme\_real\_fin}

If two or more singular regions would produce the same amplitude we only compute
one and use the [[eqv_index]] to copy the result to the others (if [[reuse_amplitudes_fks]]
is true).
<<Real subtraction: real subtraction: TBP>>=
  procedure :: compute => real_subtraction_compute
<<Real subtraction: sub interfaces>>=
    module subroutine real_subtraction_compute (rsub, emitter, &
         i_phs, alpha_s, alpha_qed, separate_alrs, sqme)
      class(real_subtraction_t), intent(inout) :: rsub
      integer, intent(in) :: emitter, i_phs
      logical, intent(in) :: separate_alrs
      real(default), intent(inout), dimension(:) :: sqme
      real(default), intent(in) :: alpha_s, alpha_qed
    end subroutine real_subtraction_compute
<<Real subtraction: procedures>>=
  module subroutine real_subtraction_compute (rsub, emitter, &
       i_phs, alpha_s, alpha_qed, separate_alrs, sqme)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    logical, intent(in) :: separate_alrs
    real(default), intent(inout), dimension(:) :: sqme
    real(default), dimension(:), allocatable :: sqme_alr_arr
    real(default), intent(in) :: alpha_s, alpha_qed
    real(default) :: sqme_alr, alpha_coupling
    integer :: alr, i_con, i_res, this_emitter
    logical :: same_emitter
    logical, dimension(:), allocatable :: alr_evaluated
    allocate (alr_evaluated(rsub%reg_data%n_regions))
    allocate (sqme_alr_arr(rsub%reg_data%n_regions))
    sqme_alr_arr = zero
    alr_evaluated = .false.
    do alr = 1, rsub%reg_data%n_regions
       if (.not. alr_evaluated(rsub%reg_data%regions(alr)%eqv_index)) then
          if (allocated (rsub%selected_alr)) then
             if (.not. any (rsub%selected_alr == alr)) cycle
          end if
          sqme_alr = zero
          if (emitter > rsub%isr_kinematics%n_in) then
             same_emitter = emitter == rsub%reg_data%regions(alr)%emitter
          else
             same_emitter = rsub%reg_data%regions(alr)%emitter <= rsub%isr_kinematics%n_in
          end if
          select case (char(rsub%reg_data%regions(alr)%nlo_correction_type))
          case ("QCD")
             alpha_coupling = alpha_s
          case ("EW")
             alpha_coupling = alpha_qed
          end select
          if (same_emitter .and. i_phs == rsub%real_kinematics%alr_to_i_phs (alr)) then
             i_res = rsub%get_i_res (alr)
             this_emitter = rsub%reg_data%regions(alr)%emitter
             sqme_alr = rsub%evaluate_emitter_region (alr, this_emitter, i_phs, &
                  i_res, alpha_coupling)
             i_con = rsub%get_i_contributor (alr)
             sqme_alr = sqme_alr * rsub%get_phs_factor (i_con)
          end if
          sqme_alr_arr(alr) = sqme_alr_arr(alr) + sqme_alr
          if (.not. (debug_active (D_SUBTRACTION) .or. debug2_active (D_SUBTRACTION))) then
             if (.not. allocated (rsub%selected_alr)) &
                  alr_evaluated(rsub%reg_data%regions(alr)%eqv_index) = .true.
          end if
       else
          sqme_alr_arr(alr) = sqme_alr_arr(rsub%reg_data%regions(alr)%eqv_index)
       end if
       if (rsub%radiation_event .and. sqme_alr_arr(alr) /= zero) then
          rsub%sqme_real_arr(alr) = sqme_alr_arr(alr)
       end if
       if (separate_alrs) then
          sqme(alr) = sqme(alr) + sqme_alr_arr(alr)
       else
          sqme(1) = sqme(1) + sqme_alr_arr(alr)
       end if
    end do
    if (debug_on) then
       if (debug2_active (D_SUBTRACTION)) call check_s_alpha_consistency ()
    end if
  contains
    subroutine check_s_alpha_consistency ()
      real(default) :: sum_s_alpha, sum_s_alpha_soft
      integer :: i_ftuple
      if (debug_on) call msg_debug2 (D_SUBTRACTION, "Check consistency of s_alpha: ")
      do alr = 1, rsub%reg_data%n_regions
         sum_s_alpha = rsub%sum_up_s_alpha(alr, i_phs)
         call msg_debug2 (D_SUBTRACTION, 'sum_s_alpha', sum_s_alpha)
         if (.not. nearly_equal(sum_s_alpha, one)) then
            call msg_bug ("The sum of all S functions should be equal to one!")
         end if
         sum_s_alpha_soft = rsub%sum_up_s_alpha_soft(alr, i_phs)
         call msg_debug2 (D_SUBTRACTION, 'sum_s_alpha_soft', sum_s_alpha_soft)
         if (.not. nearly_equal(sum_s_alpha_soft, one)) then
            call msg_bug ("The sum of all soft S functions should be equal to one!")
         end if
      end do
    end subroutine check_s_alpha_consistency
  end subroutine real_subtraction_compute

@ %def real_subtraction_compute
@ The emitter is fixed. We now have to decide whether we evaluate in
ISR or FSR region, and also if resonances are used.
<<Real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_emitter_region => &
       real_subtraction_evaluate_emitter_region
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_evaluate_emitter_region (rsub, alr, &
         emitter, i_phs, i_res, alpha_coupling) result (sqme)
      real(default) :: sqme
      class(real_subtraction_t), intent(inout) :: rsub
      integer, intent(in) :: alr, emitter, i_phs, i_res
      real(default), intent(in) :: alpha_coupling
    end function real_subtraction_evaluate_emitter_region
<<Real subtraction: procedures>>=
  module function real_subtraction_evaluate_emitter_region (rsub, alr, &
       emitter, i_phs, i_res, alpha_coupling) result (sqme)
    real(default) :: sqme
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr, emitter, i_phs, i_res
    real(default), intent(in) :: alpha_coupling
    if (emitter <= rsub%isr_kinematics%n_in) then
       sqme = rsub%evaluate_region_isr &
            (alr, emitter, i_phs, i_res, alpha_coupling)
    else
       select type (fks_mapping => rsub%reg_data%fks_mapping)
       type is (fks_mapping_resonances_t)
          call fks_mapping%set_resonance_momenta &
               (rsub%real_kinematics%xi_ref_momenta)
       end select
       sqme = rsub%evaluate_region_fsr (alr, emitter, i_phs, i_res, alpha_coupling)
    end if
  end function real_subtraction_evaluate_emitter_region

@ %def real_subtraction_evaluate_emitter_region
@ Sums up $\sum_{i_1, i_2} S_{i_1 i_2}$ for the given [[alr]].
<<Real subtraction: real subtraction: TBP>>=
  procedure :: sum_up_s_alpha => real_subtraction_sum_up_s_alpha
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_sum_up_s_alpha &
         (rsub, alr, i_phs) result (sum_s_alpha)
      real(default) :: sum_s_alpha
      class(real_subtraction_t), intent(inout) :: rsub
      integer, intent(in) :: alr, i_phs
    end function real_subtraction_sum_up_s_alpha
<<Real subtraction: procedures>>=
  module function real_subtraction_sum_up_s_alpha &
       (rsub, alr, i_phs) result (sum_s_alpha)
    real(default) :: sum_s_alpha
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr, i_phs
    type(vector4_t), dimension(:), allocatable :: p_real
    integer :: i_res, i_ftuple, i1, i2
    allocate (p_real (rsub%reg_data%n_legs_real))
    if (rsub%reg_data%has_pseudo_isr ()) then
       p_real = rsub%real_kinematics%p_real_onshell(i_phs)%get_momenta (i_phs)
    else
       p_real = rsub%real_kinematics%p_real_cms%get_momenta (i_phs)
    end if
    i_res = rsub%get_i_res (alr)
    sum_s_alpha = zero
    do i_ftuple = 1, rsub%reg_data%regions(alr)%nregions
       call rsub%reg_data%regions(alr)%ftuples(i_ftuple)%get (i1, i2)
       sum_s_alpha = sum_s_alpha + rsub%reg_data%get_svalue (p_real, alr, i1, i2, i_res)
    end do
  end function real_subtraction_sum_up_s_alpha

@ %def real_subtraction_sum_up_s_alpha
@ Sums up $\sum_{i_1, i_2} S_{i_1 i_2}$ for the given [[alr]]. The
soft S functions take the real momenta in the soft limit, i.e. the
Born momenta. For each summand of [[sum_s_alpha_soft]] we take
[[p_soft]] constructed from the emitter of the given alpha region also
for ftuples in which the first integer [[i1]] does not coincide with
the emitter. This is necessary because only if we keep [[p_soft]]
fixed, all soft S functions are computed with the same denominator and
thus add up to 1.
<<Real subtraction: real subtraction: TBP>>=
  procedure :: sum_up_s_alpha_soft => real_subtraction_sum_up_s_alpha_soft
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_sum_up_s_alpha_soft &
         (rsub, alr, i_phs) result (sum_s_alpha_soft)
      real(default) :: sum_s_alpha_soft
      class(real_subtraction_t), intent(inout) :: rsub
      integer, intent(in) :: alr, i_phs
    end function real_subtraction_sum_up_s_alpha_soft
<<Real subtraction: procedures>>=
  module function real_subtraction_sum_up_s_alpha_soft &
       (rsub, alr, i_phs) result (sum_s_alpha_soft)
    real(default) :: sum_s_alpha_soft
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr, i_phs
    type(vector4_t), dimension(:), allocatable :: p_born
    integer :: i_res, i_ftuple, i1, i2, emitter, nlegs
    allocate (p_born (rsub%reg_data%n_legs_born))
    if (rsub%reg_data%has_pseudo_isr ()) then
       p_born = rsub%real_kinematics%p_born_onshell%get_momenta (1)
    else
       p_born = rsub%real_kinematics%p_born_cms%get_momenta (1)
    end if
    i_res = rsub%get_i_res (alr)
    emitter = rsub%reg_data%regions(alr)%emitter
    associate (r => rsub%real_kinematics)
       if (emitter > rsub%sub_soft%reg_data%n_in) then
          call rsub%sub_soft%create_softvec_fsr (p_born, r%y_soft(i_phs), r%phi, &
               emitter, r%xi_ref_momenta(rsub%sub_soft%i_xi_ref (alr, i_phs)))
       else
          call rsub%sub_soft%create_softvec_isr (r%y_soft(i_phs), r%phi)
       end if
    end associate
    nlegs = rsub%reg_data%n_legs_real
    sum_s_alpha_soft = zero
    do i_ftuple = 1, rsub%reg_data%regions(alr)%nregions
       call rsub%reg_data%regions(alr)%ftuples(i_ftuple)%get (i1, i2)
       if (i2 == nlegs) then
          sum_s_alpha_soft = sum_s_alpha_soft + rsub%reg_data%get_svalue_soft &
            (p_born, rsub%sub_soft%p_soft, alr, i1, i_res)
       end if
    end do
  end function real_subtraction_sum_up_s_alpha_soft

@ %def real_subtraction_sum_up_s_alpha_soft
@ This subroutine computes the finite part of the real matrix element in
an individual singular region.
First, the radiation variables are fetched and $\mathcal{R}$ is
multiplied by the appropriate $S_\alpha$-factors,
region multiplicities and double-FSR factors.
Then, it computes the soft, collinear, soft-collinear and remnant matrix
elements and supplies the corresponding factor $1/\xi/(1-y)$ as well as
the corresponding Jacobians.
<<Real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_region_fsr => real_subtraction_evaluate_region_fsr
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_evaluate_region_fsr (rsub, alr, &
         emitter, i_phs, i_res, alpha_coupling) result (sqme_tot)
      real(default) :: sqme_tot
      class(real_subtraction_t), intent(inout) :: rsub
      integer, intent(in) :: alr, emitter, i_phs, i_res
      real(default), intent(in) :: alpha_coupling
    end function real_subtraction_evaluate_region_fsr
<<Real subtraction: procedures>>=
  module function real_subtraction_evaluate_region_fsr (rsub, alr, &
       emitter, i_phs, i_res, alpha_coupling) result (sqme_tot)
    real(default) :: sqme_tot
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr, emitter, i_phs, i_res
    real(default), intent(in) :: alpha_coupling
    real(default) :: sqme_rad, sqme_soft, sqme_coll, sqme_cs, sqme_remn
    sqme_rad = zero; sqme_soft = zero; sqme_coll = zero
    sqme_cs = zero; sqme_remn = zero
    associate (region => rsub%reg_data%regions(alr), &
         template => rsub%settings%fks_template)
      if (rsub%radiation_event) then
         sqme_rad = rsub%sqme_real_non_sub &
                     (rsub%reg_data%get_matrix_element_index (alr), i_phs)
         call evaluate_fks_factors (sqme_rad, rsub%reg_data, &
              rsub%real_kinematics, alr, i_phs, emitter, i_res)
         call apply_kinematic_factors_radiation (sqme_rad, &
              rsub%real_kinematics, i_phs)
      end if
      if (rsub%subtraction_event .and. .not. (rsub%subtraction_deactivated &
            .or. region%nlo_correction_type == "none")) then
         if (debug2_active (D_SUBTRACTION)) then
            print *, "[real_subtraction_evaluate_region_fsr]"
            print *, "xi: ", rsub%real_kinematics%xi_max(i_phs) * &
                 rsub%real_kinematics%xi_tilde
            print *, "y: ", rsub%real_kinematics%y(i_phs)
         end if
         call rsub%evaluate_subtraction_terms_fsr (alr, emitter, i_phs, &
              i_res, alpha_coupling, sqme_soft, sqme_coll, sqme_cs)
         call apply_kinematic_factors_subtraction_fsr (sqme_soft, &
              sqme_coll, sqme_cs, rsub%real_kinematics, i_phs)
         associate (symm_factor_fs => &
              rsub%reg_data%born_to_real_symm_factor_fs (alr))
            sqme_soft = sqme_soft * symm_factor_fs
            sqme_coll = sqme_coll * symm_factor_fs
            sqme_cs = sqme_cs * symm_factor_fs
         end associate
         sqme_remn = compute_sqme_remnant_fsr (sqme_soft, sqme_cs, &
              rsub%real_kinematics%xi_max(i_phs), template%xi_cut, &
              rsub%real_kinematics%xi_tilde)
         sqme_tot = - sqme_soft - sqme_coll + sqme_cs + sqme_remn
      else
         sqme_tot = sqme_rad
      end if
      sqme_tot = sqme_tot * rsub%real_kinematics%jac_rand(i_phs)
      sqme_tot = sqme_tot * rsub%reg_data%regions(alr)%mult
    end associate
    if (debug_active (D_SUBTRACTION) .and. .not. &
         debug2_active (D_SUBTRACTION)) then
       call real_subtraction_register_debug_sqme (rsub, alr, emitter, &
            i_phs, sqme_rad, sqme_soft, sqme_coll=sqme_coll, sqme_cs=sqme_cs)
    else if (debug2_active (D_SUBTRACTION)) then
       call write_computation_status_fsr ()
    end if
  contains
  <<Real subtraction: real subtraction evaluate region fsr: procedures>>
    subroutine write_computation_status_fsr (passed, total, region_type, full)
      integer, intent(in), optional :: passed, total
      character(*), intent(in), optional :: region_type
      integer :: i_born
      integer :: u
      real(default) :: xi
      logical :: yorn
      logical, intent(in), optional :: full
      yorn = .true.
      if (present (full)) yorn = full
      if (debug_on)  call msg_debug &
           (D_SUBTRACTION, "real_subtraction_evaluate_region_fsr")
      u = given_output_unit (); if (u < 0) return
      i_born = rsub%reg_data%regions(alr)%uborn_index
      xi = rsub%real_kinematics%xi_max (i_phs) * rsub%real_kinematics%xi_tilde
      write (u,'(A,I2)') 'rsub%purpose: ', rsub%purpose
      write (u,'(A,I4)') 'alr: ', alr
      write (u,'(A,I3)') 'emitter: ', emitter
      write (u,'(A,I3)') 'i_phs: ', i_phs
      write (u,'(A,F6.4)') 'xi_max: ', rsub%real_kinematics%xi_max (i_phs)
      write (u,'(A,F6.4)') 'xi_cut: ', rsub%real_kinematics%xi_max(i_phs) * &
           rsub%settings%fks_template%xi_cut
      write (u,'(A,F6.4,2X,A,F6.4)') 'xi: ', xi, 'y: ', &
           rsub%real_kinematics%y (i_phs)
      if (yorn) then
         write (u,'(A,ES16.9)')  'sqme_born: ', rsub%sqme_born(i_born)
         write (u,'(A,ES16.9)')  'sqme_real: ', sqme_rad
         write (u,'(A,ES16.9)')  'sqme_soft: ', sqme_soft
         write (u,'(A,ES16.9)')  'sqme_coll: ', sqme_coll
         write (u,'(A,ES16.9)')  'sqme_coll-soft: ', sqme_cs
         write (u,'(A,ES16.9)')  'sqme_remn: ', sqme_remn
         write (u,'(A,ES16.9)')  'sqme_tot: ', sqme_tot
         if (present (passed) .and. present (total) .and. &
              present (region_type)) &
              write (u,'(A)') char (str (passed) // " of " // str (total) // &
              " " // region_type // " points passed in total")
      end if
      write (u,'(A,ES16.9)')  'jacobian - real: ', &
           rsub%real_kinematics%jac(i_phs)%jac(1)
      write (u,'(A,ES16.9)')  'jacobian - soft: ', &
           rsub%real_kinematics%jac(i_phs)%jac(2)
      write (u,'(A,ES16.9)')  'jacobian - coll: ', &
           rsub%real_kinematics%jac(i_phs)%jac(3)
    end subroutine write_computation_status_fsr
  end function real_subtraction_evaluate_region_fsr

@ %def real_subtraction_evalute_region_fsr
@ Compares the real matrix element to the subtraction terms in the soft, the collinear
or the soft-collinear limits. Used for debug purposes if [[?test_anti_coll_limit]],
[[?test_coll_limit]] and/or [[?test_soft_limit]] are set in the Sindarin.
[[sqme_soft]] and [[sqme_cs]] need to be provided if called for FSR and [[sqme_coll_plus]],
[[sqme_coll_minus]], [[sqme_cs_plus]] as well as [[sqme_cs_minus]] need to be provided if called for ISR.
<<Real subtraction: procedures>>=
  subroutine real_subtraction_register_debug_sqme (rsub, alr, emitter, i_phs, sqme_rad, sqme_soft,&
      sqme_coll, sqme_cs, sqme_coll_plus, sqme_coll_minus, sqme_cs_plus, sqme_cs_minus)
    class(real_subtraction_t), intent(in) :: rsub
    integer, intent(in) :: alr, emitter, i_phs
    real(default), intent(in) :: sqme_rad, sqme_soft
    real(default), intent(in), optional :: sqme_coll, sqme_cs, sqme_coll_plus, sqme_coll_minus, sqme_cs_plus, sqme_cs_minus
    real(default), dimension(:), allocatable, save :: sqme_rad_store
    logical :: is_soft, is_collinear_plus, is_collinear_minus, is_fsr
    real(default), parameter :: soft_threshold = 0.001_default
    real(default), parameter :: coll_threshold = 0.99_default
    real(default), parameter :: rel_smallness = 0.01_default
    real(default) :: sqme_dummy, this_sqme_rad, y, xi_tilde
    logical, dimension(:), allocatable, save :: count_alr

    if (.not. allocated (sqme_rad_store)) then
       allocate (sqme_rad_store (rsub%reg_data%n_regions))
       sqme_rad_store = zero
    end if
    if (rsub%radiation_event) then
       sqme_rad_store(alr) = sqme_rad
    else
       if (.not. allocated (count_alr)) then
          allocate (count_alr (rsub%reg_data%n_regions))
          count_alr = .false.
       end if

       if (is_massless_vector (rsub%reg_data%regions(alr)%flst_real%flst(rsub%reg_data%n_legs_real))) then
          xi_tilde = rsub%real_kinematics%xi_tilde
          is_soft = xi_tilde < soft_threshold
       else
          is_soft = .false.
       end if
       y = rsub%real_kinematics%y(i_phs)
       is_collinear_plus = y > coll_threshold .and. &
            rsub%reg_data%regions(alr)%has_collinear_divergence()
       is_collinear_minus = -y > coll_threshold .and. &
            rsub%reg_data%regions(alr)%has_collinear_divergence()

       is_fsr = emitter > rsub%isr_kinematics%n_in

       if (is_fsr) then
          if (.not. present(sqme_coll) .or. .not. present(sqme_cs)) &
             call msg_error ("real_subtraction_register_debug_sqme: Wrong arguments for FSR")
       else
          if (.not. present(sqme_coll_plus) .or. .not. present(sqme_coll_minus) &
               .or. .not. present(sqme_cs_plus) .or. .not. present(sqme_cs_minus)) &
             call msg_error ("real_subtraction_register_debug_sqme: Wrong arguments for ISR")
       end if

       this_sqme_rad = sqme_rad_store(alr)
       if (is_soft .and. .not. is_collinear_plus .and. .not. is_collinear_minus) then
          if ( .not. nearly_equal (this_sqme_rad, sqme_soft, &
               abs_smallness=tiny(1._default), rel_smallness=rel_smallness)) then
             call msg_print_color (char ("Soft MEs do not match in region " // str (alr)), COL_RED)
          else
             call msg_print_color (char ("sqme_soft OK in region " // str (alr)), COL_GREEN)
          end if
          print *, 'this_sqme_rad, sqme_soft =    ', this_sqme_rad, sqme_soft
       end if

       if (is_collinear_plus .and. .not. is_soft) then
          if (is_fsr) then
             if ( .not. nearly_equal (this_sqme_rad, sqme_coll, &
                 abs_smallness=tiny(1._default), rel_smallness=rel_smallness)) then
               call msg_print_color (char ("Collinear MEs do not match in region " // str (alr)), COL_RED)
             else
               call msg_print_color (char ("sqme_coll OK in region " // str (alr)), COL_GREEN)
             end if
             print *, 'this_sqme_rad, sqme_coll =    ', this_sqme_rad, sqme_coll
          else
             if ( .not. nearly_equal (this_sqme_rad, sqme_coll_plus, &
                  abs_smallness=tiny(1._default), rel_smallness=rel_smallness)) then
             call msg_print_color (char ("Collinear MEs do not match in region " // str (alr)), COL_RED)
             else
                call msg_print_color (char ("sqme_coll_plus OK in region " // str (alr)), COL_GREEN)
             end if
             print *, 'this_sqme_rad, sqme_coll_plus =    ', this_sqme_rad, sqme_coll_plus
          end if
       end if

       if (is_collinear_minus .and. .not. is_soft) then
          if (.not. is_fsr) then
             if ( .not. nearly_equal (this_sqme_rad, sqme_coll_minus, &
                  abs_smallness=tiny(1._default), rel_smallness=rel_smallness)) then
                call msg_print_color (char ("Collinear MEs do not match in region " // str (alr)), COL_RED)
             else
                call msg_print_color (char ("sqme_coll_minus OK in region " // str (alr)), COL_GREEN)
             end if
             print *, 'this_sqme_rad, sqme_coll_minus =    ', this_sqme_rad, sqme_coll_minus
          end if
       end if

       if (is_soft .and. is_collinear_plus) then
          if (is_fsr) then
             if ( .not. nearly_equal (this_sqme_rad, sqme_cs, &
                  abs_smallness=tiny(1._default), rel_smallness=rel_smallness)) then
                call msg_print_color (char ("Soft-collinear MEs do not match in region " // str (alr)), COL_RED)
             else
                call msg_print_color (char ("sqme_cs OK in region " // str (alr)), COL_GREEN)
             end if
             print *, 'this_sqme_rad, sqme_cs =    ', this_sqme_rad, sqme_cs
          else
             if ( .not. nearly_equal (this_sqme_rad, sqme_cs_plus, &
                  abs_smallness=tiny(1._default), rel_smallness=rel_smallness)) then
                call msg_print_color (char ("Soft-collinear MEs do not match in region " // str (alr)), COL_RED)
             else
                call msg_print_color (char ("sqme_cs_plus OK in region " // str (alr)), COL_GREEN)
             end if
             print *, 'this_sqme_rad, sqme_cs_plus =    ', this_sqme_rad, sqme_cs_plus
          end if
       end if

       if (is_soft .and. is_collinear_minus) then
          if (.not. is_fsr) then
             if ( .not. nearly_equal (this_sqme_rad, sqme_cs_minus, &
                  abs_smallness=tiny(1._default), rel_smallness=rel_smallness)) then
                call msg_print_color (char ("Soft-collinear MEs do not match in region " // str (alr)), COL_RED)
             else
                call msg_print_color (char ("sqme_cs_minus OK in region " // str (alr)), COL_GREEN)
             end if
             print *, 'this_sqme_rad, sqme_cs_minus =    ', this_sqme_rad, sqme_cs_minus
          end if
       end if

       count_alr (alr) = .true.
       if (all (count_alr)) then
          deallocate (count_alr)
          deallocate (sqme_rad_store)
       end if
    end if
  end subroutine real_subtraction_register_debug_sqme

@ %def real_subtraction_register_debug_sqme
@ For final state radiation, the subtraction remnant cross section is
\begin{equation}
  \sigma_{\text{remn}} = \left(\sigma_{\text{soft}} - \sigma_{\text{soft-coll}}\right)
      \log (\xi_{\text{max}}) \cdot \frac{\tilde{\xi}}{\xi_{\text{cut}}}.
\end{equation}
There is only one factor of $\log (\xi_{\text{max}})$ for both limits
as $\xi_{\text{max}}$ does not depend on $y$ in the case of FSR.
We use the already computed [[sqme_soft]] and [[sqme_cs]] with a factor of
$\tilde{\xi}$ which we have to compensate. We also need a factor $1/\xi_{\text{cut}}$ here
to assure that the cross section is independent of this free cutoff parameter.
However, it still remains to be motivated analytically.
<<Real subtraction: real subtraction evaluate region fsr: procedures>>=
  function compute_sqme_remnant_fsr (sqme_soft, sqme_cs, xi_max, xi_cut, xi_tilde) result (sqme_remn)
    real(default) :: sqme_remn
    real(default), intent(in) :: sqme_soft, sqme_cs, xi_max, xi_cut, xi_tilde
    if (debug_on) call msg_debug (D_SUBTRACTION, "compute_sqme_remnant_fsr")
    sqme_remn = (sqme_soft - sqme_cs) * log (xi_max) * xi_tilde / xi_cut
  end function compute_sqme_remnant_fsr

@ %def compute_sqme_remnant_fsr
@
<<Real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_region_isr => real_subtraction_evaluate_region_isr
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_evaluate_region_isr (rsub, alr, &
         emitter, i_phs, i_res, alpha_coupling) result (sqme_tot)
      real(default) :: sqme_tot
      class(real_subtraction_t), intent(inout) :: rsub
      integer, intent(in) :: alr, emitter, i_phs, i_res
      real(default), intent(in) :: alpha_coupling
    end function real_subtraction_evaluate_region_isr
<<Real subtraction: procedures>>=
  module function real_subtraction_evaluate_region_isr (rsub, alr, &
       emitter, i_phs, i_res, alpha_coupling) result (sqme_tot)
    real(default) :: sqme_tot
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr, emitter, i_phs, i_res
    real(default), intent(in) :: alpha_coupling
    real(default) :: sqme_rad, sqme_soft, sqme_coll_plus, sqme_coll_minus
    real(default) :: sqme_cs_plus, sqme_cs_minus
    real(default) :: sqme_remn
    sqme_rad = zero; sqme_soft = zero;
    sqme_coll_plus = zero; sqme_coll_minus = zero
    sqme_cs_plus = zero; sqme_cs_minus = zero
    sqme_remn = zero
    associate (region => rsub%reg_data%regions(alr), template => rsub%settings%fks_template)
      if (rsub%radiation_event) then
         sqme_rad = rsub%sqme_real_non_sub (rsub%reg_data%get_matrix_element_index (alr), i_phs)
         call evaluate_fks_factors (sqme_rad, rsub%reg_data, rsub%real_kinematics, &
              alr, i_phs, emitter, i_res)
         call apply_kinematic_factors_radiation (sqme_rad, rsub%real_kinematics, i_phs)
      end if
      if (rsub%subtraction_event .and. .not. (rsub%subtraction_deactivated &
            .or. region%nlo_correction_type == "none")) then
         call rsub%evaluate_subtraction_terms_isr (alr, emitter, i_phs, i_res, alpha_coupling, &
              sqme_soft, sqme_coll_plus, sqme_coll_minus, sqme_cs_plus, sqme_cs_minus)
         call apply_kinematic_factors_subtraction_isr (sqme_soft, sqme_coll_plus, &
              sqme_coll_minus, sqme_cs_plus, sqme_cs_minus, rsub%real_kinematics, i_phs)
         associate (symm_factor_fs => rsub%reg_data%born_to_real_symm_factor_fs (alr))
            sqme_soft = sqme_soft * symm_factor_fs
            sqme_coll_plus = sqme_coll_plus * symm_factor_fs
            sqme_coll_minus = sqme_coll_minus * symm_factor_fs
            sqme_cs_plus = sqme_cs_plus * symm_factor_fs
            sqme_cs_minus = sqme_cs_minus * symm_factor_fs
         end associate
         sqme_remn = compute_sqme_remnant_isr (rsub%isr_kinematics%isr_mode, &
              sqme_soft, sqme_cs_plus, sqme_cs_minus, &
              rsub%isr_kinematics, rsub%real_kinematics, i_phs, template%xi_cut)
         sqme_tot = - sqme_soft - sqme_coll_plus - sqme_coll_minus &
              + sqme_cs_plus + sqme_cs_minus + sqme_remn
      else
         sqme_tot = sqme_rad
      end if
    end associate
    sqme_tot = sqme_tot * rsub%real_kinematics%jac_rand (i_phs)
    sqme_tot = sqme_tot * rsub%reg_data%regions(alr)%mult
    if (debug_active (D_SUBTRACTION) .and. .not. debug2_active (D_SUBTRACTION)) then
       call real_subtraction_register_debug_sqme (rsub, alr, emitter, i_phs, sqme_rad,&
            sqme_soft, sqme_coll_plus=sqme_coll_plus, sqme_coll_minus=sqme_coll_minus,&
            sqme_cs_plus=sqme_cs_plus, sqme_cs_minus=sqme_cs_minus)
    else if (debug2_active (D_SUBTRACTION)) then
       call write_computation_status_isr ()
    end if
  contains
  <<Real subtraction: evaluate region isr: procedures>>
    subroutine write_computation_status_isr (unit)
       integer, intent(in), optional :: unit
       integer :: i_born
       integer :: u
       real(default) :: xi
       u = given_output_unit (unit); if (u < 0) return
       i_born = rsub%reg_data%regions(alr)%uborn_index
       xi = rsub%real_kinematics%xi_max (i_phs) * rsub%real_kinematics%xi_tilde
       write (u,'(A,I4)') 'alr: ', alr
       write (u,'(A,I2)') 'emitter: ', emitter
       write (u,'(A,F4.2)') 'xi_max: ', rsub%real_kinematics%xi_max (i_phs)
       print *, 'xi: ', xi, 'y: ', rsub%real_kinematics%y (i_phs)
       print *, 'xb1: ', rsub%isr_kinematics%x(1), 'xb2: ', rsub%isr_kinematics%x(2)
       print *, 'random jacobian: ', rsub%real_kinematics%jac_rand (i_phs)
       write (u,'(A,ES16.9)')  'sqme_born: ', rsub%sqme_born(i_born)
       write (u,'(A,ES16.9)')  'sqme_real: ', sqme_rad
       write (u,'(A,ES16.9)')  'sqme_soft: ', sqme_soft
       write (u,'(A,ES16.9)')  'sqme_coll_plus: ', sqme_coll_plus
       write (u,'(A,ES16.9)')  'sqme_coll_minus: ', sqme_coll_minus
       write (u,'(A,ES16.9)')  'sqme_cs_plus: ', sqme_cs_plus
       write (u,'(A,ES16.9)')  'sqme_cs_minus: ', sqme_cs_minus
       write (u,'(A,ES16.9)')  'sqme_remn: ', sqme_remn
       write (u,'(A,ES16.9)')  'sqme_tot: ', sqme_tot
       write (u,'(A,ES16.9)')  'jacobian - real: ', rsub%real_kinematics%jac(i_phs)%jac(1)
       write (u,'(A,ES16.9)')  'jacobian - soft: ', rsub%real_kinematics%jac(i_phs)%jac(2)
       write (u,'(A,ES16.9)')  'jacobian - collplus: ', rsub%real_kinematics%jac(i_phs)%jac(3)
       write (u,'(A,ES16.9)')  'jacobian - collminus: ', rsub%real_kinematics%jac(i_phs)%jac(4)
    end subroutine write_computation_status_isr
  end function real_subtraction_evaluate_region_isr

@ %def real_subtraction_evaluate_region_isr
@ Computes the soft remnant for ISR. The formulas can be found in arXiv:1002.2581, eq. 4.21.
and arXiv:0709.2092, sec. 5.1.2.
This results in
\begin{equation}
  \sigma_{\text{remn}}^{\text{ISR}} = \log(\xi_{\text{max}}(y)) \sigma_{\text{soft}}
  - \frac{1}{2} \log(\xi_{\text{max}}(1)) \sigma^{\text{soft-coll}}_{\oplus}
  - \frac{1}{2} \log(\xi_{\text{max}}(-1)) \sigma^{\text{soft-coll}}_{\ominus}
\end{equation}
where for ISR, $\xi_{\text{max}}$ does explicitly depend on $y$
due to the rescaling of the $x$ values from the Born to the real partonic system according to
\begin{equation}
  x_\oplus = \frac{\overline{x}_\oplus}{\sqrt{1-\xi}} \sqrt{\frac{2-\xi(1-y)}{2-\xi(1+y)}}
  , \qquad
  x_\ominus = \frac{\overline{x}_\ominus}{\sqrt{1-\xi}} \sqrt{\frac{2-\xi(1+y)}{2-\xi(1-y)}}
\end{equation}
As $\xi_{\text{max}}$ is determined by the fact that the real $x_\oplus,x_\ominus$ have to
stay in a physically meaningful regime, i.e. $x_\oplus,x_\ominus < 1$, this leads to
\begin{align}
\label{eqn:xi_max_isr}
\xi_\text{max} = 1 - \text{max}
  &\left\{\frac{2(1+y)\overline{x}_\oplus^2}{\sqrt{(1+\overline{x}_\oplus^2)^2(1-y)^2 + 16y\overline{x}_\oplus^2} + (1-y)(1-\overline{x}_\oplus^2)}\right., \\
  &\left.\frac{2(1-y)\overline{x}_\oplus^2}{\sqrt{(1+\overline{x}_\oplus^2)^2(1+y)^2 - 16y\overline{x}_\oplus^2} + (1+y)(1-\overline{x}_\oplus^2)}\right\}
\end{align}
and thus
\begin{align}
  \xi_{\text{max}}(y=1) &= 1 - \overline{x}_\oplus \\
  \xi_{\text{max}}(y=-1) &= 1 - \overline{x}_\ominus
\end{align}
So we need to use the unrescaled $\overline{x}_\oplus,\overline{x}_\ominus$ here.
Factors of $\frac{1}{2}$ and $\frac{1}{\tilde{\xi}}$
are already included in the matrix elements from [[apply_kinematic_factors_subtraction_isr]].
We keep the former and remove the latter by multiplying with $\tilde{\xi}$.
The factor $1/\xi_{\text{cut}}$ is probably needed to assure that the cross section is
independent of this free cutoff parameter in analogy to the FSR case.
However, it still remains to be motivated analytically and to be validated.
<<Real subtraction: evaluate region isr: procedures>>=
  function compute_sqme_remnant_isr (isr_mode, sqme_soft, sqme_cs_plus, sqme_cs_minus, &
     isr_kinematics, real_kinematics, i_phs, xi_cut) result (sqme_remn)
    real(default) :: sqme_remn
    integer, intent(in) :: isr_mode
    real(default), intent(in) :: sqme_soft, sqme_cs_plus, sqme_cs_minus
    type(isr_kinematics_t), intent(in) :: isr_kinematics
    type(real_kinematics_t), intent(in) :: real_kinematics
    integer, intent(in) :: i_phs
    real(default), intent(in) :: xi_cut
    real(default) :: xi_tilde, xi_max, xi_max_plus, xi_max_minus, xb_plus, xb_minus
    xi_max = real_kinematics%xi_max (i_phs)
    xi_tilde = real_kinematics%xi_tilde
    select case (isr_mode)
    case (SQRTS_VAR)
       xb_plus = isr_kinematics%x(I_PLUS)
       xb_minus = isr_kinematics%x(I_MINUS)
       xi_max_plus = one - xb_plus
       xi_max_minus = one - xb_minus
    case (SQRTS_FIXED)
       xi_max_plus = real_kinematics%xi_max (i_phs)
       xi_max_minus = real_kinematics%xi_max (i_phs)
    end select
    sqme_remn = log (xi_max) * xi_tilde * sqme_soft &
         - log (xi_max_plus) * xi_tilde * sqme_cs_plus &
         - log (xi_max_minus) * xi_tilde * sqme_cs_minus
    sqme_remn = sqme_remn / xi_cut
  end function compute_sqme_remnant_isr

@ %def compute_sqme_remnant_isr
@
<<Real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_subtraction_terms_fsr => &
       real_subtraction_evaluate_subtraction_terms_fsr
<<Real subtraction: sub interfaces>>=
    module subroutine real_subtraction_evaluate_subtraction_terms_fsr &
         (rsub, alr, emitter, i_phs, i_res, alpha_coupling, sqme_soft, &
          sqme_coll, sqme_cs)
      class(real_subtraction_t), intent(inout) :: rsub
      integer, intent(in) :: alr, emitter, i_phs, i_res
      real(default), intent(in) :: alpha_coupling
      real(default), intent(out) :: sqme_soft, sqme_coll, sqme_cs
    end subroutine real_subtraction_evaluate_subtraction_terms_fsr
<<Real subtraction: procedures>>=
  module subroutine real_subtraction_evaluate_subtraction_terms_fsr &
       (rsub, alr, emitter, i_phs, i_res, alpha_coupling, sqme_soft, &
        sqme_coll, sqme_cs)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr, emitter, i_phs, i_res
    real(default), intent(in) :: alpha_coupling
    real(default), intent(out) :: sqme_soft, sqme_coll, sqme_cs
    if (debug_on)  call msg_debug &
         (D_SUBTRACTION, "real_subtraction_evaluate_subtraction_terms_fsr")
    sqme_soft = zero; sqme_coll = zero; sqme_cs = zero
    associate (xi_tilde => rsub%real_kinematics%xi_tilde, &
         y => rsub%real_kinematics%y(i_phs), &
         template => rsub%settings%fks_template)
      if (template%xi_cut > xi_tilde) &
           sqme_soft = rsub%compute_sub_soft &
                         (alr, emitter, i_phs, i_res, alpha_coupling)
      if (y - 1 + template%delta_o > 0) &
           sqme_coll = rsub%compute_sub_coll &
                         (alr, emitter, i_phs, alpha_coupling)
      if (template%xi_cut > xi_tilde .and. y - 1 + template%delta_o > 0) &
           sqme_cs = rsub%compute_sub_coll_soft &
                         (alr, emitter, i_phs, alpha_coupling)
      if (debug2_active (D_SUBTRACTION)) then
         print *, "FSR Cutoff:"
         print *, "sub_soft: ", &
              template%xi_cut > xi_tilde, "(ME: ", sqme_soft, ")"
         print *, "sub_coll: ", &
              (y - 1 + template%delta_o) > 0, "(ME: ", sqme_coll, ")"
         print *, "sub_coll_soft: ", &
              template%xi_cut > xi_tilde .and. (y - 1 + template%delta_o) > 0, &
              "(ME: ", sqme_cs, ")"
      end if
    end associate
  end subroutine real_subtraction_evaluate_subtraction_terms_fsr

@ %def real_subtraction_evaluate_subtraction_terms_fsr
@
<<Real subtraction: procedures>>=
  subroutine evaluate_fks_factors (sqme, reg_data, real_kinematics, &
      alr, i_phs, emitter, i_res)
    real(default), intent(inout) :: sqme
    type(region_data_t), intent(inout) :: reg_data
    type(real_kinematics_t), intent(in), target :: real_kinematics
    integer, intent(in) :: alr, i_phs, emitter, i_res
    real(default) :: s_alpha
    type(phs_point_set_t), pointer :: p_real => null ()
    if (reg_data%has_pseudo_isr ()) then
       p_real => real_kinematics%p_real_onshell (i_phs)
    else
       p_real => real_kinematics%p_real_cms
    end if
    s_alpha = reg_data%get_svalue (p_real%get_momenta(i_phs), alr, emitter, i_res)
    if (debug2_active (D_SUBTRACTION)) call msg_print_color('s_alpha', s_alpha, COL_YELLOW)
    if (s_alpha > one + tiny_07) call msg_fatal ("s_alpha > 1!")
    sqme = sqme * s_alpha
    associate (region => reg_data%regions(alr))
       if (emitter > reg_data%n_in) then
          if (debug2_active (D_SUBTRACTION)) &
               print *, 'Double FSR: ', region%double_fsr_factor (p_real%get_momenta(i_phs))
          sqme = sqme * region%double_fsr_factor (p_real%get_momenta(i_phs))
       end if
    end associate
  end subroutine evaluate_fks_factors

@ %def evaluate_fks_factors
@ Applies the kinematic dependent part of the Jacobian
to the squared matrix element. During integration and when generating
fixed order events, the non-kinematic part $\frac{s}{(4\pi)^3}$ is applied
in [[real_subtraction_compute]] via [[get_phs_factor]].
The additional factor $\frac{\xi}{\tilde\xi}$ comes from
eq.~(4.19f) in arXiv:1002.2581.
<<Real subtraction: procedures>>=
  subroutine apply_kinematic_factors_radiation (sqme, &
       real_kinematics, i_phs)
    real(default), intent(inout) :: sqme
    type(real_kinematics_t), intent(in) :: real_kinematics
    integer, intent(in) :: i_phs
    real(default) :: xi, xi_tilde, s_b
    xi_tilde = real_kinematics%xi_tilde
    xi = xi_tilde * real_kinematics%xi_max (i_phs)
    sqme = sqme * xi**2 / xi_tilde * real_kinematics%jac(i_phs)%jac(1)
  end subroutine apply_kinematic_factors_radiation

@ %def apply_kinematic_factors_radiation
@ This routine applies the factors in the integrand of eq. 4.20
in arXiv:1002.2581 to the matrix elements.
<<Real subtraction: procedures>>=
  subroutine apply_kinematic_factors_subtraction_fsr &
     (sqme_soft, sqme_coll, sqme_cs, real_kinematics, i_phs)
    real(default), intent(inout) :: sqme_soft, sqme_coll, sqme_cs
    type(real_kinematics_t), intent(in) :: real_kinematics
    integer, intent(in) :: i_phs
    real(default) :: xi_tilde, onemy
    xi_tilde = real_kinematics%xi_tilde
    onemy = one - real_kinematics%y(i_phs)
    sqme_soft = sqme_soft / onemy / xi_tilde
    sqme_coll = sqme_coll / onemy / xi_tilde
    sqme_cs = sqme_cs / onemy / xi_tilde
    associate (jac => real_kinematics%jac(i_phs)%jac)
       sqme_soft = sqme_soft * jac(2)
       sqme_coll = sqme_coll * jac(3)
       sqme_cs = sqme_cs * jac(2)
    end associate
  end subroutine apply_kinematic_factors_subtraction_fsr

@ %def apply_kinematic_factors_subtraction_fsr
@ This routine applies the factors in the integrand of eq. 4.21
in arXiv:1002.2581 to the matrix elements.
<<Real subtraction: procedures>>=
  subroutine apply_kinematic_factors_subtraction_isr &
     (sqme_soft, sqme_coll_plus, sqme_coll_minus, sqme_cs_plus, &
      sqme_cs_minus, real_kinematics, i_phs)
    real(default), intent(inout) :: sqme_soft, sqme_coll_plus, sqme_coll_minus
    real(default), intent(inout) :: sqme_cs_plus, sqme_cs_minus
    type(real_kinematics_t), intent(in) :: real_kinematics
    integer, intent(in) :: i_phs
    real(default) :: xi_tilde, y, onemy, onepy
    xi_tilde = real_kinematics%xi_tilde
    y = real_kinematics%y (i_phs)
    onemy = one - y; onepy = one + y
    associate (jac => real_kinematics%jac(i_phs)%jac)
       sqme_soft = sqme_soft / (one - y**2) / xi_tilde * jac(2)
       sqme_coll_plus = sqme_coll_plus / onemy / xi_tilde / two * jac(3)
       sqme_coll_minus = sqme_coll_minus / onepy / xi_tilde / two * jac(4)
       sqme_cs_plus = sqme_cs_plus / onemy / xi_tilde / two * jac(2)
       sqme_cs_minus = sqme_cs_minus / onepy / xi_tilde / two * jac(2)
    end associate
  end subroutine apply_kinematic_factors_subtraction_isr

@ %def apply_kinematic_factors_subtraction_isr
@ This subroutine evaluates the soft and collinear subtraction terms for ISR.
References:
\begin{itemize}
  \item arXiv:0709.2092, sec. 2.4.2
  \item arXiv:0908.4272, sec. 4.2
\end{itemize}
For the collinear terms, the procedure is as follows:

If the emitter is 0, then a gluon was radiated from one of the
incoming partons. Gluon emissions require two counter terms:
One for emission in the direction of the first incoming parton
$\oplus$ and a second for emission in the direction of the second
incoming parton $\ominus$ because in both cases, there are divergent
diagrams contributing to the matrix element. So in this case both,
[[sqme_coll_plus]] and [[sqme_coll_minus]], are non-zero.

If the emitter is 1 or 2, then a quark was emitted instead of a
gluon. This only leads to a divergence collinear to the emitter
because for anti-collinear quark emission, there are simply no
divergent diagrams in the same region as two collinear quarks that
cannot originate in the same splitting are non-divergent. This means
that in case the emitter is 1, we need non-zero [[sqme_coll_plus]]
and in case the emitter is 2, we need non-zero [[sqme_coll_minus]].

At this point, we want to remind ourselves that in case of initial
state divergences,  $y$ is just the polar angle, so the
[[sqme_coll_minus]] terms are there to counter emissions in the
direction of the second incoming parton $\ominus$ and {\em not} to
counter in general anti-collinear divergences.
<<Real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_subtraction_terms_isr => &
      real_subtraction_evaluate_subtraction_terms_isr
<<Real subtraction: sub interfaces>>=
    module subroutine real_subtraction_evaluate_subtraction_terms_isr (rsub, &
        alr, emitter, i_phs, i_res, alpha_coupling, sqme_soft, sqme_coll_plus, &
        sqme_coll_minus, sqme_cs_plus, sqme_cs_minus)
      class(real_subtraction_t), intent(inout) :: rsub
      integer, intent(in) :: alr, emitter, i_phs, i_res
      real(default), intent(in) :: alpha_coupling
      real(default), intent(out) :: sqme_soft
      real(default), intent(out) :: sqme_coll_plus, sqme_coll_minus
      real(default), intent(out) :: sqme_cs_plus, sqme_cs_minus
    end subroutine real_subtraction_evaluate_subtraction_terms_isr
<<Real subtraction: procedures>>=
  module subroutine real_subtraction_evaluate_subtraction_terms_isr (rsub, &
      alr, emitter, i_phs, i_res, alpha_coupling, sqme_soft, sqme_coll_plus, &
      sqme_coll_minus, sqme_cs_plus, sqme_cs_minus)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr, emitter, i_phs, i_res
    real(default), intent(in) :: alpha_coupling
    real(default), intent(out) :: sqme_soft
    real(default), intent(out) :: sqme_coll_plus, sqme_coll_minus
    real(default), intent(out) :: sqme_cs_plus, sqme_cs_minus
    sqme_coll_plus = zero; sqme_cs_plus = zero
    sqme_coll_minus = zero; sqme_cs_minus = zero
    associate (xi_tilde => rsub%real_kinematics%xi_tilde, &
         y => rsub%real_kinematics%y(i_phs), &
         template => rsub%settings%fks_template)
      if (template%xi_cut > xi_tilde) &
           sqme_soft = rsub%compute_sub_soft &
           (alr, emitter, i_phs, i_res, alpha_coupling)
      if (emitter /= 2) then
         if (y - 1 + template%delta_i > 0) then
            sqme_coll_plus = &
                 rsub%compute_sub_coll (alr, 1, i_phs, alpha_coupling)
            if (template%xi_cut > xi_tilde) then
               sqme_cs_plus = &
                    rsub%compute_sub_coll_soft (alr, 1, i_phs, alpha_coupling)
            end if
         end if
      end if
      if (emitter /= 1) then
         if (-y - 1 + template%delta_i > 0) then
            sqme_coll_minus = &
                 rsub%compute_sub_coll (alr, 2, i_phs, alpha_coupling)
            if (template%xi_cut > xi_tilde) then
               sqme_cs_minus = &
                    rsub%compute_sub_coll_soft (alr, 2, i_phs, alpha_coupling)
            end if
         end if
      end if
      if (debug2_active (D_SUBTRACTION)) then
         print *, "ISR Cutoff:"
         print *, "y: ", y
         print *, "delta_i: ", template%delta_i
         print *, "emitter: ", emitter
         print *, "sub_soft: ", &
              template%xi_cut > xi_tilde, "(ME: ", sqme_soft, ")"
         print *, "sub_coll_plus: ", &
              (y - 1 + template%delta_i) > 0, "(ME: ", sqme_coll_plus, ")"
         print *, "sub_coll_minus: ", &
              (-y - 1 + template%delta_i) > 0, "(ME: ", sqme_coll_minus, ")"
         print *, "sub_coll_soft_plus: ", template%xi_cut > xi_tilde .and. &
              (y - 1 + template%delta_i) > 0, "(ME: ", sqme_cs_plus, ")"
         print *, "sub_coll_soft_minus: ", template%xi_cut > xi_tilde .and. &
              (-y - 1 + template%delta_i) > 0, "(ME: ", sqme_cs_minus, ")"
      end if
    end associate
  end subroutine real_subtraction_evaluate_subtraction_terms_isr

@ %def real_subtraction_evaluate_subtraction_terms_isr
@ This is basically the global part of the real Jacobian corresponding to
\begin{equation*}
  \frac{q^2}{8 (2\pi)^3}.
\end{equation*}
We interpret it as the additional phase space factor of the real component,
to be more consistent with the evaluation of the Born phase space.

We specifically use the Born center-of-mass energy here.
The real center-of-mass energy is only different from the Born center-of-mass
energy in case of ISR. The missing factor $\frac{1}{1 - \xi}$ for this
conversion is supplied in [[phs_fks_generator_generate_isr]].
<<Real subtraction: real subtraction: TBP>>=
  procedure :: get_phs_factor => real_subtraction_get_phs_factor
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_get_phs_factor &
         (rsub, i_con) result (factor)
      real(default) :: factor
      class(real_subtraction_t), intent(in) :: rsub
      integer, intent(in) :: i_con
    end function real_subtraction_get_phs_factor
<<Real subtraction: procedures>>=
  module function real_subtraction_get_phs_factor (rsub, i_con) result (factor)
    real(default) :: factor
    class(real_subtraction_t), intent(in) :: rsub
    integer, intent(in) :: i_con
    real(default) :: s
    s = rsub%real_kinematics%xi_ref_momenta (i_con)**2
    factor = s / (8 * twopi3)
  end function real_subtraction_get_phs_factor

@ %def real_subtraction_get_phs_factor
@
<<Real subtraction: real subtraction: TBP>>=
  procedure :: get_i_contributor => real_subtraction_get_i_contributor
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_get_i_contributor &
         (rsub, alr) result (i_con)
      integer :: i_con
      class(real_subtraction_t), intent(in) :: rsub
      integer, intent(in) :: alr
    end function real_subtraction_get_i_contributor
<<Real subtraction: procedures>>=
  module function real_subtraction_get_i_contributor (rsub, alr) result (i_con)
    integer :: i_con
    class(real_subtraction_t), intent(in) :: rsub
    integer, intent(in) :: alr
    if (allocated (rsub%reg_data%alr_to_i_contributor)) then
       i_con = rsub%reg_data%alr_to_i_contributor (alr)
    else
       i_con = 1
    end if
  end function real_subtraction_get_i_contributor

@ %def real_subtraction_get_i_contributor
@ Computes the soft subtraction term.
If there is an initial state emission having a soft divergence, then a gluon
has to have been emitted. A gluon can always be emitted from both IS partons
and thus, we can take the [[sf_factor]] for emitter $0$ in this case.
Be aware that this approach will not work for $pe$ collisions.
<<Real subtraction: real subtraction: TBP>>=
  procedure :: compute_sub_soft => real_subtraction_compute_sub_soft
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_compute_sub_soft (rsub, alr, emitter, &
         i_phs, i_res, alpha_coupling) result (sqme_soft)
      real(default) :: sqme_soft
      class(real_subtraction_t), intent(inout) :: rsub
      integer, intent(in) :: alr, emitter, i_phs, i_res
      real(default), intent(in) :: alpha_coupling
    end function real_subtraction_compute_sub_soft
<<Real subtraction: procedures>>=
  module function real_subtraction_compute_sub_soft (rsub, alr, emitter, &
       i_phs, i_res, alpha_coupling) result (sqme_soft)
    real(default) :: sqme_soft
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr, emitter, i_phs, i_res
    real(default), intent(in) :: alpha_coupling
    integer :: i_xi_ref, i_born
    real(default) :: q2, sf_factor
    type(vector4_t), dimension(:), allocatable :: p_born
    associate (real_kinematics => rsub%real_kinematics, &
            nlo_corr_type => rsub%reg_data%regions(alr)%nlo_correction_type, &
            sregion => rsub%reg_data%regions(alr))
      sqme_soft = zero
      if (sregion%has_soft_divergence ()) then
         i_xi_ref = rsub%sub_soft%i_xi_ref (alr, i_phs)
         q2 = real_kinematics%xi_ref_momenta (i_xi_ref)**2
         allocate (p_born (rsub%reg_data%n_legs_born))
         if (rsub%reg_data%has_pseudo_isr ()) then
            p_born = real_kinematics%p_born_onshell%get_momenta (1)
         else
            p_born = real_kinematics%p_born_cms%get_momenta (1)
         end if
         if (emitter > rsub%sub_soft%reg_data%n_in) then
            call rsub%sub_soft%create_softvec_fsr &
                 (p_born, real_kinematics%y_soft(i_phs), &
                 real_kinematics%phi, emitter, &
                 real_kinematics%xi_ref_momenta(i_xi_ref))
            sf_factor = one
         else
            call rsub%sub_soft%create_softvec_isr &
                 (real_kinematics%y_soft(i_phs), real_kinematics%phi)
            sf_factor = rsub%sf_factors(alr, 0)
         end if
         i_born = sregion%uborn_index
         select case (char (nlo_corr_type))
         case ("QCD")
            sqme_soft = rsub%sub_soft%compute &
            (p_born, rsub%sqme_born_color_c(:,:,i_born) * &
            sf_factor, real_kinematics%y(i_phs), &
            q2, alpha_coupling, alr, emitter, i_res)
         case ("EW")
            sqme_soft = rsub%sub_soft%compute &
            (p_born, rsub%sqme_born_charge_c(:,:,i_born) * &
            sf_factor, real_kinematics%y(i_phs), &
            q2, alpha_coupling, alr, emitter, i_res)
         end select
      end if
    end associate
    if (debug2_active (D_SUBTRACTION)) call check_soft_vector ()
  contains
    subroutine check_soft_vector ()
      !!! p_soft = p_gluon / E_gluon only in the soft limit
      !!! This check only has to be passed for ISR or for FSR if ?test_soft_limit = true is set.
      type(vector4_t) :: p_gluon
      if (debug_on) call msg_debug2 (D_SUBTRACTION, "Compare soft vector: ")
      print *, 'p_soft: ', rsub%sub_soft%p_soft%p
      print *, 'Normalized gluon momentum: '
      if (rsub%reg_data%has_pseudo_isr ()) then
         p_gluon = rsub%real_kinematics%p_real_onshell(thr_leg(emitter))%get_momentum &
              (i_phs, rsub%reg_data%n_legs_real)
      else
         p_gluon = rsub%real_kinematics%p_real_cms%get_momentum &
              (i_phs, rsub%reg_data%n_legs_real)
      end if
      call vector4_write (p_gluon / p_gluon%p(0), show_mass = .true.)
    end subroutine check_soft_vector
  end function real_subtraction_compute_sub_soft

@ %def real_subtraction_compute_sub_soft
@
<<Real subtraction: real subtraction: TBP>>=
  procedure :: get_spin_correlation_term => &
       real_subtraction_get_spin_correlation_term
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_get_spin_correlation_term &
         (rsub, alr, i_born, emitter) result (mom_times_sqme)
      real(default) :: mom_times_sqme
      class(real_subtraction_t), intent(in) :: rsub
      integer, intent(in) :: alr, i_born, emitter
    end function real_subtraction_get_spin_correlation_term
<<Real subtraction: procedures>>=
  module function real_subtraction_get_spin_correlation_term &
       (rsub, alr, i_born, emitter) result (mom_times_sqme)
    real(default) :: mom_times_sqme
    class(real_subtraction_t), intent(in) :: rsub
    integer, intent(in) :: alr, i_born, emitter
    real(default), dimension(0:3) :: k_perp
    integer :: mu, nu
    if (rsub%sc_required(alr)) then
       if (debug2_active(D_SUBTRACTION)) call check_me_consistency ()
       associate (real_kin => rsub%real_kinematics)
         if (emitter > rsub%reg_data%n_in) then
            k_perp = real_subtraction_compute_k_perp_fsr ( &
                 real_kin%p_born_lab%get_momentum(1, emitter), &
                 rsub%real_kinematics%phi)
         else
            k_perp = real_subtraction_compute_k_perp_isr ( &
                 real_kin%p_born_lab%get_momentum(1, emitter), &
                 rsub%real_kinematics%phi)
         end if
       end associate
       mom_times_sqme = zero
       do mu = 1, 3
          do nu = 1, 3
             mom_times_sqme = mom_times_sqme + &
                  k_perp(mu) * k_perp(nu) * rsub%sqme_born_spin_c (mu, nu, emitter, i_born)
          end do
       end do
    else
       mom_times_sqme = zero
    end if
  contains
    subroutine check_me_consistency ()
      real(default) ::  sqme_sum
      if (debug_on) call msg_debug2 (D_SUBTRACTION, "Spin-correlation: Consistency check")
      sqme_sum = &
               - rsub%sqme_born_spin_c(1,1,emitter,i_born) &
               - rsub%sqme_born_spin_c(2,2,emitter,i_born) &
               - rsub%sqme_born_spin_c(3,3,emitter,i_born)
      if (.not. nearly_equal (sqme_sum, -rsub%sqme_born(i_born))) then
         print *, 'Spin-correlated matrix elements are not consistent: '
         print *, 'emitter: ', emitter
         print *, 'g^{mu,nu} B_{mu,nu}: ', -sqme_sum
         print *, 'all Born matrix elements: ', rsub%sqme_born
         call msg_fatal ("FAIL")
      else
         call msg_print_color ("Success", COL_GREEN)
      end if
    end subroutine check_me_consistency
  end function real_subtraction_get_spin_correlation_term

@ %def real_subtraction_get_spin_correlation_term
@ Construct a normalised momentum perpendicular to momentum [[p]] and
rotate by an arbitrary angle [[phi]]. The angular conventions we use
here are equivalent to those used by POWHEG.
<<Real subtraction: public>>=
  public :: real_subtraction_compute_k_perp_fsr
  public :: real_subtraction_compute_k_perp_isr
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_compute_k_perp_fsr &
         (p, phi) result (k_perp_fsr)
      real(default), dimension(0:3) :: k_perp_fsr
      type(vector4_t), intent(in) :: p
      real(default), intent(in) :: phi
    end function real_subtraction_compute_k_perp_fsr
    module function real_subtraction_compute_k_perp_isr &
         (p, phi) result (k_perp_isr)
      real(default), dimension(0:3) :: k_perp_isr
      type(vector4_t), intent(in) :: p
      real(default), intent(in) :: phi
    end function real_subtraction_compute_k_perp_isr
<<Real subtraction: procedures>>=
  module function real_subtraction_compute_k_perp_fsr &
       (p, phi) result (k_perp_fsr)
    real(default), dimension(0:3) :: k_perp_fsr
    type(vector4_t), intent(in) :: p
    real(default), intent(in) :: phi
    type(vector4_t) :: k
    type(vector3_t) :: vec
    type(lorentz_transformation_t) :: rot
    vec = p%p(1:3) / p%p(0)
    k%p(0) = zero
    k%p(1) = p%p(1); k%p(2) = p%p(2)
    k%p(3) = - (p%p(1)**2 + p%p(2)**2) / p%p(3)
    rot = rotation (cos(phi), sin(phi), vec)
    k = rot * k
    k%p(1:3) = k%p(1:3) / space_part_norm (k)
    k_perp_fsr = k%p
  end function real_subtraction_compute_k_perp_fsr

  module function real_subtraction_compute_k_perp_isr &
       (p, phi) result (k_perp_isr)
    real(default), dimension(0:3) :: k_perp_isr
    type(vector4_t), intent(in) :: p
    real(default), intent(in) :: phi
    k_perp_isr(0) = zero
    k_perp_isr(1) = sin(phi)
    k_perp_isr(2) = cos(phi)
    k_perp_isr(3) = zero
  end function real_subtraction_compute_k_perp_isr

@ %def real_subtraction_compute_k_perp_fsr, real_subtraction_compute_k_perp_isr
@
<<Real subtraction: real subtraction: TBP>>=
  procedure :: compute_sub_coll => real_subtraction_compute_sub_coll
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_compute_sub_coll &
         (rsub, alr, em, i_phs, alpha_coupling) result (sqme_coll)
      real(default) :: sqme_coll
      class(real_subtraction_t), intent(inout) :: rsub
      integer, intent(in) :: alr, em, i_phs
      real(default), intent(in) :: alpha_coupling
    end function real_subtraction_compute_sub_coll
<<Real subtraction: procedures>>=
  module function real_subtraction_compute_sub_coll &
       (rsub, alr, em, i_phs, alpha_coupling) result (sqme_coll)
    real(default) :: sqme_coll
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr, em, i_phs
    real(default), intent(in) :: alpha_coupling
    real(default) :: xi, xi_max
    real(default) :: mom_times_sqme_spin_c, sqme_born_coll
    real(default) :: N_col
    integer :: i_con, i
    real(default) :: pfr
    associate (sregion => rsub%reg_data%regions(alr))
      sqme_coll = zero
      sqme_born_coll = zero
      N_col = 1
      if (sregion%has_collinear_divergence ()) then
         xi = rsub%real_kinematics%xi_tilde * rsub%real_kinematics%xi_max(i_phs)
         if (rsub%sub_coll%use_resonance_mappings) then
            i_con = rsub%reg_data%alr_to_i_contributor (alr)
         else
            i_con = 1
         end if
         mom_times_sqme_spin_c = &
              rsub%get_spin_correlation_term (alr, sregion%uborn_index, em)
         if (rsub%reg_data%nlo_correction_type == "EW" .and. &
             sregion%nlo_correction_type == "QCD" .and. &
             qcd_ew_interferences (sregion%flst_uborn%flst)) then
            do i = 1, size (sregion%flst_uborn%flst)
               if (is_quark (sregion%flst_uborn%flst (i))) then
                  sqme_born_coll = &
                       -rsub%sqme_born_color_c (i, i, sregion%uborn_index)/CF
                  exit
               end if
            end do
         else
            sqme_born_coll = rsub%sqme_born(sregion%uborn_index)
         end if
         if (em <= rsub%sub_coll%n_in) then
            select case (rsub%isr_kinematics%isr_mode)
            case (SQRTS_FIXED)
               xi_max = rsub%real_kinematics%xi_max(i_phs)
            case (SQRTS_VAR)
               xi_max = one - rsub%isr_kinematics%x(em)
            end select
            xi = rsub%real_kinematics%xi_tilde * xi_max
            if (sregion%nlo_correction_type == "QCD") then
               call rsub%sub_coll%set_parameters (CA = CA, CF = CF, TR = TR)
            else if (sregion%nlo_correction_type == "EW") then
               if (is_quark (sregion%flst_real%flst(size(sregion%flst_real%flst)))) N_col = 3
               call rsub%sub_coll%set_parameters (CA = zero, &
                    CF = sregion%flst_real%charge(em)**2, &
                    TR = N_col*sregion%flst_real%charge(size(sregion%flst_real%flst))**2)
            end if
            sqme_coll = rsub%sub_coll%compute_isr (em, sregion%flst_real%flst, &
                 rsub%real_kinematics%p_born_lab%phs_point(1)%get (), &
                 sqme_born_coll * rsub%sf_factors(alr, em), &
                 mom_times_sqme_spin_c * rsub%sf_factors(alr, em), &
                 xi, alpha_coupling, rsub%isr_kinematics%isr_mode)
         else
            if (sregion%nlo_correction_type == "QCD") then
               call rsub%sub_coll%set_parameters (CA = CA, CF = CF, TR = TR)
            else if (sregion%nlo_correction_type == "EW") then
               if (is_quark (sregion%flst_real%flst(sregion%emitter))) N_col = 3
               call rsub%sub_coll%set_parameters (CA = zero, &
                    CF = sregion%flst_real%charge(sregion%emitter)**2, &
                    TR = N_col*sregion%flst_real%charge(sregion%emitter)**2)
            end if
            sqme_coll = rsub%sub_coll%compute_fsr (sregion%emitter, &
                 sregion%flst_real%flst, &
                 rsub%real_kinematics%xi_ref_momenta (i_con), &
                 rsub%real_kinematics%p_born_lab%get_momenta(1), &
                 sqme_born_coll, &
                 mom_times_sqme_spin_c, &
                 xi, alpha_coupling, sregion%double_fsr)
            if (rsub%sub_coll%use_resonance_mappings) then
               select type (fks_mapping => rsub%reg_data%fks_mapping)
               type is (fks_mapping_resonances_t)
                  pfr = fks_mapping%get_resonance_weight (alr, &
                       rsub%real_kinematics%p_born_cms%get_momenta(1))
               end select
               sqme_coll = sqme_coll * pfr
            end if
         end if
      end if
    end associate
  end function real_subtraction_compute_sub_coll

@ %def real_subtraction_compute_sub_coll
@ Computes the soft-collinear subtraction term. For alpha regions with emitter
$0$, this routine is called with [[em == 1]] and [[em == 2]] separately.
To still be able to use the unrescaled pdf factors stored in [[sf_factors(alr, 0)]]
in this case, we need to differentiate between [[em]] and [[em_pdf = 0]].
<<Real subtraction: real subtraction: TBP>>=
  procedure :: compute_sub_coll_soft => real_subtraction_compute_sub_coll_soft
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_compute_sub_coll_soft &
         (rsub, alr, em, i_phs, alpha_coupling) result (sqme_cs)
      real(default) :: sqme_cs
      class(real_subtraction_t), intent(inout) :: rsub
      integer, intent(in) :: alr, em, i_phs
      real(default), intent(in) :: alpha_coupling
    end function real_subtraction_compute_sub_coll_soft
<<Real subtraction: procedures>>=
  module function real_subtraction_compute_sub_coll_soft &
       (rsub, alr, em, i_phs, alpha_coupling) result (sqme_cs)
    real(default) :: sqme_cs
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr, em, i_phs
    real(default), intent(in) :: alpha_coupling
    real(default) :: mom_times_sqme_spin_c, sqme_born_coll
    real(default) :: N_col
    integer :: i_con, em_pdf, i
    associate (sregion => rsub%reg_data%regions(alr))
      sqme_cs = zero
      sqme_born_coll = zero
      N_col = 1
      if (sregion%has_collinear_divergence ()) then
         if (rsub%sub_coll%use_resonance_mappings) then
            i_con = rsub%reg_data%alr_to_i_contributor (alr)
         else
            i_con = 1
         end if
         mom_times_sqme_spin_c = rsub%get_spin_correlation_term (alr, sregion%uborn_index, em)
         if (rsub%reg_data%nlo_correction_type == "EW" .and. &
             sregion%nlo_correction_type == "QCD" .and. &
             qcd_ew_interferences (sregion%flst_uborn%flst)) then
            do i = 1, size (sregion%flst_uborn%flst)
               if (is_quark (sregion%flst_uborn%flst (i))) then
                  sqme_born_coll = -rsub%sqme_born_color_c (i, i, sregion%uborn_index)/CF
                  exit
               end if
            end do
         else
            sqme_born_coll = rsub%sqme_born(sregion%uborn_index)
         end if
         if (em <= rsub%sub_coll%n_in) then
            em_pdf = 0
            if (sregion%nlo_correction_type == "QCD") then
               call rsub%sub_coll%set_parameters (CA = CA, CF = CF, TR = TR)
            else if (sregion%nlo_correction_type == "EW") then
               if (is_quark (sregion%flst_real%flst(size(sregion%flst_real%flst)))) N_col = 3
               call rsub%sub_coll%set_parameters (CA = zero, &
                    CF = sregion%flst_real%charge(em)**2, &
                    TR = N_col*sregion%flst_real%charge(size(sregion%flst_real%flst))**2)
            end if
            sqme_cs = rsub%sub_coll%compute_isr (em, sregion%flst_real%flst, &
                 rsub%real_kinematics%p_born_lab%phs_point(1)%get (), &
                 sqme_born_coll * rsub%sf_factors(alr, em_pdf), &
                 mom_times_sqme_spin_c * rsub%sf_factors(alr, em_pdf), &
                 zero, alpha_coupling, rsub%isr_kinematics%isr_mode)
         else
            if (sregion%nlo_correction_type == "QCD") then
               call rsub%sub_coll%set_parameters (CA = CA, CF = CF, TR = TR)
            else if (sregion%nlo_correction_type == "EW") then
               if (is_quark (sregion%flst_real%flst(sregion%emitter))) N_col = 3
               call rsub%sub_coll%set_parameters (CA = zero, &
                    CF = sregion%flst_real%charge(sregion%emitter)**2, &
                    TR = N_col*sregion%flst_real%charge(sregion%emitter)**2)
            end if
            sqme_cs = rsub%sub_coll%compute_fsr (sregion%emitter, sregion%flst_real%flst, &
                 rsub%real_kinematics%xi_ref_momenta(i_con), &
                 rsub%real_kinematics%p_born_lab%phs_point(1)%get (), &
                 sqme_born_coll, &
                 mom_times_sqme_spin_c, &
                 zero, alpha_coupling, sregion%double_fsr)
         end if
      end if
    end associate
  end function real_subtraction_compute_sub_coll_soft

@ %def real_subtraction_compute_sub_coll_soft
<<Real subtraction: real subtraction: TBP>>=
  procedure :: requires_spin_correlations => &
       real_subtraction_requires_spin_correlations
<<Real subtraction: sub interfaces>>=
    module function real_subtraction_requires_spin_correlations &
         (rsub) result (val)
      logical :: val
      class(real_subtraction_t), intent(in) :: rsub
    end function real_subtraction_requires_spin_correlations
<<Real subtraction: procedures>>=
  module function real_subtraction_requires_spin_correlations &
       (rsub) result (val)
    logical :: val
    class(real_subtraction_t), intent(in) :: rsub
    val = any (rsub%sc_required)
  end function real_subtraction_requires_spin_correlations

@ %def real_subtraction_requires_spin_correlations
@
<<Real subtraction: real subtraction: TBP>>=
  procedure :: final => real_subtraction_final
<<Real subtraction: sub interfaces>>=
    module subroutine real_subtraction_final (rsub)
      class(real_subtraction_t), intent(inout) :: rsub
    end subroutine real_subtraction_final
<<Real subtraction: procedures>>=
  module subroutine real_subtraction_final (rsub)
    class(real_subtraction_t), intent(inout) :: rsub
    call rsub%sub_soft%final ()
    call rsub%sub_coll%final ()
    !!! Finalization of region data is done in pcm_nlo_final
    if (associated (rsub%reg_data)) nullify (rsub%reg_data)
    !!! Finalization of real kinematics is done in pcm_instance_nlo_final
    if (associated (rsub%real_kinematics)) nullify (rsub%real_kinematics)
    if (associated (rsub%isr_kinematics)) nullify (rsub%isr_kinematics)
    if (allocated (rsub%sqme_real_non_sub)) deallocate (rsub%sqme_real_non_sub)
    if (allocated (rsub%sqme_born)) deallocate (rsub%sqme_born)
    if (allocated (rsub%sf_factors)) deallocate (rsub%sf_factors)
    if (allocated (rsub%sqme_real_arr)) deallocate (rsub%sqme_real_arr)
    if (allocated (rsub%sqme_born_color_c)) deallocate (rsub%sqme_born_color_c)
    if (allocated (rsub%sqme_born_charge_c)) deallocate (rsub%sqme_born_charge_c)
    if (allocated (rsub%sc_required)) deallocate (rsub%sc_required)
    if (allocated (rsub%selected_alr)) deallocate (rsub%selected_alr)
  end subroutine real_subtraction_final

@ %def real_subtraction_final
@ \subsubsection{Partitions of the real matrix element and Powheg damping}
<<Real subtraction: public>>=
  public :: real_partition_t
<<Real subtraction: types>>=
  type, abstract :: real_partition_t
  contains
  <<Real subtraction: real partition: TBP>>
  end type real_partition_t

@ %def real partition_t
@
<<Real subtraction: real partition: TBP>>=
  procedure (real_partition_init), deferred :: init
<<Real subtraction: interfaces>>=
  abstract interface
     subroutine real_partition_init (partition, scale, reg_data)
       import
       class(real_partition_t), intent(out) :: partition
       real(default), intent(in) :: scale
       type(region_data_t), intent(in) :: reg_data
     end subroutine real_partition_init
  end interface

@ %def real_partition_init
@
<<Real subtraction: real partition: TBP>>=
  procedure (real_partition_write), deferred :: write
<<Real subtraction: interfaces>>=
  abstract interface
     subroutine real_partition_write (partition, unit)
       import
       class(real_partition_t), intent(in) :: partition
       integer, intent(in), optional :: unit
     end subroutine real_partition_write
  end interface

@ %def real_partition_write
@ To allow really arbitrary damping functions, [[get_f]] should get the
full real phase space as argument and not just some [[pt2]] that is
extracted higher up.
<<Real subtraction: real partition: TBP>>=
  procedure (real_partition_get_f), deferred :: get_f
<<Real subtraction: interfaces>>=
  abstract interface
    function real_partition_get_f (partition, p) result (f)
       import
       real(default) :: f
       class(real_partition_t), intent(in) :: partition
       type(vector4_t), intent(in), dimension(:) :: p
    end function real_partition_get_f
  end interface

@ %def real_partition_get_f
@
<<Real subtraction: public>>=
  public :: powheg_damping_simple_t
<<Real subtraction: types>>=
  type, extends (real_partition_t) :: powheg_damping_simple_t
     real(default) :: h2 = 5._default
     integer :: emitter
  contains
  <<Real subtraction: powheg damping simple: TBP>>
  end type powheg_damping_simple_t

@ %def powheg_damping_simple_t
@
<<Real subtraction: powheg damping simple: TBP>>=
  procedure :: get_f => powheg_damping_simple_get_f
<<Real subtraction: sub interfaces>>=
    module function powheg_damping_simple_get_f (partition, p) result (f)
      real(default) :: f
      class(powheg_damping_simple_t), intent(in) :: partition
      type(vector4_t), intent(in), dimension(:) :: p
    end function powheg_damping_simple_get_f
<<Real subtraction: procedures>>=
  module function powheg_damping_simple_get_f (partition, p) result (f)
    real(default) :: f
    class(powheg_damping_simple_t), intent(in) :: partition
    type(vector4_t), intent(in), dimension(:) :: p
    !!! real(default) :: pt2
    f = 1
    call msg_bug ("Simple damping currently not available")
    !!! TODO (cw-2017-03-01) Compute pt2 from emitter)
    !!! f = partition%h2 / (pt2 + partition%h2)
  end function powheg_damping_simple_get_f

@ %def powheg_damping_simple_get_f
@
<<Real subtraction: powheg damping simple: TBP>>=
  procedure :: init => powheg_damping_simple_init
<<Real subtraction: sub interfaces>>=
    module subroutine powheg_damping_simple_init (partition, scale, reg_data)
      class(powheg_damping_simple_t), intent(out) :: partition
      real(default), intent(in) :: scale
      type(region_data_t), intent(in) :: reg_data
    end subroutine powheg_damping_simple_init
<<Real subtraction: procedures>>=
  module subroutine powheg_damping_simple_init (partition, scale, reg_data)
    class(powheg_damping_simple_t), intent(out) :: partition
    real(default), intent(in) :: scale
    type(region_data_t), intent(in) :: reg_data
    partition%h2 = scale**2
  end subroutine powheg_damping_simple_init

@ %def powheg_damping_simple_init
@
<<Real subtraction: powheg damping simple: TBP>>=
  procedure :: write => powheg_damping_simple_write
<<Real subtraction: sub interfaces>>=
    module subroutine powheg_damping_simple_write (partition, unit)
      class(powheg_damping_simple_t), intent(in) :: partition
      integer, intent(in), optional :: unit
    end subroutine powheg_damping_simple_write
<<Real subtraction: procedures>>=
  module subroutine powheg_damping_simple_write (partition, unit)
    class(powheg_damping_simple_t), intent(in) :: partition
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit); if (u < 0) return
    write (u, "(1x,A)") "Powheg damping simple: "
    write (u, "(1x,A, "// FMT_15 // ")") "scale h2: ", partition%h2
  end subroutine powheg_damping_simple_write

@ %def powheg_damping_simple_write
@
<<Real subtraction: public>>=
  public :: real_partition_fixed_order_t
<<Real subtraction: types>>=
  type, extends (real_partition_t) :: real_partition_fixed_order_t
     real(default) :: scale
     type(ftuple_t), dimension(:), allocatable :: fks_pairs
  contains
  <<Real subtraction: real partition fixed order: TBP>>
  end type real_partition_fixed_order_t

@ %def real_partition_fixed_order_t
@
<<Real subtraction: real partition fixed order: TBP>>=
  procedure :: init => real_partition_fixed_order_init
<<Real subtraction: sub interfaces>>=
    module subroutine real_partition_fixed_order_init &
         (partition, scale, reg_data)
      class(real_partition_fixed_order_t), intent(out) :: partition
      real(default), intent(in) :: scale
      type(region_data_t), intent(in) :: reg_data
    end subroutine real_partition_fixed_order_init
<<Real subtraction: procedures>>=
  module subroutine real_partition_fixed_order_init (partition, scale, reg_data)
    class(real_partition_fixed_order_t), intent(out) :: partition
    real(default), intent(in) :: scale
    type(region_data_t), intent(in) :: reg_data
  end subroutine real_partition_fixed_order_init

@ %def real_partition_fixed_order_init
@
<<Real subtraction: real partition fixed order: TBP>>=
  procedure :: write => real_partition_fixed_order_write
<<Real subtraction: sub interfaces>>=
    module subroutine real_partition_fixed_order_write (partition, unit)
      class(real_partition_fixed_order_t), intent(in) :: partition
      integer, intent(in), optional :: unit
    end subroutine real_partition_fixed_order_write
<<Real subtraction: procedures>>=
  module subroutine real_partition_fixed_order_write (partition, unit)
    class(real_partition_fixed_order_t), intent(in) :: partition
    integer, intent(in), optional :: unit
  end subroutine real_partition_fixed_order_write

@ %def real_partition_fixed_order_write
@ Implements the suppression factor
\begin{equation}
  F(\Phi_{n+1}) = 1 - \prod_{(i,j) \in P_{FKS}} \theta \left[ m_i + m_j + h - \sqrt{(p_j + p_j)^2} \right]
\end{equation}
to split the real matrix element into singular and finite part.
<<Real subtraction: real partition fixed order: TBP>>=
  procedure :: get_f => real_partition_fixed_order_get_f
<<Real subtraction: sub interfaces>>=
    module function real_partition_fixed_order_get_f (partition, p) result (f)
      real(default) :: f
      class(real_partition_fixed_order_t), intent(in) :: partition
      type(vector4_t), intent(in), dimension(:) :: p
    end function real_partition_fixed_order_get_f
<<Real subtraction: procedures>>=
  module function real_partition_fixed_order_get_f (partition, p) result (f)
    real(default) :: f
    class(real_partition_fixed_order_t), intent(in) :: partition
    type(vector4_t), intent(in), dimension(:) :: p
    integer :: i, em
    f = zero
    PAIRS: do i = 1, size (partition%fks_pairs)
       associate (ii => partition%fks_pairs(i)%ireg)
          if (ii(1) == 0) then
            IS: do em = 1, 2
               if ((p(em) + p(ii(2)))**1 < p(em)**1 + p(ii(2))**1 + &
                    partition%scale) then
                  f = one
                  exit PAIRS
               end if
            end do IS
          else
             if ((p(ii(1)) + p(ii(2)))**1 < p(ii(1))**1 + p(ii(2))**1 + &
                  partition%scale) then
                f = one
                exit PAIRS
             end if
          end if
       end associate
    end do PAIRS
  end function real_partition_fixed_order_get_f

@ %def real_partition_fixed_order_get_f
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[real_subtraction_ut.f90]]>>=
<<File header>>

module real_subtraction_ut
  use unit_tests
  use real_subtraction_uti

<<Standard module head>>

<<Real subtraction: public test>>

contains

<<Real subtraction: test driver>>

end module real_subtraction_ut
@ %def real_subtraction_ut
@
<<[[real_subtraction_uti.f90]]>>=
<<File header>>

module real_subtraction_uti
<<Use kinds>>

  use physics_defs
  use lorentz
  use numeric_utils
  use real_subtraction

<<Standard module head>>

<<Real subtraction: test declarations>>

contains

<<Real subtraction: tests>>

end module real_subtraction_uti
@ %def real_subtraction_ut
@ API: driver for the unit tests below.
<<Real subtraction: public test>>=
  public :: real_subtraction_test
<<Real subtraction: test driver>>=
  subroutine real_subtraction_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Real subtraction: execute tests>>
  end subroutine real_subtraction_test

@ %def real_subtraction_test
@ Test the final-state collinear subtraction.
<<Real subtraction: execute tests>>=
  call test (real_subtraction_1, "real_subtraction_1", &
       "final-state collinear subtraction", &
       u, results)
<<Real subtraction: test declarations>>=
  public :: real_subtraction_1
<<Real subtraction: tests>>=
  subroutine real_subtraction_1 (u)
    integer, intent(in) :: u

    type(coll_subtraction_t) :: coll_sub
    real(default) :: sqme_coll
    type(vector4_t) :: p_res
    type(vector4_t), dimension(5) :: p_born
    real(default), dimension(4) :: k_perp
    real(default), dimension(4,4) :: b_munu
    integer :: mu, nu
    real(default) :: born, born_c
    integer, dimension(6) :: flst

    p_born(1)%p = [500, 0, 0, 500]
    p_born(2)%p = [500, 0, 0, -500]
    p_born(3)%p = [3.7755E+02, 2.2716E+02, -95.4172, 2.8608E+02]
    p_born(4)%p = [4.9529E+02, -2.739E+02, 84.8535, -4.0385E+02]
    p_born(5)%p = [1.2715E+02, 46.7375, 10.5637, 1.1778E+02]
    p_res = p_born(1) + p_born(2)
    flst = [11, -11 , -2, 2, -2, 2]

    b_munu(1, :) = [0., 0., 0., 0.]
    b_munu(2, :) = [0., 1., 1., 1.]
    b_munu(3, :) = [0., 1., 1., 1.]
    b_munu(4, :) = [0., 1., 1., 1.]

    k_perp = real_subtraction_compute_k_perp_fsr (p = p_born(5), phi = 0.5_default)
    born = - b_munu(1, 1) + b_munu(2, 2) + b_munu(3, 3) + b_munu(4, 4)
    born_c = 0.
    do mu = 1, 4
       do nu = 1, 4
          born_c = born_c + k_perp(mu) * k_perp(nu) * b_munu(mu, nu)
       end do
    end do

    write (u, "(A)") "* Test output: real_subtraction_1"
    write (u, "(A)") "*   Purpose: final-state collinear subtraction"
    write (u, "(A)")

    write (u, "(A, L1)") "* vanishing scalar-product of 3-momenta k_perp and p_born(emitter): ", &
         nearly_equal (dot_product (p_born(5)%p(1:3), k_perp(2:4)), 0._default)

    call coll_sub%init (n_alr = 1, n_in = 2)
    call coll_sub%set_parameters (CA, CF, TR)

    write (u, "(A)")
    write (u, "(A)") "* g -> qq splitting"
    write (u, "(A)")

    sqme_coll = coll_sub%compute_fsr(5, flst, p_res, p_born, &
         born, born_c, 0.5_default, 0.25_default, .false.)

    write (u, "(A,F15.12)") "ME: ", sqme_coll

    write (u, "(A)")
    write (u, "(A)") "* g -> gg splitting"
    write (u, "(A)")

    b_munu(1, :) = [0., 0., 0., 0.]
    b_munu(2, :) = [0., 0., 0., 1.]
    b_munu(3, :) = [0., 0., 1., 1.]
    b_munu(4, :) = [0., 0., 1., 1.]

    k_perp = real_subtraction_compute_k_perp_fsr (p = p_born(5), phi = 0.5_default)
    born = - b_munu(1, 1) + b_munu(2, 2) + b_munu(3, 3) + b_munu(4, 4)
    born_c = 0.
    do mu = 1, 4
       do nu = 1, 4
          born_c = born_c + k_perp(mu) * k_perp(nu) * b_munu(mu, nu)
       end do
    end do

    flst = [11, -11, 2, -2, 21, 21]
    sqme_coll = coll_sub%compute_fsr(5, flst, p_res, p_born, &
         born, born_c, 0.5_default, 0.25_default, .true.)

    write (u, "(A,F15.12)") "ME: ", sqme_coll

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: real_subtraction_1"
    write (u, "(A)")
  end subroutine real_subtraction_1

@ %def real_subtraction_1
@

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Contribution of divergencies due to PDF Evolution}

References:
\begin{itemize}
\item arXiv:hep-ph/9512328, (2.1)-(2.5), (4.29)-(4.53)
\item arXiv:0709.2092, (2.102)-(2.106)
\end{itemize}

The parton distrubition densities have to be evaluated at NLO, too.
The NLO PDF evolution is given by
\begin{equation}
  \label{eqn:pdf_nlo}
  f (\bar{x}) = \int_0^1 \int_0^1 dx dz f(x) \Gamma(z) \delta (\bar{x} - x z),
\end{equation}
where $\Gamma$ are the DGLAP evolution kernels for an $a \to d$ splitting,
\begin{equation}
  \label{eqn:dglap}
  \Gamma_a^{(d)} = \delta_{ad}\delta(1-x) - \frac{\alpha_s}{2\pi}
  \left(\frac{1}{\epsilon} P_{ad}(x,0) - K_{ad}(x)\right) +
  \mathcal{O}(\alpha_s^2).
\end{equation}
$K_{ad}$ is a renormalization scheme matching factor, which is exactly
zero in $\overline{\text{MS}}$. Let the leading-order hadronic cross
section be given by
\begin{equation}
  \label{eqn:xsec_hadro_lo}
  d\sigma^{(0)}(s) = \int dx_\oplus dx_\ominus f_\oplus (x_\oplus)
  f_\ominus (x_\ominus) d\tilde{\sigma}^{(0)} (x_\oplus x_\ominus s),
\end{equation}
then the NLO hadronic cross section is
\begin{equation}
  \label{eqn:xsec_hadro_nlo}
  d\sigma^{(1)}(s) = \int dx_\oplus dx_\ominus dz_\oplus dz_\ominus
  f_\oplus (x_\oplus) f_\ominus (x_\ominus)
  \underbrace{\Gamma_\oplus (z_\oplus) \Gamma_\ominus (z_\ominus)
    d\tilde{\sigma}^{(1)} (z_\oplus z_\ominus
    s)}_{d\hat{\sigma}^{(1)}}.
\end{equation}
$d\hat{\sigma}$ is called the subtracted partonic cross
section. Expanding in $\alpha_s$ we find
\begin{align}
  d\hat{\sigma}^{(0)}_{ab}(k_1, k_2) &= d\tilde{\sigma}_{ab}^{(0)} (k_1, k_2), \\
  d\hat{\sigma}^{(1)}_{ab}(k_1, k_2) &= d\tilde{\sigma}_{ab}^{(1)} (k_1, k_2) \\
  &+ \frac{\alpha_s}{2\pi} \sum_d
  \int dx \left (\frac{1}{\epsilon} P_{da}(x,0) - K_{da}(x)\right)
  d\tilde{\sigma}_{db}^{(0)}(xk_1, k_2)\\
  &+ \frac{\alpha_s}{2\pi} \sum_d \int \left (\frac{1}{\epsilon}
  P_{db} (x, 0) - K_{db}(x)\right) d\tilde{\sigma}_{ad}^{(0)}(k_1,
  xk_2).\\
  &= d\tilde{\sigma}_{ab}^{(1)} + d\tilde{\sigma}_{ab}^{(cnt,+)} +
  d\tilde{\sigma}_{ab}^{(cnt,-)}
\end{align}

Let us now turn to the soft-subtracted real part of the cross
section. For ease of notation, it is constrained to one singular
region,
\begin{align*}
  \label{eqn:R-in}
  d\sigma^{(in)}_\alpha &= \left[\left(\frac{1}{\xi}\right)_{c} -
    2\epsilon\left(\frac{\log \xi}{\xi}\right)_{c}\right] (1-y^2)\xi^2
  \mathcal{R}_\alpha \mathcal{S}_\alpha \\
  &\times  \frac{1}{2(2\pi)^{3-2\epsilon}}
  \left(\frac{\sqrt{s}}{2}\right)^{2-2\epsilon} \left( 1 -
  y^2\right)^{-1-\epsilon} d\phi d\xi dy d\Omega^{2-2\epsilon},
\end{align*}
where we regularize collinear divergencies using the identity
\begin{equation*}
  \left (1 - y^2 \right)^{-1-\epsilon} =
  -\frac{2^{-\epsilon}}{2\epsilon} \left (\delta(1-y) +
  \delta(1+y)\right)
     + \underbrace{\frac{1}{2} \left[ \left (\frac {1}{1-y}\right)_{c}
         + \left (\frac{1}{1+y}\right)_{c} \right]}_{\mathcal{P}(y)}.
\end{equation*}
This enables us to split the cross section into a finite and a
singular part. The latter can further be separated into a contribution
of the incoming and of the outgoing particles,
\begin{equation*}
  d\sigma^{(in)}_\alpha = d\sigma^{(in,+)}_\alpha +
  d\sigma^{(in,-)}_\alpha + d\sigma^{(in,f)}_\alpha.
\end{equation*}
They are given by
\begin{align}
  d\sigma^{(in,f)}_\alpha = & \mathcal{P}(y)
  \left[\left(\frac{1}{\xi}\right)_{c} - 2\epsilon
    \left(\frac{\log\xi}{\xi}\right)_{c}\right]
  \frac{1}{2(2\pi)^{3-2\epsilon}}
  \left(\frac{\sqrt{s}}{2}\right)^{2-2\epsilon} \nonumber\\
  & \times (1-y^2)\xi^2 \mathcal{R}_\alpha \mathcal{S}_\alpha d\phi
  d\xi dy d\Omega^{2-2\epsilon}
  \label{eqn:sigma-f}
\end{align}
and
\begin{align}
  d\sigma^{(in,\pm)}_\alpha &= -\frac{2^{-\epsilon}}{2\epsilon} \delta
  (1 \mp y) \left[ \left( \frac{1}{\xi}\right)_{c} - 2\epsilon
    \left(\frac{\log\xi}{\xi}\right)_{c}\right] \nonumber\\
  & \times \frac{1}{2(2\pi)^{3-2\epsilon}} \left(
  \frac{\sqrt{s}}{2}\right)^{2-2\epsilon} (1-y^2)\xi^2
  \mathcal{R}_\alpha \mathcal{S}_\alpha d\phi d\xi dy
  d\Omega^{2-2\epsilon}.
  \label{eqn:sigma-pm}
\end{align}
Equation \ref{eqn:sigma-f} is the contribution to the real cross
section which is computed in [[evaluate_region_isr]]. It is
regularized both in the soft and collinear limit via the plus
distributions. Equation \ref{eqn:sigma-pm} is a different
contribution. It is only present exactly in the collinear limit, due
to the delta function. The divergences present in this term do not
completely cancel out divergences in the virtual matrix element,
because the beam axis is distinguished. Thus, the conditions in which
the KLN theorem applies are not met. To see this, we carry out the
collinear limit, obtaining
\begin{equation*}
  \lim_{y \to 1} (1-y^2)\xi^2\mathcal{R}_\alpha = 8\pi\alpha_s
  \mu^{2\epsilon} \left(\frac{2}{\sqrt{s}}\right)^2 \xi P^<(1-\xi,
  \epsilon) \mathcal{R}_\alpha,
\end{equation*}
with the Altarelli-Parisi splitting kernel for $z < 1$,
$P^<(z,\epsilon)$. Moreover, $\lim_{\vec{k} \parallel \vec{k}_1} d\phi
= d\phi_3$ violates spatial averaging. The integration over the
spherical angle $d\Omega$ can be carried out easily, yielding a factor
of $2\pi^{1-\epsilon} / \Gamma(1-\epsilon)$. This allows us to
redefine $\epsilon$,
\begin{equation}
  \frac{1}{\epsilon} - \gamma_E + \log(4\pi) \to \frac{1}{\epsilon}.
\end{equation}
Coming back to $d\tilde{\sigma}_{ab}^{(cnt,+)}$ in order to make a
connection to $d{\sigma}^{(in,+)}_\alpha$, we relate $P_{ab}(z,0)$ to
$P^<_{ab}(z,0)$ via the equation
\begin{equation*}
  P_{ab}(z,0) = (1-z)P_{ab}^<(z,0)\left(\frac{1}{1-z}\right)_+ +
  \gamma(a)\delta_{ab}\delta(1-z),
\end{equation*}
which yields
\begin{equation} \label{eqn:sigma-cnt}
  d\tilde{\sigma}^{(cnt,+)}_{\alpha} = \frac{\alpha_s}{2\pi} \sum_d
  \left\lbrace -K_{da}(1-\xi) + \frac{1}{\epsilon}
  \left[\left(\frac{1}{\xi}\right)_+ \xi P_{da}^<(1-\xi,0)
    + \delta_{da}\delta(\xi)\gamma(d)\right]\right\rbrace
  \mathcal{R}_\alpha \mathcal{S}_\alpha d\phi d\xi dy.
\end{equation}
This term has the same pole structure as eqn. \ref{eqn:sigma-pm}. This
makes clear that the quantity
\begin{equation}
  d\hat{\sigma}^{(in,+)} = d\tilde{\sigma}^{(in,+)} +
  d\tilde{\sigma}^{(cnt,+)}
\end{equation}
has no collinear poles. Therefore, our task is to add up
eqns. \ref{eqn:sigma-pm} and \ref{eqn:sigma-cnt} in order to compute
the finite remainder. This is the integrand which is evaluated in the
[[dglap_remnant]] component.

So, we have to perform an expansion of $d\hat{\sigma}^{(in,+)}$ in
$\epsilon$. Hereby, we must not neglect the implicit
$\epsilon$-dependence of $P^<$, which leads to additional terms
involving the first derivative,
\begin{equation*}
  P_{ab}^<(z,\epsilon) = P_{ab}^<(z,0) + \epsilon \frac{\partial
    P_{ab}^<(z,\epsilon)}{\partial \epsilon}|_{\epsilon = 0} +
  \mathcal{O}(\alpha_s^2).
\end{equation*}
This finally gives us the equation for the collinear remnant. Note
that there is still one soft $1/\epsilon$-pole, which cancels out with
the corresponding expression in the soft-virtual terms.
\begin{align} \label{eqn:sigma-in-p-final}
  d\hat{\sigma}^{(in,+)} &= \frac{\alpha_s}{2\pi} \frac{1}{\epsilon}
  \gamma(a) \mathcal{R}_\alpha \mathcal{S}_\alpha \nonumber\\
  &+ \frac{\alpha_s}{2\pi} \sum_d \left\lbrace (1-z)
  P_{da}^<(z,0)\left[\left(\frac{1}{1-z}\right)_{c}
    \log\frac{s\delta_{\mathrm{I}}}{2\mu^2} + 2
    \left(\frac{\log(1-z)}{1-z}\right)_{c}\right] \right. \nonumber\\
  &\left . -(1-z)\frac{\partial P_{da}^<(z,\epsilon)}{\partial
    \epsilon} \left(\frac{1}{1-z}\right)_{c} - K_{da}(z)\right\rbrace
  \mathcal{R}_\alpha \mathcal{S}_\alpha d\phi d\xi dy
\end{align}


<<[[dglap_remnant.f90]]>>=
<<File header>>

module dglap_remnant

<<Use kinds with double>>
<<Use strings>>
  use phs_fks, only: isr_kinematics_t
  use fks_regions, only: region_data_t

  use nlo_data

<<Standard module head>>

<<DGLAP remnant: public>>

<<DGLAP remnant: types>>

  interface
<<DGLAP remnant: sub interfaces>>
  end interface

end module dglap_remnant

@ %def module dglap_remnant
@
<<[[dglap_remnant_sub.f90]]>>=
<<File header>>

submodule (dglap_remnant) dglap_remnant_s

  use numeric_utils
  use diagnostics
  use constants
  use physics_defs
  use pdg_arrays

  implicit none

contains

<<DGLAP remnant: procedures>>

end submodule dglap_remnant_s

@ %def dglap_remnant_s
@
<<DGLAP remnant: public>>=
  public :: dglap_remnant_t
<<DGLAP remnant: types>>=
  type :: dglap_remnant_t
     type(nlo_settings_t), pointer :: settings => null ()
     type(region_data_t), pointer :: reg_data => null ()
     type(isr_kinematics_t), pointer :: isr_kinematics => null ()
     real(default) :: CA = 0, CF = 0, TR = 0
     real(default), dimension(:), allocatable :: sqme_born
     real(default), dimension(:,:), allocatable :: sf_factors
     real(default), dimension(:,:,:), allocatable :: sqme_color_c_extra
   contains
   <<DGLAP remnant: dglap remnant: TBP>>
  end type dglap_remnant_t

@ %def dglap_remnant_t
@
<<DGLAP remnant: dglap remnant: TBP>>=
  procedure :: init => dglap_remnant_init
<<DGLAP remnant: sub interfaces>>=
    module subroutine dglap_remnant_init &
         (dglap, settings, reg_data, isr_kinematics)
      class(dglap_remnant_t), intent(inout) :: dglap
      type(nlo_settings_t), intent(in), target :: settings
      type(region_data_t), intent(in), target :: reg_data
      type(isr_kinematics_t), intent(in), target :: isr_kinematics
    end subroutine dglap_remnant_init
<<DGLAP remnant: procedures>>=
  module subroutine dglap_remnant_init &
       (dglap, settings, reg_data, isr_kinematics)
    class(dglap_remnant_t), intent(inout) :: dglap
    type(nlo_settings_t), intent(in), target :: settings
    type(region_data_t), intent(in), target :: reg_data
    integer :: n_flv_born
    type(isr_kinematics_t), intent(in), target :: isr_kinematics
    dglap%reg_data => reg_data
    n_flv_born = reg_data%get_n_flv_born ()
    allocate (dglap%sf_factors (reg_data%n_regions, 0:reg_data%n_in))
    dglap%sf_factors = zero
    dglap%settings => settings
    allocate (dglap%sqme_born(n_flv_born))
    dglap%sqme_born = zero
    allocate (dglap%sqme_color_c_extra (reg_data%n_legs_born, &
         reg_data%n_legs_born, reg_data%n_flv_born))
    dglap%sqme_color_c_extra = zero
    dglap%isr_kinematics => isr_kinematics
  end subroutine dglap_remnant_init

@ %def dglap_remnant_init
<<DGLAP remnant: dglap remnant: TBP>>=
  procedure :: set_parameters => dglap_remnant_set_parameters
<<DGLAP remnant: sub interfaces>>=
    module subroutine dglap_remnant_set_parameters (dglap, CA, CF, TR)
      class(dglap_remnant_t), intent(inout) :: dglap
      real(default), intent(in) :: CA, CF, TR
    end subroutine dglap_remnant_set_parameters
<<DGLAP remnant: procedures>>=
  module subroutine dglap_remnant_set_parameters (dglap, CA, CF, TR)
    class(dglap_remnant_t), intent(inout) :: dglap
    real(default), intent(in) :: CA, CF, TR
    dglap%CA = CA
    dglap%CF = CF
    dglap%TR = TR
  end subroutine dglap_remnant_set_parameters

@ %def dglap_remnant_set_parameters
@ Evaluates formula \ref{eqn:sigma-in-p-final}. Note that, as also in
the case for the real subtraction, we have to take into account an
additional term, occuring because the integral the plus distribution
is evaluated over is not constrained on the interval $[0,1]$.
Explicitly, this means (see JHEP 06(2010)043, (4.11)-(4.12))
\begin{align}
  \int_{\bar{x}_\oplus}^1 dz \left( \frac{1}{1-z} \right)_{\xi_{\text{cut}}} & =
  \log \frac{1-\bar{x}_\oplus}{\xi_{\text{cut}}} f(1) + \int_{\bar{x}_\oplus}^1
  \frac{f(z) - f(1)}{1-z}, \\
  \int_{\bar{x}_\oplus}^1 dz
  \left(\frac{\log(1-z)}{1-z}\right)_{\xi_{\text{cut}}} f(z) & =
  \frac{1}{2}\left( \log^2(1-\bar{x}_\oplus) - \log^2
  (\xi_{\text{cut}}) \right)f(1) +
  \int_{\bar{x}_\oplus}^1 \frac{\log(1-z)[f(z) - f(1)]}{1-z},
\end{align}
and the same of course for $\bar{x}_\ominus$. These two terms are
stored in the [[plus_dist_remnant]] variable below.

The option [[separate_uborns]] allows to compute the contribution of
the DGLAP remnant separately for each underlying Born flavor
structure. We need this option during event generation to generate
counter events with a specific Born flavor structure.
<<DGLAP remnant: dglap remnant: TBP>>=
  procedure :: evaluate => dglap_remnant_evaluate
<<DGLAP remnant: sub interfaces>>=
    module subroutine dglap_remnant_evaluate &
         (dglap, alpha_coupling, separate_uborns, sqme_dglap)
      class(dglap_remnant_t), intent(inout) :: dglap
      real(default), dimension(2), intent(in) :: alpha_coupling
      logical, intent(in) :: separate_uborns
      real(default), intent(inout), dimension(:) :: sqme_dglap
    end subroutine dglap_remnant_evaluate
<<DGLAP remnant: procedures>>=
  module subroutine dglap_remnant_evaluate &
       (dglap, alpha_coupling, separate_uborns, sqme_dglap)
    class(dglap_remnant_t), intent(inout) :: dglap
    real(default), dimension(2), intent(in) :: alpha_coupling
    logical, intent(in) :: separate_uborns
    real(default), intent(inout), dimension(:) :: sqme_dglap
    integer :: alr, emitter, i_corr
    real(default) :: sqme_alr
    logical, dimension(:,:,:), allocatable :: evaluated
    real(default) :: sb, fac_scale2
    sb = dglap%isr_kinematics%sqrts_born**2
    fac_scale2 = dglap%isr_kinematics%fac_scale**2
    allocate (evaluated(dglap%reg_data%get_n_flv_born (), &
         dglap%reg_data%get_n_flv_real (), dglap%reg_data%n_in))
    evaluated = .false.
    do alr = 1, dglap%reg_data%n_regions
       i_corr = 0
       if (dglap%reg_data%regions(alr)%nlo_correction_type == "QCD") then
          i_corr = 1
       else if (dglap%reg_data%regions(alr)%nlo_correction_type == "EW") then
          i_corr = 2
       end if
       if (allocated (dglap%settings%selected_alr)) then
          if (.not. any (dglap%settings%selected_alr == alr)) cycle
       end if
       sqme_alr = zero
       emitter = dglap%reg_data%regions(alr)%emitter
       if (emitter > dglap%reg_data%n_in .or. i_corr == 0) cycle
       associate (i_flv_born => dglap%reg_data%regions(alr)%uborn_index, &
               i_flv_real => dglap%reg_data%regions(alr)%real_index)
          if (emitter == 0) then
             do emitter = 1, 2
                if (evaluated(i_flv_born, i_flv_real, emitter)) cycle
                call evaluate_alr (alr, emitter, i_flv_born, &
                     i_flv_real, sqme_alr, evaluated)
             end do
          else if (emitter > 0) then
             if (evaluated(i_flv_born, i_flv_real, emitter)) cycle
             call evaluate_alr (alr, emitter, i_flv_born, &
                  i_flv_real, sqme_alr, evaluated)
          end if
          if (separate_uborns) then
             sqme_dglap(i_flv_born) = sqme_dglap(i_flv_born) &
                  + alpha_coupling (i_corr)/ twopi * sqme_alr
          else
             sqme_dglap(1) = sqme_dglap(1) &
                  + alpha_coupling (i_corr) / twopi * sqme_alr
          end if
       end associate
    end do

  contains
  <<DGLAP remnant: dglap remnant evaluate: procedures>>
  end subroutine dglap_remnant_evaluate

@ %def dglap_remnant_evaluate
@ We introduce $\hat{P}(z, \epsilon) = (1 - z) P(z, \epsilon)$ and have
\begin{align}
  \hat{P}_{g\to gg}(z) & = 2C_A \left[z + \frac{(1-z)^2}{z} + z(1-z)^2\right], \\
  \hat{P}_{g\to qq}(z) & = C_F (1-z) \frac{1 + (1-z)^2}{z}, \\
  \hat{P}_{q\to gq}(z) & = T_F (1 - z - 2z(1-z)^2), \\
  \hat{P}_{q\to qg}(z) & = C_F (1 + z^2).
\end{align}
<<DGLAP remnant: dglap remnant evaluate: procedures>>=
  function p_hat_gtogg (z)
    real(default) :: p_hat_gtogg
  <<p variables>>
    p_hat_gtogg = two * dglap%CA * (z + onemz**2 / z + z * onemz**2)
  end function p_hat_gtogg

  function p_hat_gtoqq (z)
    real(default) :: p_hat_gtoqq
  <<p variables>>
    p_hat_gtoqq = dglap%CF * onemz / z * (one + onemz**2)
  end function p_hat_gtoqq

  function p_hat_qtogq (z)
    real(default) :: p_hat_qtogq
  <<p variables>>
    p_hat_qtogq = dglap%TR * (onemz - two * z * onemz**2)
  end function p_hat_qtogq

  function p_hat_qtoqg (z)
    real(default) :: p_hat_qtoqg
    real(default), intent(in) :: z
    p_hat_qtoqg = dglap%CF * (one + z**2)
  end function p_hat_qtoqg

@ %def p_hat_qtoqg, p_hat_qtogq, p_hat_gtoqq, p_hat_gtogg
@
\begin{align}
  \frac{\partial P_{g\to gg}(z,\epsilon)}{\partial \epsilon}|_{\epsilon = 0} & = 0, \\
  \frac{\partial P_{g\to qq}(z,\epsilon)}{\partial \epsilon}|_{\epsilon = 0} & = -C_F z, \\
  \frac{\partial P_{q\to gq}(z,\epsilon)}{\partial \epsilon}|_{\epsilon = 0} & = -
2 T_F z (1-z), \\
  \frac{\partial P_{q\to qg}(z,\epsilon)}{\partial \epsilon}|_{\epsilon = 0} & = -C_F (1-z).\\
\end{align}
<<DGLAP remnant: dglap remnant evaluate: procedures>>=
  function p_derived_gtogg (z)
    real(default) :: p_derived_gtogg
    real(default), intent(in) :: z
    p_derived_gtogg = zero
  end function p_derived_gtogg

  function p_derived_gtoqq (z)
    real(default) :: p_derived_gtoqq
    real(default), intent(in) :: z
    p_derived_gtoqq = -dglap%CF * z
  end function p_derived_gtoqq

  function p_derived_qtogq (z)
    real(default) :: p_derived_qtogq
  <<p variables>>
    p_derived_qtogq = -two * dglap%TR * z * onemz
  end function p_derived_qtogq

  function p_derived_qtoqg (z)
    real(default) :: p_derived_qtoqg
  <<p variables>>
    p_derived_qtoqg = -dglap%CF * onemz
  end function p_derived_qtoqg

@ %def p_derived_gtogg, p_derived_gtoqq, p_derived_qtogq, p_derived_qtoqg
@
<<DGLAP remnant: dglap remnant evaluate: procedures>>=
subroutine evaluate_alr (alr, emitter, i_flv_born, i_flv_real, sqme_alr, evaluated)
  integer, intent(in) :: alr, emitter, i_flv_born, i_flv_real
  real(default), intent(inout) :: sqme_alr
  logical, intent(inout), dimension(:,:,:) :: evaluated
  real(default) :: z, jac
  real(default) :: factor, factor_soft, plus_dist_remnant
  real(default) :: xb, onemz
  real(default) :: sqme_scaled, sqme_born_dglap
  real(default) :: charge_rad2, charge_em2
  integer :: flv_em, flv_rad, N_col, i
  N_col = 1
  sqme_born_dglap = zero
  associate (template => dglap%settings%fks_template)
     z = dglap%isr_kinematics%z(emitter)
     flv_rad = dglap%reg_data%regions(alr)%flst_real%flst(dglap%reg_data%n_legs_real)
     flv_em = dglap%reg_data%regions(alr)%flst_real%flst(emitter)
     charge_rad2 = dglap%reg_data%regions(alr)%flst_real%charge(dglap%reg_data%n_legs_real)**2
     charge_em2 = dglap%reg_data%regions(alr)%flst_real%charge(emitter)**2
     if (dglap%reg_data%regions(alr)%nlo_correction_type == "QCD") then
        call dglap%set_parameters (CA = CA, CF = CF, TR = TR)
     else if (dglap%reg_data%regions(alr)%nlo_correction_type == "EW") then
        if (is_quark(flv_rad)) N_col = NC
        call dglap%set_parameters (CA = zero, CF = charge_em2, TR = N_col*charge_rad2)
     end if
     jac = dglap%isr_kinematics%jacobian(emitter)
     onemz = one - z
     factor = log (sb * template%delta_i / two / z / fac_scale2) / &
          onemz + two * log (onemz) / onemz
     factor_soft = log (sb * template%delta_i / two / fac_scale2) / &
          onemz + two * log (onemz) / onemz
     xb = dglap%isr_kinematics%x(emitter)
     plus_dist_remnant = log ((one - xb) / template%xi_cut) * log (sb * template%delta_i / &
          two / fac_scale2) + (log (one - xb)**2 - log (template%xi_cut)**2)
  end associate
  if (dglap%reg_data%nlo_correction_type == "EW" .and. &
     dglap%reg_data%regions(alr)%nlo_correction_type == "QCD" .and. &
     qcd_ew_interferences (dglap%reg_data%regions(alr)%flst_uborn%flst)) then
     do i = 1, size (dglap%reg_data%regions(alr)%flst_uborn%flst)
        if (is_quark (dglap%reg_data%regions(alr)%flst_uborn%flst (i))) then
           sqme_born_dglap = -dglap%sqme_color_c_extra (i, i, i_flv_born)/CF
           exit
        end if
     end do
  else
     sqme_born_dglap = dglap%sqme_born(i_flv_born)
  end if
  sqme_scaled = sqme_born_dglap * dglap%sf_factors(alr, emitter)
  if (is_massless_vector (flv_em) .and. is_massless_vector (flv_rad)) then
     sqme_alr = sqme_alr + p_hat_gtogg(z) * factor / z * sqme_scaled * jac &
          - p_hat_gtogg(one) * factor_soft * sqme_born_dglap * jac &
          + p_hat_gtogg(one) * plus_dist_remnant * sqme_born_dglap
  else if (is_fermion (flv_em) .and. is_massless_vector (flv_rad)) then
     sqme_alr = sqme_alr + p_hat_qtoqg(z) * factor / z * sqme_scaled * jac &
          - p_derived_qtoqg(z) / z * sqme_scaled * jac &
          - p_hat_qtoqg(one) * factor_soft * sqme_born_dglap * jac &
          + p_hat_qtoqg(one) * plus_dist_remnant * sqme_born_dglap
  else if (is_fermion (flv_em) .and. is_fermion (flv_rad)) then
     sqme_alr = sqme_alr + (p_hat_gtoqq(z) * factor - p_derived_gtoqq(z)) / z * jac * &
          sqme_scaled
  else if (is_massless_vector (flv_em) .and. is_fermion (flv_rad)) then
     sqme_alr = sqme_alr + (p_hat_qtogq(z) * factor - p_derived_qtogq(z)) / z * sqme_scaled * jac
  else
     sqme_alr = sqme_alr + zero
  end if
  evaluated(i_flv_born, i_flv_real, emitter) = .true.
end subroutine evaluate_alr
@ %dglap_remnant_evaluate_alr
@
<<p variables>>=
  real(default), intent(in) :: z
  real(default) :: onemz
  onemz = one - z

@ %def variables
@
<<DGLAP remnant: dglap remnant: TBP>>=
  procedure :: final => dglap_remnant_final
<<DGLAP remnant: sub interfaces>>=
    module subroutine dglap_remnant_final (dglap)
      class(dglap_remnant_t), intent(inout) :: dglap
    end subroutine dglap_remnant_final
<<DGLAP remnant: procedures>>=
  module subroutine dglap_remnant_final (dglap)
    class(dglap_remnant_t), intent(inout) :: dglap
    if (associated (dglap%isr_kinematics)) nullify (dglap%isr_kinematics)
    if (associated (dglap%reg_data)) nullify (dglap%reg_data)
    if (associated (dglap%settings)) nullify (dglap%settings)
    if (allocated (dglap%sqme_born)) deallocate (dglap%sqme_born)
    if (allocated (dglap%sf_factors)) deallocate (dglap%sf_factors)
  end subroutine dglap_remnant_final

@ %def dglap_remnant_final
@
\section{Dispatch}
@
<<[[dispatch_fks.f90]]>>=
<<File header>>

module dispatch_fks

<<Use kinds>>
<<Use strings>>
  use variables, only: var_list_t
  use nlo_data, only: fks_template_t, FKS_DEFAULT, FKS_RESONANCES

<<Standard module head>>

<<Dispatch fks: public>>

  interface
<<Dispatch fks: sub interfaces>>
  end interface

end module dispatch_fks
@ %def dispatch_fks
@
<<[[dispatch_fks_sub.f90]]>>=
<<File header>>

submodule (dispatch_fks) dispatch_fks_s

  use string_utils, only: split_string

  implicit none

contains

<<Dispatch fks: procedures>>

end submodule dispatch_fks_s

@ %def dispatch_fks_s
@ Initialize parameters used to optimize FKS calculations.
<<Dispatch fks: public>>=
  public :: dispatch_fks_setup
<<Dispatch fks: sub interfaces>>=
    module subroutine dispatch_fks_setup (fks_template, var_list)
      type(fks_template_t), intent(inout) :: fks_template
      type(var_list_t), intent(in) :: var_list
    end subroutine dispatch_fks_setup
<<Dispatch fks: procedures>>=
  module subroutine dispatch_fks_setup (fks_template, var_list)
    type(fks_template_t), intent(inout) :: fks_template
    type(var_list_t), intent(in) :: var_list
    real(default) :: fks_dij_exp1, fks_dij_exp2
    type(string_t) :: fks_mapping_type
    logical :: subtraction_disabled
    type(string_t) :: exclude_from_resonance
    fks_dij_exp1 = &
         var_list%get_rval (var_str ("fks_dij_exp1"))
    fks_dij_exp2 = &
         var_list%get_rval (var_str ("fks_dij_exp2"))
    fks_mapping_type = &
         var_list%get_sval (var_str ("$fks_mapping_type"))
    subtraction_disabled = &
         var_list%get_lval (var_str ("?disable_subtraction"))
    exclude_from_resonance = &
         var_list%get_sval (var_str ("$resonances_exclude_particles"))
    if (exclude_from_resonance /= var_str ("default")) &
       call split_string (exclude_from_resonance, var_str (":"), &
       fks_template%excluded_resonances)
    call fks_template%set_parameters ( &
         exp1 = fks_dij_exp1, exp2 = fks_dij_exp2, &
         xi_min = var_list%get_rval (var_str ("fks_xi_min")), &
         y_max = var_list%get_rval (var_str ("fks_y_max")), &
         xi_cut = var_list%get_rval (var_str ("fks_xi_cut")), &
         delta_o = var_list%get_rval (var_str ("fks_delta_o")), &
         delta_i = var_list%get_rval (var_str ("fks_delta_i")))
    select case (char (fks_mapping_type))
    case ("default")
       call fks_template%set_mapping_type (FKS_DEFAULT)
    case ("resonances")
       call fks_template%set_mapping_type (FKS_RESONANCES)
    end select
    fks_template%subtraction_disabled = subtraction_disabled
    fks_template%n_f = var_list%get_ival (var_str ("alphas_nf"))
  end subroutine dispatch_fks_setup

@ %def dispatch_fks_setup
@
