% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; noweb-code-mode: f90-mode -*-
% WHIZARD code as NOWEB source: Utilities
\chapter{Utilities}
\includemodulegraph{utilities}

These modules are intended as part of WHIZARD, but in fact they are
generic and could be useful for any purpose.

The modules depend only on modules from the [[basics]] set.
\begin{description}
\item[file\_utils]
  Procedures that deal with external files, if not covered by Fortran
  built-ins.
\item[file\_registries]
  Manage files that are accessed by their name.
\item[string\_utils]
  Some string-handling utilities.  Includes conversion to C string.
\item[format\_utils]
  Utilities for pretty-printing.
\item[format\_defs]
  Predefined format strings.
\item[numeric\_utils]
  Utilities for comparing numerical values.
\item[data\_utils]
  Utitilies for data structures, i.e. a fixed size queue, polymorphic binary tree and dynamic array list.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{File Utilities}

This module provides miscellaneous tools associated with named
external files.  Currently only:
\begin{itemize}
\item
  Delete a named file
\end{itemize}
<<[[file_utils.f90]]>>=
<<File header>>

module file_utils

<<Standard module head>>

<<File utils: public>>

  interface
<<File utils: sub interfaces>>
  end interface

end module file_utils
@ %def file_utils
<<[[file_utils_sub.f90]]>>=
<<File header>>

submodule (file_utils) file_utils_s

  use io_units

  implicit none

contains

<<File utils: procedures>>

end submodule file_utils_s

@ %def file_utils_s
@
\subsection{Deleting a file}
Fortran does not contain a command for deleting a file.  Here, we
provide a subroutine that deletes a file if it exists.  We do not
handle the subtleties, so we assume that it is writable if it exists.
<<File utils: public>>=
  public :: delete_file
<<File utils: sub interfaces>>=
    module subroutine delete_file (name)
      character(*), intent(in) :: name
    end subroutine delete_file
<<File utils: procedures>>=
  module subroutine delete_file (name)
    character(*), intent(in) :: name
    logical :: exist
    integer :: u
    inquire (file = name, exist = exist)
    if (exist) then
       u = free_unit ()
       open (unit = u, file = name)
       close (u, status = "delete")
    end if
  end subroutine delete_file

@ %def delete_file
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{File Registries}

This module provides a file-registry facility.  We can open and close
files multiple times without inadvertedly accessing a single file by two
different I/O unit numbers.  Opening a file the first time enters it
into the registry.  Opening again just returns the associated I/O
unit.  The registry maintains a reference count, so closing a file
does not actually complete until the last reference is released.

File access will always be sequential, however.  The file can't be
opened at different positions simultaneously.
<<[[file_registries.f90]]>>=
<<File header>>

module file_registries

<<Use strings>>

<<Standard module head>>

<<File registries: public>>

<<File registries: types>>

  interface
<<File registries: sub interfaces>>
  end interface

end module file_registries
@ %def file_registries
@
<<[[file_registries_sub.f90]]>>=
<<File header>>

submodule (file_registries) file_registries_s

  use io_units

  implicit none

contains

<<File registries: procedures>>

end submodule file_registries_s
@
\subsection{File handle}
This object holds a filename (fully qualified), the associated
unit, and a reference count.  The idea is that the object should be
deleted when the reference count drops to zero.
<<File registries: types>>=
  type :: file_handle_t
     type(string_t) :: file
     integer :: unit = 0
     integer :: refcount = 0
   contains
   <<File registries: file handle: TBP>>
  end type file_handle_t

@ %def file_handle_t
@ Debugging output:
<<File registries: file handle: TBP>>=
  procedure :: write => file_handle_write
<<File registries: sub interfaces>>=
    module subroutine file_handle_write (handle, u, show_unit)
      class(file_handle_t), intent(in) :: handle
      integer, intent(in) :: u
      logical, intent(in), optional :: show_unit
    end subroutine file_handle_write
<<File registries: procedures>>=
  module subroutine file_handle_write (handle, u, show_unit)
    class(file_handle_t), intent(in) :: handle
    integer, intent(in) :: u
    logical, intent(in), optional :: show_unit
    logical :: show_u
    show_u = .false.;  if (present (show_unit))  show_u = show_unit
    if (show_u) then
       write (u, "(3x,A,1x,I0,1x,'(',I0,')')")  &
            char (handle%file), handle%unit, handle%refcount
    else
       write (u, "(3x,A,1x,'(',I0,')')")  &
            char (handle%file), handle%refcount
    end if
  end subroutine file_handle_write

@ %def file_handle_write
@ Initialize with a file name, don't open the file yet:
<<File registries: file handle: TBP>>=
  procedure :: init => file_handle_init
<<File registries: sub interfaces>>=
    module subroutine file_handle_init (handle, file)
      class(file_handle_t), intent(out) :: handle
      type(string_t), intent(in) :: file
    end subroutine file_handle_init
<<File registries: procedures>>=
  module subroutine file_handle_init (handle, file)
    class(file_handle_t), intent(out) :: handle
    type(string_t), intent(in) :: file
    handle%file = file
  end subroutine file_handle_init

@ %def file_handle_init
@ We check the [[refcount]] before actually opening the file.
<<File registries: file handle: TBP>>=
  procedure :: open => file_handle_open
<<File registries: sub interfaces>>=
    module subroutine file_handle_open (handle)
      class(file_handle_t), intent(inout) :: handle
    end subroutine file_handle_open
<<File registries: procedures>>=
  module subroutine file_handle_open (handle)
    class(file_handle_t), intent(inout) :: handle
    if (handle%refcount == 0) then
       handle%unit = free_unit ()
       open (unit = handle%unit, file = char (handle%file), action = "read", &
            status = "old")
    end if
    handle%refcount = handle%refcount + 1
  end subroutine file_handle_open

@ %def file_handle_open
@ Analogously, close if the refcount drops to zero.  The caller may
then delete the object.
<<File registries: file handle: TBP>>=
  procedure :: close => file_handle_close
<<File registries: sub interfaces>>=
    module subroutine file_handle_close (handle)
      class(file_handle_t), intent(inout) :: handle
    end subroutine file_handle_close
<<File registries: procedures>>=
  module subroutine file_handle_close (handle)
    class(file_handle_t), intent(inout) :: handle
    handle%refcount = handle%refcount - 1
    if (handle%refcount == 0) then
       close (handle%unit)
       handle%unit = 0
    end if
  end subroutine file_handle_close

@ %def file_handle_close
@ The I/O unit will be nonzero when the file is open.
<<File registries: file handle: TBP>>=
  procedure :: is_open => file_handle_is_open
<<File registries: sub interfaces>>=
    module function file_handle_is_open (handle) result (flag)
      class(file_handle_t), intent(in) :: handle
      logical :: flag
    end function file_handle_is_open
<<File registries: procedures>>=
  module function file_handle_is_open (handle) result (flag)
    class(file_handle_t), intent(in) :: handle
    logical :: flag
    flag = handle%unit /= 0
  end function file_handle_is_open

@ %def file_handle_is_open
@ Return the filename, so we can identify the entry.
<<File registries: file handle: TBP>>=
  procedure :: get_file => file_handle_get_file
<<File registries: sub interfaces>>=
    module function file_handle_get_file (handle) result (file)
      class(file_handle_t), intent(in) :: handle
      type(string_t) :: file
    end function file_handle_get_file
<<File registries: procedures>>=
  module function file_handle_get_file (handle) result (file)
    class(file_handle_t), intent(in) :: handle
    type(string_t) :: file
    file = handle%file
  end function file_handle_get_file

@ %def file_handle_get_file
@ For debugging, return the I/O unit number.
<<File registries: file handle: TBP>>=
  procedure :: get_unit => file_handle_get_unit
<<File registries: sub interfaces>>=
    module function file_handle_get_unit (handle) result (unit)
      class(file_handle_t), intent(in) :: handle
      integer :: unit
    end function file_handle_get_unit
<<File registries: procedures>>=
  module function file_handle_get_unit (handle) result (unit)
    class(file_handle_t), intent(in) :: handle
    integer :: unit
    unit = handle%unit
  end function file_handle_get_unit

@ %def file_handle_get_unit
@
\subsection{File handles registry}
This is implemented as a doubly-linked list.  The list exists only
once in the program, as a private module variable.

Extend the handle type to become a list entry:
<<File registries: types>>=
  type, extends (file_handle_t) :: file_entry_t
     type(file_entry_t), pointer :: prev => null ()
     type(file_entry_t), pointer :: next => null ()
  end type file_entry_t

@ %def file_entry_t
@ The actual registry.  We need only the pointer to the first entry.
<<File registries: public>>=
  public :: file_registry_t
<<File registries: types>>=
  type :: file_registry_t
     type(file_entry_t), pointer :: first => null ()
   contains
   <<File registries: file registry: TBP>>
  end type file_registry_t

@ %def file_registry_t
@ Debugging output.
<<File registries: file registry: TBP>>=
  procedure :: write => file_registry_write
<<File registries: sub interfaces>>=
    module subroutine file_registry_write (registry, unit, show_unit)
      class(file_registry_t), intent(in) :: registry
      integer, intent(in), optional :: unit
      logical, intent(in), optional :: show_unit
    end subroutine file_registry_write
<<File registries: procedures>>=
  module subroutine file_registry_write (registry, unit, show_unit)
    class(file_registry_t), intent(in) :: registry
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_unit
    type(file_entry_t), pointer :: entry
    integer :: u
    u = given_output_unit (unit)
    if (associated (registry%first)) then
       write (u, "(1x,A)")  "File registry:"
       entry => registry%first
       do while (associated (entry))
          call entry%write (u, show_unit)
          entry => entry%next
       end do
    else
       write (u, "(1x,A)")  "File registry: [empty]"
    end if
  end subroutine file_registry_write

@ %def file_registry_write
@ Open a file: find the appropriate entry.  Create a new entry and add
to the list if necessary.  The list is extended at the beginning.
Return the I/O unit number for the records.
<<File registries: file registry: TBP>>=
  procedure :: open => file_registry_open
<<File registries: sub interfaces>>=
    module subroutine file_registry_open (registry, file, unit)
      class(file_registry_t), intent(inout) :: registry
      type(string_t), intent(in) :: file
      integer, intent(out), optional :: unit
    end subroutine file_registry_open
<<File registries: procedures>>=
  module subroutine file_registry_open (registry, file, unit)
    class(file_registry_t), intent(inout) :: registry
    type(string_t), intent(in) :: file
    integer, intent(out), optional :: unit
    type(file_entry_t), pointer :: entry
    entry => registry%first
    FIND_ENTRY: do while (associated (entry))
       if (entry%get_file () == file)  exit FIND_ENTRY
       entry => entry%next
    end do FIND_ENTRY
    if (.not. associated (entry)) then
       allocate (entry)
       call entry%init (file)
       if (associated (registry%first)) then
          registry%first%prev => entry
          entry%next => registry%first
       end if
       registry%first => entry
    end if
    call entry%open ()
    if (present (unit))  unit = entry%get_unit ()
  end subroutine file_registry_open

@ %def file_registry_open
@ Close a file: find the appropriate entry.  Delete the entry if there
is no file connected to it anymore.
<<File registries: file registry: TBP>>=
  procedure :: close => file_registry_close
<<File registries: sub interfaces>>=
  module subroutine file_registry_close (registry, file)
    class(file_registry_t), intent(inout) :: registry
    type(string_t), intent(in) :: file
  end subroutine file_registry_close
<<File registries: procedures>>=
  module subroutine file_registry_close (registry, file)
    class(file_registry_t), intent(inout) :: registry
    type(string_t), intent(in) :: file
    type(file_entry_t), pointer :: entry
    entry => registry%first
    FIND_ENTRY: do while (associated (entry))
       if (entry%get_file () == file)  exit FIND_ENTRY
       entry => entry%next
    end do FIND_ENTRY
    if (associated (entry)) then
       call entry%close ()
       if (.not. entry%is_open ()) then
          if (associated (entry%prev)) then
             entry%prev%next => entry%next
          else
             registry%first => entry%next
          end if
          if (associated (entry%next)) then
             entry%next%prev => entry%prev
          end if
          deallocate (entry)
       end if
    end if
  end subroutine file_registry_close

@ %def file_registry_close
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{String Utilities}

This module provides tools associated with strings
(built-in and variable).  Currently:
\begin{itemize}
\item
  Upper and lower case for strings
\item
  Convert to null-terminated C string
\end{itemize}
<<[[string_utils.f90]]>>=
<<File header>>

module string_utils

  use, intrinsic :: iso_c_binding

<<Use kinds>>
<<Use strings>>

<<Standard module head>>

<<String utils: public>>

<<String utils: interfaces>>

  interface
<<String utils: sub interfaces>>
  end interface

end module string_utils
@ %def string_utils
@
<<[[string_utils_sub.f90]]>>=
<<File header>>

submodule (string_utils) string_utils_s

  implicit none

contains

<<String utils: procedures>>

end submodule string_utils_s

@ %def string_utils_s
@
\subsection{Upper and Lower Case}
These are, unfortunately, not part of Fortran.
<<String utils: public>>=
  public :: upper_case
  public :: lower_case
<<String utils: interfaces>>=
  interface upper_case
     module procedure upper_case_char, upper_case_string
  end interface
  interface lower_case
     module procedure lower_case_char, lower_case_string
  end interface
<<String utils: sub interfaces>>=
    module function upper_case_char (string) result (new_string)
      character(*), intent(in) :: string
      character(len(string)) :: new_string
    end function upper_case_char
    module function lower_case_char (string) result (new_string)
      character(*), intent(in) :: string
      character(len(string)) :: new_string
    end function lower_case_char
    module function upper_case_string (string) result (new_string)
      type(string_t), intent(in) :: string
      type(string_t) :: new_string
    end function upper_case_string
    module function lower_case_string (string) result (new_string)
      type(string_t), intent(in) :: string
      type(string_t) :: new_string
    end function lower_case_string
<<String utils: procedures>>=
  module function upper_case_char (string) result (new_string)
    character(*), intent(in) :: string
    character(len(string)) :: new_string
    integer :: pos, code
    integer, parameter :: offset = ichar('A')-ichar('a')
    do pos = 1, len (string)
       code = ichar (string(pos:pos))
       select case (code)
       case (ichar('a'):ichar('z'))
          new_string(pos:pos) = char (code + offset)
       case default
          new_string(pos:pos) = string(pos:pos)
       end select
    end do
  end function upper_case_char

  module function lower_case_char (string) result (new_string)
    character(*), intent(in) :: string
    character(len(string)) :: new_string
    integer :: pos, code
    integer, parameter :: offset = ichar('a')-ichar('A')
    do pos = 1, len (string)
       code = ichar (string(pos:pos))
       select case (code)
       case (ichar('A'):ichar('Z'))
          new_string(pos:pos) = char (code + offset)
       case default
          new_string(pos:pos) = string(pos:pos)
       end select
    end do
  end function lower_case_char

  module function upper_case_string (string) result (new_string)
    type(string_t), intent(in) :: string
    type(string_t) :: new_string
    new_string = upper_case_char (char (string))
  end function upper_case_string

  module function lower_case_string (string) result (new_string)
    type(string_t), intent(in) :: string
    type(string_t) :: new_string
    new_string = lower_case_char (char (string))
  end function lower_case_string

@ %def upper_case lower_case
@
\subsection{C-Fortran String Conversion}
Convert a FORTRAN string to a null-terminated C string.
<<String utils: public>>=
  public :: string_f2c
<<String utils: interfaces>>=
  interface string_f2c
     module procedure string_f2c_char, string_f2c_var_str
  end interface string_f2c
<<String utils: sub interfaces>>=
    pure module function string_f2c_char (i) result (o)
      character(*), intent(in) :: i
      character(kind=c_char, len=len (i) + 1) :: o
    end function string_f2c_char
    pure module function string_f2c_var_str (i) result (o)
      type(string_t), intent(in) :: i
      character(kind=c_char, len=len (i) + 1) :: o
    end function string_f2c_var_str
<<String utils: procedures>>=
  pure module function string_f2c_char (i) result (o)
    character(*), intent(in) :: i
    character(kind=c_char, len=len (i) + 1) :: o
    o = i // c_null_char
  end function string_f2c_char

  pure module function string_f2c_var_str (i) result (o)
    type(string_t), intent(in) :: i
    character(kind=c_char, len=len (i) + 1) :: o
    o = char (i) // c_null_char
  end function string_f2c_var_str

@ %def string_f2c
@ The same task done by a subroutine, analogous to the C [[strcpy]] function.
We append a null char and copy the characters to the output string, given by a
character array -- which is equal to a [[c_char]] character string by the rule
of sequence association.

Note: Just like with the [[strcpy]] function, there is no bounds check.
<<String utils: public>>=
  public :: strcpy_f2c
<<String utils: sub interfaces>>=
    module subroutine strcpy_f2c (fstring, cstring)
      character(*), intent(in) :: fstring
      character(c_char), dimension(*), intent(inout) :: cstring
    end subroutine strcpy_f2c
<<String utils: procedures>>=
  module subroutine strcpy_f2c (fstring, cstring)
    character(*), intent(in) :: fstring
    character(c_char), dimension(*), intent(inout) :: cstring
    
    integer :: i

    do i = 1, len (fstring)
       cstring(i) = fstring(i:i)
    end do
    cstring(len(fstring)+1) = c_null_char
    
  end subroutine strcpy_f2c

@ %def strcpy_f2c
@ Convert a null-terminated C string to a Fortran string.  The C-string
argument is sequence-associated to a one-dimensional array of C characters,
where we do not know the dimension.

To convert this to a [[string_t]] object, we need to assign it or to wrap it
by another [[var_str]] conversion.
<<String utils: public>>=
  public :: string_c2f
<<String utils: sub interfaces>>=
    module function string_c2f (cstring) result (fstring)
      character(c_char), dimension(*), intent(in) :: cstring
      character(:), allocatable :: fstring
    end function string_c2f
<<String utils: procedures>>=
  module function string_c2f (cstring) result (fstring)
    character(c_char), dimension(*), intent(in) :: cstring
    character(:), allocatable :: fstring
    
    integer :: i, n
    
    n = 0
    do while (cstring(n+1) /= c_null_char)
       n = n + 1
    end do
    
    allocate (character(n) :: fstring)
    do i = 1, n
       fstring(i:i) = cstring(i)
    end do

  end function string_c2f

@ %def string_c2f
@
\subsection{Number Conversion}
Create a string from a number.  We use fixed format for the reals
and variable format for integers.
<<String utils: public>>=
  public :: str
<<String utils: interfaces>>=
  interface str
     module procedure str_log, str_logs, str_int, str_ints, &
            str_real, str_reals, str_complex, str_complexs
  end interface
<<String utils: sub interfaces>>=
    module function str_log (l) result (s)
      logical, intent(in) :: l
      type(string_t) :: s
    end function str_log
    module function str_logs (x) result (s)
      logical, dimension(:), intent(in) :: x
      type(string_t) :: s
    end function str_logs
    module function str_int (i) result (s)
      integer, intent(in) :: i
      type(string_t) :: s
    end function str_int
    module function str_ints (x) result (s)
      integer, dimension(:), intent(in) :: x
      type(string_t) :: s
    end function str_ints
    module function str_real (x) result (s)
      real(default), intent(in) :: x
      type(string_t) :: s
    end function str_real
    module function str_reals (x) result (s)
      real(default), dimension(:), intent(in) :: x
      type(string_t) :: s
    end function str_reals
    module function str_complex (x) result (s)
      complex(default), intent(in) :: x
      type(string_t) :: s
    end function str_complex
    module function str_complexs (x) result (s)
      complex(default), dimension(:), intent(in) :: x
      type(string_t) :: s
    end function str_complexs
<<String utils: procedures>>=
  module function str_log (l) result (s)
    logical, intent(in) :: l
    type(string_t) :: s
    if (l) then
       s = "True"
    else
       s = "False"
    end if
  end function str_log

  module function str_logs (x) result (s)
    logical, dimension(:), intent(in) :: x
    <<concatenate strings>>
  end function str_logs

  module function str_int (i) result (s)
    integer, intent(in) :: i
    type(string_t) :: s
    character(32) :: buffer
    write (buffer, "(I0)")  i
    s = var_str (trim (adjustl (buffer)))
  end function str_int

  module function str_ints (x) result (s)
    integer, dimension(:), intent(in) :: x
    <<concatenate strings>>
  end function str_ints

  module function str_real (x) result (s)
    real(default), intent(in) :: x
    type(string_t) :: s
    character(32) :: buffer
    write (buffer, "(ES17.10)")  x
    s = var_str (trim (adjustl (buffer)))
  end function str_real

  module function str_reals (x) result (s)
    real(default), dimension(:), intent(in) :: x
    <<concatenate strings>>
  end function str_reals

  module function str_complex (x) result (s)
    complex(default), intent(in) :: x
    type(string_t) :: s
    s = str_real (real (x)) // " + i " // str_real (aimag (x))
  end function str_complex

  module function str_complexs (x) result (s)
    complex(default), dimension(:), intent(in) :: x
    <<concatenate strings>>
  end function str_complexs

@ %def str
<<concatenate strings>>=
type(string_t) :: s
integer :: i
s = '['
do i = 1, size(x) - 1
   s = s // str(x(i)) // ', '
end do
s = s // str(x(size(x))) // ']'
@
@ Auxiliary: Read real, integer, string value.
<<String utils: public>>=
  public :: read_rval
  public :: read_ival
<<String utils: sub interfaces>>=
    module function read_rval (s) result (rval)
      real(default) :: rval
      type(string_t), intent(in) :: s
    end function read_rval
    module function read_ival (s) result (ival)
      integer :: ival
      type(string_t), intent(in) :: s
    end function read_ival
<<String utils: procedures>>=
  module function read_rval (s) result (rval)
    real(default) :: rval
    type(string_t), intent(in) :: s
    character(80) :: buffer
    buffer = s
    read (buffer, *)  rval
  end function read_rval

  module function read_ival (s) result (ival)
    integer :: ival
    type(string_t), intent(in) :: s
    character(80) :: buffer
    buffer = s
    read (buffer, *)  ival
  end function read_ival

@ %def read_rval read_ival
@
\subsection{String splitting}
<<String utils: public>>=
  public :: string_contains_word
<<String utils: sub interfaces>>=
    pure module function string_contains_word &
         (str, word, include_identical) result (val)
      logical :: val
      type(string_t), intent(in) :: str, word
      logical, intent(in), optional :: include_identical
    end function string_contains_word
<<String utils: procedures>>=
  pure module function string_contains_word &
       (str, word, include_identical) result (val)
    logical :: val
    type(string_t), intent(in) :: str, word
    type(string_t) :: str_tmp, str_out
    logical, intent(in), optional :: include_identical
    logical :: yorn
    str_tmp = str
    val = .false.
    yorn = .false.; if (present (include_identical))  yorn = include_identical
    if (yorn)  val = str == word
    call split (str_tmp, str_out, word)
    val = val .or. (str_out /= "")
  end function string_contains_word

@ %def string_contains_word
@ Create an array of strings using a separator.
<<String utils: public>>=
  public :: split_string
<<String utils: sub interfaces>>=
    pure module subroutine split_string (str, separator, str_array)
      type(string_t), dimension(:), allocatable, intent(out) :: str_array
      type(string_t), intent(in) :: str, separator
    end subroutine split_string
<<String utils: procedures>>=
  pure module subroutine split_string (str, separator, str_array)
    type(string_t), dimension(:), allocatable, intent(out) :: str_array
    type(string_t), intent(in) :: str, separator
    type(string_t) :: str_tmp, str_out
    integer :: n_str
    n_str = 0; str_tmp = str
    do while (string_contains_word (str_tmp, separator))
       n_str = n_str + 1
       call split (str_tmp, str_out, separator)
    end do
    allocate (str_array (n_str))
    n_str = 1; str_tmp = str
    do while (string_contains_word (str_tmp, separator))
       call split (str_tmp, str_array (n_str), separator)
       n_str = n_str + 1
    end do
  end subroutine split_string

@ %def split_string
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Format Utilities}

This module provides miscellaneous tools associated with formatting and
pretty-printing.
\begin{itemize}
\item
  Horizontal separator lines in output
\item
  Indenting an output line
\item
  Formatting a number for \TeX\ output.
\item
  Formatting a number for MetaPost output.
\item
  Alternate numeric formats.
\end{itemize}
<<[[format_utils.f90]]>>=
<<File header>>

module format_utils

<<Use kinds>>
<<Use strings>>

<<Standard module head>>

<<Format utils: public>>

  interface
<<Format utils: sub interfaces>>
  end interface

end module format_utils
@ %def format_utils
@
<<[[format_utils_sub.f90]]>>=
<<File header>>

submodule (format_utils) format_utils_s

  use string_utils, only: lower_case
  use io_units, only: given_output_unit

  implicit none

contains

<<Format utils: procedures>>

end submodule format_utils_s

@ %def format_utils_s
@
\subsection{Line Output}
Write a separator line.
<<Format utils: public>>=
  public :: write_separator
<<Format utils: sub interfaces>>=
    module subroutine write_separator (u, mode)
      integer, intent(in) :: u
      integer, intent(in), optional :: mode
    end subroutine write_separator
<<Format utils: procedures>>=
  module subroutine write_separator (u, mode)
    integer, intent(in) :: u
    integer, intent(in), optional :: mode
    integer :: m
    m = 1;  if (present (mode))  m = mode
    select case (m)
    case default
       write (u, "(A)")  repeat ("-", 72)
    case (1)
       write (u, "(A)")  repeat ("-", 72)
    case (2)
       write (u, "(A)")  repeat ("=", 72)
    end select
  end subroutine write_separator

@ %def write_separator
@
Indent the line with given number of blanks.
<<Format utils: public>>=
  public :: write_indent
<<Format utils: sub interfaces>>=
    module subroutine write_indent (unit, indent)
      integer, intent(in) :: unit
      integer, intent(in), optional :: indent
    end subroutine write_indent
<<Format utils: procedures>>=
  module subroutine write_indent (unit, indent)
    integer, intent(in) :: unit
    integer, intent(in), optional :: indent
    if (present (indent)) then
       write (unit, "(1x,A)", advance="no")  repeat ("  ", indent)
    end if
  end subroutine write_indent

@ %def write_indent
@
\subsection{Array Output}
Write an array of integers.
<<Format utils: public>>=
  public :: write_integer_array
<<Format utils: sub interfaces>>=
    module subroutine write_integer_array (array, unit, n_max, no_skip)
      integer, intent(in), dimension(:) :: array
      integer, intent(in), optional :: unit
      integer, intent(in), optional :: n_max
      logical, intent(in), optional :: no_skip
    end subroutine write_integer_array
<<Format utils: procedures>>=
  module subroutine write_integer_array (array, unit, n_max, no_skip)
    integer, intent(in), dimension(:) :: array
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: n_max
    logical, intent(in), optional :: no_skip
    integer :: u, i, n
    logical :: yorn
    u = given_output_unit (unit)
    yorn = .false.; if (present (no_skip)) yorn = no_skip
    if (present (n_max)) then
       n = n_max
    else
       n = size (array)
    end if
    do i = 1, n
       if (i < n .or. yorn) then
          write (u, "(I0, A)", advance = "no") array(i), ", "
       else
          write (u, "(I0)") array(i)
       end if
    end do
  end subroutine write_integer_array

@ %def write_integer_array
@
\subsection{\TeX-compatible Output}
Quote underscore characters for use in \TeX\ output.
<<Format utils: public>>=
  public :: quote_underscore
<<Format utils: sub interfaces>>=
    module function quote_underscore (string) result (quoted)
      type(string_t) :: quoted
      type(string_t), intent(in) :: string
    end function quote_underscore
<<Format utils: procedures>>=
  module function quote_underscore (string) result (quoted)
    type(string_t) :: quoted
    type(string_t), intent(in) :: string
    type(string_t) :: part
    type(string_t) :: buffer
    buffer = string
    quoted = ""
    do
      call split (part, buffer, "_")
      quoted = quoted // part
      if (buffer == "")  exit
      quoted = quoted // "\_"
    end do
  end function quote_underscore

@ %def quote_underscore
@ Format a number with $n$ significant digits for use in \TeX\ documents.
<<Format utils: public>>=
  public :: tex_format
<<Format utils: sub interfaces>>=
    module function tex_format (rval, n_digits) result (string)
      type(string_t) :: string
      real(default), intent(in) :: rval
      integer, intent(in) :: n_digits
    end function tex_format
<<Format utils: procedures>>=
  module function tex_format (rval, n_digits) result (string)
    type(string_t) :: string
    real(default), intent(in) :: rval
    integer, intent(in) :: n_digits
    integer :: e, n, w, d
    real(default) :: absval
    real(default) :: mantissa
    character :: sign
    character(20) :: format
    character(80) :: cstr
    n = min (abs (n_digits), 16)
    if (rval == 0) then
       string = "0"
    else
       absval = abs (rval)
       e = int (log10 (absval))
       if (rval < 0) then
          sign = "-"
       else
          sign = ""
       end if
       select case (e)
       case (:-3)
          d = max (n - 1, 0)
          w = max (d + 2, 2)
          write (format, "('(F',I0,'.',I0,',A,I0,A)')")  w, d
          mantissa = absval * 10._default ** (1 - e)
          write (cstr, fmt=format)  mantissa, "\times 10^{", e - 1, "}"
       case (-2:0)
          d = max (n - e, 1 - e)
          w = max (d + e + 2, d + 2)
          write (format, "('(F',I0,'.',I0,')')")  w, d
          write (cstr, fmt=format)  absval
       case (1:2)
          d = max (n - e - 1, -e, 0)
          w = max (d + e + 2, d + 2, e + 2)
          write (format, "('(F',I0,'.',I0,')')")  w, d
          write (cstr, fmt=format)  absval
       case default
          d = max (n - 1, 0)
          w = max (d + 2, 2)
          write (format, "('(F',I0,'.',I0,',A,I0,A)')")  w, d
          mantissa = absval * 10._default ** (- e)
          write (cstr, fmt=format)  mantissa, "\times 10^{", e, "}"
       end select
       string = sign // trim (cstr)
    end if
  end function tex_format

@ %def tex_format
@
\subsection{Metapost-compatible Output}
Write a number for use in Metapost code:
<<Format utils: public>>=
  public :: mp_format
<<Format utils: sub interfaces>>=
    module function mp_format (rval) result (string)
      type(string_t) :: string
      real(default), intent(in) :: rval
    end function mp_format
<<Format utils: procedures>>=
  module function mp_format (rval) result (string)
    type(string_t) :: string
    real(default), intent(in) :: rval
    character(16) :: tmp
    write (tmp, "(G16.8)")  rval
    string = lower_case (trim (adjustl (trim (tmp))))
  end function mp_format

@ %def mp_format
@
\subsection{Conditional Formatting}
Conditional format string, intended for switchable numeric precision.
<<Format utils: public>>=
  public :: pac_fmt
<<Format utils: sub interfaces>>=
    module subroutine pac_fmt (fmt, fmt_orig, fmt_pac, pacify)
      character(*), intent(in) :: fmt_orig, fmt_pac
      character(*), intent(out) :: fmt
      logical, intent(in), optional :: pacify
    end subroutine pac_fmt
<<Format utils: procedures>>=
  module subroutine pac_fmt (fmt, fmt_orig, fmt_pac, pacify)
    character(*), intent(in) :: fmt_orig, fmt_pac
    character(*), intent(out) :: fmt
    logical, intent(in), optional :: pacify
    logical :: pacified
    pacified = .false.
    if (present (pacify))  pacified = pacify
    if (pacified) then
       fmt = fmt_pac
    else
       fmt = fmt_orig
    end if
  end subroutine pac_fmt

@ %def pac_fmt
@
\subsection{Guard tiny values}
This function can be applied if values smaller than $10^{-99}$ would cause an
underflow in the output format.  We know that Fortran fixed-format can handle
this by omitting the exponent letter, but we should expect non-Fortran or
Fortran list-directed input, which would fail.  We reset such values to $\pm
10^{-99}$, assuming that such tiny values would not matter, except for being
non-zero.
<<Format utils: public>>=
  public :: refmt_tiny
<<Format utils: sub interfaces>>=
    elemental module function refmt_tiny (val) result (trunc_val)
      real(default), intent(in) :: val
      real(default) :: trunc_val
    end function refmt_tiny
<<Format utils: procedures>>=
  elemental module function refmt_tiny (val) result (trunc_val)
    real(default), intent(in) :: val
    real(default) :: trunc_val
    real(default), parameter :: tiny_val = 1.e-99_default

    if (val /= 0) then
       if (abs (val) < tiny_val) then
          trunc_val = sign (tiny_val, val)
       else
          trunc_val = val
       end if
    else
       trunc_val = val
    end if
    
  end function refmt_tiny
  
@ %def refmt_tiny
@
\subsection{Compressed output of integer arrays}
<<Format utils: public>>=
  public :: write_compressed_integer_array
<<Format utils: sub interfaces>>=
    module subroutine write_compressed_integer_array (chars, array)
      character(len=*), intent(out) :: chars
      integer, intent(in), allocatable, dimension(:) :: array
    end subroutine write_compressed_integer_array
<<Format utils: procedures>>=
  module subroutine write_compressed_integer_array (chars, array)
    character(len=*), intent(out) :: chars
    integer, intent(in), allocatable, dimension(:) :: array
    logical, dimension(:), allocatable :: used
    character(len=16) :: tmp
    type(string_t) :: string
    integer :: i, j, start_chain, end_chain
    chars = '[none]'
    string = ""
    if (allocated (array)) then
       if (size (array) > 0) then
          allocate (used (size (array)))
          used = .false.
          do i = 1, size (array)
             if (.not. used(i)) then
                start_chain = array(i)
                end_chain = array(i)
                used(i) = .true.
                EXTEND: do
                   do j = 1, size (array)
                      if (array(j) == end_chain + 1) then
                         end_chain = array(j)
                         used(j) = .true.
                         cycle EXTEND
                      end if
                      if (array(j) == start_chain - 1) then
                         start_chain = array(j)
                         used(j) = .true.
                         cycle EXTEND
                      end if
                   end do
                   exit
                end do EXTEND
                if (end_chain - start_chain > 0) then
                   write (tmp, "(I0,A,I0)") start_chain, "-", end_chain
                else
                   write (tmp, "(I0)") start_chain
                end if
                string = string // trim (tmp)
                if (any (.not. used)) then
                   string = string // ','
                end if
             end if
          end do
          chars = string
       end if
    end if
    chars = adjustr (chars)
  end subroutine write_compressed_integer_array

@ %def write_compressed_integer_array
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Format Definitions}

This module provides named integer parameters that specify certain
format strings, used for numerical output.
<<[[format_defs.f90]]>>=
<<File header>>

module format_defs

<<Standard module head>>

<<Format defs: public parameters>>

end module format_defs
@ %def format_defs
@ We collect format strings for various numerical output formats here.
<<Format defs: public parameters>>=
  character(*), parameter, public :: FMT_19 = "ES19.12"
  character(*), parameter, public :: FMT_18 = "ES18.11"
  character(*), parameter, public :: FMT_17 = "ES17.10"
  character(*), parameter, public :: FMT_16 = "ES16.9"
  character(*), parameter, public :: FMT_15 = "ES15.8"
  character(*), parameter, public :: FMT_14 = "ES14.7"
  character(*), parameter, public :: FMT_13 = "ES13.6"
  character(*), parameter, public :: FMT_12 = "ES12.5"
  character(*), parameter, public :: FMT_11 = "ES11.4"
  character(*), parameter, public :: FMT_10 = "ES10.3"

@ %def FMT_10 FMT_11 FMT_12 FMT_13 FMT_14
@ %def FMT_15 FMT_16 FMT_17 FMT_18 FMT_19
@ Fixed-point formats for better readability, where appropriate.
<<Format defs: public parameters>>=
  character(*), parameter, public :: FMF_12 = "F12.9"
@ %def FMF_12
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Numeric Utilities}

<<[[numeric_utils.f90]]>>=
<<File header>>

module numeric_utils

<<Use kinds>>
<<Use strings>>

<<Standard module head>>

<<Numeric utils: public>>

<<Numeric utils: parameters>>

<<Numeric utils: types>>

<<Numeric utils: interfaces>>

  interface
<<Numeric utils: sub interfaces>>
  end interface

end module numeric_utils
@ %def numeric_utils
@
<<[[numeric_utils_sub.f90]]>>=
<<File header>>

submodule (numeric_utils) numeric_utils_s

  use string_utils
  use constants
  use format_defs

  implicit none

contains

<<Numeric utils: procedures>>

end submodule numeric_utils_s

@ %def numeric_utils_s
@ Probably, there needs to be a single, global workspace for the whole
calculations and not one local to the integration routine.
<<Numeric utils: types>>=
  type :: int_workspace_t
     private
     integer :: limit
     integer :: size = 0
     integer :: nrmax = 1
     integer :: i = 1
     integer :: maximum_level = 0
     real(default), dimension(:), allocatable :: alist
     real(default), dimension(:), allocatable :: blist
     real(default), dimension(:), allocatable :: rlist
     real(default), dimension(:), allocatable :: elist
     integer, dimension(:), allocatable :: order
     integer, dimension(:), allocatable :: level
   contains
   <<Numeric utils: workspace: TBP>>
  end type int_workspace_t

@ %def int_workspace_t
@
<<Numeric utils: workspace: TBP>>=
  procedure :: init => int_workspace_init
<<Numeric utils: sub interfaces>>=
    module subroutine int_workspace_init (work, a, b, limit)
      class(int_workspace_t), intent(out) :: work
      real(default), intent(in) :: a, b
      integer, intent(in) :: limit
    end subroutine int_workspace_init
<<Numeric utils: procedures>>=
  module subroutine int_workspace_init (work, a, b, limit)
    class(int_workspace_t), intent(out) :: work
    real(default), intent(in) :: a, b
    integer, intent(in) :: limit
    work%limit = limit
    allocate (work%alist (limit), work%blist (limit), &
         work%rlist (limit), work%elist(limit), &
         work%order(limit), work%level(limit))
    work%alist(1) = a
    work%blist(1) = b
  end subroutine int_workspace_init

@ %def int_workspace_init
@
<<Numeric utils: workspace: TBP>>=
  procedure :: set_initial => int_workspace_set_initial
<<Numeric utils: sub interfaces>>=
    module subroutine int_workspace_set_initial (work, res, err)
      class(int_workspace_t), intent(inout) :: work
      real(default), intent(in) :: res, err
    end subroutine int_workspace_set_initial
<<Numeric utils: procedures>>=
  module subroutine int_workspace_set_initial (work, res, err)
    class(int_workspace_t), intent(inout) :: work
    real(default), intent(in) :: res, err
    work%size = 1
    work%order(1) = 1
    work%rlist(1) = res
    work%elist(1) = err
  end subroutine int_workspace_set_initial

@ %def int_workspace_set_initial
@
<<Numeric utils: workspace: TBP>>=
  procedure :: update => int_workspace_update
<<Numeric utils: sub interfaces>>=
    module subroutine int_workspace_update (work, a1, b1, area1, error1, &
         a2, b2, area2, error2)
      class(int_workspace_t), intent(inout) :: work
      real(default), intent(in) :: a1, b1, area1, error1, &
           a2, b2, area2, error2
    end subroutine int_workspace_update
<<Numeric utils: procedures>>=
  module subroutine int_workspace_update (work, a1, b1, area1, error1, &
       a2, b2, area2, error2)
    class(int_workspace_t), intent(inout) :: work
    real(default), intent(in) :: a1, b1, area1, error1, &
         a2, b2, area2, error2
    integer :: i_max, i_new, new_level
    i_max = work%i
    i_new = work%size + 1
    new_level = work%level(i_max) + 1
    ! append the newly-created intervals to the list
    if (error2 > error1) then
       ! work%blist(maxerr) is already b2
       work%alist(i_max) = a2
       work%rlist(i_max) = area2
       work%elist(i_max) = error2
       work%level(i_max) = new_level
       work%alist(i_new) = a1
       work%blist(i_new) = b1
       work%rlist(i_new) = area1
       work%elist(i_new) = error1
       work%level(i_new) = new_level
    else
       ! work%alist(maxerr) is already a1
       work%blist(i_max) = b1
       work%rlist(i_max) = area1
       work%elist(i_max) = error1
       work%level(i_max) = new_level
       work%alist(i_new) = a2
       work%blist(i_new) = b2
       work%rlist(i_new) = area2
       work%elist(i_new) = error2
       work%level(i_new) = new_level
    end if
    work%size = work%size + 1
    if (new_level > work%maximum_level) &
         work%maximum_level = new_level
    call work%sort ()
  end subroutine int_workspace_update

@ %def int_workspace_update
@
<<Numeric utils: workspace: TBP>>=
  procedure :: sort => int_workspace_sort
<<Numeric utils: sub interfaces>>=
    module subroutine int_workspace_sort (work)
      class(int_workspace_t), intent(inout) :: work
    end subroutine int_workspace_sort
<<Numeric utils: procedures>>=
  module subroutine int_workspace_sort (work)
    class(int_workspace_t), intent(inout) :: work
    integer :: last, limit, i, k, top, i_nrmax, i_maxerr
    real(default) :: errmax, errmin
    last = work%size
    limit = work%limit
    i_nrmax = work%nrmax
    i_maxerr = work%order(i_nrmax)
    ! Check whether the list contains more than two error estimates
    if (last < 3) then
       work%order(1) = 1
       work%order(2) = 2
       work%i = i_maxerr
       return
    end if
    errmax = work%elist(i_maxerr)
    ! This part of the routine is only executed if, due to a difficult
    ! integrand, subdivision increased the error estimate. In the normal
    ! case the insert procedure should start after the nrmax-th largest
    ! error estimate.
    DESCEND_NRMAX: do while (i_nrmax > 1) 
       if (errmax > work%elist(work%order(i_nrmax - 1))) then
          work%order(i_nrmax) = work%order(i_nrmax - 1)
          i_nrmax = i_nrmax - 1
       else
          exit DESCEND_NRMAX
       end if
    end do DESCEND_NRMAX
    ! Compute the number of elements in the list to be maintained in
    ! descending order. This number depends on the number of
    ! subdivisions still allowed.
    if (last < (limit/2 + 2)) then
       top = last
    else
       top = limit - last + 1
    end if
    ! Insert errmax by traversing the list top-down, starting
    ! comparison from the element elist(order(i_nrmax+1)).
    i = i_nrmax + 1  
    ! The order of the tests in the following line is important to
    ! prevent a segmentation fault
    ASCEND_TOP: do while (i < top)
       if (errmax < work%elist(work%order(i))) then
          work%order(i-1) = work%order(i)
          i = i + 1
       else
          exit ASCEND_TOP
       end if
    end do ASCEND_TOP
    work%order(i-1) = i_maxerr
    ! Insert errmin by traversing the list bottom-up
    errmin = work%elist(last)
    k = top - 1
    DESCEND_K: do while (k > i-2)
       if (errmin >= work%elist(work%order(k))) then
          work%order(k+1) = work%order(k)
          k = k - 1
       else
          exit DESCEND_K
       end if
    end do DESCEND_K
    work%order(k+1) = last
    ! Set i_max and e_max
    i_maxerr = work%order(i_nrmax)
    work%i = i_maxerr
    work%nrmax = i_nrmax
  end subroutine int_workspace_sort

@ %def int_workspace_sort
@
<<Numeric utils: public>>=
  public :: assert
<<Numeric utils: sub interfaces>>=
    module subroutine assert (unit, ok, description, exit_on_fail)
      integer, intent(in) :: unit
      logical, intent(in) :: ok
      character(*), intent(in), optional :: description
      logical, intent(in), optional :: exit_on_fail
    end subroutine assert
<<Numeric utils: procedures>>=
  module subroutine assert (unit, ok, description, exit_on_fail)
    integer, intent(in) :: unit
    logical, intent(in) :: ok
    character(*), intent(in), optional :: description
    logical, intent(in), optional :: exit_on_fail
    logical :: ef
    ef = .false.;  if (present (exit_on_fail)) ef = exit_on_fail
    if (.not. ok) then
       if (present(description)) then
          write (unit, "(A)") "* FAIL: " // description
       else
          write (unit, "(A)") "* FAIL: Assertion error"
       end if
       if (ef)  stop 1
    end if
  end subroutine assert

@ %def assert
@ Compare numbers and output error message if not equal.
<<Numeric utils: public>>=
  public:: assert_equal
  interface assert_equal
     module procedure assert_equal_integer, assert_equal_integers, &
            assert_equal_real, assert_equal_reals, &
            assert_equal_complex, assert_equal_complexs
  end interface

@
<<Numeric utils: sub interfaces>>=
    module subroutine assert_equal_integer (unit, lhs, rhs, description, exit_on_fail)
      integer, intent(in) :: unit
      integer, intent(in) :: lhs, rhs
      character(*), intent(in), optional :: description
      logical, intent(in), optional :: exit_on_fail
    end subroutine assert_equal_integer
<<Numeric utils: procedures>>=
  module subroutine assert_equal_integer (unit, lhs, rhs, description, exit_on_fail)
    integer, intent(in) :: unit
    integer, intent(in) :: lhs, rhs
    character(*), intent(in), optional :: description
    logical, intent(in), optional :: exit_on_fail
    type(string_t) :: desc
    logical :: ok
    ok = lhs == rhs
    desc = '';  if (present (description)) desc = var_str(description) // ": "
    call assert (unit, ok, char(desc // str (lhs) // " /= " // str (rhs)), exit_on_fail)
  end subroutine assert_equal_integer

@ %def assert_equal_integer
@
<<Numeric utils: sub interfaces>>= 
    module subroutine assert_equal_integers (unit, lhs, rhs, description, exit_on_fail)
      integer, intent(in) :: unit
      integer, dimension(:), intent(in) :: lhs, rhs
      character(*), intent(in), optional :: description
      logical, intent(in), optional :: exit_on_fail
    end subroutine assert_equal_integers
<<Numeric utils: procedures>>=
  module subroutine assert_equal_integers (unit, lhs, rhs, description, exit_on_fail)
    integer, intent(in) :: unit
    integer, dimension(:), intent(in) :: lhs, rhs
    character(*), intent(in), optional :: description
    logical, intent(in), optional :: exit_on_fail
    type(string_t) :: desc
    logical :: ok
    ok = all(lhs == rhs)
    desc = '';  if (present (description)) desc = var_str(description) // ": "
    call assert (unit, ok, char(desc // str (lhs) // " /= " // str (rhs)), exit_on_fail)
  end subroutine assert_equal_integers

@ %def assert_equal_integers
@
<<Numeric utils: sub interfaces>>=
    module subroutine assert_equal_real (unit, lhs, rhs, description, &
                                  abs_smallness, rel_smallness, exit_on_fail)
      integer, intent(in) :: unit
      real(default), intent(in) :: lhs, rhs
      character(*), intent(in), optional :: description
      real(default), intent(in), optional :: abs_smallness, rel_smallness
      logical, intent(in), optional :: exit_on_fail
    end subroutine assert_equal_real
<<Numeric utils: procedures>>=
  module subroutine assert_equal_real (unit, lhs, rhs, description, &
                                abs_smallness, rel_smallness, exit_on_fail)
    integer, intent(in) :: unit
    real(default), intent(in) :: lhs, rhs
    character(*), intent(in), optional :: description
    real(default), intent(in), optional :: abs_smallness, rel_smallness
    logical, intent(in), optional :: exit_on_fail
    type(string_t) :: desc
    logical :: ok
    ok = nearly_equal (lhs, rhs, abs_smallness, rel_smallness)
    desc = '';  if (present (description)) desc = var_str(description) // ": "
    call assert (unit, ok, char(desc // str (lhs) // " /= " // str (rhs)), exit_on_fail)
  end subroutine assert_equal_real

@ %def assert_equal_real
@
<<Numeric utils: sub interfaces>>=
    module subroutine assert_equal_reals (unit, lhs, rhs, description, &
                                  abs_smallness, rel_smallness, exit_on_fail)
      integer, intent(in) :: unit
      real(default), dimension(:), intent(in) :: lhs, rhs
      character(*), intent(in), optional :: description
      real(default), intent(in), optional :: abs_smallness, rel_smallness
      logical, intent(in), optional :: exit_on_fail
    end subroutine assert_equal_reals
<<Numeric utils: procedures>>=
  module subroutine assert_equal_reals (unit, lhs, rhs, description, &
                                abs_smallness, rel_smallness, exit_on_fail)
    integer, intent(in) :: unit
    real(default), dimension(:), intent(in) :: lhs, rhs
    character(*), intent(in), optional :: description
    real(default), intent(in), optional :: abs_smallness, rel_smallness
    logical, intent(in), optional :: exit_on_fail
    type(string_t) :: desc
    logical :: ok
    ok = all(nearly_equal (lhs, rhs, abs_smallness, rel_smallness))
    desc = '';  if (present (description)) desc = var_str(description) // ": "
    call assert (unit, ok, char(desc // str (lhs) // " /= " // str (rhs)), exit_on_fail)
  end subroutine assert_equal_reals

@ %def assert_equal_reals
@
<<Numeric utils: sub interfaces>>=
    module subroutine assert_equal_complex (unit, lhs, rhs, description, &
                                  abs_smallness, rel_smallness, exit_on_fail)
      integer, intent(in) :: unit
      complex(default), intent(in) :: lhs, rhs
      character(*), intent(in), optional :: description
      real(default), intent(in), optional :: abs_smallness, rel_smallness
      logical, intent(in), optional :: exit_on_fail
    end subroutine assert_equal_complex
<<Numeric utils: procedures>>=
  module subroutine assert_equal_complex (unit, lhs, rhs, description, &
                                abs_smallness, rel_smallness, exit_on_fail)
    integer, intent(in) :: unit
    complex(default), intent(in) :: lhs, rhs
    character(*), intent(in), optional :: description
    real(default), intent(in), optional :: abs_smallness, rel_smallness
    logical, intent(in), optional :: exit_on_fail
    type(string_t) :: desc
    logical :: ok
    ok = nearly_equal (real(lhs), real(rhs), abs_smallness, rel_smallness) &
         .and. nearly_equal (aimag(lhs), aimag(rhs), abs_smallness, rel_smallness)
    desc = '';  if (present (description)) desc = var_str(description) // ": "
    call assert (unit, ok, char(desc // str (lhs) // " /= " // str (rhs)), exit_on_fail)
  end subroutine assert_equal_complex

@ %def assert_equal_complex
@
<<Numeric utils: sub interfaces>>=
    module subroutine assert_equal_complexs (unit, lhs, rhs, description, &
                                  abs_smallness, rel_smallness, exit_on_fail)
      integer, intent(in) :: unit
      complex(default), dimension(:), intent(in) :: lhs, rhs
      character(*), intent(in), optional :: description
      real(default), intent(in), optional :: abs_smallness, rel_smallness
      logical, intent(in), optional :: exit_on_fail
    end subroutine assert_equal_complexs
<<Numeric utils: procedures>>=
  module subroutine assert_equal_complexs (unit, lhs, rhs, description, &
                                abs_smallness, rel_smallness, exit_on_fail)
    integer, intent(in) :: unit
    complex(default), dimension(:), intent(in) :: lhs, rhs
    character(*), intent(in), optional :: description
    real(default), intent(in), optional :: abs_smallness, rel_smallness
    logical, intent(in), optional :: exit_on_fail
    type(string_t) :: desc
    logical :: ok
    ok = all (nearly_equal (real(lhs), real(rhs), abs_smallness, rel_smallness)) &
         .and. all (nearly_equal (aimag(lhs), aimag(rhs), abs_smallness, rel_smallness))
    desc = '';  if (present (description)) desc = var_str(description) // ": "
    call assert (unit, ok, char(desc // str (lhs) // " /= " // str (rhs)), exit_on_fail)
  end subroutine assert_equal_complexs

@ %def assert_equal_complexs
@ Note that this poor man's check will be disabled if someone compiles
with [[-ffast-math]] or similar optimizations.
<<Numeric utils: procedures>>=
  elemental function ieee_is_nan (x) result (yorn)
    logical :: yorn
    real(default), intent(in) :: x
    yorn = (x /= x)
  end function ieee_is_nan

@ %def ieee_is_nan
@ This is still not perfect but should work in most cases.  Usually one
wants to compare to a relative epsilon [[rel_smallness]], except for
numbers close to zero defined by [[abs_smallness]].  Both might need
adaption to specific use cases but have reasonable defaults.
<<Numeric utils: public>>=
  public :: nearly_equal
<<Numeric utils: interfaces>>=
  interface nearly_equal
     module procedure nearly_equal_real
     module procedure nearly_equal_complex
  end interface nearly_equal

<<Numeric utils: sub interfaces>>=
    elemental module function nearly_equal_real &
         (a, b, abs_smallness, rel_smallness) result (r)
      logical :: r
      real(default), intent(in) :: a, b
      real(default), intent(in), optional :: abs_smallness, rel_smallness
    end function nearly_equal_real
<<Numeric utils: procedures>>=
  elemental module function nearly_equal_real &
       (a, b, abs_smallness, rel_smallness) result (r)
    logical :: r
    real(default), intent(in) :: a, b
    real(default), intent(in), optional :: abs_smallness, rel_smallness
    real(default) :: abs_a, abs_b, diff, abs_small, rel_small
    abs_a = abs (a)
    abs_b = abs (b)
    diff = abs (a - b)
    ! shortcut, handles infinities and nans
    if (a == b) then
       r = .true.
       return
    else if (ieee_is_nan (a) .or. ieee_is_nan (b) .or. ieee_is_nan (diff)) then
       r = .false.
       return
    end if
    abs_small = tiny_13; if (present (abs_smallness)) abs_small = abs_smallness
    rel_small = tiny_10; if (present (rel_smallness)) rel_small = rel_smallness
    if (abs_a < abs_small .and. abs_b < abs_small) then
       r = diff < abs_small
    else
       r = diff / max (abs_a, abs_b) < rel_small
    end if
  end function nearly_equal_real

@ %def nearly_equal_real
<<Numeric utils: sub interfaces>>=
    elemental module function nearly_equal_complex &
         (a, b, abs_smallness, rel_smallness) result (r)
      logical :: r
      complex(default), intent(in) :: a, b
      real(default), intent(in), optional :: abs_smallness, rel_smallness
    end function nearly_equal_complex
<<Numeric utils: procedures>>=
  elemental module function nearly_equal_complex &
       (a, b, abs_smallness, rel_smallness) result (r)
    logical :: r
    complex(default), intent(in) :: a, b
    real(default), intent(in), optional :: abs_smallness, rel_smallness
    r = nearly_equal_real (real (a), real (b), abs_smallness, rel_smallness) .and. &
        nearly_equal_real (aimag (a), aimag(b), abs_smallness, rel_smallness)
  end function nearly_equal_complex

@ %def neary_equal_complex
@ Often we will need to check whether floats vanish:
<<Numeric utils: public>>=
  public:: vanishes
  interface vanishes
     module procedure vanishes_real, vanishes_complex
  end interface
@
<<Numeric utils: sub interfaces>>=
    elemental module function vanishes_real &
         (x, abs_smallness, rel_smallness) result (r)
      logical :: r
      real(default), intent(in) :: x
      real(default), intent(in), optional :: abs_smallness, rel_smallness
    end function vanishes_real
    elemental module function vanishes_complex &
         (x, abs_smallness, rel_smallness) result (r)
      logical :: r
      complex(default), intent(in) :: x
      real(default), intent(in), optional :: abs_smallness, rel_smallness
    end function vanishes_complex
<<Numeric utils: procedures>>=
  elemental module function vanishes_real &
       (x, abs_smallness, rel_smallness) result (r)
    logical :: r
    real(default), intent(in) :: x
    real(default), intent(in), optional :: abs_smallness, rel_smallness
    r = nearly_equal (x, zero, abs_smallness, rel_smallness)
  end function vanishes_real

  elemental module function vanishes_complex &
       (x, abs_smallness, rel_smallness) result (r)
    logical :: r
    complex(default), intent(in) :: x
    real(default), intent(in), optional :: abs_smallness, rel_smallness
    r = vanishes_real (abs (x), abs_smallness, rel_smallness)
  end function vanishes_complex

@ %def vanishes
@
<<Numeric utils: public>>=
  public :: expanded_amp2
<<Numeric utils: sub interfaces>>=
    pure module function expanded_amp2 (amp_tree, amp_blob) result (amp2)
      real(default) :: amp2
      complex(default), dimension(:), intent(in) :: amp_tree, amp_blob
    end function expanded_amp2
<<Numeric utils: procedures>>=
  pure module function expanded_amp2 (amp_tree, amp_blob) result (amp2)
    real(default) :: amp2
    complex(default), dimension(:), intent(in) :: amp_tree, amp_blob
    amp2 = sum (amp_tree * conjg (amp_tree) + &
                amp_tree * conjg (amp_blob) + &
                amp_blob * conjg (amp_tree))
  end function expanded_amp2

@ %def expanded_amp2
@
<<Numeric utils: public>>=
  public :: abs2
<<Numeric utils: sub interfaces>>=
    elemental module function abs2 (c) result (c2)
      real(default) :: c2
      complex(default), intent(in) :: c
    end function abs2
<<Numeric utils: procedures>>=
  elemental module function abs2 (c) result (c2)
    real(default) :: c2
    complex(default), intent(in) :: c
    c2 = real (c * conjg(c))
  end function abs2

@ %def abs2
@ Remove element with [[index]] from array
<<Numeric utils: public>>=
  public:: remove_array_element
  interface remove_array_element
     module procedure remove_array_element_logical
  end interface
@
<<Numeric utils: sub interfaces>>=
    module function remove_array_element_logical &
         (array, index) result (array_reduced)
      logical, intent(in), dimension(:) :: array
      integer, intent(in) :: index
      logical, dimension(:), allocatable :: array_reduced
    end function remove_array_element_logical
<<Numeric utils: procedures>>=
  module function remove_array_element_logical &
       (array, index) result (array_reduced)
    logical, intent(in), dimension(:) :: array
    integer, intent(in) :: index
    logical, dimension(:), allocatable :: array_reduced
    integer :: i
    allocate (array_reduced(0))
    do i = 1, size (array)
       if (i /= index) then
          array_reduced = [array_reduced, [array(i)]]
       end if
    end do
  end function remove_array_element_logical

@ %def remove_array_element
@ Remove all duplicates from an array of signed integers and returns an
unordered array of remaining elements.
This method does not really fit into this module. It could be part of a
larger module which deals with array manipulations.
<<Numeric utils: public>>=
  public :: remove_duplicates_from_int_array
<<Numeric utils: sub interfaces>>=
    module function remove_duplicates_from_int_array &
         (array) result (array_unique)
      integer, intent(in), dimension(:) :: array
      integer, dimension(:), allocatable :: array_unique
    end function remove_duplicates_from_int_array
<<Numeric utils: procedures>>=
  module function remove_duplicates_from_int_array &
       (array) result (array_unique)
    integer, intent(in), dimension(:) :: array
    integer, dimension(:), allocatable :: array_unique
    integer :: i
    allocate (array_unique(0))
    do i = 1, size (array)
       if (any (array_unique == array(i))) cycle
       array_unique = [array_unique, [array(i)]]
    end do
  end function remove_duplicates_from_int_array

@ %def remove_duplicates_from_int_array
@
<<Numeric utils: public>>=
  public :: extend_integer_array
<<Numeric utils: sub interfaces>>=
    module subroutine extend_integer_array (list, incr, initial_value)
      integer, intent(inout), dimension(:), allocatable :: list
      integer, intent(in) :: incr
      integer, intent(in), optional :: initial_value
    end subroutine extend_integer_array
<<Numeric utils: procedures>>=
  module subroutine extend_integer_array (list, incr, initial_value)
    integer, intent(inout), dimension(:), allocatable :: list
    integer, intent(in) :: incr
    integer, intent(in), optional :: initial_value
    integer, dimension(:), allocatable :: list_store
    integer :: n, ini
    ini = 0; if (present (initial_value)) ini = initial_value
    n = size (list)
    allocate (list_store (n))
    list_store = list
    deallocate (list)
    allocate (list (n+incr))
    list(1:n) = list_store
    list(1+n : n+incr) = ini
    deallocate (list_store)
  end subroutine extend_integer_array

@ %def extend_integer_array
@
<<Numeric utils: public>>=
  public :: crop_integer_array
<<Numeric utils: sub interfaces>>=
    module subroutine crop_integer_array (list, i_crop)
      integer, intent(inout), dimension(:), allocatable :: list
      integer, intent(in) :: i_crop
    end subroutine crop_integer_array
<<Numeric utils: procedures>>=
  module subroutine crop_integer_array (list, i_crop)
    integer, intent(inout), dimension(:), allocatable :: list
    integer, intent(in) :: i_crop
    integer, dimension(:), allocatable :: list_store
    allocate (list_store (i_crop))
    list_store = list(1:i_crop)
    deallocate (list)
    allocate (list (i_crop))
    list = list_store
    deallocate (list_store)
  end subroutine crop_integer_array

@ %def crop_integer_array
@ We also need an evaluation of $\log x$ which is stable near $x=1$.
<<Numeric utils: public>>=
  public :: log_prec
<<Numeric utils: sub interfaces>>=
    module function log_prec (x, xb) result (lx)
      real(default), intent(in) :: x, xb
      real(default) :: lx
    end function log_prec
<<Numeric utils: procedures>>=
  module function log_prec (x, xb) result (lx)
    real(default), intent(in) :: x, xb
    real(default) :: a1, a2, a3, lx
    a1 = xb
    a2 = a1 * xb / two
    a3 = a2 * xb * two / three
    if (abs (a3) < epsilon (a3)) then
       lx = - a1 - a2 - a3
    else
       lx = log (x)
    end if
  end function log_prec
  
@ %def log_prec
@
<<Numeric utils: public>>=
  public :: split_array
<<Numeric utils: interfaces>>=
  interface split_array
     module procedure split_integer_array
     module procedure split_real_array
  end interface
<<Numeric utils: sub interfaces>>=
    module subroutine split_integer_array (list1, list2)
      integer, intent(inout), dimension(:), allocatable :: list1, list2
      integer, dimension(:), allocatable :: list_store
    end subroutine split_integer_array
    module subroutine split_real_array (list1, list2)
      real(default), intent(inout), dimension(:), allocatable :: list1, list2
      real(default), dimension(:), allocatable :: list_store
    end subroutine split_real_array
<<Numeric utils: procedures>>=
  module subroutine split_integer_array (list1, list2)
    integer, intent(inout), dimension(:), allocatable :: list1, list2
    integer, dimension(:), allocatable :: list_store
    allocate (list_store (size (list1) - size (list2)))
    list2 = list1(:size (list2))
    list_store = list1 (size (list2) + 1:)
    deallocate (list1)
    allocate (list1 (size (list_store)))
    list1 = list_store
    deallocate (list_store)
  end subroutine split_integer_array

  module subroutine split_real_array (list1, list2)
    real(default), intent(inout), dimension(:), allocatable :: list1, list2
    real(default), dimension(:), allocatable :: list_store
    allocate (list_store (size (list1) - size (list2)))
    list2 = list1(:size (list2))
    list_store = list1 (size (list2) + 1:)
    deallocate (list1)
    allocate (list1 (size (list_store)))
    list1 = list_store
    deallocate (list_store)
  end subroutine split_real_array

@ %def split_array
@
\subsection{Integration routines}
Gauss integration using the 41-point Gauss-Kronrod rule. 
<<Numeric utils: interfaces>>=
  abstract interface
     function g_func (x) result (f)
       import default
       real(default), intent(in) :: x
       real(default) :: f
     end function g_func
  end interface
@ %def g_func
@
<<Numeric utils: public>>=
  public :: d1mach
<<Numeric utils: sub interfaces>>=
    module function d1mach (i) result (d1)
      integer, intent(in) :: i
      real(default) :: d1
    end function d1mach
<<Numeric utils: procedures>>=
  module function d1mach (i) result (d1)
    integer, intent(in) :: i
    real(default) :: b, x
    real(default) :: d1
    !***begin prologue  d1mach
    !***purpose  return floating point machine dependent constants.
    !***library   slatec
    !***category  r1
    !***type      single precision (d1mach-s, d1mach-d)
    !***keywords  machine constants
    !***author  fox, p. a., (bell labs)
    !           hall, a. d., (bell labs)
    !           schryer, n. l., (bell labs)
    !***description
    !
    !   d1mach can be used to obtain machine-dependent parameters for the
    !   local machine environment.  it is a function subprogram with one
    !   (input) argument, and can be referenced as follows:
    !
    !        a = d1mach(i)
    !
    !   where i=1,...,5.  the (output) value of a above is determined by
    !   the (input) value of i.  the results for various values of i are
    !   discussed below.
    !
    !   d1mach(1) = b**(emin-1), the smallest positive magnitude.
    !   d1mach(2) = b**emax*(1 - b**(-t)), the largest magnitude.
    !   d1mach(3) = b**(-t), the smallest relative spacing.
    !   d1mach(4) = b**(1-t), the largest relative spacing.
    !   d1mach(5) = log10(b)
    !
    !   assume single precision numbers are represented in the t-digit,
    !   base-b form
    !
    !              sign (b**e)*( (x(1)/b) + ... + (x(t)/b**t) )
    !
    !   where 0 .le. x(i) .lt. b for i=1,...,t, 0 .lt. x(1), and
    !   emin .le. e .le. emax.
    !
    !   the values of b, t, emin and emax are provided in i1mach as
    !   follows:
    !   i1mach(10) = b, the base.
    !   i1mach(11) = t, the number of base-b digits.
    !   i1mach(12) = emin, the smallest exponent e.
    !   i1mach(13) = emax, the largest exponent e.
    !
    !
    !***references  p. a. fox, a. d. hall and n. l. schryer, framework for
    !                 a portable library, acm transactions on mathematical
    !                 software 4, 2 (june 1978), pp. 177-188.
    !***routines called  xemsgr
    !***revision history  (yymmdd)
    !   790101  date written
    !   960329  modified for fortran 90 (be after suggestions by ehg)
    !***end prologue  d1mach
    !
    x = 1.0_default
    b = radix(x)
    select case (i)
    case (1)
       d1 = b**(minexponent(x)-1) ! the smallest positive magnitude.
    case (2)
       d1 = huge(X)               ! the largest magnitude.
    case (3)
       d1 = b**(-digits(x))       ! the smallest relative spacing.
    case (4)
       d1 = b**(1-digits(x))      ! the largest relative spacing.
    case (5)
       d1 = log10(b)
    case default
       d1 = b**(minexponent(x)-1)
    end select
  end function d1mach

@ %def d1mach
@
<<Numeric utils: public>>=
  public :: dqk41
<<Numeric utils: sub interfaces>>=
    module subroutine dqk41 (f, a, b, result, abserr, resabs, resasc)
      procedure(g_func) :: f
      real(default), intent(in) :: a, b
      real(default), intent(out) :: result, abserr, resabs, resasc
    end subroutine dqk41
<<Numeric utils: procedures>>=
  module subroutine dqk41 (f, a, b, result, abserr, resabs, resasc)
    !c***begin prologue  dqk41
    !c***date written   800101   (yymmdd)
    !c***revision date  830518   (yymmdd)
    !c***category no.  h2a1a2
    !c***keywords  41-point gauss-kronrod rules
    !c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
    !c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
    !c***purpose  to compute i = integral of f over (a,b), with error
    !c                           estimate
    !c                       j = integral of abs(f) over (a,b)
    !c***description
    !c
    !c           integration rules
    !c           standard fortran subroutine
    !c           double precision version
    !c
    !c           parameters
    !c            on entry
    !c              f      - double precision
    !c                       function subprogram defining the integrand
    !c                       function f(x). the actual name for f needs to be
    !c                       declared e x t e r n a l in the calling program.
    !c
    !c              a      - double precision
    !c                       lower limit of integration
    !c
    !c              b      - double precision
    !c                       upper limit of integration
    !c
    !c            on return
    !c              result - double precision
    !c                       approximation to the integral i
    !c                       result is computed by applying the 41-point
    !c                       gauss-kronrod rule (resk) obtained by optimal
    !c                       addition of abscissae to the 20-point gauss
    !c                       rule (resg).
    !c
    !c              abserr - double precision
    !c                       estimate of the modulus of the absolute error,
    !c                       which should not exceed abs(i-result)
    !c
    !c              resabs - double precision
    !c                       approximation to the integral j
    !c
    !c              resasc - double precision
    !c                       approximation to the integal of abs(f-i/(b-a))
    !c                       over (a,b)
    !c
    !c***references  (none)
    !c***routines called  d1mach
    !c***end prologue  dqk41
    procedure(g_func) :: f
    real(default), intent(in) :: a, b
    real(default), intent(out) :: result, abserr, resabs, resasc
    real(default) :: absc, centr, dhlgth, dmax1, dmin1, &
         epmach, fc, fsum, fval1, fval2, hlgth, &
         resg, resk, reskh, uflow
    real(default), dimension(20) :: fv1, fv2
    real(default), dimension(21) :: xgk, wgk
    real(default), dimension(10) :: wg
    integer :: j, jtw, jtwm1
    !           the abscissae and weights are given for the interval (-1,1).
    !           because of symmetry only the positive abscissae and their
    !           corresponding weights are given.
    !
    !           xgk    - abscissae of the 41-point gauss-kronrod rule
    !                    xgk(2), xgk(4), ...  abscissae of the 20-point
    !                    gauss rule
    !                    xgk(1), xgk(3), ...  abscissae which are optimally
    !                    added to the 20-point gauss rule
    !
    !           wgk    - weights of the 41-point gauss-kronrod rule
    !
    !           wg     - weights of the 20-point gauss rule
    !
    !
    ! gauss quadrature weights and kronron quadrature abscissae and weights
    ! as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
    ! bell labs, nov. 1981.
    !
    data wg  (  1) / 0.017614007139152118311861962351853_default /
    data wg  (  2) / 0.040601429800386941331039952274932_default /
    data wg  (  3) / 0.062672048334109063569506535187042_default /
    data wg  (  4) / 0.083276741576704748724758143222046_default /
    data wg  (  5) / 0.101930119817240435036750135480350_default /
    data wg  (  6) / 0.118194531961518417312377377711382_default /
    data wg  (  7) / 0.131688638449176626898494499748163_default /
    data wg  (  8) / 0.142096109318382051329298325067165_default /
    data wg  (  9) / 0.149172986472603746787828737001969_default /
    data wg  ( 10) / 0.152753387130725850698084331955098_default /

    data xgk (  1) / 0.998859031588277663838315576545863_default /
    data xgk (  2) / 0.993128599185094924786122388471320_default /
    data xgk (  3) / 0.981507877450250259193342994720217_default /
    data xgk (  4) / 0.963971927277913791267666131197277_default /
    data xgk (  5) / 0.940822633831754753519982722212443_default /
    data xgk (  6) / 0.912234428251325905867752441203298_default /
    data xgk (  7) / 0.878276811252281976077442995113078_default /
    data xgk (  8) / 0.839116971822218823394529061701521_default /
    data xgk (  9) / 0.795041428837551198350638833272788_default /
    data xgk ( 10) / 0.746331906460150792614305070355642_default /
    data xgk ( 11) / 0.693237656334751384805490711845932_default /
    data xgk ( 12) / 0.636053680726515025452836696226286_default /
    data xgk ( 13) / 0.575140446819710315342946036586425_default /
    data xgk ( 14) / 0.510867001950827098004364050955251_default /
    data xgk ( 15) / 0.443593175238725103199992213492640_default /
    data xgk ( 16) / 0.373706088715419560672548177024927_default /
    data xgk ( 17) / 0.301627868114913004320555356858592_default /
    data xgk ( 18) / 0.227785851141645078080496195368575_default /
    data xgk ( 19) / 0.152605465240922675505220241022678_default /
    data xgk ( 20) / 0.076526521133497333754640409398838_default /
    data xgk ( 21) / 0.000000000000000000000000000000000_default /

    data wgk (  1) / 0.003073583718520531501218293246031_default /
    data wgk (  2) / 0.008600269855642942198661787950102_default /
    data wgk (  3) / 0.014626169256971252983787960308868_default /
    data wgk (  4) / 0.020388373461266523598010231432755_default /
    data wgk (  5) / 0.025882133604951158834505067096153_default /
    data wgk (  6) / 0.031287306777032798958543119323801_default /
    data wgk (  7) / 0.036600169758200798030557240707211_default /
    data wgk (  8) / 0.041668873327973686263788305936895_default /
    data wgk (  9) / 0.046434821867497674720231880926108_default /
    data wgk ( 10) / 0.050944573923728691932707670050345_default /
    data wgk ( 11) / 0.055195105348285994744832372419777_default /
    data wgk ( 12) / 0.059111400880639572374967220648594_default /
    data wgk ( 13) / 0.062653237554781168025870122174255_default /
    data wgk ( 14) / 0.065834597133618422111563556969398_default /
    data wgk ( 15) / 0.068648672928521619345623411885368_default /
    data wgk ( 16) / 0.071054423553444068305790361723210_default /
    data wgk ( 17) / 0.073030690332786667495189417658913_default /
    data wgk ( 18) / 0.074582875400499188986581418362488_default /
    data wgk ( 19) / 0.075704497684556674659542775376617_default /
    data wgk ( 20) / 0.076377867672080736705502835038061_default /
    data wgk ( 21) / 0.076600711917999656445049901530102_default /
    !
    !
    !           list of major variables
    !           -----------------------
    !
    !           centr  - mid point of the interval
    !           hlgth  - half-length of the interval
    !           absc   - abscissa
    !           fval*  - function value
    !           resg   - result of the 20-point gauss formula
    !           resk   - result of the 41-point kronrod formula
    !           reskh  - approximation to mean value of f over (a,b), i.e.
    !                    to i/(b-a)
    !
    !           machine dependent constants
    !           ---------------------------
    !
    !           epmach is the largest relative spacing.
    !           uflow is the smallest positive magnitude.
    !
    !***first executable statement  dqk41
    epmach = d1mach(4)
    uflow = d1mach(1)

    centr = 0.5d+00*(a+b)
    hlgth = 0.5d+00*(b-a)
    dhlgth = abs(hlgth)
    !
    ! compute the 41-point gauss-kronrod approximation to
    ! the integral, and estimate the absolute error.
    !
    resg = 0.0d+00
    fc = f(centr)
    resk = wgk(21)*fc
    resabs = abs(resk)
    do j = 1, 10
       jtw = j*2
       absc = hlgth*xgk(jtw)
       fval1 = f(centr-absc)
       fval2 = f(centr+absc)
       fv1(jtw) = fval1
       fv2(jtw) = fval2
       fsum = fval1+fval2
       resg = resg+wg(j)*fsum
       resk = resk+wgk(jtw)*fsum
       resabs = resabs+wgk(jtw)*(abs(fval1)+abs(fval2))
    end do
    do j = 1,10
       jtwm1 = j*2-1
       absc = hlgth*xgk(jtwm1)
       fval1 = f(centr-absc)
       fval2 = f(centr+absc)
       fv1(jtwm1) = fval1
       fv2(jtwm1) = fval2
       fsum = fval1+fval2
       resk = resk+wgk(jtwm1)*fsum
       resabs = resabs+wgk(jtwm1)*(abs(fval1)+abs(fval2))
     end do
     reskh = resk*0.5d+00
     resasc = wgk(21)*abs(fc-reskh)
     do j = 1, 20
        resasc = resasc+wgk(j)*(abs(fv1(j)-reskh)+abs(fv2(j)-reskh))
     end do
     result = resk*hlgth
     resabs = resabs*dhlgth
     resasc = resasc*dhlgth
     abserr = abs((resk-resg)*hlgth)
     if (resasc.ne.0.0d+00.and.abserr.ne.0.d+00) &
          abserr = resasc*dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
     if (resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1 &
          ((epmach*0.5d+02)*resabs,abserr)
   end subroutine dqk41

@ %def dqk41
@
<<Numeric utils: public>>=
  public :: dqk61
<<Numeric utils: sub interfaces>>=
    module subroutine dqk61 (f, a, b, result, abserr, resabs, resasc)
      procedure(g_func) :: f
      real(default), intent(in) :: a, b
      real(default), intent(out) :: result, abserr, resabs, resasc
    end subroutine dqk61
<<Numeric utils: procedures>>=
  module subroutine dqk61 (f, a, b, result, abserr, resabs, resasc)
    !c***begin prologue  dqk61
    !c***purpose  to compute i = integral of f over (a,b) with error
    !c                           estimate
    !c                       j = integral of abs(f) over (a,b)
    !c***library   slatec (quadpack)
    !c***category  h2a1a2
    !c***type      double precision (qk61-s, dqk61-d)
    !c***keywords  61-point gauss-kronrod rules, quadpack, quadrature
    !c***author  piessens, robert
    !c             applied mathematics and programming division
    !c             k. u. leuven
    !c           de doncker, elise
    !c             applied mathematics and programming division
    !c             k. u. leuven
    !c***description
    !c
    !c        integration rule
    !c        standard fortran subroutine
    !c        double precision version
    !c
    !c
    !c        parameters
    !c         on entry
    !c           f      - double precision
    !c                    function subprogram defining the integrand
    !c                    function f(x). the actual name for f needs to be
    !c                    declared e x t e r n a l in the calling program.
    !c
    !c           a      - double precision
    !c                    lower limit of integration
    !c
    !c           b      - double precision
    !c                    upper limit of integration
    !c
    !c         on return
    !c           result - double precision
    !c                    approximation to the integral i
    !c                    result is computed by applying the 61-point
    !c                    kronrod rule (resk) obtained by optimal addition of
    !c                    abscissae to the 30-point gauss rule (resg).
    !c
    !c           abserr - double precision
    !c                    estimate of the modulus of the absolute error,
    !c                    which should equal or exceed abs(i-result)
    !c
    !c           resabs - double precision
    !c                    approximation to the integral j
    !c
    !c           resasc - double precision
    !c                    approximation to the integral of abs(f-i/(b-a))
    !c
    !c***references  (none)
    !c***routines called  d1mach
    !c***revision history  (yymmdd)
    !c   800101  date written
    !c   890531  changed all specific intrinsics to generic.  (wrb)
    !c   890531  revision date from version 3.2
    !c   891214  prologue converted to version 4.0 format.  (bab)
    !c***end prologue  dqk61
    !c
    procedure(g_func) :: f
    real(default), intent(in) :: a, b
    real(default), intent(out) :: result, abserr, resabs, resasc
    real(default) ::  absc, centr, dhlgth, &
         epmach, fc, fsum, fval1, fval2, hlgth, &
         resg, resk, reskh, uflow
    real(default), dimension(30) :: fv1, fv2
    real(default), dimension(31) :: xgk, wgk
    real(default), dimension(15) :: wg
    integer :: j, jtw, jtwm1
    !
    !           the abscissae and weights are given for the
    !           interval (-1,1). because of symmetry only the positive
    !           abscissae and their corresponding weights are given.
    !
    !           xgk   - abscissae of the 61-point kronrod rule
    !                   xgk(2), xgk(4)  ... abscissae of the 30-point
    !                   gauss rule
    !                   xgk(1), xgk(3)  ... optimally added abscissae
    !                   to the 30-point gauss rule
    !
    !           wgk   - weights of the 61-point kronrod rule
    !
    !           wg    - weights of the 30-point gauss rule
    !
    !
    ! gauss quadrature weights and kronrod quadrature abscissae and weights
    ! as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
    ! bell labs, nov. 1981.
    !
    data wg  (  1) / 0.007968192496166605615465883474674_default /
    data wg  (  2) / 0.018466468311090959142302131912047_default /
    data wg  (  3) / 0.028784707883323369349719179611292_default /
    data wg  (  4) / 0.038799192569627049596801936446348_default /
    data wg  (  5) / 0.048402672830594052902938140422808_default /
    data wg  (  6) / 0.057493156217619066481721689402056_default /
    data wg  (  7) / 0.065974229882180495128128515115962_default /
    data wg  (  8) / 0.073755974737705206268243850022191_default /
    data wg  (  9) / 0.080755895229420215354694938460530_default /
    data wg  ( 10) / 0.086899787201082979802387530715126_default /
    data wg  ( 11) / 0.092122522237786128717632707087619_default /
    data wg  ( 12) / 0.096368737174644259639468626351810_default /
    data wg  ( 13) / 0.099593420586795267062780282103569_default /
    data wg  ( 14) / 0.101762389748405504596428952168554_default /
    data wg  ( 15) / 0.102852652893558840341285636705415_default /

    data xgk (  1) / 0.999484410050490637571325895705811_default /
    data xgk (  2) / 0.996893484074649540271630050918695_default /
    data xgk (  3) / 0.991630996870404594858628366109486_default /
    data xgk (  4) / 0.983668123279747209970032581605663_default /
    data xgk (  5) / 0.973116322501126268374693868423707_default /
    data xgk (  6) / 0.960021864968307512216871025581798_default /
    data xgk (  7) / 0.944374444748559979415831324037439_default /
    data xgk (  8) / 0.926200047429274325879324277080474_default /
    data xgk (  9) / 0.905573307699907798546522558925958_default /
    data xgk ( 10) / 0.882560535792052681543116462530226_default /
    data xgk ( 11) / 0.857205233546061098958658510658944_default /
    data xgk ( 12) / 0.829565762382768397442898119732502_default /
    data xgk ( 13) / 0.799727835821839083013668942322683_default /
    data xgk ( 14) / 0.767777432104826194917977340974503_default /
    data xgk ( 15) / 0.733790062453226804726171131369528_default /
    data xgk ( 16) / 0.697850494793315796932292388026640_default /
    data xgk ( 17) / 0.660061064126626961370053668149271_default /
    data xgk ( 18) / 0.620526182989242861140477556431189_default /
    data xgk ( 19) / 0.579345235826361691756024932172540_default /
    data xgk ( 20) / 0.536624148142019899264169793311073_default /
    data xgk ( 21) / 0.492480467861778574993693061207709_default /
    data xgk ( 22) / 0.447033769538089176780609900322854_default /
    data xgk ( 23) / 0.400401254830394392535476211542661_default /
    data xgk ( 24) / 0.352704725530878113471037207089374_default /
    data xgk ( 25) / 0.304073202273625077372677107199257_default /
    data xgk ( 26) / 0.254636926167889846439805129817805_default /
    data xgk ( 27) / 0.204525116682309891438957671002025_default /
    data xgk ( 28) / 0.153869913608583546963794672743256_default /
    data xgk ( 29) / 0.102806937966737030147096751318001_default /
    data xgk ( 30) / 0.051471842555317695833025213166723_default /
    data xgk ( 31) / 0.000000000000000000000000000000000_default /
    
    data wgk (  1) / 0.001389013698677007624551591226760_default /
    data wgk (  2) / 0.003890461127099884051267201844516_default /
    data wgk (  3) / 0.006630703915931292173319826369750_default /
    data wgk (  4) / 0.009273279659517763428441146892024_default /
    data wgk (  5) / 0.011823015253496341742232898853251_default /
    data wgk (  6) / 0.014369729507045804812451432443580_default /
    data wgk (  7) / 0.016920889189053272627572289420322_default /
    data wgk (  8) / 0.019414141193942381173408951050128_default /
    data wgk (  9) / 0.021828035821609192297167485738339_default /
    data wgk ( 10) / 0.024191162078080601365686370725232_default /
    data wgk ( 11) / 0.026509954882333101610601709335075_default /
    data wgk ( 12) / 0.028754048765041292843978785354334_default /
    data wgk ( 13) / 0.030907257562387762472884252943092_default /
    data wgk ( 14) / 0.032981447057483726031814191016854_default /
    data wgk ( 15) / 0.034979338028060024137499670731468_default /
    data wgk ( 16) / 0.036882364651821229223911065617136_default /
    data wgk ( 17) / 0.038678945624727592950348651532281_default /
    data wgk ( 18) / 0.040374538951535959111995279752468_default /
    data wgk ( 19) / 0.041969810215164246147147541285970_default /
    data wgk ( 20) / 0.043452539701356069316831728117073_default /
    data wgk ( 21) / 0.044814800133162663192355551616723_default /
    data wgk ( 22) / 0.046059238271006988116271735559374_default /
    data wgk ( 23) / 0.047185546569299153945261478181099_default /
    data wgk ( 24) / 0.048185861757087129140779492298305_default /
    data wgk ( 25) / 0.049055434555029778887528165367238_default /
    data wgk ( 26) / 0.049795683427074206357811569379942_default /
    data wgk ( 27) / 0.050405921402782346840893085653585_default /
    data wgk ( 28) / 0.050881795898749606492297473049805_default /
    data wgk ( 29) / 0.051221547849258772170656282604944_default /
    data wgk ( 30) / 0.051426128537459025933862879215781_default /
    data wgk ( 31) / 0.051494729429451567558340433647099_default /
    !
    !           list of major variables
    !           -----------------------
    !
    !           centr  - mid point of the interval
    !           hlgth  - half-length of the interval
    !           absc  - abscissa
    !           fval*  - function value
    !           resg   - result of the 30-point gauss rule
    !           resk   - result of the 61-point kronrod rule
    !           reskh  - approximation to the mean value of f
    !                    over (a,b), i.e. to i/(b-a)
    !
    !           machine dependent constants
    !           ---------------------------
    !
    !           epmach is the largest relative spacing.
    !           uflow is the smallest positive magnitude.
    !
    !***first executable statement  dqk61
    epmach = d1mach(4)
    uflow = d1mach(1)

    centr = 0.5d+00*(b+a)
    hlgth = 0.5d+00*(b-a)
    dhlgth = abs(hlgth)
    !
    ! compute the 61-point kronrod approximation to the
    ! integral, and estimate the absolute error.
    !
    resg = 0.0d+00
    fc = f(centr)
    resk = wgk(31)*fc
    resabs = abs(resk)
    do j = 1, 15
       jtw = j*2
       absc = hlgth*xgk(jtw)
       fval1 = f(centr-absc)
       fval2 = f(centr+absc)
       fv1(jtw) = fval1
       fv2(jtw) = fval2
       fsum = fval1+fval2
       resg = resg+wg(j)*fsum
       resk = resk+wgk(jtw)*fsum
       resabs = resabs+wgk(jtw)*(abs(fval1)+abs(fval2))
    end do
    do j = 1, 15
       jtwm1 = j*2-1
       absc = hlgth*xgk(jtwm1)
       fval1 = f(centr-absc)
       fval2 = f(centr+absc)
       fv1(jtwm1) = fval1
       fv2(jtwm1) = fval2
       fsum = fval1+fval2
       resk = resk+wgk(jtwm1)*fsum
       resabs = resabs+wgk(jtwm1)*(abs(fval1)+abs(fval2))
     end do
     reskh = resk*0.5d+00
     resasc = wgk(31)*abs(fc-reskh)
     do j = 1, 30
        RESASC = RESASC+WGK(J)*(ABS(FV1(J)-RESKH)+ABS(FV2(J)-RESKH))
     end do
     result = resk*hlgth
     resabs = resabs*dhlgth
     resasc = resasc*dhlgth
     abserr = abs((resk-resg)*hlgth)
     if (resasc.ne.0.0d+00.and.abserr.ne.0.0d+00) &
          abserr = resasc*min(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
     if (resabs.gt.uflow/(0.5d+02*epmach)) abserr = max &
          ((epmach*0.5d+02)*resabs,abserr)
   end subroutine dqk61

@ %def dqk61
@
<<Numeric utils: parameters>>=
  integer, parameter, public :: GAUSS_KRONROD_41 = 41, GAUSS_KRONROD_61 = 61
<<Numeric utils: public>>=
  public :: gauss_kronrod
<<Numeric utils: sub interfaces>>=
   module subroutine gauss_kronrod &
        (type, f, a, b, limit, result, abserr, epsabs, epsrel)
     integer, intent(in) :: type
     procedure(g_func) :: f
     real(default), intent(in) :: a, b
     real(default), intent(in) :: epsabs, epsrel
     real(default), intent(out) :: result, abserr
     integer, intent(in) :: limit
   end subroutine gauss_kronrod
<<Numeric utils: procedures>>=
  module subroutine gauss_kronrod &
       (type, f, a, b, limit, result, abserr, epsabs, epsrel)
    integer, intent(in) :: type
    procedure(g_func) :: f
    real(default), intent(in) :: a, b
    real(default), intent(in) :: epsabs, epsrel
    real(default), intent(out) :: result, abserr
    integer, intent(in) :: limit
    real(default) :: area, errsum
    real(default) :: tolerance_g, round_off
    real(default) :: result0, abserr0, resabs0, resasc0
    type(int_workspace_t) :: work
    real(default) :: a1, b1, a2, b2, a_i, b_i, r_i, e_i
    real(default) :: area1, area2, area12, error1, error2, error12
    real(default) :: resasc1, resasc2, resabs1, resabs2, delta
    integer :: i, iteration
    integer :: roundoff_type1, roundoff_type2
    !!! epsilon(dbl)
    real(default), parameter :: dbl_prec = 2.2204460492503131e-16_default
    !!! tiny(dbl)
    real(default), parameter :: dbl_min = 2.2250738585072014e-308_default
    iteration = 0
    if (epsabs <= 0) then
       if (epsrel < 50 * dbl_prec .or. epsrel < 0.5e-28_default) then
          error stop ("Gauss_Kronrod: tolerance cannot be achieved with given " &
               // "epsabs and epsrel")
       end if
    end if
    call work%init (a, b, limit)
    ! Perform the first integration
    select case (type)
    case (GAUSS_KRONROD_61)
       call dqk61 (f, a, b, result0, abserr0, resabs0, resasc0)
    case default
       call dqk41 (f, a, b, result0, abserr0, resabs0, resasc0)
    end select
    call work%set_initial (result0, abserr0)
    ! Test on accuracy
    tolerance_g = max (epsabs, epsrel * abs(result0))
    round_off = 50 * dbl_prec * resabs0
    if (abserr0 <= round_off .and. abserr0 > tolerance_g) then
       result = result0
       abserr = abserr0
       error stop ("Gauss_Kronrod: cannot reach tolerance because of roundoff " &
            // "error on first attempt")
    else if ((abserr0 <= tolerance_g .and. abserr0 /= resasc0) .or. &
         abserr0 == 0.0_default) then
       result = result0
       abserr = abserr0
       return
    else if (limit == 1) then
       result = result0
       abserr = abserr0
       error stop ("Gauss_Kronrod: a maximum of one iteration was insufficient")
    end if
    area = result0
    errsum = abserr0
    roundoff_type1 = 0
    roundoff_type2 = 0
    ITERATION_LOOP: do iteration = 1, limit
       a_i = work%alist(work%i)
       b_i = work%blist(work%i)
       r_i = work%rlist(work%i)
       e_i = work%elist(work%i)
       a1 = a_i
       b1 = 0.5_default * (a_i + b_i)
       a2 = b1
       b2 = b_i
       select case (type)
       case (GAUSS_KRONROD_61)
          call dqk61 (f, a1, b1, area1, error1, resabs1, resasc1)
          call dqk61 (f, a2, b2, area2, error2, resabs2, resasc2)
       case default
          call dqk41 (f, a1, b1, area1, error1, resabs1, resasc1)
          call dqk41 (f, a2, b2, area2, error2, resabs2, resasc2)
       end select
       area12 = area1 + area2
       error12 = error1 + error2
       errsum = errsum + error12 - e_i
       area = area + area12 - r_i
       if (resasc1 /= error1 .and. resasc2 /= error2) then
          delta = r_i - area12
          if (abs(delta) <= 1.0e-5_default * abs (area12) .and. &
               error12 >= 0.99_default * e_i) then
             roundoff_type1 = roundoff_type1 + 1
          end if
          if (iteration >= 10 .and. error12 > e_i) then
             roundoff_type2 = roundoff_type2 + 1
          end if
       end if
       tolerance_g = max (epsabs, epsrel * abs(area))
       if (errsum > tolerance_g) then
          if (roundoff_type1 >= 6 .or. roundoff_type2 >= 20) &
               error stop ("Gauss_Kronrod: roundoff error prevents tolerance " &
               // "from being achieved")
          ! Set error flag in the case of bad integrand behavior at a
          ! point of the integration range
          if (subinterval_too_small (a1, a2, b2)) &
               error stop ("Gauss_Kronrod: bad integrand behavior found in " &
               // "integration interval")
       end if
       call work%update (a1, b1, area1, error1, a2, b2, area2, error2)
       if (errsum <= tolerance_g)  exit ITERATION_LOOP
    end do ITERATION_LOOP
    result = sum (work%rlist (1:work%size))
    abserr = errsum
    if (errsum > tolerance_g) &
       error stop ("Gauss_Kronrod: could not integrate function")
  contains
    function subinterval_too_small (a_1, a_2, b_2) result (flag)
      real(default), intent(in) :: a_1, a_2, b_2
      logical :: flag
      real(default) :: tmp
      tmp = (1._default + 100._default * dbl_prec) * (abs(a_2) + &
           1000._default * dbl_min)
      flag = abs(a_1) <= tmp .and. abs(b_2) <= tmp
    end function subinterval_too_small
  end subroutine gauss_kronrod

@ %def gauss_kronrod
@
\subsection{Suppression of numerical noise}
<<Numeric utils: public>>=
  public :: pacify
<<Numeric utils: interfaces>>=
  interface pacify
     module procedure pacify_real_default
     module procedure pacify_complex_default
  end interface pacify

<<Numeric utils: sub interfaces>>=
    elemental module subroutine pacify_real_default (x, tolerance)
      real(default), intent(inout) :: x
      real(default), intent(in) :: tolerance
    end subroutine pacify_real_default

    elemental module subroutine pacify_complex_default (x, tolerance)
      complex(default), intent(inout) :: x
      real(default), intent(in) :: tolerance
    end subroutine pacify_complex_default
<<Numeric utils: procedures>>=
  elemental module subroutine pacify_real_default (x, tolerance)
    real(default), intent(inout) :: x
    real(default), intent(in) :: tolerance
    if (abs (x) < tolerance)  x = 0._default
  end subroutine pacify_real_default

  elemental module subroutine pacify_complex_default (x, tolerance)
    complex(default), intent(inout) :: x
    real(default), intent(in) :: tolerance
    if (abs (real (x)) < tolerance)   &
         x = cmplx (0._default, aimag (x), kind=default)
    if (abs (aimag (x)) < tolerance)  &
         x = cmplx (real (x), 0._default, kind=default)
  end subroutine pacify_complex_default

@ %def pacify
@
<<[[numeric_utils_ut.f90]]>>=
<<File header>>

module numeric_utils_ut
  use unit_tests
  use numeric_utils_uti

<<Standard module head>>

<<Numeric utils: public test>>

 contains

<<Numeric utils: test driver>>

end module numeric_utils_ut
@ %def numeric_utils_ut
@
<<[[numeric_utils_uti.f90]]>>=
<<File header>>

module numeric_utils_uti

<<Use kinds>>
  use constants, only: one, PI
  use numeric_utils

<<Standard module head>>

<<Numeric utils: test declarations>>

 contains

<<Numeric utils: tests>>

end module numeric_utils_uti
@ %def numeric_utils_uti
@
<<Numeric utils: public test>>=
  public :: numeric_utils_test
<<Numeric utils: test driver>>=
  subroutine numeric_utils_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
    <<Numeric utils: execute tests>>
  end subroutine numeric_utils_test

@ %def numeric_utils_test
@ Provide testing for routines in the [[numeric_utils]] module.
<<Numeric utils: execute tests>>=
call test (numeric_utils_1, "numeric_utils_1", &
     "check interface and implementation", &
     u, results)
<<Numeric utils: test declarations>>=
  public :: numeric_utils_1
<<Numeric utils: tests>>=
  subroutine numeric_utils_1 (u)
    integer, intent(in) :: u
    real(default) :: int, intabs, err, errabs
    real(default) :: a, b, c
    a = 0._default
    b = 1._default
    c = Pi

    write (u, "(A)") "* Test output: Numeric utils"
    write (u, "(A)") "*   Purpose: test numeric routines"
    write (u, "(A)")

    write (u, "(A)") "*   41-point Gauss-Kronrod integration"
    write (u, "(A)")
    
    call dqk41 (f_x, a, b, int, intabs, err, errabs)
    write (u, "(1x,A,F9.6)")  " Integral (x,[0,1])       = ", &
         int
    call dqk41 (f_x2, a, b, int, intabs, err, errabs)
    write (u, "(1x,A,F9.6)")  " Integral (x**2,[0,1])    = ", &
         int
    call dqk41 (sinx, a, c, int, intabs, err, errabs)
    write (u, "(1x,A,F9.6)")  " Integral (sin(x),[0,Pi]) = ", &
         int

  contains

    function f_x (x) result (f)
      real(default), intent(in) :: x
      real(default) :: f
      f = x
    end function f_x
    function f_x2 (x) result (f)
      real(default), intent(in) :: x
      real(default) :: f
      f = x**2
    end function f_x2
    function sinx (x) result (f)
      real(default), intent(in) :: x
      real(default) :: f
      f = sin(x)
    end function sinx
  end subroutine numeric_utils_1

@ %def numeric_utils_1
@
<<Numeric utils: execute tests>>=
call test (numeric_utils_2, "numeric_utils_2", &
     "check adaptive integration", &
     u, results)
<<Numeric utils: test declarations>>=
  public :: numeric_utils_2
<<Numeric utils: tests>>=
  subroutine numeric_utils_2 (u)
    integer, intent(in) :: u
    real(default) :: result, abserr
    real(default), parameter :: epsabs = 0.001_default, &
         epsrel = 0.001_default
    real(default), parameter :: a = 0._default, b = 1._default, &
         z = 0.1_default
    integer, parameter :: limit = 10000

    write (u, "(A)") "* Test output: Numeric utils"
    write (u, "(A)") "*   Purpose: test adaptive Gauss-Kronrod 41"
    write (u, "(A)")

    write (u, "(A)") "*   41-point Gauss-Kronrod integration"
    write (u, "(A)")
    
    call gauss_kronrod (GAUSS_KRONROD_41, f1_x, a, b, limit, result, &
         abserr, epsabs, epsrel)
    write (u, "(1x,A,F9.6)")  " Integral (f1_x,[0,1])     = ", &
         result
    call gauss_kronrod (GAUSS_KRONROD_41, f2_x, a, b, limit, result, &
         abserr, epsabs, epsrel)
    write (u, "(1x,A,F9.6)")  " Integral (f2_x,[0,1])     = ", &
         result

  contains

    function f1_x (x) result (f)
      real(default), intent(in) :: x
      real(default) :: f
      f = log(one - z/(one + (-one + z)*x))
    end function f1_x
    function f2_x (x) result (f)
      real(default), intent(in) :: x
      real(default) :: f
      f = log(one - z/(z + x))
    end function f2_x
  end subroutine numeric_utils_2

@ %def numeric_utils_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Binary Tree}

<<[[binary_tree.f90]]>>=
<<File header>>
module binary_tree

<<Standard module head>>

<<Binary trees: public>>
  
<<Binary trees: types>>

  interface
<<Binary trees: sub interfaces>>
  end interface

contains

<<Binary trees: module procedures>>
  
end module binary_tree
@ %def binary_tree
@
<<[[binary_tree_sub.f90]]>>=
<<File header>>

submodule (binary_tree) binary_tree_s

  use io_units

  implicit none

contains

<<Binary trees: procedures>>

end submodule binary_tree_s

@ %def binary_tree_s
@
<<Binary trees: public>>=
  public :: binary_tree_iterator_t 
<<Binary trees: types>>=
  type :: binary_tree_iterator_t
     integer, dimension(:), allocatable :: key
     integer :: current
     !! current \in {1, N}.
   contains
   <<Binary trees: iterator: TBP>>
  end type binary_tree_iterator_t

@ %def binary_tree_iterator_t
@ 
<<Binary trees: types>>=
  type :: binary_tree_node_t
     integer :: height = 0
     type(binary_tree_node_t), pointer :: left => null ()
     type(binary_tree_node_t), pointer :: right => null ()
     !!
     integer :: key = 0
     class(*), pointer :: obj => null ()
   contains
   <<Binary trees: node: TBP>>
  end type binary_tree_node_t

@ %def binary_tree_node_t
@
<<Binary trees: public>>=
  public :: binary_tree_t
<<Binary trees: types>>=
  type :: binary_tree_t
     integer :: n_elements = 0
     type(binary_tree_node_t), pointer :: root => null ()
   contains
   <<Binary trees: tree: TBP>>
  end type binary_tree_t

@ %def binary_tree_t
@
<<Binary trees: iterator: TBP>>=
  procedure :: init => binary_tree_iterator_init
<<Binary trees: sub interfaces>>=
    module subroutine binary_tree_iterator_init (iterator, btree)
      class(binary_tree_iterator_t), intent(inout) :: iterator
      type(binary_tree_t), target :: btree
    end subroutine binary_tree_iterator_init
<<Binary trees: procedures>>=
  !! We store all keys of the binary tree in an index array.
  !! Flatten the tree O(log n), each access is then O(1).
  !! However, accessing the corresponding object costs one O(log n).
  module subroutine binary_tree_iterator_init (iterator, btree)
    class(binary_tree_iterator_t), intent(inout) :: iterator
    type(binary_tree_t), target :: btree
    type(binary_tree_node_t), pointer :: node
    integer :: idx
    iterator%current = 1
    allocate (iterator%key(btree%get_n_elements ()), source = 0)
    if (.not. btree%get_n_elements () > 0) return
    idx = 1; call fill_key (idx, iterator%key, btree%root)
  contains
    recursive subroutine fill_key (idx, key, node)
      integer, intent(inout) :: idx
      integer, dimension(:), intent(inout) :: key
      type(binary_tree_node_t), pointer :: node
      if (associated (node%left)) &
           call fill_key (idx, key, node%left)
      key(idx) = node%key
      idx = idx + 1
      if (associated (node%right)) &
           call fill_key (idx, key, node%right)
    end subroutine fill_key
  end subroutine binary_tree_iterator_init

@ %def binary_tree_iterator_init
@
<<Binary trees: iterator: TBP>>=
  procedure :: is_iterable => binary_tree_iterator_is_iterable
<<Binary trees: sub interfaces>>=
    module function binary_tree_iterator_is_iterable (iterator) result (flag)
      class(binary_tree_iterator_t), intent(in) :: iterator
      logical :: flag
    end function binary_tree_iterator_is_iterable
<<Binary trees: procedures>>=
  module function binary_tree_iterator_is_iterable (iterator) result (flag)
    class(binary_tree_iterator_t), intent(in) :: iterator
    logical :: flag
    flag = iterator%current <= size (iterator%key)
  end function binary_tree_iterator_is_iterable

@ %def binary_tree_iterator_is_handle
@
<<Binary trees: iterator: TBP>>=
  procedure :: next => binary_tree_iterator_next
<<Binary trees: sub interfaces>>=
    module subroutine binary_tree_iterator_next (iterator, key)
      class(binary_tree_iterator_t), intent(inout) :: iterator
      integer, intent(out) :: key
    end subroutine binary_tree_iterator_next
<<Binary trees: procedures>>=
  module subroutine binary_tree_iterator_next (iterator, key)
    class(binary_tree_iterator_t), intent(inout) :: iterator
    integer, intent(out) :: key
    if (.not. iterator%is_iterable ()) then
       key = 0
    else
       key = iterator%key(iterator%current)
       iterator%current = iterator%current + 1
    end if
  end subroutine binary_tree_iterator_next

@ %def binary_tree_iterator_next
@
<<Binary trees: node: TBP>>=
  procedure :: init => binary_tree_node_init
<<Binary trees: sub interfaces>>=
    module subroutine binary_tree_node_init (btree_node, key, obj)
      class(binary_tree_node_t), intent(inout) :: btree_node
      integer, intent(in) :: key
      class(*), pointer :: obj
    end subroutine binary_tree_node_init
<<Binary trees: procedures>>=
  module subroutine binary_tree_node_init (btree_node, key, obj)
    class(binary_tree_node_t), intent(inout) :: btree_node
    integer, intent(in) :: key
    class(*), pointer :: obj
    btree_node%height = 1
    btree_node%left => null ()
    btree_node%right => null ()
    btree_node%key = key
    btree_node%obj => obj
  end subroutine binary_tree_node_init

@ %def binary_tree_node_init
@
<<Binary trees: node: TBP>>=
  procedure :: write => binary_tree_node_write
<<Binary trees: sub interfaces>>=
    recursive module subroutine binary_tree_node_write &
         (btree_node, unit, level, mode)
      class(binary_tree_node_t), intent(in) :: btree_node
      integer, intent(in) :: unit
      integer, intent(in) :: level
      character(len=*), intent(in) :: mode
    end subroutine binary_tree_node_write
<<Binary trees: procedures>>=
  recursive module subroutine binary_tree_node_write &
       (btree_node, unit, level, mode)
    class(binary_tree_node_t), intent(in) :: btree_node
    integer, intent(in) :: unit
    integer, intent(in) :: level
    character(len=*), intent(in) :: mode
    character(len=24) :: fmt
    if (level > 0) then
       write (fmt, "(A,I3,A)") "(", 3 * level, "X,A,1X,I3,1X,I3,A)"
    else
       fmt = "(A,1X,I3,1X,I3,1X)"
    end if
    write (unit, fmt) mode, btree_node%key, btree_node%height
    ! write (unit, fmt) btree_node%key, btree_node%get_balance ()
    if (associated (btree_node%right)) &
         call btree_node%right%write (unit, level = level + 1, mode = ">")
    if (associated (btree_node%left)) &
         call btree_node%left%write (unit, level = level + 1, mode = "<")
  end subroutine binary_tree_node_write

@  %def binary_tree_node_write
@
<<Binary trees: node: TBP>>=
  procedure :: get_balance => binary_tree_node_get_balance
<<Binary trees: sub interfaces>>=
    module function binary_tree_node_get_balance (btree_node) result (balance)
      class(binary_tree_node_t), intent(in) :: btree_node
      integer :: balance
    end function binary_tree_node_get_balance
<<Binary trees: procedures>>=
  module function binary_tree_node_get_balance (btree_node) result (balance)
    class(binary_tree_node_t), intent(in) :: btree_node
    integer :: balance
    integer :: leftHeight, rightHeight
    leftHeight = 0
    rightHeight = 0
    if (associated (btree_node%left)) leftHeight = btree_node%left%height
    if (associated (btree_node%right)) rightHeight = btree_node%right%height
    balance = leftHeight - rightHeight
  end function binary_tree_node_get_balance

@ %def binary_tree_node_get_balance
@
<<Binary trees: node: TBP>>=
  procedure :: increment_height => binary_tree_node_increment_height
<<Binary trees: sub interfaces>>=
    module subroutine binary_tree_node_increment_height (btree_node)
      class(binary_tree_node_t), intent(inout) :: btree_node
    end subroutine binary_tree_node_increment_height
<<Binary trees: procedures>>=
  module subroutine binary_tree_node_increment_height (btree_node)
    class(binary_tree_node_t), intent(inout) :: btree_node
    integer :: leftHeight, rightHeight
    leftHeight = 0
    rightHeight = 0
    if (associated (btree_node%left)) leftHeight = btree_node%left%height
    if (associated (btree_node%right)) rightHeight = btree_node%right%height
    btree_node%height = max (leftHeight, rightHeight) + 1
  end subroutine binary_tree_node_increment_height

@ %def binary_tree_node_increment_height
@ 
<<Binary trees: node: TBP>>=
  final :: binary_tree_node_final
<<Binary trees: sub interfaces>>=
    !!! !!! NAG 7 compiler bug with finalizers and unlimited polymorphism
    !!! module subroutine binary_tree_node_final (btree_node)
    !!!   type(binary_tree_node_t), intent(inout) :: btree_node
    !!! end subroutine binary_tree_node_final
<<Binary trees: module procedures>>=
  recursive subroutine binary_tree_node_final (btree_node)
    type(binary_tree_node_t), intent(inout) :: btree_node
    if (associated (btree_node%left)) deallocate (btree_node%left)
    if (associated (btree_node%right)) deallocate (btree_node%right)
    deallocate (btree_node%obj)
  end subroutine binary_tree_node_final

@ %def binary_tree_node_final
@
<<Binary trees: tree: TBP>>=
  procedure :: write => binary_tree_write
<<Binary trees: sub interfaces>>=
    module subroutine binary_tree_write (btree, unit)
      class(binary_tree_t), intent(in) :: btree
      integer, intent(in), optional :: unit
    end subroutine binary_tree_write
<<Binary trees: procedures>>=
  module subroutine binary_tree_write (btree, unit)
    class(binary_tree_t), intent(in) :: btree
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit(unit=unit)
    write (u, "(A,1X,I3)") "Number of elements", btree%n_elements
    if (associated (btree%root)) then
       call btree%root%write (u, level = 0, mode = "*")
    else
       write (u, "(A)") "Binary tree is empty."
    end if
  end subroutine binary_tree_write

@ %def binary_tree_write
@
<<Binary trees: tree: TBP>>=
  final :: binary_tree_final
<<Binary trees: sub interfaces>>=
    !!! !!! NAG 7 compiler bug with finalizers and unlimited polymorphism
    !!! module subroutine binary_tree_final (btree)
    !!!   type(binary_tree_t), intent(inout) :: btree
    !!! end subroutine binary_tree_final
<<Binary trees: module procedures>>=
  subroutine binary_tree_final (btree)
    type(binary_tree_t), intent(inout) :: btree
    btree%n_elements = 0
    if (associated (btree%root)) then
       deallocate (btree%root)
    end if
  end subroutine binary_tree_final

@ %def binary_tree_final
@
<<Binary trees: tree: TBP>>=
  procedure :: clear => binary_tree_clear
<<Binary trees: sub interfaces>>=
    module subroutine binary_tree_clear (btree)
      class(binary_tree_t), intent(inout) :: btree
    end subroutine binary_tree_clear
<<Binary trees: procedures>>=
  module subroutine binary_tree_clear (btree)
    class(binary_tree_t), intent(inout) :: btree
    call binary_tree_final (btree)
  end subroutine binary_tree_clear

@ %def binary_tree_clear
@
<<Binary trees: tree: TBP>>=
  procedure :: get_n_elements => binary_tree_get_n_elements
<<Binary trees: sub interfaces>>=
    module function binary_tree_get_n_elements (btree) result (n)
      class(binary_tree_t), intent(in) :: btree
      integer :: n
    end function binary_tree_get_n_elements
<<Binary trees: procedures>>=
  module function binary_tree_get_n_elements (btree) result (n)
    class(binary_tree_t), intent(in) :: btree
    integer :: n
    n = btree%n_elements
  end function binary_tree_get_n_elements

@ %def binary_tree_get_n_elements
@
<<Binary trees: tree: TBP>>=
  procedure :: insert => binary_tree_insert
<<Binary trees: sub interfaces>>=
    module subroutine binary_tree_insert (btree, key, obj)
      class(binary_tree_t), intent(inout) :: btree
      integer, intent(in) :: key
      class(*), pointer, intent(in) :: obj
    end subroutine binary_tree_insert
<<Binary trees: procedures>>=
  module subroutine binary_tree_insert (btree, key, obj)
    class(binary_tree_t), intent(inout) :: btree
    integer, intent(in) :: key
    class(*), pointer, intent(in) :: obj
    type(binary_tree_node_t), pointer :: node
    allocate (node)
    call node%init (key, obj)
    btree%n_elements = btree%n_elements + 1
    if (.not. associated (btree%root)) then
       btree%root => node
    else
       call btree%insert_node (btree%root, node)
    end if
  end subroutine binary_tree_insert

@ %def binary_tree_import
@
<<Binary trees: tree: TBP>>=
  procedure, private :: insert_node => binary_tree_insert_node
<<Binary trees: sub interfaces>>=
    recursive module subroutine binary_tree_insert_node (btree, parent, node)
      class(binary_tree_t), intent(in) :: btree
      type(binary_tree_node_t), intent(inout), pointer :: parent
      type(binary_tree_node_t), intent(in), pointer :: node
    end subroutine binary_tree_insert_node
<<Binary trees: procedures>>=
  recursive module subroutine binary_tree_insert_node (btree, parent, node)
    class(binary_tree_t), intent(in) :: btree
    type(binary_tree_node_t), intent(inout), pointer :: parent
    type(binary_tree_node_t), intent(in), pointer :: node
    !! Choose left or right, if associated descend recursively into subtree,
    !! else insert node.
    if (node%key > parent%key) then
       if (associated (parent%right)) then
          call btree%insert_node (parent%right, node)
       else
          parent%right => node
       end if
    else if (node%key < parent%key) then
       if (associated (parent%left)) then
          call btree%insert_node (parent%left, node)
       else
          parent%left => node
       end if
    else
       write (*, "(A,1X,I0)") "Error: MUST not insert duplicate key", node%key
       stop 1
    end if
    call parent%increment_height ()
    call btree%balance (parent, node%key)
  end subroutine binary_tree_insert_node

@ %def binary_tree_insert_node
@
<<Binary trees: tree: TBP>>=
  procedure, private :: balance => binary_tree_balance
<<Binary trees: sub interfaces>>=
    module subroutine binary_tree_balance (btree, subtree, key)
      class(binary_tree_t), intent(in) :: btree
      type(binary_tree_node_t), intent(inout), pointer :: subtree
      integer, intent(in) :: key
    end subroutine binary_tree_balance
<<Binary trees: procedures>>=
  !! Subtree: root of subtree (which is unbalance, refer to A in diagrams.)
  module subroutine binary_tree_balance (btree, subtree, key)
    class(binary_tree_t), intent(in) :: btree
    type(binary_tree_node_t), intent(inout), pointer :: subtree
    integer, intent(in) :: key
    type(binary_tree_node_t), pointer :: node, newNode
    integer :: balance
    balance = subtree%get_balance ()
    node => subtree
    newNode => null ()
    !! balance := h_left - h_right.
    !! Proof: balance > 0 => too many elements on the left side of the subtree.
    !! Proof: balance < 0 => too many elements on the right side of the subtree.
    if (balance > 1) then
       !! => left-side of subtree
       !!      A3(2)         B2(1)
       !!     /             /    \
       !!    B2(1)         C1(0)  A1(0)
       !!   /
       !!  C1(0)
       !!
       !!    A3(3)           A1(2)           C2(1)
       !!   /               /               /    \
       !!  B1(1)  LEFT     C2(1)    RIGHT  B1(0) A3(0)
       !!   \             /
       !!    C2(0)       B1(0)
       if (subtree%left%key > key) then !! rotate right
          call btree%rotate_right (node, newNode)
       else !! subtree%left%key < key, rotate left, then right.
          call btree%rotate_left (node%left, newNode)
          node%left => newNode
          call btree%rotate_right (node, newNode)
       end if
    else if (balance < -1) then
       !! => right-side of subtree
       !!   A0(2)           B1(1)
       !!    \             /    \
       !!     B1(1)       A1(0)  C3(0)
       !!      \
       !!       C3(0)*
       !!
       !!   A1(2)           A1(2)               C2(1)
       !!    \                 \               /    \
       !!     B3(1)  RIGHT     C2(1)    LEFT  A1(0) B3(0)
       !!    /                   \
       !!   C2(0)                B3(0)
       if (subtree%right%key < key) then !! rotate left
          call btree%rotate_left (node, newNode)
       else !! subtree%right%key > key, rotate right, then left.
          call btree%rotate_right (node%right, newNode)
          node%right => newNode
          call btree%rotate_left (node, newNode)
       end if
    end if
    if (associated (newNode)) subtree => newNode
  end subroutine binary_tree_balance

@ %def binary_tree_balance
@
<<Binary trees: tree: TBP>>=
  procedure :: search => binary_tree_search
<<Binary trees: sub interfaces>>=
    module subroutine binary_tree_search (btree, key, obj)
      class(binary_tree_t), intent(in) :: btree
      integer, intent(in) :: key
      class(*), pointer, intent(out) :: obj
    end subroutine binary_tree_search
<<Binary trees: procedures>>=
  module subroutine binary_tree_search (btree, key, obj)
    class(binary_tree_t), intent(in) :: btree
    integer, intent(in) :: key
    class(*), pointer, intent(out) :: obj
    type(binary_tree_node_t), pointer :: current
    current => btree%root
    obj => null ()
    if (.not. associated (current)) return
    do while (current%key /= key)
       if (current%key > key) then
          current => current%left
       else
          current => current%right
       end if
       if (.not. associated (current)) then
          !! Key not found.
          exit
       end if
    end do
    if (associated (current)) obj => current%obj
  end subroutine binary_tree_search

@ %def binary_tree_search
@
<<Binary trees: tree: TBP>>=
  procedure :: has_key => binary_tree_has_key
<<Binary trees: sub interfaces>>=
    module function binary_tree_has_key (btree, key) result (flag)
      class(binary_tree_t), intent(in) :: btree
      integer, intent(in) :: key
      logical :: flag
    end function binary_tree_has_key
<<Binary trees: procedures>>=
  module function binary_tree_has_key (btree, key) result (flag)
    class(binary_tree_t), intent(in) :: btree
    integer, intent(in) :: key
    logical :: flag
    type(binary_tree_node_t), pointer :: current
    current => btree%root
    flag = .false.
    if (.not. associated (current)) return
    do while (current%key /= key)
       if (current%key > key) then
          current => current%left
       else
          current => current%right
       end if
       if (.not. associated (current)) then
          !! Key not found.
          return
       end if
    end do
    flag = .true.
  end function binary_tree_has_key

@ %def binary_tree_has_key
@
<<Binary trees: tree: TBP>>=
  procedure, private :: rotate_right => binary_tree_rotate_right
<<Binary trees: sub interfaces>>=
    module subroutine binary_tree_rotate_right (btree, root, new_root)
      class(binary_tree_t), intent(in) :: btree
      type(binary_tree_node_t), pointer, intent(inout) :: root
      type(binary_tree_node_t), pointer, intent(out) :: new_root
    end subroutine binary_tree_rotate_right
<<Binary trees: procedures>>=
  !!      A     Move B to A.
  !!     / \
  !!    B   E   1. Split B from A%left.
  !!   / \      2. Temporarily pointer to D.
  !!  C   D     3. Replace pointer to D by pointer to A - E.
  !!            4. Set temporary pointer to D to A%left.
  !!
  !! 1.+2. B       T => D    A
  !!      /                   \
  !!     C                     E
  !!
  !! 3.    B       T => D
  !!      / \
  !!     C   A
  !!          \
  !!           E
  !!
  !! 4.    B
  !!      / \
  !!     C   A
  !!        / \
  !!       D   E
  !!
  !! \param[inout] root Root/parent root (A).
  !! \param[out] new_root New root/parent root (B).
  module subroutine binary_tree_rotate_right (btree, root, new_root)
    class(binary_tree_t), intent(in) :: btree
    type(binary_tree_node_t), pointer, intent(inout) :: root
    type(binary_tree_node_t), pointer, intent(out) :: new_root
    type(binary_tree_node_t), pointer :: tmp
    new_root => root%left
    tmp => new_root%right
    new_root%right => root
    root%left => tmp
    call root%increment_height ()
    call new_root%increment_height ()
  end subroutine binary_tree_rotate_right

@ %def binary_tree_rotate_right
@
<<Binary trees: tree: TBP>>=
  procedure, private :: rotate_left => binary_tree_rotate_left
<<Binary trees: sub interfaces>>=
    module subroutine binary_tree_rotate_left (btree, root, new_root)
      class(binary_tree_t), intent(in) :: btree
      type(binary_tree_node_t), pointer, intent(inout) :: root
      type(binary_tree_node_t), pointer, intent(out) :: new_root
    end subroutine binary_tree_rotate_left
<<Binary trees: procedures>>=
  !!      A      Move B to A.
  !!     / \
  !!    E   B    1. Split B from A%left.
  !!       / \   2. Temporarily pointer to C.
  !!      C   D  3. Replace pointer to C by pointer to A - E.
  !!             4. Set temporary pointer to C to A%right.
  !!
  !! 1.+2. B       T => C    A
  !!        \               /
  !!         D             E
  !!
  !! 3.    B       T => C
  !!      / \
  !!     A   D
  !!    /
  !!   E
  !!
  !! 4.    B
  !!      / \
  !!     A   D
  !!    / \
  !!   E   C
  module subroutine binary_tree_rotate_left (btree, root, new_root)
    class(binary_tree_t), intent(in) :: btree
    type(binary_tree_node_t), pointer, intent(inout) :: root
    type(binary_tree_node_t), pointer, intent(out) :: new_root
    type(binary_tree_node_t), pointer :: tmp
    new_root => root%right
    tmp => new_root%left
    new_root%left => root
    root%right => tmp
    call root%increment_height ()
    call new_root%increment_height ()
  end subroutine binary_tree_rotate_left

@ %def binary_tree_rotate_left
@
\subsection{Unit tests}
\label{sec:unit-tests}

<<[[binary_tree_ut.f90]]>>=
<<File header>>

module binary_tree_ut
  use unit_tests
  use binary_tree_uti

<<Standard module head>>

<<Binary tree: public test>>

 contains

<<Binary tree: test driver>>

end module binary_tree_ut
@ %def binary_tree_ut
@
<<[[binary_tree_uti.f90]]>>=
<<File header>>

module binary_tree_uti

  use binary_tree

<<Standard module head>>

  type :: btree_obj_t
     integer :: i = 0
  end type btree_obj_t

<<Binary tree: test declarations>>

 contains

<<Binary tree: tests>>

end module binary_tree_uti
@ %def binary_tree_uti
@
<<Binary tree: public test>>=
  public :: binary_tree_test
<<Binary tree: test driver>>=
  subroutine binary_tree_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
    <<Binary tree: execute tests>>
  end subroutine binary_tree_test

@ %def binary_tree_test
@ Provide testing for interface stability and correct implementation for the
binary tree and its iterator.
<<Binary tree: execute tests>>=
call test (binary_tree_1, "binary_tree_1", &
     "check interface and implementation", &
     u, results)
<<Binary tree: test declarations>>=
public :: binary_tree_1
<<Binary tree: tests>>=
  subroutine binary_tree_1 (u)
    integer, intent(in) :: u
    integer, dimension(10) :: ndx = [1, 2, 5, 7, 19, 23, 97, -1, -6, 0]
    class(*), pointer :: obj
    type(binary_tree_t) :: btree
    type(binary_tree_iterator_t) :: iterator
    integer :: i, key
    write (u, "(A)") "* Test output: Binary tree"
    write (u, "(A)") "*   Purpose: test interface and implementation of binary tree " // &
         "and its iterator using polymorph objects."
    write (u, "(A)")

    write (u, "(A)") "* Insert fixed number of objects into tree..."
    do i = 1, size (ndx)
       call allocate_obj (i, obj)
       call btree%insert (ndx(i), obj)
    end do

    write (u, "(A)") "* Search for all added objects in tree..."
    do i = size (ndx), 1, -1
       write (u, "(A,1X,I3,1X,L1)") "- Has key", ndx(i), btree%has_key (ndx(i))
       call btree%search (ndx(i), obj)
       select type (obj)
       type is (btree_obj_t)
          write (u, "(2(A,1X,I3,1X))") "- NDX", ndx(i), "OBJ", obj%i
       end select
    end do

    write (u, "(A)") "* Output binary tree in preorder..."
    call btree%write (u)

    write (u, "(A)") "* Clear binary tree..."
    call btree%clear ()
    call btree%write (u)

    write (u, "(A)") "* Insert fixed number of object into tree (reversed order)..."
    do i = size (ndx), 1, -1
       call allocate_obj (i, obj)
       call btree%insert (ndx(i), obj)
    end do

    write (u, "(A)") "* Iterate over binary tree..."
    call iterator%init (btree)
    do while (iterator%is_iterable ())
       call iterator%next (key)
       call btree%search (key, obj)
       select type (obj)
       type is (btree_obj_t)
          write (u, "(2(A,1X,I3,1X))") "- KEY", key, "OBJ", obj%i
       end select
    end do

    write (u, "(A)") "* Search for a non-existing key..."
    write (u, "(A,1X,I3,1X,L1)") "- Has key", 123, btree%has_key (123)
    call btree%search (123, obj)
    write (u, "(A,1X,L1)") "- Object found", associated (obj)

    !! Do not test against a duplicate entry as the it will forcibly stop the program.
  contains
    subroutine allocate_obj (num, obj)
      integer, intent(in) :: num
      class(*), pointer, intent(out) :: obj
      allocate (btree_obj_t :: obj)
      select type (obj)
      type is (btree_obj_t)
         obj%i = num
      end select
    end subroutine allocate_obj
  end subroutine binary_tree_1

@ %def binary_tree_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Array List}

<<[[array_list.f90]]>>=
<<File header>>

module array_list
<<Use kinds>>

<<Standard module head>>

<<Array list: public>>

<<Array list: parameters>>

<<Array list: types>>

  interface
<<Array list: sub interfaces>>
  end interface

end module array_list
@ %def array_list
@
<<[[array_list_sub.f90]]>>=
<<File header>>

submodule (array_list) array_list_s

  use, intrinsic :: iso_fortran_env, only: ERROR_UNIT
  use io_units

  implicit none

contains

<<Array list: procedures>>

end submodule array_list_s

@ %def array_list_s
@
<<Array list: parameters>>=
  integer, parameter :: ARRAY_LIST_START_SIZE = 10
  real(default), parameter :: ARRAY_LIST_GROW_FACTOR = 1.5_default, &
       ARRAY_LIST_SHRINK_THRESHOLD = 0.3_default

@ %def array_list_start_size array_list_grow_factor
@ %def array_list_shrink_threshold
@
<<Array list: public>>=
  public :: array_list_t
<<Array list: types>>=
  type :: array_list_t
     private
     integer, dimension(:), allocatable :: array
     !! Track the index to *current* item, to be stored.
     !! Must fulfill: 0 <= count <= size.
     integer :: count = 0
     !! size \in N.
     integer :: size = 0
   contains
   <<Array list: array list: TBP>>
  end type array_list_t

@ %def array_list_t
@
<<Array list: array list: TBP>>=
  procedure :: write => array_list_write
<<Array list: sub interfaces>>=
    module subroutine array_list_write (list, unit)
      class(array_list_t), intent(in) :: list
      integer, intent(in), optional :: unit
    end subroutine array_list_write
<<Array list: procedures>>=
  module subroutine array_list_write (list, unit)
    class(array_list_t), intent(in) :: list
    integer, intent(in), optional :: unit
    integer :: u
    u = ERROR_UNIT; if (present (unit)) u = unit
    write (u, "(A,2(1X,I3))") "COUNT / SIZE", list%count, list%size
    write (u, "(999(1X,I4))") list%array
  end subroutine array_list_write

@ %def array_list_write 
@
<<Array list: array list: TBP>>=
  procedure :: init => array_list_init
<<Array list: sub interfaces>>=
    module subroutine array_list_init (list)
      class(array_list_t), intent(out) :: list
    end subroutine array_list_init
<<Array list: procedures>>=
  module subroutine array_list_init (list)
    class(array_list_t), intent(out) :: list
    allocate (list%array(ARRAY_LIST_START_SIZE), source = 0)
    list%count = 0
    list%size = ARRAY_LIST_START_SIZE
  end subroutine array_list_init

@ %def array_list_init
@
<<Array list: array list: TBP>>=
  procedure :: get => array_list_get
<<Array list: sub interfaces>>=
    elemental module function array_list_get (list, index) result (data)
      class(array_list_t), intent(in) :: list
      integer, intent(in) :: index
      integer :: data
    end function array_list_get
<<Array list: procedures>>=
  elemental module function array_list_get (list, index) result (data)
    class(array_list_t), intent(in) :: list
    integer, intent(in) :: index
    integer :: data
    if (list%is_index (index)) then
       data = list%array(index)
    else
       data = 0
    end if
  end function array_list_get

@ %def array_list_get
@
<<Array list: array list: TBP>>=
  procedure :: get_count => array_list_get_count
<<Array list: sub interfaces>>=
    pure module function array_list_get_count (list) result (count)
      class(array_list_t), intent(in) :: list
      integer :: count
    end function array_list_get_count
<<Array list: procedures>>=
  pure module function array_list_get_count (list) result (count)
    class(array_list_t), intent(in) :: list
    integer :: count
    count = list%count
  end function array_list_get_count

@ %def array_list_get_count
@
<<Array list: array list: TBP>>=
  procedure :: get_size => array_list_get_size
<<Array list: sub interfaces>>=
    pure module function array_list_get_size (list) result (size)
      class(array_list_t), intent(in) :: list
      integer :: size
    end function array_list_get_size
<<Array list: procedures>>=
  pure module function array_list_get_size (list) result (size)
    class(array_list_t), intent(in) :: list
    integer :: size
    size = list%size
  end function array_list_get_size

@ %def array_list_get_size
@
<<Array list: array list: TBP>>=
  procedure :: is_full => array_list_is_full
<<Array list: sub interfaces>>=
    pure module function array_list_is_full (list) result (flag)
      class(array_list_t), intent(in) :: list
      logical :: flag
    end function array_list_is_full
<<Array list: procedures>>=
  pure module function array_list_is_full (list) result (flag)
    class(array_list_t), intent(in) :: list
    logical :: flag
    flag = list%count >= list%size
  end function array_list_is_full

@ %def array_list_is_full
@
<<Array list: array list: TBP>>=
  procedure :: is_empty => array_list_is_empty
<<Array list: sub interfaces>>=
    pure module function array_list_is_empty (list) result (flag)
      class(array_list_t), intent(in) :: list
      logical :: flag
    end function array_list_is_empty
<<Array list: procedures>>=
  pure module function array_list_is_empty (list) result (flag)
    class(array_list_t), intent(in) :: list
    logical :: flag
    flag = .not. list%count > 0
  end function array_list_is_empty

@ %def array_list_is_empty
@
<<Array list: array list: TBP>>=
  procedure :: is_index => array_list_is_index
<<Array list: sub interfaces>>=
    pure module function array_list_is_index (list, index) result (flag)
      class(array_list_t), intent(in) :: list
      integer, intent(in) :: index
      logical :: flag
    end function array_list_is_index
<<Array list: procedures>>=
  pure module function array_list_is_index (list, index) result (flag)
    class(array_list_t), intent(in) :: list
    integer, intent(in) :: index
    logical :: flag
    flag = 0 < index .and. index <= list%count
  end function array_list_is_index

@ %def array_list_is_index
@
<<Array list: array list: TBP>>=
  procedure :: clear => array_list_clear
<<Array list: sub interfaces>>=
    module subroutine array_list_clear (list)
      class(array_list_t), intent(inout) :: list
    end subroutine array_list_clear
<<Array list: procedures>>=
  module subroutine array_list_clear (list)
    class(array_list_t), intent(inout) :: list
    list%array = 0
    list%count = 0
    call list%shrink_size ()
  end subroutine array_list_clear

@ %def array_list_clear
@
<<Array list: array list: TBP>>=
  procedure :: add => array_list_add
<<Array list: sub interfaces>>=
    module subroutine array_list_add (list, data)
      class(array_list_t), intent(inout) :: list
      integer, intent(in) :: data
    end subroutine array_list_add
<<Array list: procedures>>=
  module subroutine array_list_add (list, data)
    class(array_list_t), intent(inout) :: list
    integer, intent(in) :: data
    list%count = list%count + 1
    if (list%is_full ()) then
       call list%grow_size ()
    end if
    list%array(list%count) = data
  end subroutine array_list_add

@ %def array_list_add 
@
<<Array list: array list: TBP>>=
  procedure :: grow_size => array_list_grow_size
<<Array list: sub interfaces>>=
    module subroutine array_list_grow_size (list)
      class(array_list_t), intent(inout) :: list
    end subroutine array_list_grow_size
<<Array list: procedures>>=
  module subroutine array_list_grow_size (list)
    class(array_list_t), intent(inout) :: list
    integer, dimension(:), allocatable :: array
    integer :: new_size
    if (.not. list%is_full ()) return
    new_size = int (list%size * ARRAY_LIST_GROW_FACTOR)
    allocate (array(new_size), source = 0)
    array(:list%size) = list%array
    call move_alloc (array, list%array)
    list%size = size (list%array)
  end subroutine array_list_grow_size

@ %def array_list_grow_size 
@
<<Array list: array list: TBP>>=
  procedure :: shrink_size => array_list_shrink_size
<<Array list: sub interfaces>>=
    module subroutine array_list_shrink_size (list)
      class(array_list_t), intent(inout) :: list
      integer, dimension(:), allocatable :: array
    end subroutine array_list_shrink_size
<<Array list: procedures>>=
  module subroutine array_list_shrink_size (list)
    class(array_list_t), intent(inout) :: list
    integer, dimension(:), allocatable :: array
    integer :: new_size
    !! Apply shrink threshold on count.
    ! if (.not. list%count > 0) return
    new_size = max (list%count, ARRAY_LIST_START_SIZE)
    allocate (array(new_size), source = 0)
    !! \note We have to circumvent the allocate-on-assignment,
    !! hence, we explicitly set the array boundaries.
    array(:list%count) = list%array(:list%count)
    call move_alloc (array, list%array)
    list%size = new_size
  end subroutine array_list_shrink_size

@ %def array_list_shrink_size
@
<<Array list: array list: TBP>>=
  procedure :: reverse_order => array_list_reverse_order
<<Array list: sub interfaces>>=
    module subroutine array_list_reverse_order (list)
      class(array_list_t), intent(inout) :: list
    end subroutine array_list_reverse_order
<<Array list: procedures>>=
  module subroutine array_list_reverse_order (list)
    class(array_list_t), intent(inout) :: list
    list%array(:list%count) = list%array(list%count:1:-1)
  end subroutine array_list_reverse_order

@ %def array_list_reverse_order
@
<<Array list: array list: TBP>>=
  procedure :: sort => array_list_sort
<<Array list: sub interfaces>>=
    pure module subroutine array_list_sort (list)
      class(array_list_t), intent(inout) :: list
    end subroutine array_list_sort
<<Array list: procedures>>=
  pure module subroutine array_list_sort (list)
    class(array_list_t), intent(inout) :: list
    if (list%is_empty ()) return
    call quick_sort (list%array(:list%count))
  contains
    pure recursive subroutine quick_sort (array)
      integer, dimension(:), intent(inout) :: array
      integer :: pivot, tmp
      integer :: first, last
      integer i, j
      first = 1
      last = size(array)
      pivot = array(int ((first+last) / 2.))
      i = first
      j = last
      do
         do while (array(i) < pivot)
            i = i + 1
         end do
         do while (pivot < array(j))
            j = j - 1
         end do
         if (i >= j) exit
         tmp = array(i)
         array(i) = array(j)
         array(j) = tmp
         i = i + 1
         j = j - 1
      end do
      if (first < i - 1) call quick_sort(array(first:i - 1))
      if (j + 1 < last)  call quick_sort(array(j + 1:last))
    end subroutine quick_sort
  end subroutine array_list_sort

@ %def array_list_sort
@
<<Array list: array list: TBP>>=
  procedure :: is_element => array_list_is_element
<<Array list: sub interfaces>>=
    pure module function array_list_is_element (list, data) result (flag)
      class(array_list_t), intent(in) :: list
      integer, intent(in) :: data
      logical :: flag
    end function array_list_is_element
<<Array list: procedures>>=
  pure module function array_list_is_element (list, data) result (flag)
    class(array_list_t), intent(in) :: list
    integer, intent(in) :: data
    logical :: flag
    if (list%is_empty ()) then
       flag = .false.
    else
       flag = any (data == list%array)
    end if
  end function array_list_is_element

@ %def array_list_is_element
@
<<Array list: array list: TBP>>=
  procedure :: find => array_list_find
<<Array list: sub interfaces>>=
    module function array_list_find (list, data) result (index)
      class(array_list_t), intent(inout) :: list
      integer, intent(in) :: data
      integer :: index
    end function array_list_find
<<Array list: procedures>>=
  module function array_list_find (list, data) result (index)
    class(array_list_t), intent(inout) :: list
    integer, intent(in) :: data
    integer :: index
    if (list%is_empty () &
         .or. .not. list%is_element (data)) then
       index = 0
       return
    end if
    call list%sort () !! INTENT(INOUT)
    index = binary_search_leftmost (list%array(:list%count), data)
  contains
    pure function binary_search_leftmost (array, data) result (index)
      integer, dimension(:), intent(in) :: array
      integer, intent(in) :: data
      integer :: index
      integer :: left, right
      left = 1
      right = size (array)
      do while (left < right)
         index = floor ((left + right) / 2.)
         if (array(index) < data) then
            left = index + 1
         else
            right = index
         end if
      end do
      index = left
    end function binary_search_leftmost
  end function array_list_find

@ %def array_list_find
@
<<Array list: array list: TBP>>=
  procedure :: add_at => array_list_add_at
<<Array list: sub interfaces>>=
    module subroutine array_list_add_at (list, index, data)
      class(array_list_t), intent(inout) :: list
      integer, intent(in) :: index
      integer, intent(in) :: data
    end subroutine array_list_add_at
<<Array list: procedures>>=
  module subroutine array_list_add_at (list, index, data)
    class(array_list_t), intent(inout) :: list
    integer, intent(in) :: index
    integer, intent(in) :: data
    if (.not. list%is_index (index)) return
    if (list%is_full ()) then
       call list%grow_size ()
    end if
    list%array(index + 1:list%count + 1) = list%array(index:list%count)
    list%array(index) = data
    list%count = list%count + 1
  end subroutine array_list_add_at

@ %def array_list_add_at
@
<<Array list: array list: TBP>>=
  procedure :: remove => array_list_remove
<<Array list: sub interfaces>>=
    module function array_list_remove (list) result (data)
      class(array_list_t), intent(inout) :: list
      integer :: data
    end function array_list_remove
<<Array list: procedures>>=
  module function array_list_remove (list) result (data)
    class(array_list_t), intent(inout) :: list
    integer :: data
    if (list%is_empty ()) then
       data = 0
       return
    end if
    data = list%get (list%count)
    list%array(list%count) = 0
    list%count = list%count -1
  end function array_list_remove

@ %def array_list_remove
@
<<Array list: array list: TBP>>=
  procedure :: remove_at => array_list_remove_at
<<Array list: sub interfaces>>=
    module function array_list_remove_at (list, index) result (data)
      class(array_list_t), intent(inout) :: list
      integer, intent(in) :: index
      integer :: data
    end function array_list_remove_at
<<Array list: procedures>>=
  module function array_list_remove_at (list, index) result (data)
    class(array_list_t), intent(inout) :: list
    integer, intent(in) :: index
    integer :: data
    if (list%is_empty ()) then
       data = 0
       return
    end if
    data = list%get (index)
    list%array(index:list%count - 1) = list%array(index + 1:list%count)
    list%array(list%count) = 0
    list%count = list%count - 1
  end function array_list_remove_at

@ %def array_list_remove_at
@
\subsection{Unit tests}
\label{sec:unit-tests}

<<[[array_list_ut.f90]]>>=
<<File header>>

module array_list_ut
  use unit_tests
  use array_list_uti

<<Standard module head>>

<<Array list: public test>>

 contains

<<Array list: test driver>>
end module array_list_ut
@ %def array_list_ut
@
<<[[array_list_uti.f90]]>>=
<<File header>>

module array_list_uti

  use array_list

<<Standard module head>>

<<Array list: test declarations>>

 contains

<<Array list: tests>>

end module array_list_uti
@ %def array_list_uti
@
<<Array list: public test>>=
public :: array_list_test
<<Array list: test driver>>=
subroutine array_list_test (u, results)
  integer, intent(in) :: u
  type(test_results_t), intent(inout) :: results
  <<Array list: execute tests>>
end subroutine array_list_test

@ %def array_list_test
@ Provide testing for interface stability and correct implementation for the
binary tree and its iterator.
<<Array list: execute tests>>=
call test (array_list_1, "array_list_1", &
     "check interface and implementation", &
     u, results)
<<Array list: test declarations>>=
public :: array_list_1
<<Array list: tests>>=
subroutine array_list_1 (u)
  integer, intent(in) :: u
  type(array_list_t) :: list
  integer :: ndx, data

  write (u, "(A)") "* Test output: Array list"
  write (u, "(A)") "*   Purpose: test interface and implementation of array list"
  write (u, "(A)")

  write (u, "(A)") "* Init array_list_t ..."
  call list%init ()
  write (u, "(A)") "* Test adding a single element..."
  call list%add (1)
  write (u, "(A)") "* Test removing a single element..."
  data = list%remove ()
  write (u, "(A)") "* Test growing (unnecessary, so just return)..."
  call list%grow_size ()
  write (u, "(A)") "* Test adding elements beyond initial capacity..."
  call test_grow_and_add (list)
  write (u, "(A)") "* Test adding at specific position..."
  call list%add_at (10, -1)
  write (u, "(A)") "* Test removing at specific position..."
  data = list%remove_at (11)
  write (u, "(A)") "* Test reverse ordering..."
  call list%reverse_order ()
  write (u, "(A)") "* Test sorting..."
  call list%sort ()
  write (u, "(A)") "* Test finding..."
  ndx = list%find (1)
  write (u, "(A)") "* Test shrinking..."
  call list%shrink_size ()
  write (u, "(A)") "* Test get procedures..."
  call test_get_procedures (list)
  write (u, "(A)") "* Test clearing list..."
  call list%clear ()
  write (u, "(A)") "* Test (more complicated) combinations:"
  write (u, "(A)") "* Test growing (necessary) during adding..."
  call test_grow_and_add (list)
  write (u, "(A)") "* Test adding random data and sorting..."
  call test_sort (list)
  write (u, "(A)") "* Test finding (before sorted)..."
  call test_find (list)
contains
  subroutine test_get_procedures (list)
    type(array_list_t), intent(in) :: list
    integer :: n
    logical :: flag
    n = list%get(1)
    n = list%get_size ()
    n = list%get_count ()
    flag = list%is_element (1)
  end subroutine test_get_procedures

  subroutine test_grow_and_add (list)
    type(array_list_t), intent(inout) :: list
    integer :: i
    do i = 1, 2 * list%get_size ()
       call list%add (i)
    end do
  end subroutine test_grow_and_add

  subroutine test_get (list)
    class(array_list_t), intent(inout) :: list
    integer :: i, data
    do i = list%get_count (), 1, -1
       data = list%get (i)
       if (data == 0) then
          write (u, "(A,1X,I3)") "INDEX EMPTY", i
       end if
    end do
  end subroutine test_get

  subroutine test_sort (list)
    class(array_list_t), intent(inout) :: list
    call list%add (6)
    call list%add (2)
    call list%add (9)
    call list%add (4)
    call list%add (8)
    call list%add (7)
    call list%sort ()
  end subroutine test_sort

  subroutine test_find (list)
    class(array_list_t), intent(inout) :: list
    write (u, "(A,1X,I3)") " 6 INDEX", list%find (6)
    write (u, "(A,1X,I3)") "-1 INDEX", list%find (-1)
    write (u, "(A,1X,I3)") " 3 INDEX", list%find (3)
    write (u, "(A,1X,I3)") "26 INDEX", list%find (26)
    call list%write (u)
  end subroutine test_find
end subroutine array_list_1

@ %def array_list_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Queue}

<<[[queue.f90]]>>=
<<File header>>

module queue

<<Standard module head>>

<<Queue: public>>

<<Queue: parameters>>

<<Queue: types>>

  interface
<<Queue: sub interfaces>>
  end interface

end module queue
@ %def queue
@
<<[[queue_sub.f90]]>>=
<<File header>>

submodule (queue) queue_s

  use, intrinsic :: iso_fortran_env, only: ERROR_UNIT

  implicit none

contains

<<Queue: procedures>>

end submodule queue_s

@ %def queue_s
@
<<Queue: parameters>>=
  integer, parameter :: QUEUE_SIZE = 10, &
       QUEUE_START = 0, &
       QUEUE_END = QUEUE_SIZE

@  %def queue_size queue_start queue_end
@ 
<<Queue: public>>=
  public :: queue_t
<<Queue: types>>=
  type :: queue_t
     private
     integer, dimension(QUEUE_SIZE) :: item
     integer :: front = 0
     integer :: rear = 0
   contains
   <<Queue: queue: TBP>>
  end type queue_t

@ %def queue_t
@
<<Queue: queue: TBP>>=
  procedure :: is_full => queue_is_full
<<Queue: sub interfaces>>=
    elemental module function queue_is_full (queue) result (flag)
      class(queue_t), intent(in) :: queue
      logical :: flag
    end function queue_is_full
<<Queue: procedures>>=
  elemental module function queue_is_full (queue) result (flag)
    class(queue_t), intent(in) :: queue
    logical :: flag
    flag = queue%front == 1 .and. queue%rear == QUEUE_END
  end function queue_is_full

@ %def queue_is_full
@
<<Queue: queue: TBP>>=
  procedure :: is_empty => queue_is_empty
<<Queue: sub interfaces>>=
    elemental module function queue_is_empty (queue) result (flag)
      class(queue_t), intent(in) :: queue
      logical :: flag
    end function queue_is_empty
<<Queue: procedures>>=
  elemental module function queue_is_empty (queue) result (flag)
    class(queue_t), intent(in) :: queue
    logical :: flag
    flag = queue%front == QUEUE_START
  end function queue_is_empty

@ %def queue_is_empty
@
<<Queue: queue: TBP>>=
  procedure :: enqueue => queue_enqueue
<<Queue: sub interfaces>>=
    module subroutine queue_enqueue (queue, item)
      class(queue_t), intent(inout) :: queue
      integer, intent(in) :: item
    end subroutine queue_enqueue
<<Queue: procedures>>=
  module subroutine queue_enqueue (queue, item)
    class(queue_t), intent(inout) :: queue
    integer, intent(in) :: item
    if (queue%is_full ()) then
       !! Do something. 
    else
       if (queue%front == QUEUE_START) queue%front = 1
       queue%rear = queue%rear + 1
       queue%item(queue%rear) = item
    end if
  end subroutine queue_enqueue

@ %def queue_enqueue
@
<<Queue: queue: TBP>>=
  procedure :: dequeue => queue_dequeue
<<Queue: sub interfaces>>=
    module function queue_dequeue (queue) result (item)
      class(queue_t), intent(inout) :: queue
      integer :: item
    end function queue_dequeue
<<Queue: procedures>>=
  module function queue_dequeue (queue) result (item)
    class(queue_t), intent(inout) :: queue
    integer :: item
    if (queue%is_empty ()) then
       item = 0
    else
       item = queue%item(queue%front)
       if (queue%front >= queue%rear) then
          queue%front = QUEUE_START
          queue%rear = QUEUE_START
          !! Q has only one element,
          !! so we reset the queue after deleting it.
       else
          queue%front = queue%front + 1
       end if
    end if
  end function queue_dequeue

@ %def queue_dequeue
@
<<Queue: queue: TBP>>=
  procedure :: peek => queue_peek
<<Queue: sub interfaces>>=
    module function queue_peek (queue) result (item)
      class(queue_t), intent(in) :: queue
      integer :: item
    end function queue_peek
<<Queue: procedures>>=
  module function queue_peek (queue) result (item)
    class(queue_t), intent(in) :: queue
    integer :: item
    if (queue%is_empty ()) then
       item = 0
    else
       item = queue%item(queue%front)
    end if
  end function queue_peek

@ %def queue_peek
@
<<Queue: queue: TBP>>=
  procedure :: write => queue_write
<<Queue: sub interfaces>>=
    module subroutine queue_write (queue, unit)
      class(queue_t), intent(in) :: queue
      integer, intent(in), optional :: unit
    end subroutine queue_write
<<Queue: procedures>>=
  module subroutine queue_write (queue, unit)
    class(queue_t), intent(in) :: queue
    integer, intent(in), optional :: unit
    integer :: u, i
    u = ERROR_UNIT; if (present (unit)) u = unit
    if (queue%is_empty ()) then
       write (u, *) "Empty Queue."
    else
       write (u, *) "Front ->", queue%front
       write (u, *) "Items ->"
       do i = 1, queue%rear
          write (u, *) queue%item(i)
       end do
       write (u, *) "Rear ->", queue%rear
    end if
  end subroutine queue_write

@ %def queue_write
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Iterator}

<<[[iterator.f90]]>>=
<<File header>>
module iterator

<<Standard module head>>

<<Iterator: public>>

<<Iterator: types>>

  interface
<<Iterator: sub interfaces>>
  end interface

end module iterator

@ %def iterator
@
<<[[iterator_sub.f90]]>>=
<<File header>>

submodule (iterator) iterator_s

  use, intrinsic :: iso_fortran_env, only: ERROR_UNIT

  implicit none

contains

<<Iterator: procedures>>

end submodule iterator_s

@ %def iterator_s
@
<<Iterator: public>>=
  public :: iterator_t
<<Iterator: types>>=
  !! Forward
  type :: iterator_t
     integer :: current = 0
     integer :: begin = 0
     integer :: end = 0
     integer :: step = 1
   contains
   <<Iterator: iterator: TBP>>
  end type iterator_t

@ %def iterator_t
@
<<Iterator: iterator: TBP>>=
  procedure :: write => iterator_write
<<Iterator: sub interfaces>>=
    module subroutine iterator_write (iter, unit)
      class(iterator_t), intent(in) :: iter
      integer, intent(in), optional :: unit
    end subroutine iterator_write
<<Iterator: procedures>>=
  module subroutine iterator_write (iter, unit)
    class(iterator_t), intent(in) :: iter
    integer, intent(in), optional :: unit
    integer :: u
    u = ERROR_UNIT; if (present (unit)) u = unit
    write (u, "(3(A,1X,I3,1X))") "CURRENT", iter%current, &
         "BEGIN", iter%begin, "END", iter%end
    flush (u)
  end subroutine iterator_write

@ %def iterator_write
@
<<Iterator: iterator: TBP>>=
  procedure :: init => iterator_init
<<Iterator: sub interfaces>>=
   module subroutine iterator_init (iter, begin, end, step)
     class(iterator_t), intent(inout) :: iter
     integer, intent(in) :: begin
     integer, intent(in) :: end
     integer, intent(in), optional :: step
   end subroutine iterator_init
<<Iterator: procedures>>=
  !! Proof: step > 0, begin < end.
  !! Proof: step < 0, begin > end.
  !! Proof: step /= 0.
  module subroutine iterator_init (iter, begin, end, step)
    class(iterator_t), intent(inout) :: iter
    integer, intent(in) :: begin
    integer, intent(in) :: end
    integer, intent(in), optional :: step
    iter%begin = begin
    iter%end = end
    iter%step = 1; if (present (step)) iter%step = step
    if (abs (iter%step) > 0) then
       iter%current = iter%begin
    else
       write (ERROR_UNIT, "(A)") "ERROR: Step size MUST be unequal to zero."
       stop 1
    end if
  end subroutine iterator_init

@ %def iterator_init
@
<<Iterator: iterator: TBP>>=
  procedure :: at_begin => iterator_at_begin
<<Iterator: sub interfaces>>=
    pure module function iterator_at_begin (iter) result (flag)
      class(iterator_t), intent(in) :: iter
      logical :: flag
    end function iterator_at_begin
<<Iterator: procedures>>=
  pure module function iterator_at_begin (iter) result (flag)
    class(iterator_t), intent(in) :: iter
    logical :: flag
    flag = iter%current == iter%begin
  end function iterator_at_begin

@ %def iterator_at_begin
@
<<Iterator: iterator: TBP>>=
  procedure :: at_end => iterator_at_end
<<Iterator: sub interfaces>>=
    pure module function iterator_at_end (iter) result (flag)
      class(iterator_t), intent(in) :: iter
      logical :: flag
    end function iterator_at_end
<<Iterator: procedures>>=
  pure module function iterator_at_end (iter) result (flag)
    class(iterator_t), intent(in) :: iter
    logical :: flag
    flag = iter%current == iter%end
  end function iterator_at_end

@ %def iterator_at_end
@
<<Iterator: iterator: TBP>>=
  procedure :: is_iterable => iterator_is_iterable
<<Iterator: sub interfaces>>=
    pure module function iterator_is_iterable (iter) result (flag)
      class(iterator_t), intent(in) :: iter
      logical :: flag
    end function iterator_is_iterable
<<Iterator: procedures>>=
  !! Proof: begin < current < end
  pure module function iterator_is_iterable (iter) result (flag)
    class(iterator_t), intent(in) :: iter
    logical :: flag
    if (iter%step > 0) then
       flag = iter%current <= iter%end
    else if (iter%step < 0) then
       flag = iter%current >= iter%end
    else
       flag = .false.
    end if
  end function iterator_is_iterable

@ %def iterator_is_iterable
@
<<Iterator: iterator: TBP>>=
  procedure :: next_step => iterator_next_step
<<Iterator: sub interfaces>>=
    module subroutine iterator_next_step (iter)
      class(iterator_t), intent(inout) :: iter
    end subroutine iterator_next_step
<<Iterator: procedures>>=
  module subroutine iterator_next_step (iter)
    class(iterator_t), intent(inout) :: iter
    if (.not. iter%is_iterable ()) return
    iter%current = iter%current + iter%step
  end subroutine iterator_next_step

@ %def iterator_next_step
@
<<Iterator: iterator: TBP>>=
  procedure :: next => iterator_next
<<Iterator: sub interfaces>>=
    module function iterator_next (iter) result (ndx)
      class(iterator_t), intent(inout) :: iter
      integer :: ndx
    end function iterator_next
<<Iterator: procedures>>=
  !! Proof: begin <= current <= end.
  !! However, after applying the step, this does not need to be true..
  module function iterator_next (iter) result (ndx)
    class(iterator_t), intent(inout) :: iter
    integer :: ndx
    if (.not. iter%is_iterable ()) then
       ndx = 0
       return
    end if
    ndx = iter%current
    iter%current = iter%current + iter%step
  end function iterator_next

@ %def iterator_next
@
<<Iterator: iterator: TBP>>=
  procedure :: get_current => iterator_get_current
<<Iterator: sub interfaces>>=
    pure module function iterator_get_current (iter) result (ndx)
      class(iterator_t), intent(in) :: iter
      integer :: ndx
    end function iterator_get_current
<<Iterator: procedures>>=
  pure module function iterator_get_current (iter) result (ndx)
    class(iterator_t), intent(in) :: iter
    integer :: ndx
    if (.not. iter%is_iterable ()) then
       ndx = 0
       return
    end if
    ndx = iter%current
  end function iterator_get_current

@ %def iterator_get_current
@
\subsection{Unit tests}
\label{sec:unit-tests}

<<[[iterator_ut.f90]]>>=
<<File header>>

module iterator_ut
  use unit_tests
  use iterator_uti

<<Standard module head>>

<<Iterator: public test>>

 contains

<<Iterator: test driver>>
end module iterator_ut
@ %def iterator_ut
@
<<[[iterator_uti.f90]]>>=
<<File header>>

module iterator_uti

  use iterator

<<Standard module head>>

<<Iterator: test declarations>>

 contains

<<Iterator: tests>>

end module iterator_uti
@ %def iterator_uti
@
<<Iterator: public test>>=
public :: iterator_test
<<Iterator: test driver>>=
subroutine iterator_test (u, results)
  integer, intent(in) :: u
  type(test_results_t), intent(inout) :: results
  <<Iterator: execute tests>>
end subroutine iterator_test

@ %def iterator_test
@ Provide testing for interface stability and correct implementation for the
forward integer iterator.
<<Iterator: execute tests>>=
call test (iterator_1, "iterator_1", &
     "check interface and implementation", &
     u, results)
<<Iterator: test declarations>>=
public :: iterator_1
<<Iterator: tests>>=
subroutine iterator_1 (u)
  integer, intent(in) :: u
  type(iterator_t) :: iter

  write (u, "(A)") "* Test output: iterator_1"
  write (u, "(A)") "*   Purpose: test interface and implementation of the forward integer iterator"
  write (u, "(A)")

  call iter%init (1, 10)
  call iter%write (u)
  do while (iter%is_iterable ())
     write (u, "(A,1X,I3)") "NDX", iter%next ()
  end do

  call iter%init (10, 1, -1)
  call iter%write (u)
  do while (iter%is_iterable ())
     write (u, "(A,1X,I3)") "NDX", iter%next ()
  end do
  write (u, "(A,1X,I3)") "INVALID NDX", iter%next ()

  call iter%init (1, 10)
  call iter%write (u)
  do while (iter%is_iterable ())
     call iter%next_step ()
     write (u, "(A)") "STEP."
  end do
end subroutine iterator_1
@
