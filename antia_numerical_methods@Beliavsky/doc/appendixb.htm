<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtHgold 4.00">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Appendix B</title> 
 
  


  
 
 









  
     
  
      
     
  
 
 
 
  
  
 
 
















        














   











<div class="p"><!----></div>

<div class="p"><!----></div>


    
  




<table align="center" border="0"><tr><td>
&nbsp;</td></tr></table><!--hboxt--><br /><br />

<br /><span class="roman"><b><font size="+2"> APPENDIX&nbsp;&nbsp;B</font></b></span><br /><br />
<hr />
<br />

<br /><font size="+2"> FORTRAN PROGRAMS </font><br /><br /><br /><br />

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<p>
 B.1 <a href="#Introduction">Introduction </a>


<p>
 B.2 <a href="#Roundoff Error">Roundoff Error </a>
<table BORDER=0 WIDTH="50%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#cassum">CASSUM</a></td>
<td>&nbsp; <a href="#round">ROUND</a></td>
</tr>
</table>

<p>
 B.3 <a href="#Linear Algebraic Equations">Linear Algebraic Equations </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#gauelm">GAUELM</a></td>
<td>&nbsp; <a href="#matinv">MATINV</a></td>
<td>&nbsp; <a href="#crout">CROUT</a></td>
<td>&nbsp; <a href="#crouth">CROUTH</a></td>
<td>&nbsp; <a href="#cholsk">CHOLSK</a></td>
<td>&nbsp; <a href="#gaubnd">GAUBND</a></td>
<td>&nbsp; <a href="#svd">SVD</a></td>
<td>&nbsp; <a href="#svdevl">SVDEVL</a></td>
</tr>
</table>


<p>
 B.4 <a href="#Interpolation">Interpolation </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#divdif">DIVDIF</a></td>
<td>&nbsp; <a href="#divdif0">DIVDIF0</a></td>
<td>&nbsp; <a href="#nearst">NEARST</a></td>
<td>&nbsp; <a href="#spline">SPLINE</a></td>
<td>&nbsp; <a href="#splevl">SPLEVL</a></td>
<td>&nbsp; <a href="#smooth">SMOOTH</a></td>
<td>&nbsp; <a href="#bsplin">BSPLIN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bspint">BSPINT</a></td>
<td>&nbsp; <a href="#bspevl">BSPEVL</a></td>
<td>&nbsp; <a href="#ratnal">RATNAL</a></td>
<td>&nbsp; <a href="#poly2">POLY2</a></td>
<td>&nbsp; <a href="#linrn">LINRN</a></td>
<td>&nbsp; <a href="#locate">LOCATE</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bspint2">BSPINT2</a></td>
<td>&nbsp; <a href="#bspev2">BSPEV2</a></td>
<td>&nbsp; <a href="#bspintn">BSPINTN</a></td>
<td>&nbsp; <a href="#bspevn">BSPEVN</a></td>
<td>&nbsp; <a href="#bspevn1">BSPEVN1</a></td>
<td>&nbsp; <a href="#bspevn2">BSPEVN2</a></td>
</tr>
</table>


<p>
 B.5 <a href="#Differentiation">Differentiation </a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#drvt">DRVT</a>



<p>
 B.6 <a href="#Integration">Integration </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#simson">SIMSON</a></td>
<td>&nbsp; <a href="#splint">SPLINT</a></td>
<td>&nbsp; <a href="#bspqd">BSPQD</a></td>
<td>&nbsp; <a href="#rombrg">ROMBRG</a></td>
<td>&nbsp; <a href="#epsiln">EPSILN</a></td>
<td>&nbsp; <a href="#gauss">GAUSS</a></td>
<td>&nbsp; <a href="#gaucby">GAUCBY</a></td>
<td>&nbsp; <a href="#gaucb1">GAUCB1</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#gaucb2">GAUCB2</a></td>
<td>&nbsp; <a href="#gausq2">GAUSQ2</a></td>
<td>&nbsp; <a href="#gausq">GAUSQ</a></td>
<td>&nbsp; <a href="#gaulag">GAULAG</a></td>
<td>&nbsp; <a href="#lagure">LAGURE</a></td>
<td>&nbsp; <a href="#hermit">HERMIT</a></td>
<td>&nbsp; <a href="#gaulg2">GAULG2</a></td>
<td>&nbsp; <a href="#gaulog">GAULOG</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#gausrc">GAUSRC</a></td>
<td>&nbsp; <a href="#gauleg">GAULEG</a></td>
<td>&nbsp; <a href="#gaujac">GAUJAC</a></td>
<td>&nbsp; <a href="#lagurw">LAGURW</a></td>
<td>&nbsp; <a href="#gauher">GAUHER</a></td>
<td>&nbsp; <a href="#gauswt">GAUSWT</a></td>
<td>&nbsp; <a href="#filon">FILON</a></td>
<td>&nbsp; <a href="#adpint">ADPINT</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#kronrd">KRONRD</a></td>
<td>&nbsp; <a href="#gaus16">GAUS16</a></td>
<td>&nbsp; <a href="#cauchy">CAUCHY</a></td>
<td>&nbsp; <a href="#euler">EULER</a></td>
<td>&nbsp; <a href="#bspqd2">BSPQD2</a></td>
<td>&nbsp; <a href="#bspqdn">BSPQDN</a></td>
<td>&nbsp; <a href="#mulint">MULINT</a></td>
<td>&nbsp; <a href="#ngauss">NGAUSS</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#sphnd">SPHND</a></td>
<td>&nbsp; <a href="#strint">STRINT</a></td>
<td>&nbsp; <a href="#stroud">STROUD</a></td>
<td>&nbsp; <a href="#mcarlo">MCARLO</a></td>
<td>&nbsp; <a href="#ran">RAN</a></td>
<td>&nbsp; <a href="#ranf">RANF</a></td>
<td>&nbsp; <a href="#equids">EQUIDS</a></td>
</tr>
</table>


<p>
 B.7 <a href="#Nonlinear Algebraic Equations">Nonlinear Algebraic Equations </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bisect">BISECT</a></td>
<td>&nbsp; <a href="#secant">SECANT</a></td>
<td>&nbsp; <a href="#secanc">SECANC</a></td>
<td>&nbsp; <a href="#secani">SECANI</a></td>
<td>&nbsp; <a href="#newrap">NEWRAP</a></td>
<td>&nbsp; <a href="#brent">BRENT</a></td>
<td>&nbsp; <a href="#search">SEARCH</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#zroot">ZROOT</a></td>
<td>&nbsp; <a href="#zroot2">ZROOT2</a></td>
<td>&nbsp; <a href="#muller">MULLER</a></td>
<td>&nbsp; <a href="#muler2">MULER2</a></td>
<td>&nbsp; <a href="#delves">DELVES</a></td>
<td>&nbsp; <a href="#contur">CONTUR</a></td>
<td>&nbsp; <a href="#newrac">NEWRAC</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#polyr">POLYR</a></td>
<td>&nbsp; <a href="#lagitr">LAGITR</a></td>
<td>&nbsp; <a href="#polyc">POLYC</a></td>
<td>&nbsp; <a href="#lagitc">LAGITC</a></td>
<td>&nbsp; <a href="#davidn">DAVIDN</a></td>
<td>&nbsp; <a href="#newton">NEWTON</a></td>
<td>&nbsp; <a href="#broydn">BROYDN</a></td>
</tr>
</table>


<p>
 B.8 <a href="#Optimisation">Optimisation </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#brackm">BRACKM</a></td>
<td>&nbsp; <a href="#golden">GOLDEN</a></td>
<td>&nbsp; <a href="#brentm">BRENTM</a></td>
<td>&nbsp; <a href="#davidm">DAVIDM</a></td>
<td>&nbsp; <a href="#bfgs">BFGS</a></td>
<td>&nbsp; <a href="#linmin">LINMIN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#flnm">FLNM</a></td>
<td>&nbsp; <a href="#nminf">NMINF</a></td>
<td>&nbsp; <a href="#linmnf">LINMNF</a></td>
<td>&nbsp; <a href="#fln">FLN</a></td>
<td>&nbsp; <a href="#simplx">SIMPLX</a></td>
<td>&nbsp; <a href="#simpx">SIMPX</a></td>
</tr>
</table>


<p>
 B.9 <a href="#Statistical Inferences">Statistical Inferences </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#shsort">SHSORT</a></td>
<td>&nbsp; <a href="#gammap">GAMMAP</a></td>
<td>&nbsp; <a href="#betap">BETAP</a></td>
<td>&nbsp; <a href="#betser">BETSER</a></td>
<td>&nbsp; <a href="#betcon1">BETCON1</a></td>
<td>&nbsp; <a href="#betcon">BETCON</a></td>
<td>&nbsp; <a href="#betai">BETAI</a></td>
<td>&nbsp; <a href="#fbeta">FBETA</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#rangau">RANGAU</a></td>
<td>&nbsp; <a href="#iranbin">IRANBIN</a></td>
<td>&nbsp; <a href="#iranpoi">IRANPOI</a></td>
<td>&nbsp; <a href="#pcor">PCOR</a></td>
</tr>
</table>


<p>
 B.10 <a href="#Functional Approximations">Functional Approximations </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#polfit">POLFIT</a></td>
<td>&nbsp; <a href="#polevl">POLEVL</a></td>
<td>&nbsp; <a href="#polfit1">POLFIT1</a></td>
<td>&nbsp; <a href="#polort">POLORT</a></td>
<td>&nbsp; <a href="#polfit2">POLFIT2</a></td>
<td>&nbsp; <a href="#polev2">POLEV2</a></td>
<td>&nbsp; <a href="#polfitn">POLFITN</a></td>
<td>&nbsp; <a href="#polevn">POLEVN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#polevn1">POLEVN1</a></td>
<td>&nbsp; <a href="#polevn2">POLEVN2</a></td>
<td>&nbsp; <a href="#llsq">LLSQ</a></td>
<td>&nbsp; <a href="#bspfit">BSPFIT</a></td>
<td>&nbsp; <a href="#bspfit2">BSPFIT2</a></td>
<td>&nbsp; <a href="#bspfitw2">BSPFITW2</a></td>
<td>&nbsp; <a href="#bspfitn">BSPFITN</a></td>
<td>&nbsp; <a href="#bspfitwn">BSPFITWN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#linfitxy">LINFITXY</a></td>
<td>&nbsp; <a href="#nllsq">NLLSQ</a></td>
<td>&nbsp; <a href="#dft">DFT</a></td>
<td>&nbsp; <a href="#fft">FFT</a></td>
<td>&nbsp; <a href="#fftr">FFTR</a></td>
<td>&nbsp; <a href="#fftn">FFTN</a></td>
<td>&nbsp; <a href="#lapinv">LAPINV</a></td>
<td>&nbsp; <a href="#pold">POLD</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#rmk">RMK</a></td>
<td>&nbsp; <a href="#rmk1">RMK1</a></td>
<td>&nbsp; <a href="#rmkd">RMKD</a></td>
<td>&nbsp; <a href="#rmkd1">RMKD1</a></td>
<td>&nbsp; <a href="#pade">PADE</a></td>
<td>&nbsp; <a href="#chebcf">CHEBCF</a></td>
<td>&nbsp; <a href="#chebex">CHEBEX</a></td>
<td>&nbsp; <a href="#chebap">CHEBAP</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#remes">REMES</a></td>
<td>&nbsp; <a href="#fm">FM</a></td>
<td>&nbsp; <a href="#gamma">GAMMA</a></td>
<td>&nbsp; <a href="#gamln">GAMLN</a></td>
<td>&nbsp; <a href="#erf">ERF</a></td>
<td>&nbsp; <a href="#erfc">ERFC</a></td>
<td>&nbsp; <a href="#bj0">BJ0</a></td>
<td>&nbsp; <a href="#bj1">BJ1</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bjn">BJN</a></td>
<td>&nbsp; <a href="#by0">BY0</a></td>
<td>&nbsp; <a href="#bjy0">BJY0</a></td>
<td>&nbsp; <a href="#by1">BY1</a></td>
<td>&nbsp; <a href="#bjy1">BJY1</a></td>
<td>&nbsp; <a href="#byn">BYN</a></td>
<td>&nbsp; <a href="#sphbjn">SPHBJN</a></td>
<td>&nbsp; <a href="#bi0">BI0</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bi1">BI1</a></td>
<td>&nbsp; <a href="#bin">BIN</a></td>
<td>&nbsp; <a href="#bk0">BK0</a></td>
<td>&nbsp; <a href="#bk1">BK1</a></td>
<td>&nbsp; <a href="#bkn">BKN</a></td>
<td>&nbsp; <a href="#dawson">DAWSON</a></td>
<td>&nbsp; <a href="#fermmo5">FERMM05</a></td>
<td>&nbsp; <a href="#ferm05">FERM05</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#ferm15">FERM15</a></td>
<td>&nbsp; <a href="#ferm25">FERM25</a></td>
<td>&nbsp; <a href="#pleg">PLEG</a></td>
<td>&nbsp; <a href="#plm">PLM</a></td>
<td>&nbsp; <a href="#ylm">YLM</a></td>
<td>&nbsp; <a href="#minmax">MINMAX</a></td>
<td>&nbsp; <a href="#polyl1">POLYL1</a></td>
<td>&nbsp; <a href="#linl1">LINL1</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#simpl1">SIMPL1</a></td>
</tr>
</table>


<p>
 B.11 <a href="#Algebraic Eigenvalue Problem">Algebraic Eigenvalue Problem </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#invit">INVIT</a></td>
<td>&nbsp; <a href="#tred2">TRED2</a></td>
<td>&nbsp; <a href="#trbak">TRBAK</a></td>
<td>&nbsp; <a href="#tql2">TQL2</a></td>
<td>&nbsp; <a href="#tridia">TRIDIA</a></td>
<td>&nbsp; <a href="#sturm">STURM</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#tinvit">TINVIT</a></td>
<td>&nbsp; <a href="#herevp">HEREVP</a></td>
<td>&nbsp; <a href="#balanc">BALANC</a></td>
<td>&nbsp; <a href="#balbak">BALBAK</a></td>
<td>&nbsp; <a href="#elmhes">ELMHES</a></td>
<td>&nbsp; <a href="#hqr">HQR</a></td>
</tr>
</table>


<p>
 B.12 <a href="#Ordinary Differential Equations">Ordinary Differential Equations </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#rkm">RKM</a></td>
<td>&nbsp; <a href="#rk4">RK4</a></td>
<td>&nbsp; <a href="#rk2">RK2</a></td>
<td>&nbsp; <a href="#mstep">MSTEP</a></td>
<td>&nbsp; <a href="#adams">ADAMS</a></td>
<td>&nbsp; <a href="#strt4">STRT4</a></td>
<td>&nbsp; <a href="#gear">GEAR</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#extp">EXTP</a></td>
<td>&nbsp; <a href="#fdm">FDM</a></td>
<td>&nbsp; <a href="#gevp">GEVP</a></td>
<td>&nbsp; <a href="#gaublk">GAUBLK</a></td>
<td>&nbsp; <a href="#setmat">SETMAT</a></td>
<td>&nbsp; <a href="#bspode">BSPODE</a></td>
</tr>
</table>


<p>
 B.13 <a href="#Integral Equations">Integral Equations </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#fred">FRED</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#fredco">FREDCO</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#funk">FUNK</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#rls">RLS</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#forw">FORW</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#volt">VOLT</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#volt2">VOLT2</a></td>
</tr>
</table>


<p>
 B.14 <a href="#Partial Differential Equations">Partial Differential Equations </a>
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#crank">CRANK</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#lines">LINES</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#adm">ADM</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#lax">LAX</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#sor">SOR</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#adi">ADI</a></td>
</tr>
</table>

<p>
   <a href="#Bibliography">Bibliography </a>

<p>


   

<br /><br />
<a name="Introduction"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.1&nbsp; INTRODUCTION </b></td></tr></table><!--hboxt-->

<br />All subprograms in this appendix are written in Fortran&nbsp;77, and have 
been checked to some extent, but the author cannot guarantee their correctness. 
<b>Readers are welcome to use these subprograms at their own risk</b>. 
It should be noted that, these subprograms are not a substitute for standard 
mathematical software, but merely concrete (and straightforward) 
examples of implementing numerical 
algorithms described in this book. They are only suitable for 
solving exercises and simple problems encountered in scientific computations. 
These subprograms can be effectively used to understand the working as well as the 
limitations of various numerical algorithms, on different problems. 
Readers are expected to use these subprograms with `reasonable' inputs. 
Passing on arbitrary or invalid input parameters may give upredictable 
results with or without any warning. 
Apart form the mathematical software libraries a number of software 
packages are also available which allow the mathematical problems 
to be specified in a convenient form for numerical solution. 
These software may also produce incorrect results without 
any warning. Thus it is advisable to use only those software 
where the user is aware of which technique is actually implemented, 
so that their limitations may be known. The programs in the 
online material are also provided in the same spirit. They may not 
necessarily give the correct result in all cases, but since the 
algorithm used is known to the readers, they can modify these 
to suit their requirements. 

<div class="p"><!----></div>
The programs in this Appendix are all written in 
Fortran&nbsp;77, but may require some changes before running them on a new 
system. They should also work with Fortran&nbsp;90 or later versions with some 
modifications. 
We leave it to the readers to figure out the changes needed to 
run the programs on their machines. In particular, there may be 
some conflict in names as the Fortran library may have another 
subprogram with same name with same or different arguments. In such 
cases an explicit EXTERNAL declaration may be needed to force the 
compiler to use the right routine. 
We assume that the readers are 
familiar with Fortran programming. Nevertheless, in this section we 
give a brief description of common pitfalls in Fortran programming. 
It is not expected to be an exhaustive summary of Fortran programming, 
but just a warning signal for those who are not very familiar with 
the art of programming. 

<div class="p"><!----></div>
One aspect of Fortran programming which causes some confusion among the 
beginners is that, the individual program units are usually compiled separately. 
Hence, there is no way the machine can check inconsistencies in 
passing arguments to subprograms. Although, some of the modern Fortran 
compilers do check for such inconsistencies, 
in general, it is the responsibility of the 
user to ensure that the dummy arguments and the actual arguments 
match each other in type. This is also true when the actual 
argument is a constant, since there will be no type conversion when the 
subroutine is actually called. For example, consider the following 
statements 

<div class="p"><!----></div>
<br /> <tt><table align="left" border="0"><tr><td width="20" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;&nbsp;CALL ADD(1,2,S) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
  END 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
  SUBROUTINE ADD(A,B,S) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
  S=A+B 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
  END
<div class="p"><!----></div>
</tt><br /> Here the variables A and B in the subroutine are of type  REAL, while the 
actual arguments in the calling program are integers. The computer 
will not convert the arguments when the  CALL statement is executed. 
Instead the same sequence of bits i.e., &#8230;001 and &#8230;0010 
are interpreted as REAL numbers. With the IEEE format 
they will be interpreted as 
numbers close to the underflow limit. For example, in the 32-bit IEEE format 
these numbers are interpreted 
as 1.4&times;10<sup>&#8722;45</sup> and 2.8&times;10<sup>&#8722;45</sup>, respectively.  

<div class="p"><!----></div>
Even more interesting situation can arise if the actual argument is a  
constant while the corresponding argument in the subroutine is changed 
during the execution of subroutine. In such cases, the constant 
can get changed resulting in 
unpredictable results. This kind of problems will not be detected by even 
those compilers which detect the conflict in type of variables while 
calling a subroutine. 
For example, consider the following statements: 

<div class="p"><!----></div>
<br /> <tt><table align="left" border="0"><tr><td width="20" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;&nbsp;A=3.0 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
  CALL CHANG(2.0,A) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
  B=2.0*A 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
   PRINT *,A,B 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
  END 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
  SUBROUTINE CHANG(A,B) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
  A=A+B 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
  END
<div class="p"><!----></div>
</tt><br /> On most machines, this program will print the values  3 and 15 for A and B 
respectively. This problem arises because the constant 2.0 will be changed to  
5.0 when the 
subroutine CHANG is executed, because the variable A is changed from 2.0 to 5.0 
in the subroutine. As a result, the next statement 
(i.e., <tt>B=2.0*A</tt>) is interpreted as <tt>B=5.0*A</tt>. Of course, some of 
the modern compilers do not pass a constant directly as an argument to 
a subroutine, and this problem may not occur on such systems. 
In general, it is always safe to use variables 
as actual arguments while calling any subroutine. 

<div class="p"><!----></div>
There is another very common error while passing the dimension as  
arguments. Let us assume that there is a subroutine  MAT to solve a system of 
linear equations A<b>x</b> = <b>b</b>, where A is a n&times;n matrix 
while <b>b</b> and <b>x</b> 
are n-vectors. Since the subroutine is written for any value of n, the 
actual dimension of the matrix has to be passed as an argument. If we 
take a simplistic attitude and write the subroutine and call statements as 

<div class="p"><!----></div>
<br /> <tt><table align="left" border="0"><tr><td width="20" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;&nbsp;DIMENSION A(5,5),B(5),X(5) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
     ... 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
 N=3 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
 CALL MAT(N,A,B,X) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
 END 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
 SUBROUTINE MAT(N,A,B,X) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
 DIMENSION A(N,N),B(N),X(N)
<div class="p"><!----></div>
</tt><br /> Here we expect to use a maximum dimension of 5, and the dimensions of 
arrays are declared accordingly in the calling program. But in this particular 
case, the matrix happens to be 3&times;3 and hence N is set to 3. 
The computer stores all arrays in its linear memory in certain order. For 
example, A(<span class="roman">I</span>, <span class="roman">J</span>) will be the kth element of this array, where  
k=<span class="roman">I</span>+(<span class="roman">J</span>&#8722;1)5. 
Hence, if the program is run with the following matrix 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
A = </td><td align="left" class="cl">&#x239B;<br />&#x239C;<br />&#x239C;<br />
&#x239C;<br />&#x239D;
</td><td nowrap="nowrap"><table border="0" align="left" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
1</td></tr></table></td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
2</td></tr></table></td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
3</td></tr></table></td></tr>
 <tr><td nowrap="nowrap" align="center" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
4</td></tr></table></td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
5</td></tr></table></td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
6</td></tr></table></td></tr>
 <tr><td nowrap="nowrap" align="center" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
7</td></tr></table></td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
8</td></tr></table></td><td nowrap="nowrap" align="center">
<table><tr><td nowrap="nowrap" align="center" colspan="1">9</td></tr></table></td></tr></table>
</td><td nowrap="nowrap"></td><td align="left" class="cl">&#x239E;<br />&#x239F;<br />&#x239F;<br />
&#x239F;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.1)</td></tr></table>
</td></tr></table>

 
the numbers are stored in the computer's memory in the following order 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 1&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;&#8722; &nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;&#8722; &nbsp;&nbsp;&nbsp;&nbsp;&#8722; &nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;&#8722;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.2)</td></tr></table>
</td></tr></table>

 
where the dashes denote the memory locations which are not used by the 
current matrix. When the subroutine is called, the information about where the array 
A starts in the computer memory, as well as the dummy arguments used to 
define the dimension of A are passed on to the subroutine. Consequently, the 
array is dimensioned as A(3, 3). Hence, the array A is interpreted as 3&times;3 
array and only the first nine elements of A will be considered in the same 
order as given above. As a result, the matrix is interpreted as 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 A = </td><td align="left" class="cl">&#x239B;<br />&#x239C;<br />&#x239C;<br />
&#x239C;<br />&#x239D;
</td><td nowrap="nowrap"><table border="0" align="left" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
1</td></tr></table></td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#8722;</td></tr></table></td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
5</td></tr></table></td></tr>
 <tr><td nowrap="nowrap" align="center" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
 4</td></tr></table></td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#8722;</td></tr></table></td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
8</td></tr></table></td></tr>
 <tr><td nowrap="nowrap" align="center" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
 7</td></tr></table></td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
2</td></tr></table></td><td nowrap="nowrap" align="center">
<table><tr><td nowrap="nowrap" align="center" colspan="1">&#8722;</td></tr></table></td></tr></table>
</td><td nowrap="nowrap"></td><td align="left" class="cl">&#x239E;<br />&#x239F;<br />&#x239F;<br />
&#x239F;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.3)</td></tr></table>
</td></tr></table>

 
where three of the elements are undefined. This is completely different from 
the matrix which was intended to be transferred. 
It should be noted that, this problem does not arise for one-dimensional 
arrays like B and X, since the first three memory locations will 
be correctly interpreted as the corresponding elements. 
To circumvent this difficulty, 
most of the standard subroutines include one more argument to pass the actual 
value of the first dimension for a two-dimensional array. 
The second dimension need not be passed correctly, since that is not used in 
computing the order of elements in the array. For example, if the dimension 
in the subroutine is changed to A(5, <span class="roman">N</span>), the correspondence will be 
correctly established. Similarly, for a three-dimensional array, the first 
two dimensions will have to be specified correctly, while the third one need 
not be specified correctly. In fact, Fortran&nbsp;77 allows the last dimension of 
an array 
to be represented by an asterisk. The above example can be rewritten as 

<div class="p"><!----></div>
<br /> <tt><table align="left" border="0"><tr><td width="20" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;&nbsp;DIMENSION A(5,5),B(5),X(5) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
     ... 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
 N=3 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
 N1=5 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
 CALL MAT(N,N1,A,B,X) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
 END 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
 SUBROUTINE MAT(N,N1,A,B,X) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
 DIMENSION A(N1,*),B(*),X(*)
<div class="p"><!----></div>
</tt><br /> Here N1 is the actual value of the first dimension of the array A. In all 
subroutines requiring arrays of dimension two or higher, it is preferable to  
have additional arguments to specify the actual values of the 
required dimensions. If there is no provision to pass on this value 
then the dimension in the calling program must exactly match what 
is expected in the subroutine. The exact matching of dimensions is 
required only if the calling program also needs to refer to elements 
in the concerned array. If the array is merely passed on to different 
subroutines, then the dimensions in calling program are immaterial 
as long as all subroutines are provided with the same dimension 
information and the size of array in calling program is larger than 
the required size in the subroutines. 

<div class="p"><!----></div>
In many routines, dealing with arrays 
of n-dimensions, where n may be variable, it is not convenient 
to define multi-dimensional array. In most of these routines (e.g., 
<a href="appendixb.htm#bspintn"> BSPINTN</a> or <a href="appendixb.htm#polfitn"> POLFITN</a>) the 
corresponding array is treated as a one-dimensional array with the 
required size and the order of element is calculated explicitly. 
The dimensions of the array are assumed to match the actual size. 
Thus for a problem in four dimension with array A(4,5,6,7) 
in the calling program. The subroutine will treat it as a one-dimensional 
array AS(840), and element A(i,j,k,l) corresponds to 
AS(i+(j&#8722;1)4+(k&#8722;1)20+(l&#8722;1)120) in the subroutine. It is generally 
assumed that there are no gaps in the memory allocation, that is, 
the dimensions of array A must exactly match the size of array in 
the given problem. Alternately, even the calling program may also 
use a one-dimensional array and calculate the required index as 
mentioned above. 

<div class="p"><!----></div>
Some of the subroutines (e.g., <a href="appendixb.htm#bsplin"> BSPLIN</a>, <a href="appendixb.htm#muler2"> MULER2</a>, 
<a href="appendixb.htm#mstep"> MSTEP</a>, <a href="appendixb.htm#ranf"> RANF</a>, <a href="appendixb.htm#secani"> SECANI</a>, <a href="appendixb.htm#splevl"> SPLEVL</a>) 
assume that the value of variables is 
preserved after the execution is over, as these values are used 
during subsequent calls to the subroutine. Most Fortran compilers 
use static memory allocation and the values are automatically 
preserved. However, some of the modern compilers allocate the memory 
dynamically, in which case, the values may not be preserved, unless 
a SAVE statement is included. A save statement without arguments 
implies that the values of all permissible variables are preserved. 
Such a statement is included in some subroutines, but it might 
have been omitted in some cases. 

<div class="p"><!----></div>
As far as possible, the subroutines use the normal Fortran naming convention 
to determine the type of variables. Only for logical, complex or double 
precision variables the convention has been broken. In most such 
cases, an implicit statement has been used to define a new convention 
for determining the type of variable. 
All subroutines use double precision arithmetic, as on most 
modern computers there is little difference in execution time between 
single and double precision arithmetic. 
If the user is interested in 
using the single precision arithmetic, then in most cases 
only the IMPLICIT REAL*8 
statement should be commented out or modified to REAL*4. For most 
subroutines this should work. Nevertheless,  
single precision (REAL*4) version of all subroutines is provided in 
a separate directory. In most of these routines the constants are 
still left in double precision and hence some calculations may still be 
done in double precision. Similarly, quadruple precision (REAL*16) 
version of the subroutines is also provided in a separate directory 
but again some of the constants are in double precision only so the 
accuracy may not always be higher. In particular, all routines using 
rational function approximations have the same constants as in double 
precision version which will only give accuracy of order of 10<sup>&#8722;15</sup>. 
It is nontrivial to change these routines to get higher order accuracy 
as in most cases the range of approximation will have to be split 
to achieve higher accuracy. Further calculation of the required coefficients 
of rational function approximations will require higher order accuracy.  
Similarly, the weights and abscissas of some of the Gaussian formulae 
have not been calculated to higher accuracy. 

<div class="p"><!----></div>
 Most of the subprograms have a parameter IER which is used as an error flag. 
After execution of the subprograms IER should be zero if no error has 
occurred. Nonzero values of IER indicate some error condition. 
Values of IER less than 100, usually (but not necessarily) 
indicate an error condition, which  
is not very serious and the result may still be useful. 
However, further checks may be necessary before accepting the result. 
In most of the interpolation and integration routines IER is set to 
values less than 100 even when it fails to converge to satisfactory 
accuracy. This is mainly because in most cases these routines will 
still give a reasonable accuracy. But this may not be the case 
in exceptional situations, due to singularity, or in case of integration 
in large number of dimensions, simply because the number of points 
allowed to be used may be completely inadequate. 
Even a zero value of IER does not necessarily imply that the result is correct 
as all possible errors are not detected by any of these subroutines. 
Thus additional checks are required in all cases. 
But in general one can expect that the result is likely 
to be correct if IER is zero. 
A value of <span class="roman">IER</span>  &gt;  100, usually 
signifies that the execution had to be terminated 
because of some serious error, and the result is not likely to be correct. 
Of course, there will be many cases where even the results in these 
cases are acceptable, but it will need careful analysis. 
A few of the subprograms (e.g., <a href="appendixb.htm#bisect"> BISECT</a>, <a href="appendixb.htm#newrap"> NEWRAP</a>, <a href="appendixb.htm#fred"> FRED</a>, 
<a href="appendixb.htm#secani"> SECANI</a>) 
return a negative value of IER under some special 
circumstances, even though the execution is successful. 
It may be noted that some subprograms call other subprograms. 
Hence, if IER is nonzero 
the error may have occurred in the secondary subroutines. In such cases, only 
the final value of IER may be returned. 
It may be noted that if an error condition is detected the variable 
that is expected to return the required result may contain some 
irrelevant value. Hence it is necessary to check the value of IER 
after every call to these routines before accepting the result. 
The value of IER returned by various programs has been modified since 
the first edition was written, to make them more or less unique 
between different 
subroutines. In the present version, when IER &gt; 0, in most 
cases the first 
digit is determined by the topic covered by the subroutine. Thus 
the values 1x or 1xx are for linear algebra routines (Chapters 3 and 11), 
values 2x or 2xx are for interpolation and differentiation (Chapters 4 and 5), 
3x or 3xx for integration (Chapters 6), 
4x or 4xx for nonlinear equations (Chapter 7), 
5x or 5xx for optimisation (Chapter 8), 
6x or 6xx for statistics and approximation (Chapters 9, 10), 
7x or 7xx for differential and integral equations (Chapters 12, 13, 14). 

<div class="p"><!----></div>
Many of the subprograms have a parameter REPS and/or AEPS, which specify 
the required 
accuracy. Depending on the subroutine this parameter could control either the relative 
or the absolute error in the final result. In all cases, some heuristic 
convergence test is used to check for convergence of the results. 
Consequently, the actual error may not necessarily be smaller than the required 
accuracy. 
On the other hand, in most of the simple cases, where the convergence is very 
rapid the actual error may be an order of magnitude smaller than the 
required accuracy. 

<div class="p"><!----></div>
In the following sections we give the description of each subprogram 
included in the online material and its usage. A brief description of each variable 
in the call statement also appears in the Fortran files. Some programs 
giving actual examples of usage are also included in the online material. 
Subprograms with an underscore in the names are simple variants of 
other subprograms with the suffix dropped and are not described separately 
in this Appendix. For example, GAUELM<tt>_</tt>C is a variant of GAUELM 
for complex arithmetic. 
These subprograms are also included in the list 
which can be found in the online material. 

<div class="p"><!----></div>
 

<br /><br />
<a name="Roundoff Error"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.2&nbsp; ROUNDOFF ERROR </b></td></tr></table><!--hboxt-->

<br /> 
<table BORDER=0 WIDTH="50%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#cassum">CASSUM</a></td>
<td>&nbsp; <a href="#round">ROUND</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="cassum"> </a>
 <b>1.&nbsp;CASSUM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/cassum.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/sum.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
  Function routine to sum N terms of a series using the 
cascade sum algorithm. The Ith term is calculated by the 
FUNCTION TERM(I), which must be supplied by the user. 
If the number of terms exceeds 
2<sup><span class="roman">N</span><span class="roman">2</span><span class="roman">MAX</span></sup>&nbsp;&nbsp;(=2<sup>30</sup>), then true "binary" sum may not be calculated. 
By a simple change as indicated in the program, it is possible to use 
this subroutine to sum the terms in a real array TERM<!--hbox-->. In that case TERM 
should be a real array containing the terms to be summed. 
Function CASSUM<tt>_</tt>A implements this variation. 

<div class="p"><!----></div>
 <br /><br /><a name="round"> </a>
 <b>2.&nbsp;ROUND&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/round.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/round.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to round a real number 
X to N digits using base B<!--hbox-->. It is assumed that 
&#295; <span class="roman">B</span><sup><span class="roman">N</span></sup> &lt; 1, since 
otherwise, the accuracy of computer arithmetic is not sufficient to 
give N digits. The returned value of the function ROUND will be the 
rounded value of X<!--hbox-->. 
This function can be used to simulate an arithmetic 
with required number of digits by rounding intermediate 
results after each arithmetic operation to required number of digits. 
Since it is fairly expensive to use this function routine, 
it should be used for small problems only. 

<div class="p"><!----></div>
 

<br /><br />
<a name="Linear Algebraic Equations"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.3&nbsp; LINEAR ALGEBRAIC EQUATIONS </b></td></tr></table><!--hboxt-->

<br /> 
 
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#gauelm">GAUELM</a></td>
<td>&nbsp; <a href="#matinv">MATINV</a></td>
<td>&nbsp; <a href="#crout">CROUT</a></td>
<td>&nbsp; <a href="#crouth">CROUTH</a></td>
<td>&nbsp; <a href="#cholsk">CHOLSK</a></td>
<td>&nbsp; <a href="#gaubnd">GAUBND</a></td>
<td>&nbsp; <a href="#svd">SVD</a></td>
<td>&nbsp; <a href="#svdevl">SVDEVL</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="gauelm"> </a>
 <b>3.&nbsp;GAUELM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gauelm.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/linear.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a system of N linear equations using 
Gaussian elimination with partial pivoting. N is the number of equations 
as well as the number of unknown variables. NUM is the number of different 
right-hand side vectors, for which the equations are to be solved.  
A is a real array of length   
<span class="roman">LJ</span>&times;<span class="roman">N</span> containing the matrix of coefficients. 
<span class="roman">A</span><span class="roman">(</span><span class="roman">i</span><span class="roman">,</span> <span class="roman">j</span><span class="roman">)</span> is 
the coefficient of x<sub>j</sub> in the ith equation. The matrix will be overwritten 
by the subroutine. Hence, if it is required afterwards, a separate copy 
should be saved. X is a real array of length  <span class="roman">LJ</span>&times;<span class="roman">NUM</span>, 
containing the right-hand sides of the linear systems. The system will 
be solved for each right-hand side vector given by the columns of X<!--hbox-->. 
<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">J</span><span class="roman">)</span> should contain the Ith component for the Jth right-hand 
side vector. After execution, the array X will contain the required solutions. 
Thus the right hand side vectors too will be overwritten by the 
subroutine and if they are required afterwards, a separate copy should 
be preserved. 
DET is an output parameter containing the value of the determinant. 
INC is an integer array of length  N, which will contain the pivoting 
information after the subroutine is executed. LJ is the actual value of the 
first dimension of arrays A and X, as declared in the calling program 
(LJ &#8805; <span class="roman">N</span>). IER 
is the error parameter. IER=101 indicates that <span class="roman">N</span> &#8804; 0, or  
<span class="roman">N</span> &gt; <span class="roman">LJ</span>, in which case, no calculations will be performed. 
IER=121 denotes that at some stage of elimination process, the pivot turned 
out to be zero, in which case, the calculations are terminated at that stage. 
This failure can occur only for matrices which are singular or almost singular. 
This error can also arise if the first dimension of the matrix is not 
specified correctly. 
IFLG is an integer parameter which determines the kind of calculations 
required. If <span class="roman">IFLG</span> &#8804; 1, the elimination is performed 
and IFLG is set to 2, so that next time the elimination is not performed. 
For higher values of IFLG it is assumed that elimination has already 
been performed, and the matrix A is overwritten by the triangular factors, 
while the array INC contains the information about interchanges. 
For <span class="roman">IFLG</span> &#8804; 0, both the elimination as well as solution for the 
required right-hand sides is calculated. If IFLG=1, then only the elimination 
is performed and the value of determinant is calculated. If <span class="roman">IFLG</span> &#8805; 2, 
then only the solution for the required right-hand sides is obtained. 
It may be noted that the subroutine resets the value of IFLG to 2. Hence, 
if it is called again for a different matrix, the value of 
IFLG must be set to 0 or 1, to perform elimination for the new matrix. 
To calculate the inverse of a matrix, the subroutine can be called with  
NUM=<span class="roman">N</span> and array X set to a unit matrix of order N<!--hbox-->. 
In this case, the 
inverse will be returned in the array X<!--hbox-->. This subroutine assumes that the 
matrix is equilibrated and does not attempt any scaling. The determinant 
is calculated in the simple form, which may give overflow or underflow for 
some matrices. If the system of equations is ill-conditioned, the results could be 
unreliable and the subroutine may not give any indication of the problem. 
To detect ill-conditioning the test for zero pivots may be modified 
as indicated in the program. However, such simple tests may give misleading 
results in some cases. <a href="appendixb.htm#svd"> SVD</a> should be used to check for ill-conditioning. 
To solve a system of equations with complex coefficients all real 
variables except those beginning with R should be treated as complex. 
This can achieved by an IMPLICIT COMPLEX(A-H, S-Z) statement 
and is implemented in GAUELM<tt>_</tt>C. 

<div class="p"><!----></div>
 <br /><br /><a name="matinv"> </a>
 <b>4.&nbsp;MATINV&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/matinv.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/matinv.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the inverse of a square 
matrix using Gaussian elimination, with partial pivoting. 
N is the order of matrix, IA is the first dimension of arrays A and AI 
as specified in the calling program. A is a real array of 
length <span class="roman">IA</span>&times;<span class="roman">N</span> containing the matrix, which must 
be supplied at the time of calling.  AI is a real array of 
length <span class="roman">IA</span>&times;<span class="roman">N</span> which will contain the inverse of A 
as calculated by the subroutine. IWK is an integer array of length N 
used as scratch space. IER is the error parameter, whose value may 
be set by subroutine GAUELM, which is used to calculate the inverse. 
Instead of <a href="appendixb.htm#gauelm"> GAUELM</a> it is possible to use CROUT for calculating the 
triangular decomposition, but in that case an extra real scratch array 
of length N, will be required. 

<div class="p"><!----></div>
 <br /><br /><a name="crout"> </a>
 <b>5.&nbsp;CROUT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/crout.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/linear.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a system of N linear equations using 
Crout's algorithm for LU decomposition, with partial pivoting.  
N is the number of equations 
as well as the number of unknown variables. NUM is the number of different 
right-hand side vectors, for which the equations are to be solved.  
A is a real array of length 
<span class="roman">LJ</span>&times;<span class="roman">N</span>, containing the matrix of coefficients. <span class="roman">A</span><span class="roman">(</span><span class="roman">i</span><span class="roman">,</span> <span class="roman">j</span><span class="roman">)</span> is 
the coefficient of x<sub>j</sub> in ith equation. This matrix will be overwritten 
by the subroutine. Hence, if it is required afterwards, a separate copy 
should be saved. After execution, A will contain the triangular decomposition of 
the original matrix. 
X is a real array of length  <span class="roman">LJ</span>&times;<span class="roman">NUM</span>, 
containing the right-hand sides of the linear systems. The system will 
be solved for each right-hand side vector given by the columns of X<!--hbox-->. 
<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">J</span><span class="roman">)</span> should contain the Ith component for the Jth right-hand 
side vector. After execution, the array X will contain the required solutions. 
Thus if the right-hand side vectors are required afterwards, a separate 
copy must be preserved. 
DET and IDET are the output parameters containing the value of the determinant 
in a scaled form. 
The actual value of the determinant is <span class="roman">DET</span>&times;2<sup><span class="roman">IDET</span></sup>. 
INC is an integer array of length  N, which will contain the pivoting 
information after the subroutine is executed. LJ is the actual value of the 
first dimension of arrays A and X, as declared in the calling program 
(LJ &#8805; <span class="roman">N</span>). IER 
is the error parameter. IER=102 indicates that <span class="roman">N</span> &#8804; 0, or  
<span class="roman">N</span> &gt; <span class="roman">LJ</span>, in which case, no calculations will be performed. 
IER=122 denotes that at some stage of LU decomposition the pivot turned 
out to be zero, in which case, the calculations are terminated at that stage. 
This failure can occur only for matrices which are singular or almost singular. 
IFLG is an integer parameter which determines the kind of calculations 
required. If <span class="roman">IFLG</span> &#8804; 1, the LU decomposition is performed 
and IFLG is set to 2, so that next time the triangular decomposition is not performed. 
For higher values of IFLG, it is assumed that LU decomposition has already 
been performed, and the matrix A is overwritten by the triangular factors, 
while the array INC contains the information about interchanges. 
For <span class="roman">IFLG</span> &#8804; 0, both the LU decomposition as well as the solution for the 
required right-hand sides are obtained. If IFLG=1, then only LU decomposition 
is performed and the value of determinant is calculated. If <span class="roman">IFLG</span> &#8805; 2, 
then only the solution for the required right-hand sides are obtained. 
It may be noted that, the subroutine resets the value of IFLG to 2. Hence, 
if it is called again for a different matrix, the value of 
IFLG must be set to 0 or 1, to perform LU decomposition for the new matrix. 
WK is a real array of length  N used as a scratch space by the 
subroutine to store intermediate results. 
To calculate the inverse of a matrix, the subroutine can be called with  
NUM=<span class="roman">N</span> and array X set to a unit matrix of order N<!--hbox-->. 
In this case, the 
inverse will be returned in the array X<!--hbox-->. This subroutine implements implicit 
scaling of rows as explained in Section 3.3. If the system of equations is ill-conditioned, the results could be 
unreliable and the subroutine may not give any indication of the problem. 
To detect ill-conditioning the test for zero pivots may be modified 
as indicated in the program. However, such simple tests may give misleading 
results in some cases. <a href="appendixb.htm#svd"> SVD</a> should be used to check for ill-conditioning. 
To solve a system of equations with complex coefficients all real 
variables except those beginning with R should be treated as complex. 
This can achieved by an IMPLICIT COMPLEX(A-H, S-Z) statement 
and is implemented in CROUT<tt>_</tt>C. 

<div class="p"><!----></div>
 <br /><br /><a name="crouth"> </a>
 <b>6.&nbsp;CROUTH&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/crouth.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/linear.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a system of N linear equations using 
the technique of iterative refinement and the Crout's algorithm for  
LU decomposition with partial pivoting. 
N is the number of equations 
as well as the number of unknown variables. NUM is the number of different 
right-hand side vectors, for which the equations are to be solved.  
A is a real array of length   
<span class="roman">LJ</span>&times;<span class="roman">N</span>, containing the matrix of coefficients. <span class="roman">A</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">J</span><span class="roman">)</span> is 
the coefficient of x<sub>j</sub> in Ith equation. The matrix will be preserved 
by the subroutine. B is a real array of the same dimensions as A<!--hbox-->.  
After execution, B will contain the triangular decomposition of 
the original matrix. 
X is a real array of length  <span class="roman">LJ</span>&times;<span class="roman">NUM</span>, 
containing the right-hand sides of the linear systems. The system will 
be solved for each right-hand side vector given by the columns of X<!--hbox-->. 
<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">J</span><span class="roman">)</span> should contain the Ith component for the Jth right-hand 
side vector. After execution, the array X will contain the required solutions. 
DET and IDET are the output parameters containing the value of the determinant 
in a scaled form. 
The actual value of the determinant will be <span class="roman">DET</span>&times;2<sup><span class="roman">IDET</span></sup>. 
INC is an integer array of length  N, which will contain the pivoting 
information after the subroutine is executed. LJ is the actual value of the 
first dimension of arrays A, B and X, as declared in the calling program 
(LJ &#8805; <span class="roman">N</span>). 
REPS is the required relative accuracy, to which the iterative refinement is 
required. The iteration is terminated when the maximum change in any component 
of the solution is less than REPS times the maximum component of the solution 
vector.  REPS should be 
greater than &#295; for the arithmetic used. 
It should be noted that convergence of iteration does not guarantee 
that the solution is accurate to the specified level. A reasonable estimate 
of error is provided by WK(J) for the Jth right-hand side. However, 
for extremely ill-conditioned matrices, it may underestimate the error. 
IER is the error parameter. 
IER=11 implies that the iterative refinement did not converge 
to the specified accuracy. 
This failure can 
occur if the system of equations is extremely ill-conditioned, or if the specified 
value of REPS is too low, or if the residues are accumulated using the  
same level of precision as all other calculations. 
To avoid this the variable D1 should generally be of higher precision 
than other variables. If the compiler supports REAL*16 arithmetic, D1 
should be declared so. For single precision version of CROUTH, the 
variable D1 should be in double precision. 
If the matrix is ill-conditioned, increasing NITR may cause the iteration 
to converge, but the result is unlikely to be more reliable. 
IER=102 indicates that <span class="roman">N</span> &#8804; 0 or  
<span class="roman">N</span> &gt; <span class="roman">LJ</span>, in which case, no calculations will be performed. 
IER=122 denotes that at some stage of LU decomposition, the pivot turned 
out to be zero, in which case, the calculations are terminated at that stage. 
This failure can occur only for matrices which are singular or almost singular. 
IFLG is an integer parameter which determines the kind of calculations 
required. If <span class="roman">IFLG</span> &#8804; 1, the LU decomposition is performed 
and IFLG is set to 2, so that next time the LU decomposition is not performed. 
For higher values of IFLG, it is assumed that LU decomposition has already 
been performed and the array B contains the triangular factors, 
while the array INC contains the information about interchanges. 
For <span class="roman">IFLG</span> &#8804; 0, both the LU decomposition as well as solution for the 
required right-hand sides are obtained. If IFLG=1, then only the LU decomposition 
is performed and the value of determinant is calculated. If <span class="roman">IFLG</span> &#8805; 2, 
then only the solution for the required right-hand sides are obtained. 
It may be noted that the subroutine resets the value of IFLG to 2. Hence, 
if it is called again for a different matrix, the value of 
IFLG must be set to 0 or 1, to perform LU decomposition for the new matrix. 
WK is a real array of length  2<span class="roman">N</span>+<span class="roman">NUM</span> 
used as a scratch space by the subroutine to store intermediate results. 
After execution, WK(I) will contain the estimated error for the Ith 
right-hand side. 
This subroutine requires subroutine <a href="appendixb.htm#crout"> CROUT</a> to perform the LU decomposition 
and to calculate solution of resulting equations for a given right-hand side vector. 
To calculate the inverse of a matrix, the subroutine can be called with  
NUM=<span class="roman">N</span> and array X set to a unit matrix of order N<!--hbox-->. 
In this case, the 
inverse will be returned in the array X<!--hbox-->.  
If the system of equations is extremely ill-conditioned, the results could be 
unreliable and the subroutine may not give any indication of problem. 
However, in most cases, WK(I) will give a reasonable estimate of the actual error. 
This subroutine should give correctly rounded solution to the system as 
represented in the computer, provided the system is not too ill-conditioned 
for the precision of arithmetic used in the calculations. 
It may be noted that for iterative refinement to converge it may be 
necessary to calculate the residuals using higher precision arithmetic 
as compared to that used for solution. Otherwise, the solution may not 
converge. For this purpose the variable D1 should have higher precision 
as compared to other variables. 

<div class="p"><!----></div>
 <br /><br /><a name="cholsk"> </a>
 <b>7.&nbsp;CHOLSK&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/cholsk.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/linear.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a system of N linear equations 
with a real symmetric positive definite matrix using Cholesky decomposition. 
N is the number of equations 
as well as the number of unknown variables. NUM is the number of different 
right-hand side vectors, for which the equations are to be solved.  
A is a real array of length 
<span class="roman">ND</span>&times;<span class="roman">N</span>, containing the matrix of coefficients. <span class="roman">A</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">J</span><span class="roman">)</span> is 
the coefficient of x<sub>J</sub> in Ith equation. Only the lower triangular 
part of the matrix may be used by the program, though the memory is 
reserved for the full array. 
This matrix will be overwritten 
by the subroutine. Hence, if it is required afterwards, a separate copy 
should be saved. After execution, A will contain the Cholesky decomposition of 
the original matrix in its lower triangular part. 
X is a real array of length  <span class="roman">ND</span>&times;<span class="roman">NUM</span>, 
containing the right-hand sides of the linear systems. The system will 
be solved for each right-hand side vector given by the columns of X<!--hbox-->. 
<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">J</span><span class="roman">)</span> should contain the Ith component for the Jth right-hand 
side vector. After execution, the array X will contain the required solutions. 
DET is the output parameter containing the value of the determinant. 
ND is the actual value of the 
first dimension of arrays A and X, as declared in the calling program 
(ND &#8805; <span class="roman">N</span>). IER 
is the error parameter. IER=103 indicates that <span class="roman">N</span> &#8804; 0, or  
<span class="roman">N</span> &gt; <span class="roman">ND</span>, in which case, no calculations will be performed. 
IER=123 denotes that at some stage of Cholesky decomposition 
the pivot turned 
out to be zero, in which case, the calculations are terminated at that stage. 
This failure can occur if the triangular decomposition does not 
exist without pivoting or if the matrix is not positive definite or if 
it is almost singular. 
IFLG is an integer parameter which determines the kind of calculations 
required. If <span class="roman">IFLG</span> &#8804; 1, the triangular decomposition is performed 
and IFLG is set to 2, so that next time the triangular decomposition is not performed. 
For higher values of IFLG, it is assumed that the Cholesky 
decomposition has already 
been performed, and the matrix A is overwritten by the triangular factor. 
For <span class="roman">IFLG</span> &#8804; 0, both the decomposition as well as the solution for the 
required right-hand sides are obtained. If IFLG=1, then only decomposition 
is performed and the value of determinant is calculated. If <span class="roman">IFLG</span> &#8805; 2, 
then only the solution for the required right-hand sides are obtained. 
It may be noted that, the subroutine resets the value of IFLG to 2. Hence, 
if it is called again for a different matrix, the value of 
IFLG must be set to 0 or 1, to perform Cholesky decomposition for the new matrix. 
To calculate the inverse of a matrix, the subroutine can be called with  
NUM=<span class="roman">N</span> and array X set to a unit matrix of order N<!--hbox-->. 
In this case, the 
inverse will be returned in the array X<!--hbox-->. 
If the system of equations is ill-conditioned, the results could be 
unreliable and the subroutine may not give any indication of the problem. 

<div class="p"><!----></div>
 <br /><br /><a name="gaubnd"> </a>
 <b>8.&nbsp;GAUBND&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gaubnd.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gaubnd.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a system of N linear equations using 
Gaussian elimination with partial pivoting for a band matrix. 
The matrix is stored in the band form as explained below. 
N is the number of equations 
as well as the number of unknown variables. KB is the bandwidth of 
the matrix, that is, a<sub>ij</sub>=0, if &#124;i&#8722;j&#124; &gt; <span class="roman">KB</span>. 
NUM is the number of different 
right-hand side vectors, for which the equations are to be solved.  
A is a real array of length   
<span class="roman">LJ</span>&times;(3<span class="roman">KB</span>+1) containing the matrix of coefficients 
which is stored in the band form. 
<span class="roman">A</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">J</span>&#8722;<span class="roman">I</span><span class="roman">+</span><span class="roman">KB</span><span class="roman">+</span><span class="roman">1</span><span class="roman">)</span> is 
the coefficient of x<sub>J</sub> in the Ith equation. It may be noted that 
if KB is comparable to N, then the band form will require larger 
storage than the simple form of storing the matrix and no purpose will 
be served by using this subroutine instead of <a href="appendixb.htm#gauelm"> GAUELM</a><!--hbox-->. 
The matrix A will be overwritten 
by the subroutine. Hence, if it is required afterwards, a separate copy 
should be saved. X is a real array of length  <span class="roman">LJ</span>&times;<span class="roman">NUM</span>, 
containing the right-hand sides of the linear systems. The system will 
be solved for each right-hand side vector given by the columns of X<!--hbox-->. 
<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">J</span><span class="roman">)</span> should contain the Ith component for the Jth right-hand 
side vector. After execution, the array X will contain the required solutions. 
DET and IDET are the output parameters containing the value of the determinant 
in a scaled form. 
The actual value of the determinant is <span class="roman">DET</span>&times;2<sup><span class="roman">IDET</span></sup>. 
INC is an integer array of length  N, which will contain the pivoting 
information after the subroutine is executed. LJ is the actual value of the 
first dimension of arrays A and X, as declared in the calling program 
(LJ &#8805; <span class="roman">N</span>). IER 
is the error parameter. IER=104 indicates that <span class="roman">N</span> &#8804; 0, or  
<span class="roman">N</span> &gt; <span class="roman">LJ</span> or <span class="roman">KB</span> &gt; <span class="roman">N</span>, in which case, 
no calculations will be performed. 
IER=124 implies that at some stage of elimination process, the pivot turned 
out to be zero, in which case, the calculations are terminated at that stage. 
This failure can occur only for matrices which are singular or almost singular. 
This failure can also occur if the matrix is not specified correctly 
as explained above. 
IFLG is an integer parameter which determines the kind of calculations 
required. If <span class="roman">IFLG</span> &#8804; 1, the elimination is performed 
and IFLG is set to 2, so that next time the elimination is not performed. 
For higher values of IFLG it is assumed that elimination has already 
been performed, and the matrix A is overwritten by the triangular factors, 
while the array INC contains the information about interchanges. 
For <span class="roman">IFLG</span> &#8804; 0, both the elimination as well as solution for the 
required right-hand sides is calculated. If IFLG=1, then only the elimination 
is performed and the value of determinant is calculated. If <span class="roman">IFLG</span> &#8805; 2, 
then only the solution for the required right-hand sides is obtained. 
For IFLG=&#8722;1, both elimination and solution are calculated 
without pivoting and IFLG is set to 2. This option can be used if 
the matrix is known to be diagonally dominant and pivoting is not 
necessary. 
It may be noted that the subroutine resets the value of IFLG to 2. Hence, 
if it is called again for a different matrix, the value of 
IFLG must be set to 0 or 1 or &#8722;1, to perform elimination for the new matrix. 
WK is a real array of length 3<span class="roman">KB</span>+1 used as scratch space. 
To calculate the inverse of a matrix, the subroutine can be called with  
NUM=<span class="roman">N</span> and array X set to a unit matrix of order N<!--hbox-->. 
In this case, the 
inverse will be returned in the array X<!--hbox-->. 
The inverse of a band matrix will in general not be banded and full 
storage will be required to store the inverse. 
This subroutine assumes that the 
matrix is equilibrated and does not attempt any scaling. 
If the system of equations is ill-conditioned, the results could be 
unreliable and the subroutine may not give any indication of the problem. 
To detect ill-conditioning the test for zero pivots may be modified 
as indicated below. However, such simple tests may give misleading 
results in some cases. 
To solve a system of equations with complex coefficients all real 
variables except those beginning with R should be treated as complex. 
This can achieved by an IMPLICIT COMPLEX(A-H, S-Z) statement. 
GAUBND<tt>_</tt>C provides the implementation for complex matrices. 

<div class="p"><!----></div>
 <br /><br /><a name="svd"> </a>
 <b>9.&nbsp;SVD&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/svd.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/linear.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform the singular value decomposition of 
a <span class="roman">M</span>&times;<span class="roman">N</span> matrix, A=U&#931;V<sup>T</sup> (<span class="roman">M</span> &#8805; <span class="roman">N</span>). 
This subroutine is 
based on the procedure <i>svd</i>  in Wilkinson and Reinsch&nbsp;(1971). 
A is a real array of length 
<span class="roman">LA</span>&times;<span class="roman">N</span> containing the matrix. After execution, the matrix U 
of SVD will be overwritten on A<!--hbox-->. V is a real array of length  
<span class="roman">LV</span>&times;<span class="roman">N</span>, which will contain the matrix V (not V<sup>T</sup>) 
of SVD<!--hbox-->. SIGMA is a 
real array of length  N, which will contain the singular values of 
A, i.e., the diagonal elements of the diagonal matrix &#931;. The singular 
values may not be arranged in a descending order. LA is the integer variable 
specifying the actual value of the first dimension of array A in the calling 
program (LA &#8805; <span class="roman">M</span>). 
Similarly, LV is the actual value of the first dimension of array 
V in the calling program (LV &#8805; <span class="roman">N</span>). 
E is a real array of length  N, which 
is used as a scratch space to store intermediate results. 
IER is the error parameter. 
IER=12 implies that the QR iteration used for finding SVD of the bidiagonal  
form did not converge to the required accuracy. In this case, the last value 
is accepted and calculations are continued.  
This situation will generally arise only if parameter REPS is too low for the arithmetic used. 
If a reasonable value of REPS is specified, then it normally requires only 
two or three iterations for each singular value, as compared to the maximum number 
of iterations <span class="roman">ITMAX</span>=30. 
IER=105 denotes that <span class="roman">N</span> &#8804; 0, or <span class="roman">N</span> &gt; <span class="roman">LV</span>, or <span class="roman">M</span> &#8804; 0, 
or <span class="roman">M</span> &gt; <span class="roman">LA</span>, or <span class="roman">N</span> &gt; <span class="roman">M</span>, in which case, no calculations are performed. 

<div class="p"><!----></div>
 <br /><br /><a name="svdevl"> </a>
 <b>10.&nbsp;SVDEVL&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/svdevl.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/linear.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to evaluate the solution of a system of 
linear equations 
using the SVD (<b>x</b>=V&#931;<sup>&#8722;1</sup>U<sup>T</sup><b>b</b>).  
This subroutine assumes that SVD is already performed. 
N is the number of variables in the linear system, while M is the  
number of equations. U is a real array of size  <span class="roman">LU</span>&times;<span class="roman">N</span> 
containing the left-hand transformation matrix in SVD<!--hbox-->. V is a real array of length 
<span class="roman">LV</span>&times;<span class="roman">N</span> containing the right-hand transformation matrix in 
SVD<!--hbox-->. SIGMA is a real array of length  N, containing the singular 
values. The singular values need not be arranged in any definite order. 
LU and LV are the actual values of the first dimension of arrays 
U and V respectively, 
in the calling program. B is a real array of length M containing 
the right-hand side vector. After execution, 
B will contain the required solution. WK is a real array of length  N used 
as a scratch space by the subroutine. REPS specifies the required accuracy 
for zeroing the singular values. If &#963;<sub>i</sub> &lt; <span class="roman">REPS</span>&times;max(&#963;<sub>j</sub>), 
then the corresponding &#963;<sub>i</sub><sup>&#8722;1</sup> is set to zero while calculating 
the solution. For a square matrix, where none of the singular values are 
reduced to zero, this subroutine gives the unique solution. If some of the singular 
values are reduced to zero, it gives solution with minimum norm to which any 
arbitrary combination of columns of V corresponding to zero &#963;<sub>i</sub> 
can be added, to get the general solution. If any of the singular values 
are reduced to zero the routine will give the least squares solution 
unless the right hand side is in the range of the matrix. The right hand 
side is in the range if it is orthogonal to all columns of U corresponding 
to singular values which have been reduced to zero. 
For over-determined systems 
(<span class="roman">M</span> &gt; <span class="roman">N</span>), this subroutine gives the least squares solution (with minimum 
norm if some of the singular values are reduced to zero). Before using 
this subroutine, the singular value decomposition should be computed using 
the subroutine <a href="appendixb.htm#svd"> SVD</a><!--hbox-->. It should be noted that, the subroutine SVD overwrites the 
matrix U on the original matrix A. 

<div class="p"><!----></div>
 

<br /><br />
<a name="Interpolation"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.4&nbsp; INTERPOLATION </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#divdif">DIVDIF</a></td>
<td>&nbsp; <a href="#divdif0">DIVDIF0</a></td>
<td>&nbsp; <a href="#nearst">NEARST</a></td>
<td>&nbsp; <a href="#spline">SPLINE</a></td>
<td>&nbsp; <a href="#splevl">SPLEVL</a></td>
<td>&nbsp; <a href="#smooth">SMOOTH</a></td>
<td>&nbsp; <a href="#bsplin">BSPLIN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bspint">BSPINT</a></td>
<td>&nbsp; <a href="#bspevl">BSPEVL</a></td>
<td>&nbsp; <a href="#ratnal">RATNAL</a></td>
<td>&nbsp; <a href="#poly2">POLY2</a></td>
<td>&nbsp; <a href="#linrn">LINRN</a></td>
<td>&nbsp; <a href="#locate">LOCATE</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bspint2">BSPINT2</a></td>
<td>&nbsp; <a href="#bspev2">BSPEV2</a></td>
<td>&nbsp; <a href="#bspintn">BSPINTN</a></td>
<td>&nbsp; <a href="#bspevn">BSPEVN</a></td>
<td>&nbsp; <a href="#bspevn1">BSPEVN1</a></td>
<td>&nbsp; <a href="#bspevn2">BSPEVN2</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="divdif"> </a>
 <b>11.&nbsp;DIVDIF&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/divdif.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/interp.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine for interpolation using the Newton's 
divided difference formula. XB is the x value at which interpolated value is 
required. NTAB is the number of entries in the table. 
Arrays X and F of length NTAB contain the abscissas and the 
function values at the corresponding points. The array X must contain 
abscissas in either ascending or descending order. 
NUSE specifies the maximum 
number of points to be used for interpolation. If NUSE is larger than 
NTAB, or the parameter NMAX in the subroutine, then it will be reduced 
to the minimum of these three numbers and the error flag IER 
will be set to 22. If NUSE is less than 1, it will be set to MIN(6, NTAB) and 
IER will be set to 21. In all cases, after execution, NUSE will contain the 
number of points actually used. Thus for subsequent calls NUSE must be 
reset to the required value before call. 
FB is the output array of length NUSE which will contain the 
interpolated values. FB(I) gives the interpolated value using I points, 
and FB(NUSE) gives the final value. AEPS specifies the required accuracy. 
Interpolation is continued, until two successive values 
differ by less than AEPS<!--hbox-->. If AEPS &#8804; 0, then this convergence criterion will 
never be satisfied. IER is the error parameter. 
IER=21 implies that NUSE &lt; 1, in which case it is set 
to MIN(6, NTAB). 
IER=22 implies that NUSE &gt; NTAB, or 
NUSE &gt; NMAX, in which case it is reduced appropriately. 
IER=23 implies that the interpolation has not converged 
to the specified accuracy. DFB and DDFB are output parameters 
containing the first and second derivative at the same point XB<!--hbox-->. 
It should be noted that the convergence criterion only checks for 
convergence of interpolated value and not the derivatives. Hence, the 
error in computed derivatives may be much larger. In particular, 
if the derivative is required at one of the tabular points, then 
AEPS should be set to zero, since otherwise the interpolated value 
will converge immediately and execution will be terminated with 
a very crude estimate for the derivatives. 
If the derivatives are not required, then subroutine DIVDIF0 may be used. 
This subroutine requires the function <a href="appendixb.htm#nearst"> NEARST</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="divdif0"> </a>
 <b>12.&nbsp;DIVDIF0&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/divdif0.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/poly2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine for interpolation using the Newton's 
divided difference formula. This is a simplified version of DIVDIF 
which avoids derivative calculation and has a flag to decide whether 
the first point for interpolation should be chosen from the nearest value 
in table or another point specified by the user. This flag may be 
useful if the routine is used to calculate interpolation 
in higher dimensions. 
XB is the x value at which interpolated value is 
required. NTAB is the number of entries in the table. 
Arrays X and F of length NTAB contain the abscissas and the 
function values at the corresponding points. The array X must contain 
abscissas in either ascending or descending order. 
NUSE specifies the maximum 
number of points to be used for interpolation. If NUSE is larger than 
NTAB, or the parameter NMAX in the subroutine, then it will be reduced 
to the minimum of these three numbers and the error flag IER 
will be set to 22. If NUSE is less than 1, it will be set to MIN(6, NTAB) and 
IER will be set to 21. In all cases, after execution, NUSE will contain the 
number of points actually used. Thus for subsequent calls NUSE must be 
reset to the required value before call. 
FB is the output array of length NUSE which will contain the 
interpolated values. FB(I) gives the interpolated value using I points, 
and FB(NUSE) gives the final value. AEPS specifies the required accuracy. 
Interpolation is continued, until two successive values 
differ by less than AEPS<!--hbox-->. If AEPS &#8804; 0, then this convergence criterion will 
never be satisfied and NUSE points will be used for interpolation. 
IER is the error parameter. 
IER=21 implies that NUSE &lt; 1, in which case it is set 
to MIN(6, NTAB). 
IER=22 implies that NUSE &gt; NTAB, or 
NUSE &gt; NMAX, in which case it is reduced appropriately. 
IER=23 implies that the interpolation has not converged 
to the specified accuracy. 
IFLG is an integer variable used as a flag to decide the first point 
to be used for interpolation. If IFLG=0 then the nearest point in the 
table is used to start interpolation. For other values of IFLG a 
user supplied value (IF1) is used, provided that it is admissible 
(1 &#8804; IF1 &#8804; NTAB). IF1 specifies the first point 
to be used for interpolation when IFLG &#8800; 0. For IFLG=0 
the subroutine uses the nearest point in that table and the value 
of IF1 is set to index of this point, so that next time we can use 
the same point if the interpolation in required at same XB with  
different F values. This situation arises if this routine is used 
for interpolation in more than one variables. 
This subroutine requires the function <a href="appendixb.htm#nearst"> NEARST</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="nearst"> </a>
 <b>13.&nbsp;NEARST&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/nearst.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/interp.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to locate the nearest value in an 
ordered table using a bisection algorithm. 
X is a real array containing the table with NTAB entries in either ascending or 
descending order. After execution, X(NEARST) will be the point nearest to XB<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="spline"> </a>
 <b>14.&nbsp;SPLINE&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/spline.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/interp.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the coefficients of cubic spline 
interpolation with not-a-knot boundary conditions using N tabular points. 
Arrays X and F of length N should contain the input data. 
F(I) should contain the function value at X(I). 
The array X must be in ascending or descending order. After execution, 
array C of length 3&times;<span class="roman">N</span>, will contain the coefficients of cubic spline. 
If XB is between X(I) and X(<span class="roman">I</span>+1), (1 &#8804; <span class="roman">I</span> &lt; <span class="roman">N</span>) the interpolant 
is given by  <tt>F(I)+DX*(C(1,I)+DX*(C(2,I)+DX*C(3,I)))</tt>, where 
<span class="roman">DX</span><span class="roman"> = </span><span class="roman">XB</span>&#8722;<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>. 
IER is the error parameter. 
IER=201 implies that the number of points is less 
than 2. If the number of points is 2, linear interpolation will be used, 
while for <span class="roman">N</span>=3 quadratic interpolation will be used. 
For higher values of N, cubic spline interpolation with not-a-knot 
boundary conditions is calculated. 

<div class="p"><!----></div>
 <br /><br /><a name="splevl"> </a>
 <b>15.&nbsp;SPLEVL&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/splevl.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/interp.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine for evaluating the cubic spline interpolant at 
XB, using the coefficients of cubic spline which have been calculated by the 
subroutine SPLINE<!--hbox-->. This subroutine first locates the subinterval containing 
the required point XB, using the technique described in Section&nbsp;4.2. N is the number of data points. 
X and F are arrays of length N containing the data points, 
F(I) is the tabulated function value at X(I). 
C is a real array of length 3&times;<span class="roman">N</span> containing the coefficients of cubic spline. 
The array X must be in ascending or descending order. 
DFB and DDFB are output parameters containing the first and second derivatives 
of the tabulated function 
at x=<span class="roman">XB</span>. IER is the error parameter. 
IER=24 implies that XB is outside the 
range of table on the higher side, in which case, the cubic for last 
subinterval will be used. IER=25 implies that XB is outside the range on the 
lower side, in which case, the cubic for the first subinterval will be used. 
It may be noted that spline interpolation is extremely unreliable outside 
the range of table and resulting value may have large errors. 
For extrapolation, it may be better to use polynomial interpolation 
with subroutine <a href="appendixb.htm#divdif"> DIVDIF</a>, though it also has limitations. 
IER=201 implies that <span class="roman">N</span> &lt; 2. 
After execution SPLEVL will contain the interpolated value of 
the function at XB<!--hbox-->. 
Before using this function, the coefficients 
of cubic spline must be calculated using subroutine <a href="appendixb.htm#spline"> SPLINE</a> or any other 
equivalent subroutine. 

<div class="p"><!----></div>
 <br /><br /><a name="smooth"> </a>
 <b>16.&nbsp;SMOOTH&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/smooth.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/smooth.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to draw a smooth curve passing through a set of 
data points using cubic spline interpolation. 
X and F are arrays of length NTAB containing the given data points, 
C is a real array of dimension (3, NTAB), which will contain the coefficients 
of cubic spline. The array X must be in either ascending or descending 
order. 
This subroutine will calculate the interpolated value of 
the function at NP uniformly spaced points in the interval spanned by the 
tabular points. XP and FP should be arrays of length NP which will contain the 
X  and F values for the uniformly spaced output table. If NP is sufficiently 
large, the output arrays XP and FP can be used to plot a smooth curve through 
the given points. It may be noted that this subroutine does not actually 
plot the function but only generates data that can be used to get a 
smooth plot through the data points. If additional smoothing is required 
and the curve is not required to pass through data points then a 
least squares approximation should be used to generate the points 
using subroutine <a href="appendixb.htm#bspfit"> BSPFIT</a> instead of SPLINE<!--hbox-->. 
IER is the error parameter. 
IER=202 implies that <span class="roman">NP</span> &lt; 2. Other values of IER may be set by 
subroutine SPLINE which is called to calculate the spline coefficients. 
This subroutine requires subroutine <a href="appendixb.htm#spline"> SPLINE</a> 
and function <a href="appendixb.htm#splevl"> SPLEVL</a><!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="bsplin"> </a>
 <b>17.&nbsp;BSPLIN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bsplin.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bsplin.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the B-spline basis functions 
at a specified point. X is a real array of size NX containing the knots. 
The knots must be in ascending order and distinct. 
NX is the number of knots. K is the order 
of B-spline, <span class="roman">K</span>=4 implies cubic B-splines, while <span class="roman">K</span>=2 gives linear 
B-splines, etc. XB is the point at which B-splines need to be evaluated. 
NDERIV specifies the number of derivatives to be calculated, 
for NDERIV &#8804; 0 only the B-splines will be calculated. 
For NDERIV=1, the first derivative of B-splines will also be calculated. 
For NDERIV &gt; 1, the second derivative will also be calculated. 
Higher derivatives are not calculated, but the program can be modified 
to include calculation of higher derivatives. 
B, DB and DDB are real arrays of length <span class="roman">NX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2 which will contain the 
values of B-splines, its first and second derivative respectively. 
All <span class="roman">NX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2 basis functions and if required the derivatives are 
calculated simultaneously using the recurrence relations. 
Even if derivatives are not required the arrays with required size 
must be supplied. 
This subroutine first locates the subinterval containing 
the required point XB, using the technique described in Section&nbsp;4.2. LEFT is an output variable which will give the location of XB in the 
table of knots, i.e., X(LEFT) &#8804; XB &#8804; X(LEFT+1). 
IER is the error parameter, 
IER=26 implies that the required 
point is outside the table on higher side. IER=27 implies that the 
required point, XB is outside the range of table on lower side. 
In both these cases the basis functions will be calculated using 
the same recurrence relations, but the results may not be useful. 
IER=203 implies that <span class="roman">NX</span> &lt; 2, <span class="roman">K</span> &lt; 1 or 
<span class="roman">K</span> &gt; KMAX=20, in which case no calculations are done. The parameter KMAX 
in the subroutine can be trivially increased, but such high order 
splines may not be meaningful. 
WK is a real array of length <span class="roman">N</span><span class="roman">+</span><span class="roman">2</span><span class="roman">K</span>+1 used as scratch space. 

<div class="p"><!----></div>
 <br /><br /><a name="bspint"> </a>
 <b>18.&nbsp;BSPINT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspint.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/interp.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the coefficients for 
B-spline interpolation to a table of values. N is the number of 
points in the table, X and F are real arrays of length N, specifying 
the abscissas and function values. The abscissas X must be unique 
and in ascending order. F(I) is the tabulated function value at X(I). 
K is the order of B-spline interpolation required. 
<span class="roman">K</span>=4 implies cubic B-splines, while <span class="roman">K</span>=2 gives linear B-splines, etc. 
A is a real array of length LA&times;3<span class="roman">K</span>, which will contain the triangular 
decomposition of the matrix of equations 
that is solved to calculate the coefficients of expansion. Since 
the matrix is in band form with bandwidth <span class="roman">K</span>&#8722;1, it is stored in 
band form. This matrix will be required if another interpolation 
with same set of knots is required with different F<!--hbox-->. This is useful 
in B-spline interpolation in higher dimensions. LA is the first 
dimension of A as specified in the calling routine (LA &#8805; <span class="roman">N</span>). 
C is a real array 
of length N, which will contain the coefficients of B-spline 
basis functions in expansion for interpolation. XF is a real array 
of size NO, which will contain the knots used for B-spline definition. 
Since the number of B-spline basis functions 
with NO knots is <span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, some tabular points may have to be dropped 
to ensure that <span class="roman">N</span><span class="roman">=</span><span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2. This is equivalent to using the not-a-knot 
boundary condition in cubic spline. The number of points to be dropped 
depends on K<!--hbox-->. In all cases some points near both ends are dropped. 
For linear B-splines, <span class="roman">K</span>=2 all points are used. For cubic B-splines, 
<span class="roman">K</span>=4, the 2nd and <span class="roman">N</span>&#8722;1 th points are dropped. 
NO is the number of knots used for B-spline interpolation, this would 
be equal to <span class="roman">N</span>+2&#8722;<span class="roman">K</span>. IFLG is an integer variable that specifies what 
calculation is to be done. For IFLG &#8804; 1 the matrix is calculated 
and its triangular decomposition is computed. If execution is 
successful, IFLG will be set to 2, so that next time the matrix 
calculations will be skipped. If IFLG &#8804; 0 the coefficients of 
expansion are also calculated. If IFLG=&#8722;1, the system of equations 
will be solved without pivoting. This option may not be used as 
the coefficient matrix may not be diagonally dominant and some 
pivot may turn out to be zero. 
If IFLG=2, only the coefficients of 
expansion will be calculated using the old triangular decomposition 
available in A and the (hopefully new) function values F<!--hbox-->. 
INC is an integer array of length N, which will contain the pivoting 
information for solution of system of linear equations. This array 
will be required if another interpolation with same knots is needed. 
WK is a real array of length 3<span class="roman">N</span><span class="roman">+</span><span class="roman">K</span>+7 used as scratch space. 
IER is the error parameter. IER=204 implies 
<span class="roman">N</span> &lt; <span class="roman">K</span> or <span class="roman">K</span> &lt; 2, in which 
case no calculations are done. Other values may be set by subroutines 
BSPLIN or GAUBND, which are called. This subroutine requires 
subroutine <a href="appendixb.htm#bsplin"> BSPLIN</a> to calculate the B-spline basis functions and  
subroutine <a href="appendixb.htm#gaubnd"> GAUBND</a> to solve the system of linear equations with a 
band matrix. The interpolant at any required point 
can be calculated using FUNCTION <a href="appendixb.htm#bspevl"> BSPEVL</a>, using the calculated 
coefficients of expansion. 

<div class="p"><!----></div>
 <br /><br /><a name="bspevl"> </a>
 <b>19.&nbsp;BSPEVL&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspevl.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/interp.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the value of 
function using available coefficients of B-spline expansion. 
The calculated value is given by: 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">BSPEVL</span>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">WT</span>(i) &#981;<sub>i</sub>(<span class="roman">X</span><span class="roman">0</span>), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.4)</td></tr></table>
</td></tr></table>

 
where &#981;<sub>i</sub> are the B-spline basis functions. 
It can be used to calculate the interpolated value of the function, 
if the coefficients are already calculated using BSPINT<!--hbox-->. 
N is the number of knots, which may not be the same as the number of 
points in the table for interpolation. X is a real array of 
length N containing the knots for B-splines. 
X(1) should contain the first knot and the knots must be distinct 
and in ascending order. 
K is the order of B-splines, 
<span class="roman">K</span>=2 gives linear B-splines, while <span class="roman">K</span>=4 yields cubic B-splines, etc. 
NDERIV specifies the number of derivatives to be calculated. 
For NDERIV &#8804; 0 only the function value will be calculated. 
For NDERIV=1, the first derivative is also calculated. 
For NDERIV &gt; 1, the second derivative will also be calculated. 
WT is the real array of length N, containing the coefficients of 
expansion in terms of B-spline basis functions. These coefficients 
must be calculated beforehand using <a href="appendixb.htm#bspint"> BSPINT</a> or any other equivalent 
routine for B-spline approximations.  X0 is the point 
where the function value needs to be calculated. DF is the first 
derivative of function at X0, while DDF is the second derivative. 
The derivatives would be calculated only if NDERIV has been set 
appropriately. 
WK is a real array of length at least 4<span class="roman">N</span>+5<span class="roman">K</span>+2 used as scratch space. 
IER is the error parameter, which should be zero after successful 
execution. Nonzero values of IER may be set by subroutine <a href="appendixb.htm#bsplin"> BSPLIN</a> which is called 
to calculate the B-spline basis functions. 
This routine requires subroutine BSPLIN<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="ratnal"> </a>
 <b>20.&nbsp;RATNAL&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/ratnal.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/interp.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine for rational function interpolation. 
XB is the x value at which interpolated value is 
required. NTAB is the number of entries in the given table. 
Arrays X and F of length NTAB contain the abscissas and the 
function values at the corresponding points. The array X must contain 
abscissas in either ascending or descending order. 
NUSE specifies the maximum 
number of points to be used for interpolation. If NUSE is larger than 
NTAB or the parameter NMAX in the subroutine, then it will be reduced 
to the minimum of these three numbers and the error flag IER 
may be set to 22. If NUSE is less than 1, it will be set to MIN(6, NTAB) and 
IER will be set to 21. In all cases, after execution, NUSE will contain the 
number of points actually used. Thus NUSE must be reset to required 
value before subsequent calls to the routine. 
FB is the output parameter containing the 
interpolated value. AEPS is a real parameter specifying the required accuracy. 
Interpolation will be continued until two successive values 
differ by less than AEPS<!--hbox-->. If AEPS &#8804; 0, then this convergence criterion will 
never be satisfied. IER is the error parameter. 
IER=21 implies that NUSE &lt; 1, in which case it is set 
to MIN(6, NTAB). 
IER=22 implies that NUSE &gt; NTAB, or 
NUSE &gt; NMAX, in which case it is reduced appropriately. 
IER=23 implies that, the interpolation has not converged 
to the specified accuracy. IER=205 implies that, the execution was 
terminated 
because the denominator at some stage was zero. In this case, either the 
interpolant has a pole at the requested point or it has a 0/0 form, and 
the subroutine will return with the interpolated value obtained in the 
previous step. This value may or may not be acceptable. The reliability 
of this value may be verified 
by running this subroutine with successively increasing value of NUSE, 
until it encounters the singularity. If these values are converging, then 
the result may be acceptable. 
This subroutine requires function <a href="appendixb.htm#nearst"> NEARST</a><!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="poly2"> </a>
 <b>21.&nbsp;POLY2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/poly2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/poly2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine for polynomial interpolation in two dimensions. 
(XB1, XB2) is the point at which interpolated value is required. X1 and X2 are 
real arrays of length N1 and N2 respectively, containing the abscissas. F is an 
array of length NDIM&times;<span class="roman">N</span><span class="roman">2</span> containing the function values 
F(I, J)=f(<span class="roman">X</span><span class="roman">1</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span><span class="roman">,</span> <span class="roman">X</span><span class="roman">2</span><span class="roman">(</span><span class="roman">J</span><span class="roman">)</span>). NDIM should be set to the actual value of the 
first dimension of the array F<!--hbox--> in the calling program 
(NDIM &#8805; <span class="roman">N</span><span class="roman">1</span>). 
NP1 and NP2 are the number of points to be 
used along the two axes for interpolation. The subroutine may adjust 
these values if required. 
FB is the output parameter 
containing the interpolated value. IER is the error parameter. 
IER=206 implies that <span class="roman">N</span><span class="roman">1</span> &gt; NDIM, in which case no 
calculations are done. 
This subroutine calls DIVDIF0 for one-dimensional 
interpolation along X1. To improve efficiency, the derivative calculation 
has been removed from DIVDIF0 and a flag has been introduced to avoid 
locating the nearest point every time. 
This subroutine will require subroutine <a href="appendixb.htm#divdif0"> DIVDIF0</a> and function <a href="appendixb.htm#nearst"> NEARST</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="linrn"> </a>
 <b>22.&nbsp;LINRN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/linrn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/poly2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform linear interpolation in N variables. 
XB is a real array of length N containing the coordinates of the point at which 
interpolated value is required. X is a real array of length 
NXD&times;<span class="roman">N</span> containing the 
abscissas. F is an N-dimensional array with dimension  
F(NDIM(1), &#8230;, NDIM(N)) containing the function values 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 <span class="roman">F</span><span class="roman">(</span><span class="roman">I</span><span class="roman">1</span><span class="roman">,</span> <span class="roman">I</span><span class="roman">2</span>, &#8230;, <span class="roman">IN</span>)=f(<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">1</span><span class="roman">,</span> <span class="roman">1</span><span class="roman">)</span><span class="roman">,</span> <span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">2</span><span class="roman">,</span> <span class="roman">2</span><span class="roman">)</span>, &#8230;, <span class="roman">X</span><span class="roman">(</span><span class="roman">IN</span><span class="roman">,</span> <span class="roman">N</span><span class="roman">)</span>). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.5)</td></tr></table>
</td></tr></table>

 
NP is an integer array of length N, and NP(I) is the number of tabular points along 
Ith coordinate. FB is the output parameter which will contain the  
interpolated value. NDIM is an integer array of length N, 
specifying the dimension of F as explained above. 
This array must specify the dimensions of F as used in the calling 
program. 
NXD is the actual value of the first dimension of X, and it should be 
greater than the maximum element in NP<!--hbox-->. IN is an integer array of length 
 2N, which is used as a scratch space to store intermediate 
quantities. Similarly, HN is a real 
array of length  N, also used as a scratch space.  
As an example, 
consider the case, when we want to perform interpolation in four variables, 
with 4, 5, 6 and 7 points along the four coordinates, then the relevant 
statements could be as follows 

<div class="p"><!----></div>
<br /> <tt><table align="left" border="0"><tr><td width="13" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;DIMENSION F(5,5,6,8),X(10,5),XB(5),NP(5),NDIM(5),IWK(10),WK(5) 
<br /><table align="left" border="0"><tr><td width="16" align="right">
</td></tr></table><!--hbox-->
  DATA N,NXD,(NP(I),I=1,4),(NDIM(I),I=1,4)/4,10,4,5,6,7,5,5,6,8/ 
<br /><table align="left" border="0"><tr><td width="16" align="right">
</td></tr></table><!--hbox-->
  . . . . . . . . . . . . . . . .  
<br /><table align="left" border="0"><tr><td width="16" align="right">
</td></tr></table><!--hbox-->
  CALL LINRN(N,XB,X,F,NP,FB,NDIM,NXD,IWK,WK,IER)</tt> 

<div class="p"><!----></div>
<br /> IER is the error parameter. 
IER=207 signifies that NP(I) is less than two or 
greater than NDIM(I) or NXD for some I, 
in which case no calculations are performed. 
This subroutine requires function LOCATE<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="locate"> </a>
 <b>23.&nbsp;LOCATE&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/locate.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/linrn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to locate a given point XB between 
two points of an ordered table using the bisection algorithm. 
X is the table with NP entries 
in either ascending or descending order. 
After execution, LOCATE returns a value such that, 
XB should be between X(LOCATE) and X(LOCATE+1), unless it is outside the 
range of the table. If XB is before the first point, then LOCATE=1,  
while if XB is beyond the last point, then <span class="roman">LOCATE</span>=<span class="roman">NP</span>&#8722;1. 

<div class="p"><!----></div>
  <br /><br /><a name="bspint2"> </a>
 <b>24.&nbsp;BSPINT2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspint2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/poly2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the coefficients of 
interpolating B-spline expansion in two dimensions. NX, NY are the 
number of points along x and y, respectively in the table. 
X, Y are real arrays of length NX and NY containing the abscissas. 
The abscissas must be distinct and in ascending order. 
F is a real array of size <span class="roman">LA</span>&times;<span class="roman">NY</span> containing 
the function values. F(I, J) should contain f(<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span><span class="roman">,</span> <span class="roman">Y</span><span class="roman">(</span><span class="roman">J</span><span class="roman">)</span>). 
K is an integer variable specifying the required order of B-splines, 
<span class="roman">K</span>=4 for cubic B-splines, <span class="roman">K</span>=2 for linear B-splines, etc. 
For simplicity, it is assumed that order is the same for expansions 
along x and y. AX is a real array of length <span class="roman">LA</span>&times;<span class="roman">3</span><span class="roman">K</span> 
which will contain 
the triangular decomposition of matrix for interpolation along X<!--hbox-->. 
AY is a real array of length <span class="roman">LA</span>&times;<span class="roman">3</span><span class="roman">K</span> which will contain 
the triangular decomposition of matrix for interpolation along Y<!--hbox-->. 
LA is the first dimension of arrays AX, AY, C, F as declared in the 
calling program. For simplicity, the first dimension is assumed to 
be the same in all these arrays. LA has to be greater than the  
maximum of NX and NY<!--hbox-->. C is a real array of length 
<span class="roman">LA</span>&times;<span class="roman">NY</span> which will 
contain the calculated coefficients of expansion. This array will 
be required to evaluate the interpolated value at any given point. 
XF and YF are real arrays of length MX and MY, respectively 
containing the knots for B-splines along X and Y<!--hbox-->. 
MX, MY are the actual number of knots 
used along x and y. These numbers may not be the same as NX, NY since 
some points may have to be dropped to match the number of equations and 
number of B-spline basis functions. IFLG is a flag to decide the 
nature of computations. For IFLG &#8804; 1 the triangular decomposition 
of matrices is calculated, for larger values of IFLG it is assumed that 
the triangular decomposition and other information is already available 
in arrays AX, AY<!--hbox-->. INTX and INTY are integer arrays of lengths NX and NY 
respectively, which will contain the information about pivoting used 
to solve the system of equations for determining the coefficients 
for 1-dimensional interpolation. 
WK is a real array of length <span class="roman">NX</span>&times;<span class="roman">LA</span><span class="roman">+</span><span class="roman">NX</span><span class="roman">+</span><span class="roman">NY</span> used as scratch space. 
IER is the error parameter. IER=0 implies successful execution of 
the program. Nonzero values may be set by BSPINT, BSPLIN or <a href="appendixb.htm#gaubnd"> GAUBND</a> 
which are called. This subroutine requires <a href="appendixb.htm#bspint"> BSPINT</a>, <a href="appendixb.htm#bsplin"> BSPLIN</a> and GAUBND<!--hbox-->. 
The interpolated value can be calculated using function routine BSPEV2 
using the coefficients computed by BSPINT2. 

<div class="p"><!----></div>
 <br /><br /><a name="bspev2"> </a>
 <b>25.&nbsp;BSPEV2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspev2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/poly2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the value of 
function using available coefficients of B-spline expansion in two 
dimensions. 
The calculated value is given by: 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">BSPEV</span><span class="roman">2</span>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">NX</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;</td><td nowrap="nowrap" align="center">
<small><span class="roman">NY</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">WT</span>(i, j) &#981;<sub>i</sub>(<span class="roman">X</span><span class="roman">0</span>)&#968;<sub>j</sub>(<span class="roman">Y</span><span class="roman">0</span>), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.6)</td></tr></table>
</td></tr></table>

 
where &#981;<sub>i</sub>(x) are the B-spline basis functions along x 
and &#968;<sub>i</sub>(y) are the B-spline basis functions along y. 
It can be used to calculate the interpolated value of the function 
if the coefficients are already calculated using BSPINT2. 
NX, NY are the number of knots along X, Y, which may not be the same as 
the number of 
points in the table for interpolation. X, Y are real arrays of length 
NX, NY containing the knots for B-splines. 
The knots must be in ascending order with X(1) and Y(1) containing 
the first knot along respective directions. 
K is the order of B-splines, 
<span class="roman">K</span>=2 gives linear B-splines, while <span class="roman">K</span>=4 yields cubic B-splines, etc. 
For simplicity, the order is assumed to be the same along both axes. 
NDERIV specifies the number of derivatives to be calculated. 
For NDERIV &#8804; 0 only the function value will be calculated. 
For NDERIV=1, the first derivatives are also calculated. 
For NDERIV &gt; 1, the second derivatives will also be calculated. 
WT is the real array of length <span class="roman">IW</span>&times;(<span class="roman">NY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2), 
containing the coefficients 
of expansion in terms of B-spline basis functions. These coefficients 
must be calculated beforehand using <a href="appendixb.htm#bspint2"> BSPINT2</a> or any other equivalent 
routine for B-spline approximations.  X0, Y0 is the point 
where the function value needs to be calculated. DFX, DFY are the first 
derivatives of function with respect to x,y respectively, 
at (X0, Y0). while DFXX, DFXY, DFYY are the second derivatives 
&#8706;<sup>2</sup>f/&#8706;x<sup>2</sup>, &#8706;<sup>2</sup>f/&#8706;x&#8706;y, 
&#8706;<sup>2</sup>f/&#8706;y<sup>2</sup>. 
The derivatives would be calculated only if NDERIV has been set 
appropriately. 
WK is a real array of length at least 7&times;max(<span class="roman">NX</span><span class="roman">,</span><span class="roman">NY</span>)+8<span class="roman">K</span>+2 
used as scratch space. 
IER is the error parameter, which should be zero after successful 
execution. Nonzero values of IER may be set by subroutine <a href="appendixb.htm#bsplin"> BSPLIN</a> which is called 
to calculate the B-spline basis functions. 
This routine requires subroutine BSPLIN<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="bspintn"> </a>
 <b>26.&nbsp;BSPINTN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspintn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bspintn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the coefficients for 
B-spline interpolation to a table of values in N dimensions. 
N is the number of dimensions. NK is an integer array of length N, giving 
the number of tabular points along each dimension. NK(I) is the number 
of points along x<sub>I</sub>. X is a real array of length NXD&times;<span class="roman">N</span> 
specifying the 
abscissas along each dimension. X(I, J) is the Ith abscissa along 
the Jth dimension.  For each dimension, the abscissas must be unique 
and in ascending order. NXD is the first dimension of arrays X, XF 
and INTX as specified in the calling program, 
NXD &#8805; max(NK(1), NK(2),&#8230;, NK(N)). 
F is a real array of length NK(1)&times;NK(2)&times;&#8230;&times;NK(N) containing the table of values. Since BSPINTN 
treats this array as a one dimensional array, the dimensions of 
F in the calling program must exactly match the size of the table so that 
there are no gaps in memory allocation. For example, the dimension 
could be F(NK(1), NK(2), &#8230;, NK(N)). Alternately, it could be treated 
as a one dimensional array of appropriate length. 
K is the order of B-spline 
interpolation required. 
<span class="roman">K</span>=4 implies cubic B-splines, while <span class="roman">K</span>=2 gives linear B-splines, etc. 
For simplicity, K is assumed to be the same along all dimensions. 
AX is a real array of length NXD&times;3<span class="roman">K</span>&times;<span class="roman">N</span>, 
which will contain the triangular 
decomposition of the matrix of equations 
that is solved to calculate the coefficients of expansion for 
each dimension. Since 
the matrix is in band form with bandwidth <span class="roman">K</span>&#8722;1, it is stored in 
band form.  
C is a real array of length NK(1)&times;NK(2)&times;&#8230;&times;NK(N), which will contain the coefficients of B-spline 
basis functions in expansion for interpolation. This array is also 
treated as one-dimensional array just like F and hence the dimensions 
in calling program must exactly match the size of the table. 
XF is a real array of size NXD&times;<span class="roman">N</span> which will contain 
the knots used in each dimension. 
This array will contain the knots used for B-spline interpolation in 
each dimension. Since the number of B-spline basis functions 
with MK(I) knots is <span class="roman">MK</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, some tabular points may have to be dropped 
to ensure that <span class="roman">NK</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span><span class="roman">=</span><span class="roman">MK</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2. 
This is equivalent to using the not-a-knot 
boundary conditions in cubic spline interpolation. 
The number of points to be dropped 
depends on K<!--hbox-->. In all cases some points near both ends are dropped. 
For linear B-splines, <span class="roman">K</span>=2 all points are used. For cubic B-splines, 
<span class="roman">K</span>=4, the 2nd and NK(I)&#8722;1 th points are dropped. 
MK is an integer array of length N containing the number of knots 
for B-splines in each dimension. 
MK(I) is the number of knots used for B-spline interpolation, this would 
be equal to NK(I)+2&#8722;<span class="roman">K</span>. 
INTX is an integer array of length NXD&times;<span class="roman">N</span>, which 
will contain the pivoting 
information for solution of system of linear equations. 
WK is a real array of length NK(1)&times;NK(2)&times;&#8230;&times;NK(N)+3<span class="roman">K</span>, used as scratch space. 
IER is the error parameter. IER=0 implies successful execution of 
subroutine. Nonzero values may be set by subroutines BSPINT, 
BSPLIN or GAUBND, which are called. 
It may be noted that for simplicity, this subroutine does not use IFLG 
to control the calculations as for large number of dimensions main 
effort goes in calculating the coefficients rather than in calculating 
the triangular decomposition of matrices. 
This subroutine requires 
subroutine <a href="appendixb.htm#bspint"> BSPINT</a> to perform interpolation in one dimension, 
subroutine <a href="appendixb.htm#bsplin"> BSPLIN</a> to calculate the B-spline basis functions and  
subroutine <a href="appendixb.htm#gaubnd"> GAUBND</a> to solve the system of linear equations with a 
band matrix. The interpolant at any required point 
can be calculated using FUNCTION <a href="appendixb.htm#bspevn">BSPEVN</a>, using the calculated 
coefficients of expansion. If the first derivative of the function is 
also required then use <a href="appendixb.htm#bspevn1">BSPEVN1</a>, while for second derivatives use 
<a href="appendixb.htm#bspevn2">BSPEVN2</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="bspevn"> </a>
 <b>27.&nbsp;BSPEVN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspevn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bspintn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the value of 
function using available coefficients of B-spline expansion in n-dimensions. 
The calculated value is given by: 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">BSPEVN</span>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>1</sub>=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#8230;</td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">(</span><span class="roman">n</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>n</sub>=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">WT</span>(i<sub>1</sub>, &#8230;, i<sub>n</sub>)&times;&#981;<sub>i<sub>1</sub></sub><sup>(1)</sup>(<span class="roman">X</span><span class="roman">0</span>(1))&#8230;&#981;<sub>i<sub>n</sub></sub><sup>(n)</sup>(<span class="roman">X</span><span class="roman">0</span>(n)), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.7)</td></tr></table>
</td></tr></table>
 
where &#981;<sub>i<sub>j</sub></sub><sup>(j)</sup> are the B-spline basis functions along jth 
dimension. 
It can be used to calculate the interpolated value of the function 
if the coefficients are already calculated using BSPINTN<!--hbox-->. 
N is the number of dimensions. 
NK is an integer array of length N containing the number of knots 
along each dimension, which may not be the same as the number of 
points in the table for interpolation. 
NK(I) is the number of knots along the Ith dimension. 
X is a real array of length <span class="roman">NXD</span>&times;<span class="roman">N</span> 
containing the knots for B-splines along each dimension. 
The knots must be distinct and in ascending order with X(I, J) containing 
Ith knot along Jth dimension. 
NXD is the first dimension of array X in the calling program. 
NXD must be greater than or equal to the maximum of <span class="roman">NK</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>. 
K is the order of B-splines, 
<span class="roman">K</span>=2 gives linear B-splines, while <span class="roman">K</span>=4 yields cubic B-splines, etc. 
WT is the real array of length (NK(1)+<span class="roman">K</span>&#8722;2)(NK(2)+<span class="roman">K</span>&#8722;2) &#8230;(NK(N)+<span class="roman">K</span>&#8722;2), containing the coefficients of 
expansion in terms of B-spline basis functions. Since BSPEVN treats 
this array as a one-dimensional array, the dimensions of this array 
in the calling program must exactly match the table size, so that 
there are no gaps in memory allocation. For example, the dimension 
could be WT(NK(1)+K&#8722;2, NK(2)+K&#8722;2, &#8230;, NK(N)+K&#8722;2). 
These coefficients WT 
must be calculated beforehand using <a href="appendixb.htm#bspintn"> BSPINTN</a> or any other equivalent 
routine for B-spline approximations in n-dimensions.  X0 is a 
real array of length N, specifying the coordinates of the point 
where the function value needs to be calculated. 
WK is a real array of length at least 
(NXD+<span class="roman">K</span>)(3N+1)+<span class="roman">K</span>+2 
used as scratch space. 
IWK is an integer array of length at least 2N used as scratch space. 
IER is the error parameter, which should be zero after successful 
execution. Nonzero values of IER may be set by subroutine <a href="appendixb.htm#bsplin"> BSPLIN</a> which is called 
to calculate the B-spline basis functions. 
This routine does not calculate the derivatives of expansion.  
Since calculating derivatives could require considerable extra time,
separate versions of this routine <a href="appendixb.htm#bspevn1">BSPEVN1</a> and
<a href="appendixb.htm#bspevn2">BSPEVN2</a> are 
provided to calculate first and second derivatives. These routines 
can be used instead of BSPEVN when derivatives are required. 
This routine requires subroutine BSPLIN<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="bspevn1"> </a>
 <b>28.&nbsp;BSPEVN1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspevn1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bspintn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the value of 
function and its first derivatives using available coefficients of 
B-spline expansion in n-dimensions. This routine is the version of 
BSPEVN to calculate the first derivatives in addition to function 
values. It can be used when derivatives are also required. The arguments 
are the same as those for BSPEVN, except for array DF of length N, which 
will contain the calculated derivatives with respect to each of the 
dimensions. DF(I) will contain the first derivative with respect to 
x<sub>I</sub> at the point X0. The scratch array WK should have a length 
of at least (NXD+<span class="roman">K</span>)(3N+1)+<span class="roman">K</span><span class="roman">+</span><span class="roman">N</span>+2. 
If only function value is required then <a href="appendixb.htm#bspevn">BSPEVN</a> 
should be used, while if second derivative is also required then 
BSPEVN2 should be used. 

<div class="p"><!----></div>
 <br /><br /><a name="bspevn2"> </a>
 <b>29.&nbsp;BSPEVN2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspevn2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bspintn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the value of 
function and its first and second derivatives using available coefficients of 
B-spline expansion in n-dimensions. This routine is the version of 
BSPEVN to calculate the first  and second derivatives in addition to function 
values. It can be used when derivatives are also required. The arguments 
are the same as those for BSPEVN, except for array DF of length N, which 
will contain the calculated derivatives with respect to each of the 
dimensions. DF(I) will contain the first derivative with respect to 
x<sub>I</sub> at the point X0. DDF is a real array of length 
<span class="roman">N</span>&times;<span class="roman">N</span>, which will contain the calculated second derivatives. DDF(I, J) will contain &#8706;<sup>2</sup> f/&#8706;x<sub>I</sub>&#8706;x<sub>J</sub> 
at the point X0. There is no provision to pass the first dimension of DDF 
and hence it should match the value in this subroutine. 
The scratch array WK should have a length 
of at least (NXD+<span class="roman">K</span>)(3N+1)+<span class="roman">K</span><span class="roman">+</span><span class="roman">N</span>+<span class="roman">N</span><sup>2</sup>+2. 
If second derivatives are not required then it will be 
better to use BSPEVN1 (for first derivatives) or <a href="appendixb.htm#bspevn"> BSPEVN</a> (for only function 
value). 

<div class="p"><!----></div>
 

<br /><br />
<a name="Differentiation"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.5&nbsp; DIFFERENTIATION </b></td></tr></table><!--hboxt-->

<br /> 

<div class="p"><!----></div>
<br /><br /><a name="drvt"> </a>
 <b>30.&nbsp;DRVT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/drvt.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/drvt.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate derivative of a function which 
can be evaluated at any required point using a user supplied function 
routine FUNCTION F(X). This 
subroutine uses h&#8594;0 extrapolation to obtain accurate value of the 
derivative. It can evaluate the first, second, third or fourth derivative 
of the given function. 
A is the 
value of x at which the derivative is to be evaluated. ID is the order 
of the derivative required. ID can be 1, 2, 3 or 4. If any other value is 
specified the program will exit with the error flag IER set to 208. 
HH0 is the initial spacing to be used, which depends on the 
function and the precision of the arithmetic used. A value between 0.1  
and 1 will usually be sufficient. If HH0 is too large, then sufficient 
accuracy may not be achieved by the program, while if it is too small, 
then roundoff error will dominate. AEPS and REPS specify the 
required absolute and relative accuracy. This subroutine exits when 
the difference between successive values is less than 
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">DRVT</span>&#124;), or when roundoff error is 
dominating. The presence of roundoff error is detected by using a simple 
test as explained in Section&nbsp;5.3. F is the name of the function routine which calculates the 
given function at any required point. This routine must be supplied by the 
user. IER is the error parameter, 
which will be set to 28 if sufficient accuracy is not achieved. 
IER will be set to 29 if roundoff errors start dominating before  
adequate convergence is achieved. IER will be set to 208 if ID is outside 
the specified range.  

<div class="p"><!----></div>
 

<br /><br />
<a name="Integration"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.6&nbsp; INTEGRATION </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#simson">SIMSON</a></td>
<td>&nbsp; <a href="#splint">SPLINT</a></td>
<td>&nbsp; <a href="#bspqd">BSPQD</a></td>
<td>&nbsp; <a href="#rombrg">ROMBRG</a></td>
<td>&nbsp; <a href="#epsiln">EPSILN</a></td>
<td>&nbsp; <a href="#gauss">GAUSS</a></td>
<td>&nbsp; <a href="#gaucby">GAUCBY</a></td>
<td>&nbsp; <a href="#gaucb1">GAUCB1</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#gaucb2">GAUCB2</a></td>
<td>&nbsp; <a href="#gausq2">GAUSQ2</a></td>
<td>&nbsp; <a href="#gausq">GAUSQ</a></td>
<td>&nbsp; <a href="#gaulag">GAULAG</a></td>
<td>&nbsp; <a href="#lagure">LAGURE</a></td>
<td>&nbsp; <a href="#hermit">HERMIT</a></td>
<td>&nbsp; <a href="#gaulg2">GAULG2</a></td>
<td>&nbsp; <a href="#gaulog">GAULOG</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#gausrc">GAUSRC</a></td>
<td>&nbsp; <a href="#gauleg">GAULEG</a></td>
<td>&nbsp; <a href="#gaujac">GAUJAC</a></td>
<td>&nbsp; <a href="#lagurw">LAGURW</a></td>
<td>&nbsp; <a href="#gauher">GAUHER</a></td>
<td>&nbsp; <a href="#gauswt">GAUSWT</a></td>
<td>&nbsp; <a href="#filon">FILON</a></td>
<td>&nbsp; <a href="#adpint">ADPINT</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#kronrd">KRONRD</a></td>
<td>&nbsp; <a href="#gaus16">GAUS16</a></td>
<td>&nbsp; <a href="#cauchy">CAUCHY</a></td>
<td>&nbsp; <a href="#euler">EULER</a></td>
<td>&nbsp; <a href="#bspqd2">BSPQD2</a></td>
<td>&nbsp; <a href="#bspqdn">BSPQDN</a></td>
<td>&nbsp; <a href="#mulint">MULINT</a></td>
<td>&nbsp; <a href="#ngauss">NGAUSS</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#sphnd">SPHND</a></td>
<td>&nbsp; <a href="#strint">STRINT</a></td>
<td>&nbsp; <a href="#stroud">STROUD</a></td>
<td>&nbsp; <a href="#mcarlo">MCARLO</a></td>
<td>&nbsp; <a href="#ran">RAN</a></td>
<td>&nbsp; <a href="#ranf">RANF</a></td>
<td>&nbsp; <a href="#equids">EQUIDS</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="simson"> </a>
 <b>31.&nbsp;SIMSON&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/simson.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/quad.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to integrate a smooth function over 
a finite interval using composite Simpson's rule. 
RI is the output parameter containing the calculated 
value of the integral. XL and XU are the lower and upper limits for 
the integral. It is not essential to have <span class="roman">XL</span>  &lt;  <span class="roman">XU</span>. REPS and 
AEPS specify the required relative and absolute accuracy. The calculations 
are terminated when two successive values differ by less than 
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RI</span>&#124;). 
DIF is an output parameter containing 
an estimate of (absolute) error calculated by the subroutine. N is an 
output parameter which will contain the number of function evaluations 
used by the subroutine. IER is the error parameter. IER=30 denotes 
that the subroutine has failed to converge to the specified accuracy. 
In most cases the computed value of the integral may still be approximately 
correct. Only in extreme cases the computed value will be far from actual 
value. 
In this case, RI will contain the best estimate for integral 
and DIF should contain the estimated error. 
The parameter NMAX in the subroutine could be increased, if larger 
number of function evaluations are to be allowed. However, in most case, 
it will be better to use another technique for evaluating the integral. 
FUN is the name of the function routine to calculate the integrand. 
FUNCTION FUN(X) must be supplied by the user. 

<div class="p"><!----></div>
 <br /><br /><a name="splint"> </a>
 <b>32.&nbsp;SPLINT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/splint.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/splint.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function supplied 
in the form of a table of values by integrating the interpolating 
cubic spline. Before calling this subroutine, the coefficients of cubic 
spline must be calculated by a call to subroutine SPLINE<!--hbox-->. 
SINT and TINT are the output parameters 
containing the value of the integral. SINT is the estimate using 
cubic spline, while TINT is the trapezoidal rule estimate, using only the 
tabular points. The difference between TINT and SINT may give some 
estimate of truncation error in the calculations. 
If the limits are not among the tabular points, then the 
function value at the end points are obtained using function SPLEVL<!--hbox-->. 
A and B are the lower and 
upper limits of the integral. It is  essential to ensure that <span class="roman">A</span> &lt; <span class="roman">B</span>. 
N is the number of points in the table of values. X and F are real arrays 
of length  N, containing the abscissas and function values.  
The abscissas must be supplied in ascending order. C is 
a real array of length 3&times;<span class="roman">N</span> containing the coefficients of cubic 
spline, which may be calculated using the subroutine SPLINE<!--hbox-->. IER 
is the error parameter. 
IER=31 denotes that the lower limit A is outside the limits of table, 
while IER=32 denotes that the upper limit 
B is outside the limits of table. In such 
cases, the accuracy of integration may be questionable. 
IER=301 implies that 
<span class="roman">A</span> &gt; <span class="roman">B</span> or <span class="roman">X</span>(1) &gt; <span class="roman">X</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span>. 
This subroutine 
requires function <a href="appendixb.htm#splevl"> SPLEVL</a> to evaluate the cubic spline, while subroutine 
<a href="appendixb.htm#spline">SPLINE</a> will be required to calculate the coefficients of cubic spline 
before calling this subroutine. 

<div class="p"><!----></div>
 <br /><br /><a name="bspqd"> </a>
 <b>33.&nbsp;BSPQD&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspqd.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/splint.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to compute integral of an expansion in 
terms of B-spline basis functions. The expansion may be obtained by 
interpolating or approximating a table of values. 
Before calling this subroutine, the coefficients of B-spline 
expansion must be calculated by a call to subroutine BSPINT<!--hbox-->. 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 <span class="roman">BSPQD</span>=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">XU</span></small><!--sup
--><br /><br />
<small><span class="roman">XL</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp; </td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">WT</span><span class="roman">(</span><span class="roman">i</span><span class="roman">)</span>&nbsp;&nbsp;&#981;<sub>i</sub>(x)&nbsp;&nbsp;dx&nbsp;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.8)</td></tr></table>
</td></tr></table>

 
where &#981;<sub>i</sub>(x) are the B-spline basis functions of order K<!--hbox-->. 
N is the number of knots, X is a real array of length N 
containing the knots for B-splines.  
The knots must be in ascending order with X(1) containing the first 
knot. 
K is the order of B-splines, 
<span class="roman">K</span>=2 gives linear B-splines, while <span class="roman">K</span>=4 yields cubic B-splines, etc. 
WT is a real array of length <span class="roman">N</span><span class="roman">+</span><span class="roman">K</span>&#8722;2 containing the coefficients 
of expansion in terms of B-spline basis functions. These coefficients 
may be calculated using <a href="appendixb.htm#bspint"> BSPINT</a> for interpolation in a table of values. 
XL and XU are the lower and 
upper limits of the integral. 
WK is a real array of length at least 5<span class="roman">N</span>+6<span class="roman">K</span>+9 used as scratch space. 
IER is the error parameter. 
IER=31 denotes that the lower limit XL is outside the limits of table, 
while IER=32 denotes that the upper limit 
XU is outside the limits of table. In such 
cases, the accuracy of integration may be questionable. 
Other values of IER may be set by subroutine BSPLIN which is called 
to calculate B-spline basis functions. 
This subroutine 
requires function <a href="appendixb.htm#bsplin"> BSPLIN</a> to evaluate the B-spline basis functions, 
 while subroutine 
<a href="appendixb.htm#bspint"> BSPINT</a> will be required to calculate the coefficients of B-spline 
before calling this subroutine. 

<div class="p"><!----></div>
 <br /><br /><a name="rombrg"> </a>
 <b>34.&nbsp;ROMBRG&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/rombrg.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/quad.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function over 
a finite interval, using 
Romberg integration or the h&#8594;0 extrapolation. RI is the output parameter 
containing the value of the integral. A and B are the lower and 
upper limits of the integral. It is not essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>. GI is 
a real array of dimension  NMAX (=13), 
containing the expected values of successive exponents 
in the error expansion for the trapezoidal rule. If <span class="roman">GI</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> &#8804; 0, 
then it will be set to 2I, which is the correct value for smooth 
functions. AEPS and REPS specify the required absolute and relative accuracy.  
The calculations 
are terminated when the successive values differ by less than 
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RI</span>&#124;). DIF is an 
output parameter giving the error as estimated by the subroutine. 
N specifies the number of abscissas to be used for the first attempt 
with trapezoidal rule. After execution, N will contain the number of abscissas 
actually used by the subroutine. Hence, N will have to be reset after 
every call to the subroutine. 
If <span class="roman">N</span> &lt; 2 it will be set to a default value of 2. 
On the other hand, if <span class="roman">N</span> &gt; <span class="roman">NPT</span>&nbsp;&nbsp;(=100), then it will be set to a 
default value of 
2 and the error flag IER will be set to 33. In particular, this situation may 
arise if N is not reset after the previous call to the subroutine. 
IER is the error parameter. 
IER=30 denotes that the subroutine failed to converge to the specified 
accuracy. In this case, RI will contain the best estimate for the integral 
and DIF should contain the estimated error. 
The parameter NMAX inside the subroutine could be increased to allow 
for larger number of function evaluations, but it is better to use some 
other technique for evaluating the integral. FUN is the name of the 
function routine used to calculate the value of the integrand. 
FUNCTION FUN(X) must be supplied by the user. This subroutine should 
be used for smooth functions with GI(I)=0. It can also handle 
algebraic singularity at one or both end points, provided correct 
values of GI are supplied. 

<div class="p"><!----></div>
 <br /><br /><a name="epsiln"> </a>
 <b>35.&nbsp;EPSILN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/epsiln.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/quad.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function over 
a finite interval, using 
&#1013;-algorithm to accelerate the convergence. RI is the output parameter 
containing the value of the integral. A and B are the lower and 
upper limits of the integral. It is not essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>. 
AEPS and REPS specify the required absolute and relative accuracy.  
The calculations 
are terminated when the successive values differ by less than 
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RI</span>&#124;). DIF is an 
output parameter giving the error as estimated by the subroutine. 
N specifies the number of abscissas to be used for the first attempt 
with trapezoidal rule. After execution, N will contain the number of abscissas 
actually used by the subroutine. Hence, N will have to be reset after 
every call to the subroutine. 
If <span class="roman">N</span> &lt; 2, it will be set to a default value of 2. 
On the other hand, if <span class="roman">N</span> &gt; <span class="roman">NPT</span>&nbsp;&nbsp;(=100), then it will be set to a 
default value of 
2 and the error flag IER will be set to 33. In particular, this situation may 
arise if N is not reset after the previous call to the subroutine. 
IER is the error parameter. 
IER=30 denotes that the subroutine failed to converge to the specified 
accuracy. 
IER=34 denotes that at some stage while constructing the &#1013;-table, 
the denominator was zero. In this case, the calculations are continued 
further after ignoring the corresponding term. This may be justified if 
this problem occurs in higher columns which are not converging because 
of roundoff error. A better strategy would be to stop calculating the 
higher columns. 
IER=35 denotes that the roundoff error 
is dominating and the calculations are terminated, even though the required 
accuracy is not achieved. 
In all these cases, RI will contain the best estimate for the integral 
and DIF should contain the estimated error. 
The parameter NMAX inside the subroutine could be increased to allow 
for larger number of function evaluations, but that is not 
recommended. FUN is the name of the 
function routine used to calculate the value of the integrand. 
FUNCTION FUN(X) must be supplied by the user. This subroutine could 
be used for singular integrands, if only moderate accuracy is required. 
It will fail to converge to high accuracy because of roundoff error. 

<div class="p"><!----></div>
 <br /><br /><a name="gauss"> </a>
 <b>36.&nbsp;GAUSS&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gauss.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/quad.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function over a 
finite interval, using 
composite Gauss-Legendre formulae. RINT is the output parameter 
containing the value of the integral. A and B are the lower and 
upper limits of the integral. It is not essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>. 
NP specifies the formula to be used. This subroutine uses a composite rule 
based on NP-point Gauss-Legendre formula. NP should be 2, 4, 8, 16 or 32, 
since these are the only formulae for which the weights and abscissas are 
incorporated. If NP is not equal to one of these values, then it will be set 
to a default value of 8, and error flag IER will be set to 36. 
AEPS and REPS specify the required absolute and relative accuracy. 
The calculations 
are terminated when the successive values differ by less than 
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). DIF is an 
output parameter giving the error as estimated by the subroutine. 
NPT is an output parameter containing the number of function 
evaluations actually used by the subroutine. IER is the error parameter. 
IER=30 denotes that the subroutine failed to converge to the specified 
accuracy. 
In this case, RINT will contain the best estimate for the integral 
and DIF should contain the estimated error. In such cases, attempt could 
be made to use higher order Gaussian formula, NP=32 is the maximum 
value allowed by this subroutine. 
The parameter NMAX inside the subroutine could be increased to allow 
for larger number of function evaluations, but it will be preferable to 
use some other technique for evaluating the integral. IER=36 implies that 
NP was not 2,4,8,16 or 32, in which case it is set to 8. 
FUN is the name of the 
function routine used to calculate the value of the integrand. 
FUNCTION FUN(X) must be supplied by the user. This subroutine should 
be used for smooth  functions. NP could be set to a low value 
if only moderate accuracy is required, while for high accuracy NP may 
be increased. The optimum value of NP will depend on the degree of smoothness 
of the integrand and the accuracy required. 

<div class="p"><!----></div>
 <br /><br /><a name="gaucby"> </a>
 <b>37.&nbsp;GAUCBY&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gaucby.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gaucby.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function using 
Gauss-Chebyshev formulae with weight function 1/&#8730;{(x&#8722;<span class="roman">A</span>)(<span class="roman">B</span>&#8722;x)}. 
RINT is the output parameter 
containing the value of the integral. A and B are the lower and 
upper limits of the integral. It is essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>. 
AEPS and REPS specify the required absolute and relative accuracy. 
The calculations 
are terminated when the successive values differ by less than 
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). DIF is an 
output parameter giving the error as estimated by the subroutine. 
NPT is an output parameter containing the number of function 
evaluations actually used by the subroutine. IER is the error parameter. 
IER=30 denotes that the subroutine failed to converge to the specified 
accuracy. 
In this case, RINT will contain the best estimate for the integral 
and DIF should contain the estimated error. 
The parameter NMAX inside the subroutine could be increased to allow 
for larger number of function evaluations, but it will be preferable to 
use some other technique for evaluating the integral. FUN is the name of the 
function routine used to calculate the value of the integrand multiplied 
by &#8730;{(x&#8722;<span class="roman">A</span>)(<span class="roman">B</span>&#8722;x)}. 
FUNCTION FUN(X) must be supplied by the user. This subroutine should 
be used for functions with square root singularity at both ends. 
It will evaluate the integral 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">B</span></small><!--sup
--><br /><br />
<small><span class="roman">A</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">FUN</span>(x)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">(x&#8722;<span class="roman">A</span>)(<span class="roman">B</span>&#8722;x)<br /></div>                                </td></tr></table></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;dx&nbsp;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.9)</td></tr></table>
</td></tr></table>

 

<div class="p"><!----></div>
 <br /><br /><a name="gaucb1"> </a>
 <b>38.&nbsp;GAUCB1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gaucb1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gaucb1.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function using 
Gauss-Chebyshev formulae with weight function &#8730;{(x&#8722;<span class="roman">A</span>)/(<span class="roman">B</span>&#8722;x)}. 
RINT is the output parameter 
containing the value of the integral. A and B are the lower and 
upper limits of the integral. It is essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>. 
AEPS and REPS specify the required absolute and relative accuracy. 
The calculations 
are terminated when the successive values differ by less than 
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). DIF is an 
output parameter giving the error as estimated by the subroutine. 
NPT is an output parameter containing the number of function 
evaluations actually used by the subroutine. IER is the error parameter. 
IER=30 denotes that the subroutine failed to converge to the specified 
accuracy. 
In this case, RINT will contain the best estimate for the integral 
and DIF should contain the estimated error. 
The parameter NMAX inside the subroutine could be increased to allow 
for larger number of function evaluations, but it will be preferable to 
use some other technique for evaluating the integral. FUN is the name of the 
function routine used to calculate the value of the integrand multiplied 
by &#8730;{(<span class="roman">B</span>&#8722;x)/(x&#8722;<span class="roman">A</span>)}. 
FUNCTION FUN(X) must be supplied by the user. This subroutine should 
be used for functions with square root singularity at both ends. 
It will evaluate the integral 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">B</span></small><!--sup
--><br /><br />
<small><span class="roman">A</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">FUN</span>(x)</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">x&#8722;<span class="roman">A</span><br /></div>                                </td></tr></table>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><span class="roman">B</span>&#8722;x<br /></div>                                </td></tr></table></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;dx&nbsp;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.10)</td></tr></table>
</td></tr></table>

 

<div class="p"><!----></div>
 <br /><br /><a name="gaucb2"> </a>
 <b>39.&nbsp;GAUCB2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gaucb2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gaucb2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function using 
Gauss-Chebyshev formulae with weight function &#8730;{(x&#8722;<span class="roman">A</span>)(<span class="roman">B</span>&#8722;x)}. 
RINT is the output parameter 
containing the value of the integral. A and B are the lower and 
upper limits of the integral. It is essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>. 
AEPS and REPS specify the required absolute and relative accuracy. 
The calculations 
are terminated when the successive values differ by less than 
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). DIF is an 
output parameter giving the error as estimated by the subroutine. 
NPT is an output parameter containing the number of function 
evaluations actually used by the subroutine. IER is the error parameter. 
IER=30 denotes that the subroutine failed to converge to the specified 
accuracy. 
In this case, RINT will contain the best estimate for the integral 
and DIF should contain the estimated error. 
The parameter NMAX inside the subroutine could be increased to allow 
for larger number of function evaluations, but it will be preferable to 
use some other technique for evaluating the integral. FUN is the name of the 
function routine used to calculate the value of the integrand divided 
by &#8730;{(<span class="roman">B</span>&#8722;x)(x&#8722;<span class="roman">A</span>)}. 
FUNCTION FUN(X) must be supplied by the user. This subroutine should 
be used for functions with square root singularity at both ends. 
It will evaluate the integral 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">B</span></small><!--sup
--><br /><br />
<small><span class="roman">A</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">FUN</span>(x)</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">(x&#8722;<span class="roman">A</span>)(<span class="roman">B</span>&#8722;x)<br /></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;dx&nbsp;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.11)</td></tr></table>
</td></tr></table>

 

<div class="p"><!----></div>
 <br /><br /><a name="gausq2"> </a>
 <b>40.&nbsp;GAUSQ2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gausq2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gausq.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function with 
square root singularity over 
(0, a] using a combination of Gauss-Legendre and a Gaussian formula 
with 1/&#8730;x weight function. 
RINT is the output parameter 
containing the value of the integral. A is the upper 
limit of the integral. A1 is the point at which the integral is broken, 
with the integral over [<span class="roman">A</span><span class="roman">1</span><span class="roman">,</span><span class="roman">A</span>] being evaluated using Gauss-Legendre 
formula, while that over (0, <span class="roman">A</span><span class="roman">1</span>] is evaluated using a 
Gaussian formula with 1/&#8730;x weight function. 
If <span class="roman">A</span> &lt; <span class="roman">A</span><span class="roman">1</span>, then A1 is set equal to A to 
start with. A1 is adjusted by the subroutine to achieve the required accuracy. 
After execution, A1 will contain the final value used by the subroutine. 
A1 may need to be reset after every call to GAUSQ2<!--hbox-->. If the next integral is 
similar to the previous one, then the value of A1 need not be reset, since 
it is probably the required value. 
AEPS and REPS specify the required absolute and relative accuracy. 
The calculations 
are terminated when the successive values differ by less than 
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). 
Convergence is checked separately for the two integrals. 
DIF is an 
output parameter giving the error as estimated by the subroutine. 
NP is the output parameter 
containing the number of function evaluations 
actually used by the subroutine. This subroutine calls the subroutines 
GAUSS and GAUSQ to perform the integration over required subintervals. 
IER is the error parameter. 
IER=30 denotes that the subroutine GAUSS failed to converge to the specified 
accuracy over the interval [<span class="roman">A</span><span class="roman">1</span><span class="roman">,</span><span class="roman">A</span>]. IER=37 denotes that the subroutine 
GAUSQ failed to converge to the specified accuracy, even when A1 was reduced 
to its minimum permissible value of AMN (=0.01). 
This limit is provided to prevent the subroutine from getting into an infinite 
loop. This can happen if the integrand is not in a form f(x)/&#8730;x 
as required for Gaussian formula. If necessary, the lower limit 
AMN can be reduced. 
IER=38 denotes that both subroutines failed. 
In all these cases, RINT will contain the best estimate for the integral 
and DIF should contain the estimated error. 
F is the name of the 
function routine used to calculate the value of the integrand. 
F2 is the name of the function routine used to calculate <tt>F(X)*SQRT(X)</tt>, 
as required by the Gaussian formula. Note that the subroutine 
will find the integral 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)&nbsp;&nbsp;dx=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span></small><!--sup
--><br /><br />
<small><span class="roman">A</span><span class="roman">1</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)&nbsp;&nbsp;dx +</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span><span class="roman">1</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">F</span><span class="roman">2</span>(x)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8730;x<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;dx&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.12)</td></tr></table>
</td></tr></table>

 
Both the FUNCTION F(X), and FUNCTION F2(X) must be supplied by the user. 
The requirement of two separate functions is to avoid possible problems 
caused by singularity in integrand. 
If <span class="roman">A</span>&#8722;<span class="roman">A</span><span class="roman">1</span> &lt; <span class="roman">AEPS</span>, then the 
first integral is not evaluated. This condition may need to be changed 
if the integral can make significant contribution, even though this condition 
is satisfied, which may happen if the limits are very small. 
This subroutine requires subroutines <a href="appendixb.htm#gauss"> GAUSS</a> and GAUSQ<!--hbox-->. 
It should be used only 
for those functions which have square root singularity at x=0. 
It can be used for integrands of form f(x)/&#8730;x, where f(x) 
is regular at x=0. It can also be used for integrands of form 
f(x)&#8730;x=(xf(x))/&#8730;x. 

<div class="p"><!----></div>
 <br /><br /><a name="gausq"> </a>
 <b>41.&nbsp;GAUSQ&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gausq.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gausq.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral  

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">FUN</span>(x)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8730;x<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;dx&nbsp;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.13)</td></tr></table>
</td></tr></table>

 
using Gaussian formulae with 1/&#8730;x weight function. 
The subroutine computes the integral using 
different formulae, until convergence is achieved or until the table of 
weights and abscissas is exhausted. 
RINT is the output parameter 
containing the value of the integral. A is the upper 
limit of the integral.  
REPS and AEPS specify the required  accuracy, while DIF is an 
output parameter giving the error as estimated by the subroutine. 
The convergence criterion used is &#124;<span class="roman">DIF</span>&#124; &lt; max(<span class="roman">REPS</span>&#124;<span class="roman">RINT</span>&#124;, <span class="roman">AEPS</span>). 
IER is the error parameter. 
IER=30 denotes that the subroutine failed to converge to the specified 
accuracy. 
In this case, RINT will contain the best estimate for the integral 
and DIF should contain the estimated error. In such cases, we can try 
to use a lower value of A<!--hbox-->. 
NPT is an output parameter containing the number of function 
evaluations actually used by the subroutine. 
FUN is the name of the 
function routine used to calculate the value of the integrand  
(multiplied by &#8730;x). 
FUNCTION FUN(X) must be supplied by the user. This subroutine should 
be used for functions which have a square root singularity 
(functions of form f(x)/&#8730;x or f(x)&#8730;x) at x=0. 
This routine should be preferably used through <a href="appendixb.htm#gausq2"> GAUSQ2</a>, in which case the 
upper limit A may be adjusted if the required accuracy is not achieved. 

<div class="p"><!----></div>
 <br /><br /><a name="gaulag"> </a>
 <b>42.&nbsp;GAULAG&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gaulag.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gaulag.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function over 
[a,&#8734;) using a combination of Gauss-Laguerre and Gauss-Legendre 
quadrature formulae. 
RINT is the output parameter 
containing the value of the integral. A is the lower 
limit of the integral. A1 is the point at which the integral is broken, 
with the integral over [<span class="roman">A</span><span class="roman">,</span><span class="roman">A</span><span class="roman">1</span>] being evaluated using Gauss-Legendre 
formula, while that over [<span class="roman">A</span><span class="roman">1</span>,&#8734;) is evaluated using the 
Gauss-Laguerre formula. If <span class="roman">A</span><span class="roman">1</span> &lt; <span class="roman">A</span>, then A1 is set equal to A to 
start with. A1 is adjusted by the subroutine to achieve the required accuracy. 
After execution, A1 will contain the final value used by the subroutine. 
A1 may need to be reset after every call to GAULAG<!--hbox-->. If the next integral is 
similar to the previous one, then the value of A1 need not be reset, since 
it is probably the required value. 
AEPS and REPS specify the required absolute and relative accuracy. 
The calculations 
are terminated when the successive values differ by less than 
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). 
Convergence is checked separately for the two integrals. DIF is an 
output parameter giving the error as estimated by the subroutine. 
NP is the output parameter 
containing the number of function evaluations 
actually used by the subroutine. This subroutine calls the subroutines 
GAUSS and <a href="appendixb.htm#lagure"> LAGURE</a> to perform the integration over required subintervals. 
IER is the error parameter. 
IER=30 denotes that the subroutine GAUSS failed to converge to the specified 
accuracy over the interval [<span class="roman">A</span><span class="roman">,</span><span class="roman">A</span><span class="roman">1</span>]. IER=37 denotes that the subroutine 
LAGURE failed to converge to the specified accuracy, even when A1 was raised 
to its maximum permissible value of AMAX (=50). 
This limit is provided to prevent the subroutine from getting into an infinite 
loop. This can happen if the integrand is not in a form e<sup>&#8722;x</sup>f(x) 
as required for Gauss-Laguerre formula. If necessary, the upper limit 
AMAX can be increased. 
IER=38 denotes that both subroutines failed. 
In all these cases, RINT will contain the best estimate for the integral 
and DIF should contain the estimated error. 
F is the name of the 
function routine used to calculate the value of the integrand. 
F2 is the name of the function routine used to calculate <tt>F(X)*EXP(X)</tt>, 
as required by the Gauss-Laguerre formula. Note that the subroutine 
will find the integral 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><br />
<small><span class="roman">A</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)&nbsp;&nbsp;dx=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span><span class="roman">1</span></small><!--sup
--><br /><br />
<small><span class="roman">A</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)&nbsp;&nbsp;dx +</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><br />
<small><span class="roman">A</span><span class="roman">1</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
e<sup>&#8722;x</sup><span class="roman">F</span><span class="roman">2</span>(x)&nbsp;&nbsp;dx&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.14)</td></tr></table>
</td></tr></table>

 
Both the FUNCTION F(X), and FUNCTION F2(X) must be supplied by the user. 
The requirement of two separate functions is to avoid the problem of overflow 
and underflow, which may occur if F2 is formed by adding the exponential 
factor to F inside the subroutine. If <span class="roman">A</span><span class="roman">1</span>&#8722;<span class="roman">A</span> &lt; <span class="roman">AEPS</span>, then the 
first integral is not evaluated. This condition may need to be changed 
if the integral can make significant contribution, even though this condition 
is satisfied, which may happen if the limits are very small. 
This subroutine requires subroutines <a href="appendixb.htm#gauss"> GAUSS</a> and LAGURE<!--hbox-->. 
It should be used only 
for those functions which fall off exponentially at large X<!--hbox-->. Similar 
subroutine can be written to handle singularities by combining the 
Gauss-Legendre formula with another Gaussian formula for singular weight 
functions. 

<div class="p"><!----></div>
 <br /><br /><a name="lagure"> </a>
 <b>43.&nbsp;LAGURE&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/lagure.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gaulag.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral  
&#8747;<sub><span class="roman">A</span></sub><sup>&#8734;</sup> e<sup>&#8722;x</sup><span class="roman">F</span>(x)&nbsp;&nbsp;dx 
using Gauss-Laguerre formulae. The subroutine computes the integral using 
different formulae, until convergence is achieved or until the table of 
weights and abscissas is exhausted. 
RINT is the output parameter 
containing the value of the integral. A is the lower 
limit of the integral.  
REPS and AEPS specify the required  accuracy, while DIF is an 
output parameter giving the error as estimated by the subroutine. 
The convergence criterion used is &#124;<span class="roman">DIF</span>&#124; &lt; max(<span class="roman">REPS</span>&#124;<span class="roman">RINT</span>&#124;, <span class="roman">AEPS</span>). 
NPT is an output parameter containing the number of function 
evaluations actually used by the subroutine. IER is the error parameter. 
IER=30 denotes that the subroutine failed to converge to the specified 
accuracy. 
In this case, RINT will contain the best estimate for the integral 
and DIF should contain the estimated error. In such cases, we can try 
to use a higher value of A<!--hbox-->. 
It may be noted that, depending on the function being integrated 
the higher order formula may have problems, because of underflow and 
overflow on computers with short range for the exponents. 
F is the name of the 
function routine used to calculate the value of the integrand  
(multiplied by e<sup>x</sup>). 
FUNCTION F(X) must be supplied by the user. This subroutine should 
be used for functions which fall off exponentially at large x. 
It will be better to use this routine through <a href="appendixb.htm#gaulag"> GAULAG</a>, which adjusts 
the lower limit A to achieve the required accuracy. 

<div class="p"><!----></div>
 <br /><br /><a name="hermit"> </a>
 <b>44.&nbsp;HERMIT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/hermit.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/hermit.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral  
&#8747;<sub>&#8722;&#8734;</sub><sup>&#8734;</sup> e<sup>&#8722;x<sup>2</sup></sup><span class="roman">F</span>(x)&nbsp;&nbsp;dx 
using Gauss-Hermite formulae. The subroutine computes the integral using 
different formulae, until convergence is achieved or until the table of 
weights and abscissas is exhausted. 
RINT is the output parameter 
containing the value of the integral. 
REPS and AEPS specify the required  accuracy, while DIF is an 
output parameter giving the error as estimated by the subroutine. 
The convergence criterion used is &#124;<span class="roman">DIF</span>&#124; &lt; max(<span class="roman">REPS</span>&#124;<span class="roman">RINT</span>&#124;, <span class="roman">AEPS</span>). 
NPT is an output parameter containing the number of function 
evaluations actually used by the subroutine. IER is the error parameter. 
IER=30 denotes that the subroutine failed to converge to the specified 
accuracy. 
In this case, RINT will contain the best estimate for the integral 
and DIF should contain the estimated error. 
It may be noted that, depending on the function being integrated 
the higher order formula may have problems, because of underflow and 
overflow on computers with short range for the exponents. 
F is the name of the 
function routine used to calculate the value of the integrand  
(multiplied by e<sup>x<sup>2</sup></sup>). 
FUNCTION F(X) must be supplied by the user. This subroutine should 
be used for functions which fall off exponentially as e<sup>&#8722;x<sup>2</sup></sup> 
at large &#124;x&#124;. In this case it is not possible to divide the range 
and hence it is not possible to apply any composite formulae or 
to use a combination of formulae to improve accuracy. 

<div class="p"><!----></div>
 <br /><br /><a name="gaulg2"> </a>
 <b>45.&nbsp;GAULG2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gaulg2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gaulog.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function with 
logarithmic singularity over 
(0, a] using a combination of Gauss-Legendre and a Gaussian formula 
with log(1/x) weight function. 
RINT is the output parameter 
containing the value of the integral. A is the upper 
limit of the integral. A1 is the point at which the integral is broken, 
with the integral over [<span class="roman">A</span><span class="roman">1</span><span class="roman">,</span><span class="roman">A</span>] being evaluated using Gauss-Legendre 
formula, while that over (0, <span class="roman">A</span><span class="roman">1</span>] is evaluated using a 
Gaussian formula with log(1/x) weight function. 
If <span class="roman">A</span> &lt; <span class="roman">A</span><span class="roman">1</span>, then A1 is set equal to A to 
start with. A1 is adjusted by the subroutine to achieve the required accuracy. 
After execution, A1 will contain the final value used by the subroutine. 
A1 may need to be reset after every call to GAULG2<!--hbox-->. If the next integral is 
similar to the previous one, then the value of A1 need not be reset, since 
it is probably the required value. 
AEPS and REPS specify the required absolute and relative accuracy. 
The calculations 
are terminated when the successive values differ by less than 
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RINT</span>&#124;). This criterion is applied 
separately to each part of the integral. 
DIF is an 
output parameter giving the error as estimated by the subroutine. 
NP is the output parameter 
containing the number of function evaluations 
actually used by the subroutine. This subroutine calls the subroutines 
<a href="appendixb.htm#gauss">GAUSS</a> and
<a href="appendixb.htm#gaulog"> GAULOG</a> to perform the integration over required subintervals. 
IER is the error parameter. 
IER=31 denotes that the subroutine GAUSS failed to converge to the specified 
accuracy over the interval [<span class="roman">A</span><span class="roman">1</span><span class="roman">,</span><span class="roman">A</span>]. IER=32 denotes that the subroutine 
GAULOG failed to converge to the specified accuracy, even when A1 was reduced 
to its minimum permissible value of AMN (=0.01). 
This limit is provided to prevent the subroutine from getting into an infinite 
loop. This can happen if the integrand is not in a form f(x)log(x) 
as required for Gaussian formula. If necessary, the lower limit 
AMN can be reduced. 
IER=34 denotes that 
subroutine GAUSS failed while evaluating the integral over [0,A1]. 
In case of multiple failures, the second digit of IER will be the sum 
of these values. 
In all these cases, RINT will contain the best estimate for the integral 
and DIF should contain the estimated error. 
F is the name of the 
function routine used to calculate the value of the integrand. 
F2 is the name of the function routine used to calculate <tt>F(X)/LOG(1/X)</tt>, 
as required by the Gaussian formula. Note that the subroutine 
will find the integral 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)&nbsp;&nbsp;dx=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span></small><!--sup
--><br /><br />
<small><span class="roman">A</span><span class="roman">1</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)&nbsp;&nbsp;dx &#8722;log(<span class="roman">A</span><span class="roman">1)</span></td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span><span class="roman">1</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span><span class="roman">2</span>(x)&nbsp;&nbsp;dx +</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span><span class="roman">1</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span><span class="roman">2</span>(x)log(<span class="roman">A</span><span class="roman">1</span>/x)&nbsp;&nbsp;dx&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.15)</td></tr></table>
</td></tr></table>

 
Both the FUNCTION F(X), and FUNCTION F2(X) must be supplied by the user. 
The requirement of two separate functions is to avoid possible problems 
caused by singularity in integrand. 
The first two integrals should not have any singularity and are evaluated 
using Gauss-Legendre formula, while the last integral is evaluated using 
Gaussian formula with logarithmic singularity. 
Note that the last two integrals arise when the range in integral over 
(0, A1] is transformed to (0, 1]. 
If <span class="roman">A</span>&#8722;<span class="roman">A</span><span class="roman">1</span> &lt; <span class="roman">AEPS</span>, then the 
first integral is not evaluated. This condition may need to be changed 
if the integral can make significant contribution, even though this condition 
is satisfied, which may happen if the limits are very small. 
This subroutine requires subroutines <a href="appendixb.htm#gauss"> GAUSS</a> and GAULOG<!--hbox-->. 
It should be used only 
for those functions which have logarithmic singularity at x=0. 

<div class="p"><!----></div>
 <br /><br /><a name="gaulog"> </a>
 <b>46.&nbsp;GAULOG&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gaulog.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gaulog.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral  

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">A</span></small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(x)log(<span class="roman">A</span>/x)&nbsp;&nbsp;dx&nbsp;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.16)</td></tr></table>
</td></tr></table>

 
using Gaussian formulae with log(<span class="roman">A</span>/x) weight function. 
The subroutine computes the integral using 
different formulae, until convergence is achieved or until the table of 
weights and abscissas is exhausted. 
RINT is the output parameter 
containing the value of the integral. A is the upper 
limit of the integral.  
REPS and AEPS specify the required  accuracy, while DIF is an 
output parameter giving the error as estimated by the subroutine. 
The convergence criterion used is &#124;<span class="roman">DIF</span>&#124; &lt; max(<span class="roman">REPS</span>&#124;<span class="roman">RINT</span>&#124;, <span class="roman">AEPS</span>). 
IER is the error parameter. 
IER=30 denotes that the subroutine failed to converge to the specified 
accuracy. 
In this case, RINT will contain the best estimate for the integral 
and DIF should contain the estimated error. In such cases, we can try 
to use a lower value of A<!--hbox-->. 
NPT is an output parameter containing the number of function 
evaluations actually used by the subroutine. 
F is the name of the 
function routine used to calculate the value of the integrand  
(divided by log<span class="roman">(A</span>/x)). 
FUNCTION F(X) must be supplied by the user. This subroutine should 
be used for functions which have a logarithmic singularity at x=0. 
It would be better to use this routine through <a href="appendixb.htm#gaulg2"> GAULG2</a> which adjusts 
the value of A to achieve required accuracy. 

<div class="p"><!----></div>
 <br /><br /><a name="gausrc"> </a>
 <b>47.&nbsp;GAUSRC&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gausrc.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gausrc.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate weights and abscissas of 
a Gaussian quadrature formula, with arbitrary weight function. 
This subroutine requires the recurrence relation for the corresponding 
orthogonal polynomials. 
The recurrence relation is assumed to be in the form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 P<sub>j</sub>(x)=(a<sub>j</sub> x +b<sub>j</sub>)P<sub>j&#8722;1</sub>(x)&#8722;c<sub>j</sub> P<sub>j&#8722;2</sub>(x), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.17)</td></tr></table>
</td></tr></table>

 
where P<sub>j</sub>(x) is the orthogonal polynomial of degree j in x. 
The coefficients a<sub>j</sub>,b<sub>j</sub>,c<sub>j</sub> for j=1,2,&#8230;,n must be supplied. 
Here N is the number 
of abscissas in the required Gaussian formula. Output parameters W and AB are real arrays 
of length  N, containing the weights and corresponding 
abscissas.  
COF is a real array of length 3&times;<span class="roman">N</span> containing the coefficients 
in the recurrence relation for the polynomials. COF(1, i), COF(2, i) 
and COF(3, i) are respectively, a<sub>i</sub>,b<sub>i</sub>,c<sub>i</sub> as defined above. 
These coefficients must be supplied. 
RI0 is the integral 
 &#8747;<sub>a</sub><sup>b</sup>w(x)&nbsp;&nbsp;dx for the required weight function over the corresponding 
interval. If this integral is not known it must be evaluated using 
appropriate quadrature formula before using this subroutine to calculate 
the weights and abscissas. 
IER is the error parameter. 
If <span class="roman">N</span> &#8804; 0 then IER is set to 302 and no 
calculations are performed. 
IER=321 implies that some coefficient becomes imaginary during 
calculation. This could happen only if coefficients for 
recurrence relation are not specified correctly. 
Other values may be set by TQL2 which is called to solve the eigenvalue 
problem. 
WK is a real array of length <span class="roman">N</span>&times;(<span class="roman">N</span>+2) used as 
scratch space. 
There is no error check 
on the output and the accuracy can be tested by integrating the 
functions w(x)x<sup>n</sup>  for n=0,1,&#8230;,2<span class="roman">N</span>&#8722;1, using the calculated 
weights and abscissas. This routine is in general better conditioned 
than <a href="appendixb.htm#gauswt"> GAUSWT</a>, which uses only the moments. 
This routine requires subroutine <a href="appendixb.htm#tql2"> TQL2</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="gauleg"> </a>
 <b>48.&nbsp;GAULEG&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gauleg.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gauleg.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate weights and abscissas of 
a Gauss-Legendre quadrature formula. 
This subroutine uses the recurrence relation for Legendre 
polynomials 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 nP<sub>n</sub>(x)=(2n&#8722;1)xP<sub>n&#8722;1</sub>(x)&#8722;(n&#8722;1)P<sub>n&#8722;2</sub>(x), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.18)</td></tr></table>
</td></tr></table>

 
to calculate the weights and abscissas using subroutine GAUSRC<!--hbox-->. 
Here N is the number 
of abscissas in the required Gaussian formula. Output parameters W and A are real arrays 
of length  N, containing the weights and corresponding 
abscissas.  
IER is the error parameter. IER=0 implies successful execution. 
Nonzero values may be set by subroutine GAUSRC<!--hbox-->. 
WK is a real array of length <span class="roman">N</span>&times;(<span class="roman">N</span>+2)+3(<span class="roman">N</span>+1) used as 
scratch space. 
There is no error check 
on the output and the accuracy can be tested by integrating the 
functions x<sup>j</sup>  for j=0,1,&#8230;,2<span class="roman">N</span>&#8722;1, using the calculated 
weights and abscissas. 
This routine requires subroutines <a href="appendixb.htm#gausrc"> GAUSRC</a> and <a href="appendixb.htm#tql2"> TQL2</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="gaujac"> </a>
 <b>49.&nbsp;GAUJAC&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gaujac.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gaujac.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate weights and abscissas of 
a Gauss-Jacobi quadrature formula. 
This subroutine uses the recurrence relation for Jacobi 
polynomials 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
2n(n+&#945;+&#946;)(2n&#8722;2+&#945;+&#946;)P<sub>n</sub><sup>&#945;,&#946;</sup>(x)=</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6> </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8722;2(n&#8722;1+&#945;)(n&#8722;1+&#946;)(2n+&#945;+&#946;)P<sub>n&#8722;2</sub><sup>&#945;,&#946;</sup>(x)</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+(2n&#8722;1+&#945;+&#946;)</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
&#945;<sup>2</sup>&#8722;&#946;<sup>2</sup>+(2n+&#945;+&#946;) (2n&#8722;2+&#945;+&#946;)x</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
P<sub>n&#8722;1</sub><sup>&#945;,&#946;</sup>(x),</td></tr></table></td></tr></table>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.19) </td></tr></table>

 
to calculate the weights and abscissas using subroutine GAUSRC<!--hbox-->. 
Here N is the number 
of abscissas in the required Gaussian formula while ALP and BETA are 
the indices 
&#945; and &#946; in (<span class="roman">B</span>.19). The corresponding weight function is 
w(x)=(1&#8722;x)<sup>&#945;</sup> (1+x)<sup>&#946;</sup> on the interval (&#8722;1,1). 
Output parameters W and A are real arrays 
of length  N, containing the weights and corresponding 
abscissas.  
IER is the error parameter. IER=0 implies successful execution. 
IER=313 implies ALP &#8804; &#8722;1 or BETA &#8804; &#8722;1. 
Other values may be set by subroutine GAUSRC<!--hbox-->. 
WK is a real array of length <span class="roman">N</span>&times;(<span class="roman">N</span>+2)+3(<span class="roman">N</span>+1) used as 
scratch space. 
There is no error check 
on the output and the accuracy can be tested by integrating the 
functions (1&#8722;x)<sup>&#945;</sup>(1+x)<sup>&#946;</sup> x<sup>j</sup> for j=0,1,&#8230;,2<span class="roman">N</span>&#8722;1, 
using the calculated weights and abscissas. 
Setting ALP=0 and BETA=0 in this routine 
should yield the Gauss-Legendre formula. 
Similarly, setting ALP=&#8722;1/2 and 
BETA=&#8722;1/2 should yield the Gauss-Chebyshev formula. 
Using &#945; = 0 one can calculate quadrature formulae for algebraic 
singularity of form t<sup>&#946;</sup>, by transforming the lower limit to t=0. 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>1</small><!--sup
--><br /><br />
<small>&#8722;1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
(1&#8722;x)<sup>&#945;</sup>(1+x)<sup>&#946;</sup> f(x)&nbsp;&nbsp;dx = 2<sup>&#945;+&#946;+1</sup></td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>1</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
(1&#8722;t)<sup>&#945;</sup> t<sup>&#946;</sup> f(2t&#8722;1)&nbsp;&nbsp;dt&nbsp;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.20)</td></tr></table>
</td></tr></table>

 
Thus for integration over interval (0,1) the weights W(I) should 
be divided by 2<sup>1+&#945;+&#946;</sup> and abscissas should be (1+A(I))/2. 
This routine requires subroutines <a href="appendixb.htm#gausrc"> GAUSRC</a> and <a href="appendixb.htm#tql2"> TQL2</a> and function 
<a href="appendixb.htm#gamma"> GAMMA</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="lagurw"> </a>
 <b>50.&nbsp;LAGURW&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/lagurw.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/lagurw.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate weights and abscissas of 
a Gauss-Laguerre quadrature formula. 
This subroutine uses the recurrence relation for associated Laguerre 
polynomials 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 nL<sub>n</sub><sup>&#945;</sup>(x)=(n+&#945;)</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
(2n&#8722;1+&#945;)&#8722;x</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
L<sub>n&#8722;1</sub><sup>&#945;</sup>(x)&#8722; (n&#8722;1+&#945;)<sup>2</sup>(n+&#945;)L<sub>n&#8722;2</sub><sup>&#945;</sup>(x), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.21)</td></tr></table>
</td></tr></table>

 
to calculate the weights and abscissas using subroutine GAUSRC<!--hbox-->. 
Here N is the number 
of abscissas in the required Gaussian formula and ALP is the index 
&#945; in (<span class="roman">B</span>.21). The corresponding weight function is 
w(x)=x<sup>&#945;</sup> e<sup>&#8722;x</sup> on the interval (0,&#8734;). 
Output parameters W and A are real arrays 
of length  N, containing the weights and corresponding 
abscissas.  
IER is the error parameter. IER=0 implies successful execution. 
IER=313 implies ALP &#8804; &#8722;1. 
Other values may be set by subroutine GAUSRC<!--hbox-->. 
WK is a real array of length <span class="roman">N</span>&times;(<span class="roman">N</span>+2)+3(<span class="roman">N</span>+1) used as 
scratch space. 
There is no error check 
on the output and the accuracy can be tested by integrating the 
functions e<sup>&#8722;x</sup>x<sup>j+&#945;</sup> for j=0,1,&#8230;,2<span class="roman">N</span>&#8722;1, 
using the calculated weights and abscissas. 
For ALP=0 it will yield the standard Gauss-Laguerre 
quadrature formula. 
This routine requires subroutines <a href="appendixb.htm#gausrc"> GAUSRC</a> and <a href="appendixb.htm#tql2"> TQL2</a> and function 
<a href="appendixb.htm#gamma"> GAMMA</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="gauher"> </a>
 <b>51.&nbsp;GAUHER&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gauher.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gauher.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate weights and abscissas of 
a Gauss-Hermite quadrature formula. 
This subroutine uses the recurrence relation for Hermite 
polynomials 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 H<sub>n</sub>(x)=2xH<sub>n&#8722;1</sub>(x)&#8722; 2(n&#8722;1)H<sub>n&#8722;2</sub>(x), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.22)</td></tr></table>
</td></tr></table>

 
to calculate the weights and abscissas using subroutine GAUSRC<!--hbox-->. 
Here N is the number 
of abscissas in the required Gaussian formula. 
The corresponding weight function is w(x)=e<sup>&#8722;x<sup>2</sup></sup> on the interval (&#8722;&#8734;,&#8734;). 
Output parameters W and A are real arrays 
of length  N, containing the weights and corresponding 
abscissas.  
IER is the error parameter. IER=0 implies successful execution. 
Nonzero values may be set by subroutine GAUSRC<!--hbox-->. 
WK is a real array of length <span class="roman">N</span>&times;(<span class="roman">N</span>+2)+3(<span class="roman">N</span>+1) used as 
scratch space. 
There is no error check 
on the output and the accuracy can be tested by integrating the 
functions e<sup>&#8722;x<sup>2</sup></sup>x<sup>j</sup> for j=0,1,&#8230;,2<span class="roman">N</span>&#8722;1, 
using the calculated weights and abscissas. 
This routine requires subroutines <a href="appendixb.htm#gausrc"> GAUSRC</a> and <a href="appendixb.htm#tql2"> TQL2</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="gauswt"> </a>
 <b>52.&nbsp;GAUSWT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gauswt.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gauswt.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate weights and abscissas of 
a Gaussian quadrature formula, with arbitrary weight function. 
This subroutine requires the values of moments i.e., the integrals 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">FMOM</span>(m)=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>b</small><!--sup
--><br /><br />
<small>a</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
w(x)x<sup>m</sup>&nbsp;&nbsp;dx&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m=0,1,&#8230;,2<span class="roman">N</span>&#8722;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.23)</td></tr></table>
</td></tr></table>

 
Existence of such 
formulae should be ensured before trying to use this subroutine. 
If w(x) &gt; 0 throughout the interval, then such formulae should exist. 
Here N is the number 
of abscissas in the required Gaussian formula. Output parameters W and AB are real arrays 
of length  N, containing the weights and corresponding 
abscissas. N should be less than NPMAX (=65).  
FMOM is the name of the function routine which 
calculates the moments as defined above. FUNCTION FMOM(M) must be 
supplied by the user. QGAUS is a logical parameter which specifies the 
type of formula required. If QGAUS=.TRUE., then a Gaussian formula is 
found, while if QGAUS=.FALSE., then the subroutine calculates the 
weights for an interpolatory formula with given 
weight function.  In this case, the array AB must contain the required 
abscissas. IER is the error parameter. 
If <span class="roman">N</span> &#8804; 0 or <span class="roman">N</span> &#8805; <span class="roman">NPMAX</span>, then IER is set to 303 and no 
calculations are performed. IER=322 implies that the subroutine <a href="appendixb.htm#gauelm"> GAUELM</a> 
failed to find the coefficients of the required polynomial. IER=323 
implies that the subroutine POLYR failed to find zeros of the polynomial. 
Both these errors can occur only for QGAUS=.TRUE. and 
in both these cases, no further calculations are performed. Similarly, 
IER=324 implies that subroutine GAUELM failed to calculate the weights. 
In this case, the abscissas are already calculated, but the values may 
not be reliable. IER=322, 323, 324 will normally imply that either the 
Gaussian formula does not exist or the weights and abscissas cannot 
be calculated because of ill-conditioning. In latter case, improving 
the accuracy of arithmetic may help. Even if IER=0,  
the results could be unreliable. In particular, the zeros of polynomial 
may be complex, but only the real part may be returned in AB<!--hbox-->. This failure 
can occur either because of ill-conditioning, or because the formula 
does not exist. 
This subroutine requires subroutines <a href="appendixb.htm#polyr"> POLYR</a> and 
<a href="appendixb.htm#lagitr"> LAGITR</a> for solving the required polynomial, and subroutine <a href="appendixb.htm#gauelm"> GAUELM</a> 
for solving a system of linear equations. The algorithm used here 
is rather ill-conditioned and should not be used for large N, unless 
very high precision arithmetic is being used. There is no error check 
on the output and the accuracy can be tested by integrating the 
functions w(x)x<sup>n</sup>  for n=0,1,&#8230;,2<span class="roman">N</span>&#8722;1, using the calculated 
weights and abscissas. It may be better to use this subroutine in 
double precision. If the recurrence relation for the corresponding 
orthogonal polynomial are known then <a href="appendixb.htm#gausrc"> GAUSRC</a> should be used to 
calculate the weights and abscissas. 

<div class="p"><!----></div>
 <br /><br /><a name="filon"> </a>
 <b>53.&nbsp;FILON&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/filon.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/filon.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to evaluate integrals of the form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>b</small><!--sup
--><br /><br />
<small>a</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
f(x)sin(kx)&nbsp;&nbsp;dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="roman">or</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>b</small><!--sup
--><br /><br />
<small>a</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
f(x)cos(kx)&nbsp;&nbsp;dx&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.24)</td></tr></table>
</td></tr></table>

 
using Filon's method. 
RI is an output parameter which will contain the 
value of the integral. XL and XU are the lower and upper limits for 
the integral. It is not essential to have <span class="roman">XL</span>  &lt;  <span class="roman">XU</span>.  
RK is the coefficient k, multiplying x in the sine or cosine function. 
QSIN is a logical variable, QSIN=.TRUE. implies that the integrand 
involves sin(kx) while QSIN=.FALSE. implies that the oscillatory factor 
is cos(kx). AEPS and REPS specify the required absolute and 
relative accuracy. The calculations 
are terminated when the successive values differ by less than 
max(<span class="roman">AEPS</span><span class="roman">,</span> <span class="roman">REPS</span>&times;&#124;<span class="roman">RI</span>&#124;). 
DIF is an output parameter which should contain 
an estimate of (absolute) error calculated by the subroutine. N is an 
output parameter containing the number of function evaluations 
used by the subroutine. IER is the error parameter. IER=30 denotes 
that the subroutine has failed to converge to the specified accuracy. 
In this case, RI will contain the best estimate for the integral 
and DIF should contain the estimated error. 
The parameter NMAX in the subroutine could be increased if larger 
number of function evaluations are to be allowed. 
FUN is the name of the function routine to calculate the non-oscillatory 
part f(x) in the integrand. 
FUNCTION FUN(X) must be supplied by the user. The parameter THC in the 
parameter statement is the 
critical value of &#952;, below which the Taylor series expansion 
is used to evaluate the functions &#945;(&#952;), &#946;(&#952;) and 
&#947;(&#952;). THC should be of the order of (100&#295;)<sup>1/6</sup>. 
If other values are used, the errors could be larger. 

<div class="p"><!----></div>
 <br /><br /><a name="adpint"> </a>
 <b>54.&nbsp;ADPINT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/adpint.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/quad.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function using 
adaptive integration based on Gauss-Kronrod rule. RINT is the output parameter 
containing the value of the integral. XL and XU are the lower and 
upper limits of the integral. It is not essential to have <span class="roman">XL</span> &lt; <span class="roman">XU</span>. 
REPS and AEPS specify the required  accuracy, while DIF is an 
output parameter giving the error as estimated by the subroutine. 
The subroutine will attempt to ensure that 
<span class="roman">DIF</span> &lt; max(&#124;<span class="roman">RINT</span>&#124;&times;<span class="roman">REPS</span>,<span class="roman">AEPS</span>). 
However, it is not always possible to ensure that DIF is less than the 
expected tolerance and in some cases even though the execution is 
successfully completed DIF may be somewhat larger than the required 
accuracy. 
NPT is an output parameter which will contain the number of function 
evaluations actually used by the subroutine. NMAX is the maximum 
number of function evaluations that user is prepared to allow. 
If <span class="roman">NMAX</span> &#8804; 0, then NMAX will be set to a default value of MAXPT (=100000). 
IER is the error parameter. 
IER=31 denotes that the subroutine failed to converge to the specified 
accuracy on at least one subinterval. IER=32 denotes that this failure 
occurred more than IFMAX (=5) times. In this case the accuracy requirement 
is adjusted by effectively increasing AEPS within the routine. 
The value of parameter AEPS is not actually changed. 
This failure could occur if the function has 
a very strong singularity at some points, or if the accuracy requirement 
is too high. In the former case, increasing IPMAX in 
the subroutine may help, provided the singularity is at x=0, since 
otherwise it is not possible to subdivide the interval if it spans two consecutive 
numbers in the machine representation. It may be better to shift the  
singularity to x=0. IER=325 denotes that the subroutine failed to achieve 
satisfactory accuracy in NMAX function evaluations. This situation may occur either 
because of singularity, or because very high accuracy is required. 
Increasing NMAX or REPS may help in such cases. 
In all cases, RI will contain the best estimate for integral 
and DIF should contain the estimated error. If the integrand has singularities, 
then this estimate may be unreliable. F is the name of the 
function routine used to calculate the value of the integrand. 
FUNCTION F(X) must be supplied by the user. This subroutine also needs 
the subroutine <a href="appendixb.htm#kronrd"> KRONRD</a><!--hbox--> (or <a href="appendixb.htm#gaus16"> GAUS16</a>). This subroutine could 
be used for mildly singular functions or for functions which vary 
by several orders of magnitude over the interval of integration. 
However, if very large interval is given and the function is 
almost constant over most of the interval, spurious convergence may 
take place as the subroutine may fail to detect the variation in 
function value. In such cases integration should be calculated over 
smaller subintervals and sum can be calculated to get the total integral. 

<div class="p"><!----></div>
 <br /><br /><a name="kronrd"> </a>
 <b>55.&nbsp;KRONRD&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/kronrd.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/quad.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function using 
Gauss-Kronrod formula. RI is the output parameter 
containing the value of the integral. A and B are the lower and 
upper limits of the integral. It is not essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>. 
DIF is an 
output parameter giving the error, as estimated by the subroutine. 
The subroutine uses 7-point Gauss-Legendre formula and its 15-point 
Kronrod extension to calculate the integral. RI will contain the 
estimate using 15-point Kronrod formula, while DIF contains the 
magnitude of the difference between the two values. 
N is an output parameter which will contain the number of function 
evaluations actually used by the subroutine. F is the name of the 
function routine to calculate the integrand. 
FUNCTION F(X) must be supplied by the user.  
This subroutine is used by <a href="appendixb.htm#adpint"> ADPINT</a><!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="gaus16"> </a>
 <b>56.&nbsp;GAUS16&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gaus16.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/adpint.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute integral of a function using 
16 point Gauss-Legendre formula. 
This subroutine can be used instead of KRONRD with ADPINT for adaptive 
integration. It calculates the integral using 8 and 16 point Gaussian 
formula and the difference between the two estimates is considered 
as estimated error. This routine will be less efficient as compared 
to KRONRD as it requires 24 function evaluations as opposed to 15 
required by KRONRD<!--hbox-->. Although, the 16 point Gauss-Legendre formula 
will have higher accuracy as compared to 15 point Gauss-Kronrod formula, 
the error estimate is essentially the error in 8-point Gauss-Legendre 
formula and it will not be much different from that obtained by KRONRD. 
Since the adaptive choice of subintervals is determined by the 
estimated error, it will be almost same for both these routines. 
Thus in general <a href="appendixb.htm#kronrd"> KRONRD</a> should be preferred but this routine is 
provided as an alternative. 
RI is the output parameter 
containing the value of the integral obtained using 16 point formula. 
A and B are the lower and 
upper limits of the integral. It is not essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>. 
DIF is an 
output parameter giving the error, as estimated by the subroutine. 
The subroutine uses 8 and 16-point Gauss-Legendre formulae 
to calculate the integral. RI will contain the 
estimate using 16-point Gaussian formula, while DIF contains the 
magnitude of the difference between the two values. 
N is an output parameter which will contain the number of function 
evaluations actually used by the subroutine. F is the name of the 
function routine to calculate the integrand. 
FUNCTION F(X) must be supplied by the user.  
This subroutine is used by <a href="appendixb.htm#adpint"> ADPINT</a><!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="cauchy"> </a>
 <b>57.&nbsp;CAUCHY&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/cauchy.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/cauchy.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute the Cauchy principal 
value of an integral. It uses ADPINT to perform the integral as 
explained in Section 6.6.10.   RI is the output parameter 
containing the value of the integral. A and B are the lower and 
upper limits of the integral. It is essential to have <span class="roman">A</span> &lt; <span class="roman">B</span>. 
C is the point inside the interval [A, B] where the integrand is 
singular. 
REPS and AEPS specify the required  accuracy, while DIF is an 
output parameter giving the error as estimated by the subroutine. 
The subroutine will attempt to ensure that 
<span class="roman">DIF</span> &lt; max(&#124;<span class="roman">RINT</span>&#124;&times;<span class="roman">REPS</span>,<span class="roman">AEPS</span>). 
F is the name of the 
function routine used to calculate the value of the integrand. 
FUNP is the name of the function routine used to calculate <span class="roman">F</span><span class="roman">(</span><span class="roman">C</span><span class="roman">+</span><span class="roman">X</span><span class="roman">)</span><span class="roman">+</span><span class="roman">F</span><span class="roman">(</span><span class="roman">C</span>&#8722;<span class="roman">X</span><span class="roman">)</span>. 
IER is the error parameter. 
IER=304 denotes that <span class="roman">A</span> &gt; <span class="roman">B</span>, <span class="roman">A</span> &gt; <span class="roman">C</span> 
or <span class="roman">C</span> &gt; <span class="roman">B</span>. In this case no calculations are done. 
Other values of IER may be set by subroutine ADPINT, which is called 
twice to perform the integration. The value of IER is set to 
<span class="roman">IER</span><span class="roman">1</span>+2<span class="roman">IER</span><span class="roman">2</span>, where IER1 and IER2 are the values of 
IER returned by two calls to ADPINT. 
In these cases DIF will contain the 
estimated error in the computed value of RI<!--hbox-->. 
NPT is an output parameter which will contain the number of function 
evaluations actually used by the subroutine. 
This subroutine needs subroutines <a href="appendixb.htm#adpint"> ADPINT</a> and <a href="appendixb.htm#kronrd"> KRONRD</a><!--hbox-->. 
FUNCTION F(X) and FUNCTION FUNP(X) must be supplied by the user. 
The value of C is available through common block CAUFN. There is no provision 
to pass on the name of the function F(X) to FUNP(X) and if needed it will 
have to be put explicitly. If <span class="roman">F</span><span class="roman">(</span><span class="roman">C</span><span class="roman">+</span><span class="roman">X</span><span class="roman">)</span><span class="roman">+</span><span class="roman">F</span><span class="roman">(</span><span class="roman">C</span>&#8722;<span class="roman">X</span><span class="roman">)</span> can be simplified to 
remove singularity, the roundoff errors will be reduced. 

<div class="p"><!----></div>
 <br /><br /><a name="euler"> </a>
 <b>58.&nbsp;EULER&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/euler.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/euler.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to compute the sum of an alternating 
series using Euler's transformation. 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 <span class="roman">SUM</span>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">A</span><span class="roman">0</span>&times;(&#8722;1)<sup>i&#8722;1</sup> <span class="roman">TERM</span>(i). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.25)</td></tr></table>
</td></tr></table>

 
The series may be finite or infinite. Before applying the Euler 
transformation, it is advisable to sum the first few terms (and last 
few terms, if the series is finite) separately 
as it helps in improving the convergence. This subroutine sums the 
first M1 terms and the last M2 terms separately and applies the Euler 
transform to the remaining terms from <span class="roman">M</span><span class="roman">1</span>+1 to <span class="roman">N</span>&#8722;<span class="roman">M</span><span class="roman">2</span>. 
The differences are calculated until the sum of each part converges 
to the specified accuracy. For finite series the contribution from 
the upper end is calculated separately. At most NMAX differences are 
calculated. If the sum does not converge then another attempt may 
be made by increasing M1 or M2. Although, NMAX can be trivially 
increased, but if the convergence is slow the error estimate will 
be unreliable and it will be better to improve convergence, which is 
generally achieved by increasing M1 or M2. 
Increasing NMAX may not help, as in most cases the roundoff error will 
dominate in higher order differences. 
N is the number of terms 
to be summed, while M1, M2 are the number of terms at the two ends 
which need to be summed separately. 
For summing an infinite series use <span class="roman">N</span>=0, in which case M2 is ignored. 
A0 specifies the sign of the first 
term. The sum assuming the first term to be positive is multiplied by 
A0. REPS and AEPS specify the required relative and absolute accuracy. 
The estimated error should be less than max(AEPS, REPS&times;&#124;SUM&#124;). DIF is the output parameter which 
gives the estimated error in the computed value of the sum. 
In most cases, actual error will be somewhat larger than DIF and can be estimated 
by repeating the calculations with different values of M1 and M2. 
N1, N2 are the number of terms from both ends actually used by the 
subroutine. M2 and N2 are relevant only for finite series. SUM is the calculated 
value of the sum. 
IER is the error parameter. 
IER=31 implies that <span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">2</span><span class="roman">NMAX</span> &#8805; <span class="roman">N</span>, in which case 
M1 is set to N and the series is summed directly. In this case although 
Euler transform is not used the sum should be exact apart from roundoff 
errors. IER=32 implies that the series obtained after Euler transform did 
not converge to required accuracy at the lower end. 
IER=34 implies that the series obtained after Euler transform did 
not converge to required accuracy at the upper end. This is relevant 
only for finite series. 
IER=36 implies that the series obtained after Euler transform did 
not converge to required accuracy at both ends. 
TERM is the name of the function routine to calculate the terms of the 
series. FUNCTION TERM(I) must be supplied by the user to calculate 
the Ith term of the series apart from the sign as in Eq.&nbsp;(<span class="roman">B</span>.25). 

<div class="p"><!----></div>
 <br /><br /><a name="bspqd2"> </a>
 <b>59.&nbsp;BSPQD2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspqd2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bspqd2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to compute integral of an expansion in 
terms of B-spline basis functions in two dimensions over a rectangular region. 
The expansion may be obtained by 
interpolating or approximating a table of values. 
Before calling this subroutine, the coefficients of B-spline 
expansion must be calculated by a call to the subroutine BSPINT2<!--hbox-->. 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 <span class="roman">BSPQD</span><span class="roman">2</span>=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">XU</span></small><!--sup
--><br /><br />
<small><span class="roman">XL</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx </td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">YU</span></small><!--sup
--><br /><br />
<small><span class="roman">YL</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dy &nbsp;&nbsp;&nbsp; </td><td nowrap="nowrap" align="center">
<small><span class="roman">NX</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp; </td><td nowrap="nowrap" align="center">
<small><span class="roman">NY</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">WT</span><span class="roman">(</span><span class="roman">i</span><span class="roman">,</span> <span class="roman">j</span><span class="roman">)</span>&nbsp;&nbsp;&#981;<sub>i</sub>(x)&#968;<sub>j</sub>(y), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.26)</td></tr></table>
</td></tr></table>

 
where &#981;<sub>i</sub>(x) are the B-spline basis functions of order K 
along x, and &#968;<sub>j</sub>(y) are those along y. 
The integral is evaluated recursively. First the integral along x 
is evaluated for each value of j and then the integral over y is 
calculated. It may be noted that the function BSPQD to evaluate 
the integral in one dimension is not called recursively and hence 
one copy will be sufficient for both directions. 
NX, NY are the number of knots along x and y respectively. 
X and Y are real arrays of length NX and NY 
containing the knots for B-splines. 
The knots must be in ascending order with X(1), Y(1) containing the 
first knot in respective directions. 
K is the order of B-splines, 
<span class="roman">K</span>=2 gives linear B-splines, while <span class="roman">K</span>=4 yields cubic B-splines, etc. 
WT is a real array of length <span class="roman">IW</span>&times;(<span class="roman">NY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) 
containing the coefficients 
of expansion in terms of B-spline basis functions. These coefficients 
may be calculated using <a href="appendixb.htm#bspint2"> BSPINT2</a> for interpolation in a table of values. 
IW is the first dimension of array WT as declared in the calling program. 
XL and XU are the lower and upper limits of the integral along x. 
YL and YU are the lower and upper limits of the integral along y. 
WK is a real array of length at least 
6max(<span class="roman">NX</span><span class="roman">,</span><span class="roman">NY</span>)+6<span class="roman">K</span>+9 used as scratch space. 
IER is the error parameter. IER=0 implies successful execution 
of the subroutine. Nonzero values may be set by BSPQD which is called 
to perform integration in one dimension. 
This subroutine 
requires function <a href="appendixb.htm#bsplin"> BSPLIN</a> to evaluate the B-spline basis functions, 
and function <a href="appendixb.htm#bspqd"> BSPQD</a> for integration in one dimension, 
 while subroutine 
<a href="appendixb.htm#bspint2"> BSPINT2</a> will be required to calculate the coefficients of B-spline 
before calling this subroutine. 

<div class="p"><!----></div>
 <br /><br /><a name="bspqdn"> </a>
 <b>60.&nbsp;BSPQDN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspqdn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bspqdn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to compute integral of an expansion in 
terms of B-spline basis functions in n dimensions over a hyper-rectangular region. 
The expansion may be obtained by 
interpolating or approximating a table of values. 
Before calling this subroutine, the coefficients of B-spline 
expansion must be calculated by a call to the subroutine BSPINTN<!--hbox-->. 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">BSPQDN</span>=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">XU</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span></small><!--sup
--><br /><br />
<small><span class="roman">XL</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx<sub>1</sub>&#8230;</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small><span class="roman">XU</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span></small><!--sup
--><br /><br />
<small><span class="roman">XL</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx<sub>N</sub> </td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>1</sub>=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#8230;</td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>N</sub>=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">WT</span><span class="roman">(</span><span class="roman">i</span><sub><span class="roman">1</span></sub><span class="roman">,</span> &#8230;<span class="roman">,</span> <span class="roman">i</span><sub><span class="roman">N</span></sub><span class="roman">)</span>&nbsp;&nbsp;&#981;<sub>i<sub>1</sub></sub><sup>(1)</sup>(x<sub>1</sub>) &#8230;&#981;<sub>i<sub>N</sub></sub><sup>(N)</sup>(x<sub>N</sub>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.27)</td></tr></table>
</td></tr></table>
 
where &#981;<sub>i</sub><sup>(j)</sup>(x) are the B-spline basis functions of order K 
along x<sub>j</sub>. 
The integral is evaluated recursively. First the integral along x<sub>1</sub> 
is evaluated for each value of other indices and then the integral over x<sub>2</sub> is 
calculated and so on. 
It may be noted that the function BSPQD to evaluate 
the integral in one dimension is not called recursively and hence 
one copy will be sufficient for all directions. 
N is the number of dimensions. 
NK is an integer array of length N containing the number of knots along 
each direction. NK(I) is the number of knots along Ith dimension. 
X is a real array of length <span class="roman">NXD</span>&times;<span class="roman">N</span> 
containing the knots for B-splines along each dimension. 
The knots must be in ascending order. 
X(I, J) is the Ith knot along Jth dimension. 
It may be noted that the subroutine BSPINTN gives the list of knots 
in the same format and that array can be directly used in this 
subroutine. 
NXD is the first dimension of the array X as specified in the calling 
program, NXD &#8805; max(<span class="roman">NK</span>(i)). 
K is the order of B-splines, 
<span class="roman">K</span>=2 gives linear B-splines, while <span class="roman">K</span>=4 yields cubic B-splines, etc. 
WT is a real array of length 
(<span class="roman">NK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">NK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)&#8230;(<span class="roman">NK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) 
containing the coefficients 
of expansion in terms of B-spline basis functions. These coefficients 
may be calculated using <a href="appendixb.htm#bspintn"> BSPINTN</a> for interpolation in a table of values. 
The coefficients are assumed to be stored in natural 
Fortran order with no gaps in data. In the calling 
program the array should have dimension 
WT(NK(1)+K&#8722;2, NK(2)+K&#8722;2, &#8230;, NK(N)+K&#8722;2). 
Alternately, it can be treated as a one dimensional array of required 
length. 
XL and XU are real arrays of length N containing the lower and upper 
limits of the integral along each direction. 
XL(I) is the lower limit and XU(I) is the upper limit for integration 
along Ith dimension. 
WK is a real array of length about twice that of WT used as scratch space. 
The actual length of WK used in the routine is a bit complicated and is 
given by 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small>N</small><!--sup
--><br /><font size="+3">&#8719;<br />
</font><small>i=2</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
(<span class="roman">NK</span><span class="roman">(</span><span class="roman">i</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)+</td><td nowrap="nowrap" align="center">
<small>N</small><!--sup
--><br /><font size="+3">&#8719;<br />
</font><small>i=3</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
(<span class="roman">NK</span><span class="roman">(</span><span class="roman">i</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)+15 +6<span class="roman">K</span>+5&times;</td><td nowrap="nowrap" align="center">
max<br />
</td><td nowrap="nowrap">(<span class="roman">NK</span>(i)). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.28)</td></tr></table>
</td></tr></table>

 
For <span class="roman">N</span> &gt; 2 this should always be less than twice the length of WT in 
practical problems. 
IER is the error parameter. IER=0 implies successful execution 
of the subroutine. Nonzero values may be set by BSPQD which is called 
to perform integration in one dimension. 
This routine 
requires function <a href="appendixb.htm#bsplin"> BSPLIN</a> to evaluate the B-spline basis functions, 
and function <a href="appendixb.htm#bspqd"> BSPQD</a> for integration in one dimension, 
 while subroutine 
<a href="appendixb.htm#bspintn"> BSPINTN</a> will be required to calculate the coefficients of B-splines 
before calling this subroutine. 

<div class="p"><!----></div>
 <br /><br /><a name="mulint"> </a>
 <b>61.&nbsp;MULINT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/mulint.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/multi.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine for integration over a hyper-rectangle 
in N&nbsp;dimensions using a series of product Gauss-Legendre formulae. 
A and B are real arrays of length  N, with A(I) and B(I) 
specifying the lower and upper limits for the Ith variable. 
It is not essential to have <span class="roman">A</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> &lt; <span class="roman">B</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>. N is an integer variable 
specifying the number of dimensions. There is no limit on the value of N 
as far as this subroutine is concerned, but the subroutine <a href="appendixb.htm#ngauss"> NGAUSS</a> which 
is invoked to actually evaluate the integrals will have some limit. 
If this limit is exceeded, IER will be set to 305. 
M is an integer array of length  N, specifying 
which Gaussian formula is to be used along each axis in the first 
approximation. The subroutine will attempt to use M(I)-point Gauss-Legendre  
formula along the Ith axis. Formulae with 2, 4, 8, 16 and 32 points 
are incorporated in the subroutine. 
If any other value is specified for M(I), then M(I) will be 
set to the default value of 2. IND is an integer array of length  
N, specifying the number of subdivisions to be used for the first 
approximation along each axis. If <span class="roman">IND</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> &lt;  1, then IND(I) is set to a 
default value of 1. After execution, the arrays M and IND will contain the final 
values of the formula and number of subintervals used along each axis. 
M[I] and IND[I] are increased to achieve the required accuracy or 
until the maximum number of function evaluations is reached. 
F is the name of the function routine to calculate the value of integrand 
at any given point. FUNCTION F(N, X) must be supplied by the user. 
(Here the first argument specifies the number of dimensions, while the second 
argument is a real array of length N, specifying the coordinates of the 
point at which the integrand is to be evaluated.) RINT is the output  
parameter which will contain the value of the integral. 
REPS and AEPS specify the accuracy required by user while DIF is 
an output parameter containing the estimated (absolute) error in RINT<!--hbox-->. 
The subroutine will attempt to ensure that 
<span class="roman">DIF</span> &lt; max(&#124;<span class="roman">RINT</span>&#124;&times;<span class="roman">REPS</span>,<span class="roman">AEPS</span>). 
NUM is an output parameter containing the number of function evaluations 
actually used by the subroutine. MAXPT is the maximum limit on the 
number of function evaluations which the user is prepared for. If 
<span class="roman">MAXPT</span> &lt; 1, then it is set to a default value of MAXPTS (=1100000). The value 
of MAXPT will depend on the computer time that is available and the 
accuracy required. IER is the error parameter. 
If the integral failed to converge to the required 
accuracy in MAXPT function evaluations, IER will be set to 39. In this 
case, RINT will contain the best approximation to the integral and DIF 
will contain the error estimate. 
The error estimate may not be very reliable as the number of points 
may not be sufficient to check for convergence along each dimension. 
If a second attempt is to be 
made with larger MAXPT, then the values of M(I) and IND(I) should not 
be reset, since that will save some function evaluations in computing initial 
approximations, which are known to be unsatisfactory. 
IER=305 implies that N is beyond the permissible limits. 
IER=307 implies that the number of points exceeded 
MAXPT in the first attempt itself. In such cases, no approximation for the 
integral will be available. 
This subroutine 
requires subroutine NGAUSS. 

<div class="p"><!----></div>
 <br /><br /><a name="ngauss"> </a>
 <b>62.&nbsp;NGAUSS&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/ngauss.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/multi.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine for integration over a hyper-rectangle 
in N&nbsp;dimensions using a  product Gauss-Legendre formula. 
A and B are real arrays of length  N, with A(I) and B(I) 
specifying the lower and upper limits for the Ith variable. 
It is not essential to have <span class="roman">A</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> &lt; <span class="roman">B</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>. N is an integer variable 
specifying the number of dimensions. The value of N must be between  
1 and 20. If N is outside these limits, IER will be set to 305. 
It is trivial to increase the upper limit on N by increasing NMAX 
but it is unlikely that subroutine will succeed for such dimensions. 
In any case MAXPT will also have to be increased correspondingly. 
M is an integer array of length  N, specifying 
the Gaussian formula to be used along each axis. 
The subroutine attempts to use M(I)-point Gauss-Legendre  
formula along the Ith axis. Formulae with 2, 4, 8, 16 and 32 points 
are incorporated in the subroutine. 
If any other value is specified for M(I), then IER will 
be set to 306 and no calculations will be attempted. 
IND is an integer array of length  
N, specifying the number of subdivisions to be used 
along each axis. If <span class="roman">IND</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> &lt;  1, then IER will be set to 306 
and no calculations will be performed. 
F is the name of the function routine to calculate the value of integrand 
at any given point. The FUNCTION F(N, X) must be supplied by the user. 
(Here the first argument specifies the number of dimensions, while the second 
argument is a real array of length N specifying the coordinates of the 
point at which the integrand is to be evaluated.) RI is the output  
parameter which will contain the value of the integral. 
NUM is an output parameter containing the number of function evaluations 
actually used by the subroutine. MAXPT is the maximum limit on the 
number of function evaluations which the user is prepared for. If 
<span class="roman">MAXPT</span> &lt; 1, then it is set to a default value of MAXPTS (=1100000). The value 
of MAXPT will depend on the computer time that is available and the 
accuracy required. IER is the error parameter. 
IER=305 implies that <span class="roman">N</span> &lt; 1 or <span class="roman">N</span> &#8805; NMAX, 
IER=306 implies M(J) is not admissible or <span class="roman">IND</span><span class="roman">(</span><span class="roman">J</span><span class="roman">)</span> &lt; 1 for some J, 
IER=307 implies that the number of points exceeded 
MAXPT. In all these cases no calculations are performed. 
This routine is called by <a href="appendixb.htm#mulint"> MULINT</a> which adjusts the number of abscissas 
to be used along each dimension depending on the required accuracy. 

<div class="p"><!----></div>
 <br /><br /><a name="sphnd"> </a>
 <b>63.&nbsp;SPHND&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/sphnd.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/multisp.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to transform the coordinates from 
hyper-spherical to Cartesian in n-dimensions. It can be used for 
integration over hyper-spherical shell in n-dimensions using subroutine 
<a href="appendixb.htm#mulint"> MULINT</a>, <a href="appendixb.htm#strint"> STRINT</a>, <a href="appendixb.htm#mcarlo"> MCARLO</a> or <a href="appendixb.htm#equids"> EQUIDS</a> when the function is known in terms 
of Cartesian coordinates. For this purpose SPHND should be 
passed on as the name of the function routine to calculate the integrand. 
The limits A(I) and B(I) of integration along Ith dimension 
should be [0,&#960;] for <span class="roman">I</span>=2,&#8230;,<span class="roman">N</span>&#8722;1, [0,2&#960;] 
for <span class="roman">I</span><span class="roman">=</span><span class="roman">N</span> and [r<sub>l</sub>,r<sub>u</sub>] for <span class="roman">I</span><span class="roman">=</span><span class="roman">1</span>. Here r<sub>l</sub> and r<sub>u</sub> are the radial 
coordinates of the hyper-spherical shell over which integration is 
required. For integration over a hyper-sphere of radius R, r<sub>l</sub>=0 and 
r<sub>u</sub>=R. This routine gives the transformation between hyper-spherical 
coordinates x<sub>i</sub> and Cartesian coordinates y<sub>i</sub> 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 y<sub>1</sub></td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=x<sub>1</sub>cos(x<sub>2</sub>),</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 y<sub>2</sub></td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=x<sub>1</sub>sin(x<sub>2</sub>)cos(x<sub>3</sub>),</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 y<sub>3</sub></td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=x<sub>1</sub>sin(x<sub>2</sub>)sin(x<sub>3</sub>)cos(x<sub>4</sub>),</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
  </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&#8230;</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 y<sub>n&#8722;1</sub></td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=x<sub>1</sub>sin(x<sub>2</sub>)sin(x<sub>3</sub>)&#8230;sin(x<sub>n&#8722;1</sub>)cos(x<sub>n</sub>),</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 y<sub>n</sub></td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">=x<sub>1</sub>sin(x<sub>2</sub>)sin(x<sub>3</sub>)&#8230;sin(x<sub>n&#8722;1</sub>)sin(x<sub>n</sub>).</td></tr></table></td></tr></table>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.29)</td></tr></table>

 
The integral can be written as 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><br />
<small>S<sub>n</sub></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
f(x)&nbsp;&nbsp;dV=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>r<sub>u</sub></small><!--sup
--><br /><br />
<small>r<sub>l</sub></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx<sub>1</sub></td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#960;</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx<sub>2</sub>&#8230;</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#960;</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx<sub>n&#8722;1</sub></td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>2&#960;</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
dx<sub>n</sub> f(x) x<sub>1</sub><sup>n&#8722;1</sup> </td><td nowrap="nowrap" align="center">
<small>n&#8722;1</small><!--sup
--><br /><font size="+3">&#8719;<br />
</font><small>i=2</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
sin<sup>n&#8722;i</sup>x<sub>i</sub>&nbsp;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.30)</td></tr></table>
</td></tr></table>

 
The function f(x) is calculated after transformation to Cartesian 
coordinates and the volume element as given above is multiplied. 
N is the number of dimensions, X and Y are real arrays of length N 
containing the coordinates of required point. X(I) are the input 
hyper-spherical coordinates, while Y(I) are the Cartesian coordinates. 
FUNCTION FUNSPH(N, Y) is called to calculate the required function 
in Cartesian coordinates. Since there is no provision to pass on the 
name of this function, it has to be the same as what appears in the routine. 
Again since there is no provision to pass on an error flag, the 
routine terminates the execution if <span class="roman">N</span> &gt; NMAX=50 or 
if <span class="roman">N</span> &#8804; 0. 

<div class="p"><!----></div>
 <br /><br /><a name="strint"> </a>
 <b>64.&nbsp;STRINT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/strint.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/multi.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine for integration over a hyper-rectangle 
in N&nbsp;dimensions using compound monomial rules of degree 1, 3 or 5. 
A and B are real arrays of length  N, with A(I) and B(I) 
specifying the lower and upper limits for the Ith variable. 
It is not essential to have <span class="roman">A</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> &lt; <span class="roman">B</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>. N is an integer variable 
specifying the number of dimensions. There is no limit on the value of N 
as far as this subroutine is concerned, but the subroutine <a href="appendixb.htm#stroud"> STROUD</a> which 
is invoked to actually evaluate the integrals will have some limit. 
If this limit is exceeded, IER will be set to 309. 
Although, a large limit on N is allowed the result is unlikely to be 
reliable for very large values of N. 
M is an integer parameter specifying the formula to be used on each subdivision. 
The allowed values of M are 1, 3 and 5. <span class="roman">M</span>=1 selects the one-point 
formula of degree one (essentially a generalisation of the midpoint rule). 
<span class="roman">M</span>=3 selects the 2N-point formula of degree 3 due to Stroud. <span class="roman">M</span>=5 selects 
the (2<span class="roman">N</span><sup>2</sup>+1)-point formula of degree 5. If M is not one of these values, 
it will be 
set to the default value of 3. IND is an integer array of length  
N, specifying the number of subdivisions to be used for the first 
approximation along each axis. If <span class="roman">IND</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> &lt;  1, then it will be set to a 
default value of 1. After execution, the array IND will contain the final 
values of the number of subintervals used along each axis. 
F is the name of the function routine to calculate the value of the integrand 
at any given point. FUNCTION F(N, X) must be supplied by the user. 
(Here the first argument specifies the number of dimensions, while the second 
argument is a real array of length N, specifying the coordinates of the 
point at which the integrand is to be evaluated.) RINT is the output  
parameter which will contain the value of the integral. 
REPS and AEPS specify the accuracy required by user, while DIF is 
an output parameter containing the estimated (absolute) error in RINT<!--hbox-->. 
The subroutine will attempt to ensure that 
<span class="roman">DIF</span> &lt; max(&#124;<span class="roman">RINT</span>&#124;&times;<span class="roman">REPS</span>,<span class="roman">AEPS</span>). 
NUM is an output parameter containing the number of function evaluations 
actually used by the subroutine. MAXPT is the maximum limit on the 
number of function evaluations which the user is prepared for. If 
<span class="roman">MAXPT</span> &lt; 1, then it is set to a default value of MAXPTS (=1000000). The value 
of MAXPT will depend on the computer time that is available and the 
accuracy required. IER is the error parameter. 
If the integral fails to converge to the required 
accuracy in MAXPT function evaluations, IER will be set to 39. In this 
case, RINT will contain the best approximation to the integral and DIF 
will contain the error estimate. 
The error estimate may not be very reliable as the number of points 
may not be sufficient to check for convergence along each dimension. 
If a second attempt is to be 
made with larger MAXPT, then the values of IND(I) should not 
be reset, since that will save some function evaluations in computing initial 
approximations, which are known to be unsatisfactory. 
IER=308 implies that the number of points exceeded 
MAXPT in the first attempt itself. In such cases, no approximation for the 
integral will be available. 
IER=309 implies that N is outside the limits accepted by STROUD. 
This subroutine requires 
subroutine STROUD. 

<div class="p"><!----></div>
 <br /><br /><a name="stroud"> </a>
 <b>65.&nbsp;STROUD&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/stroud.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/multi.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine for integration over a hyper-rectangle 
in N&nbsp;dimensions using a  compound monomial rule of degree 1, 3 or 5. 
A and B are real arrays of length  N, with A(I) and B(I) 
specifying the lower and upper limits for the Ith variable. 
It is not essential to have <span class="roman">A</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> &lt; <span class="roman">B</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>. N is an integer variable 
specifying the number of dimensions. The value of N must be between  
1 and 50. 
If N is outside these limits, IER will be set to 309. 
M is an integer specifying the formula to be used on each subdivision. 
The allowed values of M are 1, 3 and 5. <span class="roman">M</span>=1 selects the one-point 
formula of degree one (essentially a generalisation of the midpoint rule). 
<span class="roman">M</span>=3 selects the 2N-point formula of degree 3 due to Stroud. <span class="roman">M</span>=5 selects 
the (2<span class="roman">N</span><sup>2</sup>+1)-point formula of degree 5. 
If any other value is specified for M, then IER will 
be set to 310 and no calculations will be attempted. 
IND is an integer array of length  
N, specifying the number of subdivisions to be used 
along each axis. If <span class="roman">IND</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> &lt;  1, then IER will be set to 310 
and no calculations will be performed. 
F is the name of the function routine to calculate the value of integrand 
at any given point. The FUNCTION F(N, X) must be supplied by the user. 
(Here the first argument specifies the number of dimensions, while second 
argument is a real array of length N specifying the coordinates of the 
point at which the integrand is to be evaluated.) RI is the output  
parameter which will contain the value of the integral. 
NUM is an output parameter containing the number of function evaluations 
actually used by the subroutine. MAXPT is the maximum limit on the 
number of function evaluations which the user is prepared for. If 
<span class="roman">MAXPT</span> &lt; 1, then it is set to a default value of MAXPTS (=1000000). The value 
of MAXPT will depend on the computer time that is available and the 
accuracy required. IER is the error parameter. 
IER=308 implies that the number of points exceeded 
MAXPT. 
IER=309 implies that the <span class="roman">N</span> &lt; 1 or <span class="roman">N</span> &gt; NMAX. 
IER=310 implies that the M is not 1, 3 or 5 or 
IND(I) &lt; 1 for some I<!--hbox-->. In all these cases no 
calculations are done. 
This routine is called by <a href="appendixb.htm#strint"> STRINT</a> which adjusts the number of abscissas 
to be used along each dimension depending on the required accuracy. 

<div class="p"><!----></div>
 <br /><br /><a name="mcarlo"> </a>
 <b>66.&nbsp;MCARLO&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/mcarlo.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/multi.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine for integration over a hyper-rectangle 
in N&nbsp;dimensions using Monte Carlo method. 
A and B are real arrays of length  N, with A(I) and B(I) 
specifying the lower and upper limits for the Ith variable. 
It is not essential to have <span class="roman">A</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> &lt; <span class="roman">B</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>. N is an integer variable 
specifying the number of dimensions. The value of N must be between  
1 and NMAX (=50). 
If N is outside these limits, IER will be set to 311. 
NPT is the maximum number of function evaluations to be used for integration. 
F is the name of the function routine to calculate the value of the integrand 
at any given point. The FUNCTION F(N, X) must be supplied by the user. 
(Here the first argument specifies the number of dimensions, while the second 
argument is a real array of length N specifying the coordinates of the 
point at which the integrand is to be evaluated.) RI is an output  
parameter, which will contain the value of the integral. 
REPS and AEPS specify the desired accuracy. 
ERR is an output parameter containing the (absolute) error estimate for 
the integral. This error estimate is obtained by using the variance 
&#963; as defined in Section 6.11. ERR is set to 2.576&#963;/&#8730;{<span class="roman">NP</span>} corresponding to a confidence level of 99%. 
The subroutine attempts to ensure that 
<span class="roman">ERR</span> &lt; max(&#124;<span class="roman">RI</span>&#124;&times;<span class="roman">REPS</span>,<span class="roman">AEPS</span>). 
NP is the number of function evaluations actually used by the subroutine. 
IER is the error parameter. 
IER=39 implies that the subroutine failed to converge to the specified 
accuracy. In this case, RI will contain the best estimate and ERR the 
corresponding error estimate. 
IER=311 implies that <span class="roman">N</span> &lt; 1 or <span class="roman">N</span> &gt; 50 and no calculations are 
done. 
This subroutine requires FUNCTION <a href="appendixb.htm#ranf"> RANF</a>(ISEED) 
to generate random numbers. If a different routine is used for this purpose, 
then the value of seed may have to be changed.  

<div class="p"><!----></div>
 <br /><br /><a name="ran1"> </a>
 <b>67.&nbsp;RAN1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/ran1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gaubnd.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to generate a sequence of random numbers 
using a simple linear congruential method. The constants AM, A and AC  
will give overflow in integer arithmetic using 32-bits and hence these 
must be treated as double precision variables. 
SEED could be set to any positive value less than AM, before 
first call to the routine. After the first call, this variable should not be 
changed in any other program. It may be noted that this routine requires 
a real number as seed as opposed to RANF, which needs an integer seed 
as argument. Further, in this case the seed has to be positive, while 
for RANF it has to be negative for initialisation. This has to be kept 
in mind while changing the random number generator in any program. 

<div class="p"><!----></div>
 <br /><br /><a name="ranf"> </a>
 <b>68.&nbsp;RANF&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/ranf.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/multi.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to generate a sequence of random numbers 
using a combination of three linear congruential generators. 
This subroutine is based on the subroutine RAN1 in Press <i>et al.</i>&nbsp;(2007). 
The constants m,a and c for each of these generators are 
chosen, such that there should be no overflow on a machine with 32-bit word 
length. ISEED could be set to any negative value, before 
first call to the routine. After the first call, this variable should not be 
changed in any other program. 

<div class="p"><!----></div>
 <br /><br /><a name="equids"> </a>
 <b>69.&nbsp;EQUIDS&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/equids.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/multi.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine for integration over a hyper-rectangle 
in N&nbsp;dimensions using the method based on equidistributed sequences. 
A and B are real arrays of length  N, with A(I) and B(I) 
specifying the lower and upper limits for the Ith variable. 
It is not essential to have <span class="roman">A</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> &lt; <span class="roman">B</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>. N is an integer variable 
specifying the number of dimensions. N should be between 1 and NMAX (=21). 
If N is outside these limits, then IER will be set to 312. 
NPT is the maximum number of function evaluations to be used in computing the 
integral. 
F is the name of the function routine to calculate the value of the integrand 
at any given point. The FUNCTION F(N, X) must be supplied by the user. 
(Here the first argument specifies the number of dimensions, while the second 
argument is a real array of length N specifying the coordinates of the 
point at which the integrand is to be evaluated.) S1 and S2 are the output  
parameters which will contain the value of the integral. 
These values provide the two approximations using equidistributed sequences. 
If the function is sufficiently smooth, S2 is expected to be a better 
approximation and could in general be used as the best approximation to 
the integral. 
REPS and AEPS specify the accuracy required by the user, while DIF is 
an output parameter containing the estimated (absolute) error in S2. 
The subroutine attempts to ensure that 
<span class="roman">DIF</span> &lt; max(&#124;<span class="roman">S</span><span class="roman">2</span>&#124;&times;<span class="roman">REPS</span>,<span class="roman">AEPS</span>). 
NP is an output parameter containing the number of function evaluations 
actually used by the subroutine. 
If the integral fails to converge to the required 
accuracy in NPT function evaluations, the error 
parameter IER will be set to 39. In this 
case, S2 (or S1) will contain the best approximation to the integral and DIF 
will contain the error estimate. Evaluation of the sum in EQUIDS involves 
large roundoff errors and it is recommended to use this routine  
with double precision. IER=312 implies that <span class="roman">N</span> &lt; 1 or <span class="roman">N</span> &gt;  NMAX. 

<div class="p"><!----></div>
  

<br /><br />
<a name="Nonlinear Algebraic Equations"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.7&nbsp; NONLINEAR ALGEBRAIC EQUATIONS </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bisect">BISECT</a></td>
<td>&nbsp; <a href="#secant">SECANT</a></td>
<td>&nbsp; <a href="#secanc">SECANC</a></td>
<td>&nbsp; <a href="#secani">SECANI</a></td>
<td>&nbsp; <a href="#newrap">NEWRAP</a></td>
<td>&nbsp; <a href="#brent">BRENT</a></td>
<td>&nbsp; <a href="#search">SEARCH</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#zroot">ZROOT</a></td>
<td>&nbsp; <a href="#zroot2">ZROOT2</a></td>
<td>&nbsp; <a href="#muller">MULLER</a></td>
<td>&nbsp; <a href="#muler2">MULER2</a></td>
<td>&nbsp; <a href="#delves">DELVES</a></td>
<td>&nbsp; <a href="#contur">CONTUR</a></td>
<td>&nbsp; <a href="#newrac">NEWRAC</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#polyr">POLYR</a></td>
<td>&nbsp; <a href="#lagitr">LAGITR</a></td>
<td>&nbsp; <a href="#polyc">POLYC</a></td>
<td>&nbsp; <a href="#lagitc">LAGITC</a></td>
<td>&nbsp; <a href="#davidn">DAVIDN</a></td>
<td>&nbsp; <a href="#newton">NEWTON</a></td>
<td>&nbsp; <a href="#broydn">BROYDN</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="bisect"> </a>
 <b>70.&nbsp;BISECT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bisect.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/realrt.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to find a real zero of a continuous function 
using the method of bisection. XL and XU bracket the interval containing the 
zero. The function must have opposite signs at these two points. This 
interval will be refined by bisection, and after execution XL and XU 
will contain the refined estimate for the interval containing the zero. 
It is not necessary to have <span class="roman">XL</span> &lt; <span class="roman">XU</span>. 
X is an output parameter which will contain the interpolated value of 
the zero, using the last estimate at the end points XL and XU<!--hbox-->. NB is 
an input parameter specifying the number of bisections to be performed. 
F is the name of the function routine to calculate the function. IER is 
the error parameter. IER=401 implies that <span class="roman">NB</span> &#8804; 0, in which case, 
no calculations are performed. IER=421 implies that the function has the same 
sign at both the end points and hence bisection cannot be performed. 
IER=&#8722;1 implies that the function vanishes at one of the points. 
Hence, the required number of bisections have not been performed, but 
in this case, X will contain the "zero". 
Before invoking this subroutine, it must be ensured that the function is 
continuous in the interval. In particular, the sign change should not be due 
to a singularity within the interval. The number of bisections to be performed 
should be carefully chosen, since performing unnecessary bisections will 
not improve the accuracy of the computed zero. The FUNCTION F(X) 
must be supplied by the user. 

<div class="p"><!----></div>
 <br /><br /><a name="secant"> </a>
 <b>71.&nbsp;SECANT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/secant.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/realrt.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate a real zero of a given function 
using the secant iteration. XL and XU specify the limits within which the 
zero is expected. It is essential to have <span class="roman">XL</span> &lt; <span class="roman">XU</span> i.e., XL 
is the lower limit and XU is the upper limit. It is not necessary that the 
function value should have opposite sign at these two points. The limits are 
only used to terminate the iteration, if it is going astray. X0 is the 
initial guess for the zero and it is essential to have  
<span class="roman">XL</span> &#8804; <span class="roman">X</span><span class="roman">0</span> &#8804; <span class="roman">XU</span>. 
X is an output parameter containing the computed value of 
the zero. REPS and AEPS specify the relative 
and absolute convergence criterion. The zero should be determined 
with an accuracy 
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;). FUN is the name of the 
external routine to calculate the required function. FUNCTION FUN(X) 
must be supplied by the user. IER is the error parameter. 
IER=40 implies that 
the calculated values of the function at the two most recent points 
was equal, and it is not possible to continue the iteration further. 
This situation can arise if the zero is multiple, or if the convergence criterion 
is too stringent, or sometimes just by coincidence. In the first two cases, 
the computed value of the zero may be reasonable. 
IER=402 implies that the starting value was outside the given 
interval, in which case, no calculations are performed.  
IER=422 implies that the iteration has gone outside the prescribed 
limits, and was terminated at that stage. This situation may arise, because 
the zero is outside or close to the specified limits. However, this is not 
essential and the iteration may tend to go outside for other reasons. IER=423 
implies that the iteration failed to converge to the specified accuracy. 
This failure could be due to various reasons, like very stringent convergence 
criterion, or excessive roundoff error in calculating the function, or  
the iteration simply failed to detect the zero. 
This subroutine attempts 
to make a reasonable guess for the second starting value, using the 
limiting interval and the convergence criterion. However, if the root 
is too large, or too small, or if the bounding interval is very large 
this choice may not be good. In such cases, the iteration may not converge. 
This problem can be rectified by choosing the proper increment DX at 
the first step, or by making the bounding interval smaller. 
If the function is calculated in the form FUN&times;2<sup><span class="roman">JF</span></sup>  
to avoid overflows and underflows, then use the subroutine SECAN<tt>_</tt>2 instead 
of SECANT<!--hbox-->. The call statement is identical for the two routines. 

<div class="p"><!----></div>
 <br /><br /><a name="secanc"> </a>
 <b>72.&nbsp;SECANC&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/secanc.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/secanc.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate a complex zero of a given function 
using the secant iteration. This is the complex version of SECANT<!--hbox-->. 
In this case the root cannot be bracketed between limits and only the 
magnitude of root is used to check if it is within limits. 
The limit is 
only used to terminate the iteration, if it is going astray. X0 is the 
initial guess for the zero and it is essential to have  
&#124;<span class="roman">X</span><span class="roman">0</span>&#124; &lt; <span class="roman">R</span>. R is the limiting magnitude for the root. 
X is an output parameter containing the computed value of 
the zero. X and X0 are complex variables, while R is real. 
REPS and AEPS specify the relative 
and absolute convergence criterion. The zero should be determined 
with an accuracy 
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;). FUN is the name of the 
external routine to calculate the required function. FUNCTION FUN(X) 
must be supplied by the user. IER is the error parameter. 
IER=40 implies that 
the calculated values of the function at the two most recent points 
was equal, and it is not possible to continue the iteration further. 
This situation can arise if the zero is multiple, or if the convergence criterion 
is too stringent, or sometimes just by coincidence. In the first two cases, 
the computed value of the zero may be reasonable. 
IER=402 implies that the starting value was outside the specified 
interval, in which case, no calculations are performed.  
IER=422 implies that the iteration has gone outside the prescribed 
limits, and was terminated at that stage. This situation may arise, because 
the zero is outside or close to the specified limits. However, this is not 
essential and the iteration may tend to go outside for other reasons. IER=423 
implies that the iteration failed to converge to the specified accuracy. 
This failure could be due to various reasons, like very stringent convergence 
criterion, or excessive roundoff error in calculating the function, or  
the iteration simply failed to detect the zero. 
This subroutine attempts 
to make a reasonable guess for the second starting value. 
However, if the roots are close then this value may not be appropriate. 
In such cases, the iteration may not converge. 
This problem can be rectified by choosing the proper increment DX at 
the first step. 
If the function is calculated in the form FUN&times;2<sup><span class="roman">JF</span></sup>  
to avoid overflows and underflows, then use the subroutine SECANC<tt>_</tt>2 instead 
of SECANC<!--hbox-->. The call statement is identical for the two routines. 

<div class="p"><!----></div>
 <br /><br /><a name="secani"> </a>
 <b>73.&nbsp;SECANI&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/secani.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/secan_2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate a real zero of a given function 
using the secant iteration. The function is calculated in the form 
F&times;2<sup><span class="roman">JF</span></sup> to avoid overflows and underflows. 
It also uses the reverse communication technique for passing function 
values. This subroutine will return control to the calling program when 
it needs a function evaluation. In that case, the error parameter IER 
will be set to a negative value and the function should be evaluated 
at X<!--hbox-->. The value of the function should be returned in the variables 
F and JF<!--hbox-->. During the function evaluation variables other than F and JF 
in the call statement should not be disturbed. Before the first call, 
IER should be set to zero. IER &#8805; 0 implies that the execution 
is complete and no more function evaluations are required. In that 
case the value of X will give the root (if IER=0) or the final value 
of X where the function was evaluated. 
XL and XU specify the limits within which the 
zero is expected. It is essential to have <span class="roman">XL</span> &lt; <span class="roman">XU</span> i.e., XL 
is the lower limit and XU is the upper limit. It is not necessary that the 
function value should have opposite sign at these two points. The limits are 
only used to terminate the iteration, if it is going astray. X0 is the 
initial guess for the zero and it is essential to have  
<span class="roman">XL</span> &#8804; <span class="roman">X</span><span class="roman">0</span> &#8804; <span class="roman">XU</span>. 
X is an output parameter containing the value of x at which the 
function value is required, when IER &lt; 0. For other values 
of IER it will contain the computed root or a failed approximation to it. 
The calculated function value is to be passed through the variables 
F and JF<!--hbox-->. 
REPS and AEPS specify the relative 
and absolute convergence criterion. The zero should be determined 
with an accuracy 
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;).  
IER is the error parameter. 
If IER &lt; 0, then a fresh function evaluation is required. 
IER=0 implies that function execution has been successfully 
completed and X should contain the calculated root. 
IER=40 implies that 
the calculated values of the function at the two most recent points 
was equal, and it is not possible to continue the iteration further. 
This situation can arise if the zero is multiple, or if the convergence criterion 
is too stringent, or sometimes just by coincidence. In the first two cases, 
the computed value of the zero may be reasonable. 
IER=402 implies that the starting value was outside the given 
interval, in which case, no calculations are performed.  
IER=422 implies that the iteration has gone outside the prescribed 
limits, and was terminated at that stage. This situation may arise, because 
the zero is outside or close to the specified limits. However, this is not 
essential and the iteration may tend to go outside for other reasons. IER=423 
implies that the iteration failed to converge to the specified accuracy. 
This failure could be due to various reasons, like very stringent convergence 
criterion, or excessive roundoff error in calculating the function, or  
the iteration simply failed to detect the zero. 
This subroutine attempts 
to make a reasonable guess for the second starting value, using the 
limiting interval and the convergence criterion. However, if the root 
is too large, or too small, or if the bounding interval is very large 
this choice may not be good. In such cases, the iteration may not converge. 
This problem can be rectified by choosing the proper increment DX at 
the first step, or by making the bounding interval smaller. 

<div class="p"><!----></div>
 <br /><br /><a name="newrap"> </a>
 <b>74.&nbsp;NEWRAP&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/newrap.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/newrap.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate a real zero of a given function 
using the Newton-Raphson method. This subroutine tries to estimate the 
multiplicity of the zero by looking at the convergence rate and then 
uses this estimate to accelerate the convergence. 
XL and XU specify the limits within which the 
zero is expected. It is essential to have <span class="roman">XL</span> &lt; <span class="roman">XU</span> i.e., XL 
is the lower limit and XU is the upper limit. It is not necessary that the 
function should have opposite signs at these two points. The limits are 
only used to terminate the iteration, if it is going astray. X0 is the 
initial guess for the zero and it is essential to have  
<span class="roman">XL</span> &#8804; <span class="roman">X</span><span class="roman">0</span> &#8804; <span class="roman">XU</span>. X is an output parameter containing 
the computed value of the zero. REPS and AEPS specify the relative 
and absolute convergence criterion. The zero should be calculated 
with an accuracy 
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;). FUN is the name of the 
external routine to calculate the required function and its derivative. 
FUNCTION FUN(X, DF) must be supplied by the user, 
where DF is the first derivative of FUN<!--hbox--> at X<!--hbox-->. IER is the error 
parameter. IER=403 implies that the starting value was outside the given 
range, in which case, no calculations are performed.  
IER=424 implies that the iteration has gone outside the prescribed 
limits, and was terminated at that stage. This situation may arise, because 
the zero is outside or close to the specified limits. However, this is not 
essential and iteration may tend to go outside for other reasons. IER=425 
implies that the iteration failed to converge to the specified accuracy. 
This failure could be due to various reasons, like very stringent convergence 
criterion, or excessive roundoff error in calculating the function, or  
the iteration simply failed to detect the zero. IER=426 implies that 
the calculated value of the derivative at the last point is zero, 
and it is not possible to continue the iteration further. In this case 
the zero is detected to be simple. This can happen by coincidence. 
This situation can happen if the zero is multiple, in which case 
IER is set to 126&#8722;100&times;multiplicity. 
In this case, 
the computed value of the zero may be reasonable. On successful completion 
of the subroutine, IER will be zero if the root is simple and IER=&#8722;k, 
if the root is detected to be multiple with multiplicity k. 
Function FUN(X, DF) must be supplied by the user. 
<a href="appendixb.htm#newrac"> NEWRAC</a> is the complex version of this subroutine. 

<div class="p"><!----></div>
 <br /><br /><a name="brent"> </a>
 <b>75.&nbsp;BRENT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/brent.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/root.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate a real zero of a given function 
using the Brent's method. This subroutine is based on the routine given 
by Brent&nbsp;(1973). A and B specify the limits within which the 
zero is located. It is essential that the function has opposite signs 
at these two points. The values of A and B will be updated by the 
subroutine to locate the zero with required accuracy. 
X is the output parameter containing the computed value of the 
zero. REPS and AEPS specify the relative 
and absolute convergence criterion. The zero should be calculated 
with an accuracy 
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;). F is the name of the 
external routine to calculate the required function. FUNCTION F(X) 
must be supplied by the user. 
IER is the error 
parameter.  
IER=427 implies that the function has the same sign at both the end 
points and hence the Brent's method cannot be applied. 
IER=428 
implies that the iteration failed to converge to the specified accuracy. 
This failure could be due to the fact that the convergence criterion 
is too stringent. Increasing the parameter NIT in 
the subroutine may allow convergence, but before doing that it must be ensured 
that it will be meaningful to do so. Since convergence to any arbitrary 
accuracy does not ensure that the zero is correct to that accuracy. 
If the accuracy requirement cannot be satisfied within the available 
floating-point arithmetic, then the iteration may never converge to the 
specified accuracy. 
Before invoking this subroutine, it must be ensured that the function is 
continuous in the interval. In particular, the sign change should not be due 
to a singularity within the interval. 

<div class="p"><!----></div>
 <br /><br /><a name="search"> </a>
 <b>76.&nbsp;SEARCH&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/search.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/search.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to search for complex zeros by looking for  
sign changes in the real and imaginary parts of the function. It will 
output an array of values in the two-dimensional plane giving the 
quadrant value of the function at that point. Using this array the zero may be located 
as explained in Section&nbsp;7.7. The zeros will be searched  in a rectangular region bounded by RX1 and RX2 along the real axis and by 
RY1 and RY2 along the imaginary axis. It is not really essential to have 
<span class="roman">RX</span><span class="roman">1</span> &lt; <span class="roman">RX</span><span class="roman">2</span> or <span class="roman">RY</span><span class="roman">1</span> &lt; <span class="roman">RY</span><span class="roman">2</span>. NX and NY are the number 
of points along the real and imaginary axes respectively, where the 
function value is calculated. 
NX and NY should be greater than 1, if not, a default value of 21 will be 
used.  Further, <span class="roman">NX</span> &#8804; <span class="roman">IMAX</span>&nbsp;&nbsp;(=41), otherwise it will be reduced 
to the maximum permissible value of IMAX<!--hbox-->. 
CFUN is the 
name of the function routine to calculate the function of complex variable. 
FUNCTION CFUN(Z) must be supplied by the user. Here Z and CFUN are both 
complex variables. Output is written on the Fortran logical unit 6, which 
may be printed on a printer or displayed on the screen. 

<div class="p"><!----></div>
 <br /><br /><a name="zroot"> </a>
 <b>77.&nbsp;ZROOT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/zroot.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/muller.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate complex zeros of a given function 
using Muller's method. This subroutine uses deflation to remove 
the known zeros. Deflation is carried out by explicitly dividing the 
function by factors of the form z&#8722;z<sub>i</sub>, where z<sub>i</sub> are the known zeros. 
This subroutine calls <a href="appendixb.htm#muller"> MULLER</a> (or
<a href="appendixb.htm#muler2">MULER2</a>) to find the zeros. N specifies 
the number of zeros to be determined. CX is a complex array of length 
 N, containing the N starting values for the iteration. NZ 
is the number of known zeros of the given function. CZERO is a 
complex array of length  <span class="roman">NZ</span>+<span class="roman">N</span> containing the 
zeros. At the time of calling, the first NZ elements should 
contain the known zeros of the function. All zeros found by the subroutine 
will be added to this list and the value of NZ will be increased accordingly. 
REPS and AEPS specify the relative 
and absolute convergence criterion. The zeros should be calculated 
with an accuracy 
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;).  
IER is the error parameter. 
IER=41 implies that the Muller's iteration did not converge to  
the required accuracy for at least one of the zeros, but the computed 
root may still be acceptable at lower accuracy. This means that 
the subroutine MULLER has come out with a nonzero value of IER, which 
is less than 100. 
IER=429 implies that the iteration failed to 
converge for at least one of the zeros. The number of zeros successfully 
found can be obtained from NZ, which will give the number of known zeros 
including those which were known before the subroutine was called. 
RMAX is a parameter to specify the approximate 
range of z values, where zeros are required. If the iteration 
goes outside the region &#124;<span class="roman">Z</span>&#124; &#8804; <span class="roman">RMAX</span>, then it will be terminated. 
This parameter may be used to ensure that iteration does not stray into 
a region which will yield overflow or some other problem. 
CF is the name of the 
external routine to calculate the required function. FUNCTION CF(Z) 
(or FUNCTION CF(Z, IX) for MULER2) 
must be supplied by the user. Here both CF and Z are assumed to be of type 
COMPLEX<!--hbox-->. 
Apart from this function, the subroutine also requires 
subroutine <a href="appendixb.htm#muller"> MULLER</a> or <a href="appendixb.htm#muler2"> MULER2</a>. 
To use MULER2 instead of MULLER, change 
the call statement as indicated in the comments. 
ZROOT2 is the version of ZROOT for use with MULER2. 

<div class="p"><!----></div>
 <br /><br /><a name="zroot2"> </a>
 <b>78.&nbsp;ZROOT2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/zroot2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/muler2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate complex zeros of a given function 
using Muller's method. This subroutine uses deflation to remove 
the known zeros. Deflation is carried out by explicitly dividing the 
function by factors of the form z&#8722;z<sub>i</sub>, where z<sub>i</sub> are the known zeros. 
This subroutine calls <a href="appendixb.htm#muler2"> MULER2</a> (or
<a href="appendixb.htm#muller">MULLER</a>) to find the zeros. N specifies 
the number of zeros to be determined. CX is a complex array of length 
 N, containing the N starting values for the iteration. NZ 
is the number of known zeros of the given function. CZERO is a 
complex array of length  <span class="roman">NZ</span>+<span class="roman">N</span> containing the 
zeros. At the time of calling, the first NZ elements should 
contain the known zeros of the function. All zeros found by the subroutine 
will be added to this list and the value of NZ will be increased accordingly. 
REPS and AEPS specify the relative 
and absolute convergence criterion. The zeros should be calculated 
with an accuracy 
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;).  
IER is the error parameter. 
IER=41 implies that the Muller's iteration did not converge to  
the required accuracy for at least one of the zeros, but the computed 
root may still be acceptable at lower accuracy. This means that 
the subroutine MULER2 has come out with a nonzero value of IER, which 
is less than 100. 
IER=429 implies that the iteration failed to 
converge for at least one of the zeros. The number of zeros successfully 
found can be obtained from NZ, which will give the number of known zeros 
including those which were known before the subroutine was called. 
RMAX is a parameter to specify the approximate 
range of z values, where zeros are required. If the iteration 
goes outside the region &#124;<span class="roman">Z</span>&#124; &#8804; <span class="roman">RMAX</span>, then it will be terminated. 
This parameter may be used to ensure that iteration does not stray into 
a region which will yield overflow or some other problem. 
CF is the name of the 
external routine to calculate the required function. FUNCTION CF(Z, IX) 
(or FUNCTION CF(Z) for MULLER) 
must be supplied by the user. Here both CF and Z are assumed to be of type 
COMPLEX 
and IX is an integer variable such that the function value 
is given by f(<span class="roman">Z</span>)=<span class="roman">CF</span>&times;2<sup><span class="roman">IX</span></sup>. This form is useful 
for functions which will otherwise result in overflow or underflow. 
Apart from this function, the subroutine also requires 
subroutine <a href="appendixb.htm#muler2"> MULER2</a> or <a href="appendixb.htm#muller"> MULLER</a>. Subroutine MULER2 uses 
<i>reverse communication</i>  technique to pass the function value. 
This subroutine 
returns the control to the calling program whenever a function evaluation 
is required. This technique is useful when a large number of parameters, 
including some external subprogram names, are required 
for the function evaluation. At the first call to MULER2 the error 
parameter IER should be set to zero. When the control is returned to 
the calling program, it should check the 
value of IER to decide the action. If IER &lt; 0, then a function 
evaluation is required and the subroutine should be called once 
again after calculating the function. It is important to ensure that 
none of the other parameters in the call statements, e.g., CX1, CX2, CX3 
and IER are changed in between. Nonnegative values of IER signify that 
the execution of MULER2 is complete and it should not be called again. 
ZROOT is the version of ZROOT2 for use with MULLER<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="muller"> </a>
 <b>79.&nbsp;MULLER&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/muller.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/muller.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate a complex zero of a given function 
using Muller's method. CX1, CX2 and CX3 are complex variables  
specifying the three starting values required for Muller's method. 
After execution, CX3 will contain the computed value of the zero, 
while CX2 and CX1 will contain the previous iterates. 
REPS and AEPS specify the relative and absolute convergence criterion. 
The root should be calculated with an accuracy 
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">CX</span><span class="roman">3</span>&#124;).  
IER is the error parameter. 
IER=42 implies 
that the iteration converged to a moderate accuracy specified by 
the parameter REPS0 (=10<sup>&#8722;4</sup>), but after some stage the difference 
between successive iterates started increasing and the iteration 
was terminated. This will usually imply that specified accuracy is 
too stringent, or that there is a significant roundoff error 
in evaluating the function. 
In such cases, the computed value of the zero should be within the 
domain of indeterminacy for the function and may be acceptable. 
The difference &#124;CX2&#8722;CX3&#124; should give an estimate of 
accuracy achieved. 
IER=43 implies that the moderate convergence criterion was satisfied, 
but the iteration failed to converge to the required accuracy in  
specified maximum number of iterations NIT ( = 50). This failure could be 
due to slow convergence and increasing the value of NIT, or a second 
attempt with the new estimate as the starting value may yield a better 
result. Further, the difference between CX1, CX2 and CX3 will give an 
estimate of the expected error in the computed zero. 
IER=404 implies that the three starting 
values are not distinct, in which case no calculations are performed. 
IER=431 implies that iteration has gone outside the specified limits 
i.e., &#124;<span class="roman">CX</span><span class="roman">3</span>&#124; &gt; <span class="roman">RMAX</span>. IER=432 implies that the iteration 
has failed to converge to any reasonable accuracy. 
IER=433 implies that the iteration cannot be continued further, because 
the denominator in the iteration function vanishes. In this case, 
CX1, CX2 and CX3 will contain the last three iterates. This failure can 
occur at multiple zeros after the iteration has entered into the 
domain of indeterminacy, in which case, the root may be acceptable. 
CF is the name of the 
external routine to calculate the required function. FUNCTION CF(Z) 
must be supplied by the user. 
Here CF and Z are both  complex variables. 
NZ is the number of known zeros of the function. CZERO is a complex array 
of length  NZ containing the known zeros.  
RMAX is a parameter to specify the approximate 
range of z values, where zeros are required. If the iteration 
gives &#124;<span class="roman">Z</span>&#124; &gt; <span class="roman">RMAX</span>, then it will be terminated. 
This parameter may be used to ensure that the iteration does not stray into 
a region which will yield overflows or other problems. 

<div class="p"><!----></div>
 <br /><br /><a name="muler2"> </a>
 <b>80.&nbsp;MULER2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/muler2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/muler2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate a complex zero of a given 
function using Muller's method. This subroutine is essentially identical 
to the subroutine MULLER described earlier, except for the fact that 
here the given function is calculated in the form  
f(<span class="roman">CX</span>)=<span class="roman">CF</span>&times;2<sup><span class="roman">IX</span></sup>, which is suitable for those 
functions which will normally overflow or underflow on the computer. 
For example, this subroutine is very useful to calculate the zeros of determinants 
arising out of finite difference approximation to differential equations. 
Apart from this, it uses the reverse communication technique for passing 
function values. This subroutine will return control to the calling 
program when it needs a function evaluation. In that case, the 
error parameter IER will be set to a negative value and the function 
should be evaluated at z=<span class="roman">CX</span>. The value of the function 
should be returned in the variables CF and IX<!--hbox-->. Here CX and CF are 
complex variables while IX is an integer. The function value is expressed 
in the form explained above. During the function evaluation 
variables other than CF and IX in the call statement should not be disturbed. 
Before the first call IER should be set to zero. 
IER &#8805; 0 imply that the execution is complete and no more function 
evaluations are required. 
Apart from CF, CX and IX other 
arguments as well as error exits are identical to those for <a href="appendixb.htm#muller">MULLER</a>. 
For an example of the usage of this subroutine see subroutine <a href="appendixb.htm#zroot2"> ZROOT2</a> above. 

<div class="p"><!----></div>
 <br /><br /><a name="delves"> </a>
 <b>81.&nbsp;DELVES&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/delves.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/delves.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate complex zeros of an analytic 
function inside a given circle in the complex plane. This subroutine 
uses the quadrature based method described in Section&nbsp;7.9. This method also requires the first derivative of the function. 
CZ is a complex 
variable specifying the centre of the required circle in the complex 
plane. RAD is a real variable specifying the radius of this circle. 
The roots inside a circle with centre at CZ and radius RAD should 
be calculated. CF is the name of the function routine used to calculate the 
given function and its derivative. 
FUNCTION CF(Z, CDF) must be supplied by the user, where  
CF, CDF and Z are complex variables and CDF is the first derivative of CF<!--hbox--> at Z<!--hbox-->. 
NZ is an output parameter 
containing the number of roots located by the subroutine. CZERO is a 
complex array of length  NMAX(=5), which will contain the zeros 
located by the subroutine. Since this subroutine will not attempt 
to determine the zeros, unless the number is less than or 
equal to <span class="roman">NMAX</span>, the 
size of the array CZERO need not be more than NMAX<!--hbox-->. IER is the error 
parameter. IER=405 implies that the radius RAD is zero or negative, in 
which case, no calculations are performed. IER=434 implies that the 
number of zeros inside the circle exceeds NMAX and no further 
calculations are performed. In this case, NZ will contain the estimated number 
of zeros inside the circle. To find the zeros in this case, a second 
attempt may be made with smaller circles covering the original area. 
IER=435 implies that the Newton-Raphson iteration for refining the 
calculated zero did not converge for at least one zero. 
In such cases, again a second attempt with smaller circle may help. 
These problems may be due to the fact that the contour is very close to 
one of the zero, in which case changing the radius may help. 
IER=436 implies that the subroutine POLYC fails to find the 
roots of the required polynomial. In this case, attempt will be made 
using Newton-Raphson method on whatever values are available. 
Other values of IER may be set by the subroutine <a href="appendixb.htm#contur"> CONTUR</a>, which is called to 
evaluate the contour integrals. 
REPS and AEPS specify the relative and absolute convergence criterion. 
The zeros should be calculated with an accuracy 
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span>&#124;). 
This subroutine requires subroutine CONTUR to calculate the contour integrals, 
subroutines <a href="appendixb.htm#polyc"> POLYC</a> and <a href="appendixb.htm#lagitc"> LAGITC</a> to calculate the zeros of resulting 
polynomial, and subroutine <a href="appendixb.htm#newrac"> NEWRAC</a> to refine the calculated zeros by 
iterating on the original function. In addition of course, the function 
routine CF will be required. Before using this subroutine, it is 
essential to ensure that the required function is analytic everywhere 
inside the given circle. 

<div class="p"><!----></div>
 <br /><br /><a name="contur"> </a>
 <b>82.&nbsp;CONTUR&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/contur.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/delves.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to evaluate the contour integrals over 
a circle, as required by the subroutine DELVES for finding complex 
zeros of an analytic function. 
CF is the name of the function routine used to calculate the 
given function. FUNCTION CF(Z, CDF) must be supplied by the user. Here  
CF, CDF and Z are complex variables and CDF is the first derivative of CF<!--hbox--> at Z<!--hbox-->. 
CZ is a complex 
variable specifying the centre of the required circle in the complex 
plane. RAD is a real variable specifying the radius of this circle. 
NZ is an output parameter, containing the number of zeros 
inside a circle with centre at CZ and radius RAD<!--hbox-->. 
CS is a complex 
array of length  NMAX, which will contain the calculated 
values of the contour integrals 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">CS</span><span class="roman">(</span><span class="roman">K</span><span class="roman">)</span>=</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#960;i<br /></td><td nowrap="nowrap" align="center">
</td><td align="center">&#8992;<br />(&#x239C;)<br />&#8993;<br /></td><td></td><td nowrap="nowrap" align="center">
z<sup><span class="roman">K</span></sup>f(z)&nbsp;&nbsp;dz
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>f&#8242;(z)<br /></td><td nowrap="nowrap" align="center">
 = </td><td nowrap="nowrap" align="center">
<small><span class="roman">NZ</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
z<sub>j</sub><sup><span class="roman">K</span></sup>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<span class="roman">K</span>=1,2,&#8230;,<span class="roman">NZ</span>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.31)</td></tr></table>
</td></tr></table>

 
where z<sub>j</sub> are the zeros inside the given circle. 
NMAX is the maximum number of zeros to be located. 
IER is the error 
parameter. IER=437 implies that the calculation of the first integral 
giving the number of roots within the given circle has not converged 
satisfactorily. This failure could be due to the fact that the circle is too big, 
or the boundary is too close to one of the zeros. A second attempt with a 
smaller circle or after shifting the original circle appropriately may 
help in this case. IER=434 implies that the 
number of zeros inside the circle exceeds NMAX and no further 
calculations are performed. 
In this case, NZ will contain the estimated number 
of zeros inside the circle. To find the zeros in this case, a second 
attempt may be made with smaller circles covering the original area. 
IER=44 implies that the iteration to estimate the first integral did  
not converge to satisfactory accuracy, but the value is less than 0.5 
in magnitude. In this case, most probably there is no root inside the given 
circle and NZ is set to zero. IER=45 implies that the integral 
did not converge to a satisfactory accuracy, but the value of NZ may still 
be reasonable. In this case, the calculations are continued further. 
IER=46 implies that the iteration for evaluation of the higher integrals 
i.e., (CS(I), I=1, NZ) did not converge to satisfactory accuracy. 
The calculations are not aborted at this stage, since most of the effort 
required in this subroutine has anyway been spent by now. With little 
extra effort, we can as well compute the zeros and check if they are reliable. 
The reliability can be verified by the fact that the iteration with original 
function converges during the refinement phase in subroutine <a href="appendixb.htm#delves"> DELVES</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="newrac"> </a>
 <b>83.&nbsp;NEWRAC&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/newrac.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/delves.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate a complex zero of a given function 
using the Newton-Raphson method. This is a complex version of subroutine 
<a href="appendixb.htm#newrap"> NEWRAP</a>, but it does not try to estimate the multiplicity of the zero. 
CX is the complex variable 
specifying the starting value. After execution, 
CX will contain the computed value of the zero. 
REPS and AEPS specify the relative 
and absolute convergence criterion. The zero should be calculated with 
an accuracy of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">CX</span>&#124;).  
IER is the error parameter. IER=425 implies that the iteration 
did not converge. IER=426 implies that the derivative turns out to be zero 
at some stage, in which case, the iteration cannot be continued further. 
If the zero is multiple, then this situation can arise, when the iteration is inside 
the domain of indeterminacy. In that case, the computed zero may be acceptable. 
However, in other cases, the computed zero will have no meaning if the 
derivative is zero. CFUN is the name of the 
external routine to calculate the required function and its derivative. 
FUNCTION CFUN(Z, CDF) must be supplied by the user, 
where CF, CDF and Z are all complex variables and CDF is the first derivative 
of the function CFUN at Z<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="polyr"> </a>
 <b>84.&nbsp;POLYR&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polyr.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polyr.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate all zeros of a polynomial 
of degree N, with real coefficients, using Laguerre's method. N is the 
degree of polynomial, A is a real array of length <span class="roman">N</span>+1 containing 
the coefficients of the polynomial. A(I) is the coefficient of x<sup>I&#8722;1</sup> 
in the polynomial i.e., A(1) is the constant term while A(N+1) is the 
coefficient of x<sup>N</sup>. A(N+1) should be nonzero. CX is a complex array 
of length N, 
which will contain the zeros of the polynomial after the execution is 
complete. The roots are sorted in the order of increasing real part. 
However, if the subroutine is terminated abnormally, then the roots may 
not be sorted. 
IER is the error parameter. IER=406 implies that <span class="roman">N</span> &#8804; 0, 
while IER=408 implies that <span class="roman">A</span><span class="roman">(</span><span class="roman">N</span><span class="roman">+</span><span class="roman">1</span><span class="roman">)</span>=0. 
In such cases, no calculations are performed. 
IER=430 implies that the Laguerre's iteration failed to converge at some 
stage. In this case, the roots already located until then, will be available 
in CX<!--hbox-->. IER=n&times;11 implies that the iteration for 
refining the roots did not converge for n of the roots. 
QREFIN is a logical parameter, QREFIN=.TRUE. specifies 
that the computed zeros should be "refined" by iterating with the original 
polynomial. QREFIN=.FALSE. specifies that the refinement is not required. 
This parameter may be useful, if there is some doubt that the iteration during 
refinement has converged to some other root, thereby giving rise to an 
apparent double root. WK is a real array of length <span class="roman">N</span>+1, which 
is used as a scratch space by the subroutine to store intermediate numbers. 
The parameter EPS inside the subroutine should be of the order of &#295; 
for the arithmetic being used. This value is used only to decide whether 
the root is real or complex. If z=x+iy is the computed root and 
&#124;y&#124; &#8804; 10EPS&times;&#124;x&#124;, then the root is assumed to be real. Depending on the 
outcome of this test, 
the subroutine performs deflation for a real root, or a pair of complex 
conjugate roots. This parameter EPS should be changed to appropriate 
value, but the exact value may not be crucial for working of the subroutine, 
unless there are roots with very small, but nonzero imaginary parts. 
This subroutine requires subroutine LAGITR to perform the Laguerre's 
iteration. 

<div class="p"><!----></div>
 <br /><br /><a name="lagitr"> </a>
 <b>85.&nbsp;LAGITR&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/lagitr.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polyr.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to find one root of a polynomial of degree N 
with real coefficients, 
using Laguerre's method. N is the degree of polynomial and A is the real 
array of length <span class="roman">N</span>+1 containing the coefficients. 
A(I) is the coefficient of x<sup>I&#8722;1</sup>. 
CXI is the starting value for the Laguerre's iteration. After execution, 
CXI will contain the computed root. IER is the error 
parameter. IER=439 implies that the iteration has failed to converge to 
any reasonable accuracy. IER=438 implies that the denominator in the iteration 
function vanishes and the iteration cannot be continued. In practice, 
it is rare for this iteration to fail, unless the polynomial is too  
ill-conditioned for the precision of the arithmetic used. 

<div class="p"><!----></div>
 <br /><br /><a name="polyc"> </a>
 <b>86.&nbsp;POLYC&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polyc.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polyc.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate all zeros of a polynomial 
of degree N, with complex coefficients, using Laguerre's method.  
This subroutine is the complex version of <a href="appendixb.htm#polyr">POLYR</a>. N is the 
degree of polynomial. COF is a complex array of length  <span class="roman">N</span><span class="roman">+</span><span class="roman">1</span>, containing 
the coefficients of the polynomial. COF(I) is the coefficient of x<sup>I&#8722;1</sup> 
in the polynomial i.e., COF(1) is the constant term while COF(N+1) is the 
coefficient of x<sup><span class="roman">N</span></sup>. COF(N+1) should be nonzero. CX is a complex array 
of length N, 
which will contain the zeros of the polynomial after the execution is 
complete. IER is the error parameter. IER=406 implies that <span class="roman">N</span> &#8804; 0, 
while IER=408 implies that <span class="roman">COF</span><span class="roman">(</span><span class="roman">N</span><span class="roman">+</span><span class="roman">1</span><span class="roman">)</span>=0. 
In such cases, no calculations are performed. 
IER=430 implies that the Laguerre's iteration failed to converge at some 
stage. In this case, the roots already located until then, will be available 
in CX<!--hbox-->. IER=n&times;11 implies that the iteration for 
refining the roots did not converge for n of the roots. 
QREFIN is a logical parameter, QREFIN=.TRUE. specifies 
that the computed zeros should be "refined" by iterating with the original 
polynomial. QREFIN=.FALSE. specifies that the refinement is not required. 
This parameter may be useful, if there is some doubt that the iteration during 
refinement has converged to some other root, thereby giving rise to an 
apparent double root. CWK is a complex array of length  <span class="roman">N</span>+1, which 
is used as a scratch space by the subroutine to store intermediate numbers. 
This subroutine requires subroutine LAGITC to perform the Laguerre's 
iteration. 

<div class="p"><!----></div>
 <br /><br /><a name="lagitc"> </a>
 <b>87.&nbsp;LAGITC&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/lagitc.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polyc.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
  Subroutine to find one root of a polynomial of degree N 
with complex coefficients, 
using Laguerre's method. N is the degree of polynomial and COF is a complex 
array of length <span class="roman">N</span>+1 
containing the coefficients. COF(I) is the coefficient of x<sup>I&#8722;1</sup>. 
CXI is the starting value for the Laguerre's iteration. After execution, 
CXI will contain the computed root. IER is the error 
parameter. IER=439 implies that the iteration has failed to converge to 
any reasonable accuracy. IER=438 implies that the denominator in the iteration 
function vanishes and the iteration cannot be continued. In practice, 
it is rare for this iteration to fail, unless the polynomial is too  
ill-conditioned for the precision of the arithmetic used. 

<div class="p"><!----></div>
 <br /><br /><a name="davidn"> </a>
 <b>88.&nbsp;DAVIDN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/davidn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/newton.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a system of nonlinear equations using 
Davidenko's method. This method can be coupled with any subroutine 
for solving a system of nonlinear equations to improve its chances of 
convergence. It can be used with subroutine <a href="appendixb.htm#newton"> NEWTON</a> for Newton's method, 
when the Jacobian can be easily calculated, or 
with subroutine <a href="appendixb.htm#broydn"> BROYDN</a> for Broyden's method, when the Jacobian is too 
complicated to be calculated explicitly. FCN is the name of the subroutine to calculate 
the vector function, i.e., the left-hand sides of the equations 
(the right-hand sides are assumed to be zero). This subroutine should also 
calculate the Jacobian if Newton's method is to be used. This subroutine 
must contain the COMMON/DNFUN/&#8230; statement to enable it to use the 
arguments from the common block. The value of THETA, the initial 
guess X0 and corresponding function values F0, which may be required to 
calculate the function required for the Davidenko's method. The function 
can be parametrised in any convenient way, but <span class="roman">THETA</span>=&#952;<sub>0</sub> should 
have the solution X0 and <span class="roman">THETA</span>=0 should correspond to the required 
function. The subroutine FCN should be of the form 

<div class="p"><!----></div>
<br /> <tt><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;&nbsp;SUBROUTINE FCN(NP,X,F,DF) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
   IMPLICIT REAL*8(A-H,O-Z) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
   PARAMETER(NMAX=200) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
   DIMENSION X(NP),F(NP),DF(NP,NP) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
   COMMON/DNFUN/THETA,X0(NMAX),F0(NMAX) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
   ....................... 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
   F(1)=........... 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
   ................ 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
   F(NP)=.......... 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
   DO  I=1,NP 
<br /><table align="left" border="0"><tr><td width="37" align="right">
</td></tr></table><!--hbox-->
   F(I)=F(I)-THETA*F0(I) 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
   ENDDO 
<br /><table align="left" border="0"><tr><td width="23" align="right">
</td></tr></table><!--hbox-->
 END
<div class="p"><!----></div>
</tt> Here NP is the number of variables, X and F are the vectors <b>x</b> and 
<b>f</b>, DF is the Jacobian. This form is for use with subroutine NEWTON<!--hbox-->. 
For use with BROYDN, the variable DF should be removed from the list 
of argument as well as from the dimension statement. The last few 
statements parametrise the function for Davidenko's method. Other 
parametrisation mentioned in Section&nbsp;7.16 can also be used, but if X(I) also occurs with THETA, then the Jacobian will also need to be modified (if 
Newton's method is to be used). If the function has some natural 
parameter, then it can be used instead of artificial parametrisation, 
provided the solution is known for some value of the parameter and 
&#952; = 0 corresponds to the required solution. The last requirement 
can be removed by a trivial change in the subroutine. 
The subroutine FCN with above specifications 
must be supplied by the user. 

<div class="p"><!----></div>
NP is the number of variables which 
must be equal to the number of equations. X is a real array of length 
NP containing the starting values. After execution, the solution 
will be returned in the same array. It is not essential to supply the 
starting values, since these values can be supplied at the time of 
execution through the read statement. Apart from the starting values, 
the subroutine will also ask for successive values of THETA, the 
parameter introduced into the equations. The value of THETA should 
be changed from &#952;<sub>0</sub> to zero gradually, where &#952;<sub>0</sub> is 
the value for which X0 is the exact solution 
of the system of equations. The value of &#952;<sub>0</sub> 
is generally assumed to be 1. Steps in which the value of THETA 
should change will depend on the functions involved. If at any stage the 
iteration fails to converge, a second attempt could be made with THETA 
changing in smaller steps, or with a different starting value. 
F is a real array of length  
NP, which will contain the value of the vector function <b>f</b> 
at the point specified by the array X<!--hbox-->. REPS and AEPS specify the relative 
and absolute convergence criterion.  
All components of the root should be calculated to an accuracy 
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>&#124;). The subroutine initially 
uses a more modest criterion, which may need to be changed if some 
of the components of the root are very small, since an absolute criterion 
with <span class="roman">AEPS</span><span class="roman">0</span>=10<sup>&#8722;4</sup> may be too large in that case. 
For such cases, change the  
value of AEPS0 suitably. AEPS0 may be set equal to AEPS if needed. 
IER is the error parameter. 
IER=407 implies that the value of 
NP is greater than NMAX (=200), or <span class="roman">NP</span> &lt; 1. In this case, the value of NMAX can be increased 
and the COMMON statement changed appropriately in the SUBROUTINE FCN<!--hbox-->. 
IER=440 implies that THETA did not reduce to zero, even after 
100 steps. In this case, a second attempt could be made with the last 
value of X as the starting value. 
Apart from this, other values of IER 
may be returned by the subroutine NEWTON or BROYDN<!--hbox-->. WK is a real 
array of length  <span class="roman">NP</span><sup>2</sup>+<span class="roman">NP</span> for subroutine NEWTON and 
max(2<span class="roman">NP</span><sup>2</sup>,<span class="roman">NP</span><sup>2</sup>+4<span class="roman">NP</span>) for BROYDN<!--hbox-->.  
WK is used as a scratch space to store intermediate results.  
IWK is an integer array of 
length  NP used as a scratch space to store intermediate numbers. 
This subroutine 
requires subroutine <a href="appendixb.htm#newton"> NEWTON</a> or <a href="appendixb.htm#broydn"> BROYDN</a> to solve the system of nonlinear 
equations and subroutine <a href="appendixb.htm#gauelm"> GAUELM</a> to solve intermediate systems 
of linear equations. 
To use BROYDN instead of NEWTON, the call statement should 
be changed as indicated in the comments. 
DAVIDN<tt>_</tt>B is the version for use with BROYDN. 

<div class="p"><!----></div>
 <br /><br /><a name="newton"> </a>
 <b>89.&nbsp;NEWTON&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/newton.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/newton.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a system of nonlinear equations 
using Newton's method. This method requires the calculation of the full 
Jacobian at every step. This subroutine can be used directly, if a 
good approximation to the root is known. Otherwise, it 
may be better to use it through subroutine <a href="appendixb.htm#davidn"> DAVIDN</a> to improve the chances 
of convergence. NP is the number of equations in the system. X is a real 
array of length NP containing the initial approximation to the solution. 
After execution, the computed solution will be returned in the same array. 
F is a real array of length NP containing the value of vector function 
<b>f</b> at the point specified by the array X<!--hbox-->. 
FCN is the name of the subroutine used to calculate the 
left-hand sides of the system of equations (the right-hand sides 
are assumed to be zero). 
The subroutine FCN(NP, X, F, DF) must be supplied by the user. (Here NP 
is the number of equations in the system. X and F are real arrays of 
length  NP containing the values of <b>x</b> and the vector function 
<b>f</b>, respectively. DF is a two-dimensional real array  
of length <span class="roman">NP</span>&times;<span class="roman">NP</span> containing the Jacobian with 
<span class="roman">DF</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">J</span><span class="roman">)</span>=&#8706;<span class="roman">F</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>/&#8706;<span class="roman">X</span><span class="roman">(</span><span class="roman">J</span><span class="roman">)</span>. 
It should be noted that in subroutine FCN,  
the first dimension of array DF must be equal to NP itself.) 
REPS and AEPS specify the relative and absolute convergence criterion.  
All components of the root should be calculated to an accuracy 
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>&#124;). IER is the error 
parameter. IER=442 implies that the iteration did not converge 
to the specified accuracy. 
IER=441 implies that the subroutine <a href="appendixb.htm#gauelm"> GAUELM</a> used to solve the intermediate 
systems of linear equation has failed. This failure can occur if the value 
of NP is unacceptable, or if the Jacobian matrix is nearly singular. WK is a real 
array of length  <span class="roman">NP</span><sup>2</sup>+<span class="roman">NP</span>, used as a scratch space to 
store intermediate results. IWK is an integer array of 
length  NP, used as a scratch space to store intermediate numbers. 

<div class="p"><!----></div>
 <br /><br /><a name="broydn"> </a>
 <b>90.&nbsp;BROYDN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/broydn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/broydn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a system of nonlinear equations 
using Broyden's method. This method does not require the calculation of  
derivatives. This subroutine can be used directly if a 
good approximation to the root is known. Otherwise, it 
may be better to use it through subroutine <a href="appendixb.htm#davidn"> DAVIDN</a><tt>_</tt>B to improve the chances 
of convergence. NP is the number of equations in the system. X is a real 
array of length NP containing the initial approximation to the solution. 
After execution, the computed solution will be returned in the same array. 
F is a real array of length NP containing the value of vector function 
<b>f</b> at the point specified by the array X<!--hbox-->. 
FCN is the name of the subroutine used to calculate the 
left-hand sides of the system of equations (the right-hand sides 
are assumed to be zero). 
The subroutine FCN(NP, X, F) must be supplied by the user. (Here NP 
is the number of equations in the system. X and F are real arrays of 
length  NP containing the values of <b>x</b> and the vector function 
<b>f</b><b>(</b><b>x</b><b>)</b>, respectively.) 
REPS and AEPS specify the relative and absolute convergence criterion.  
All components of the root should be calculated to an accuracy 
of max(<span class="roman">AEPS</span>,<span class="roman">REPS</span> &#124;<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>&#124;). IER is the error 
parameter. IER=442 implies that the iteration did not converge 
to the specified accuracy. 
IER=441 implies that the subroutine <a href="appendixb.htm#gauelm"> GAUELM</a> used to solve the intermediate 
systems of linear equation has failed. This failure can occur if the value 
of NP is unacceptable, or if the matrix is nearly singular. WK is a real 
array of length  max(2<span class="roman">NP</span><sup>2</sup>,<span class="roman">NP</span><sup>2</sup>+4<span class="roman">NP</span>), 
used as a scratch space to store intermediate results.  
IWK is an integer array of 
length  NP used as a scratch space to store intermediate numbers. 

<div class="p"><!----></div>
 

<br /><br />
<a name="Optimisation"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.8&nbsp; OPTIMISATION </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#brackm">BRACKM</a></td>
<td>&nbsp; <a href="#golden">GOLDEN</a></td>
<td>&nbsp; <a href="#brentm">BRENTM</a></td>
<td>&nbsp; <a href="#davidm">DAVIDM</a></td>
<td>&nbsp; <a href="#bfgs">BFGS</a></td>
<td>&nbsp; <a href="#linmin">LINMIN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#flnm">FLNM</a></td>
<td>&nbsp; <a href="#nminf">NMINF</a></td>
<td>&nbsp; <a href="#linmnf">LINMNF</a></td>
<td>&nbsp; <a href="#fln">FLN</a></td>
<td>&nbsp; <a href="#simplx">SIMPLX</a></td>
<td>&nbsp; <a href="#simpx">SIMPX</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="brackm"> </a>
 <b>91.&nbsp;BRACKM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/brackm.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/golden.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to bracket a minimum in one dimension. 
At the time of 
calling A and B should contain the two starting values for search. 
After execution, the triplet (A, X, B) should bracket 
the minimum with <span class="roman">F</span><span class="roman">(</span><span class="roman">X</span><span class="roman">)</span> &lt; min(<span class="roman">F</span><span class="roman">(</span><span class="roman">A</span><span class="roman">)</span><span class="roman">,</span> <span class="roman">F</span><span class="roman">(</span><span class="roman">B</span><span class="roman">)</span>) and  
X in between A and B<!--hbox-->. F is the name of the function routine used to 
calculate the function to be minimised. FUNCTION F(X) must be supplied 
by the user. IER is the error parameter. IER=501 implies that  
<span class="roman">A</span>=<span class="roman">B</span> and no calculations are performed. IER=521 implies 
that the subroutine failed to locate a minimum. This failure can occur, if there 
is no minimum, or if the initial step &#124;<span class="roman">B</span>&#8722;<span class="roman">A</span>&#124; is too large, which 
causes the subroutine to jump over the minimum, or if the minimum is too 
far off as compared to the initial step size. 

<div class="p"><!----></div>
 <br /><br /><a name="golden"> </a>
 <b>92.&nbsp;GOLDEN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/golden.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/golden.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to minimise a function in one dimension 
using the golden section search. Before calling the subroutine, the 
minimum should be bracketed by the triplet (A, X, B) with X in between 
A and B and <span class="roman">F</span><span class="roman">(</span><span class="roman">X</span><span class="roman">)</span> &lt; min(<span class="roman">F</span><span class="roman">(</span><span class="roman">A</span><span class="roman">)</span><span class="roman">,</span><span class="roman">F</span><span class="roman">(</span><span class="roman">B</span><span class="roman">)</span>). It is not necessary 
to have <span class="roman">B</span> &gt; <span class="roman">A</span>, but X must be between A and B<!--hbox-->. 
After execution, the 
final bracket will be overwritten on (A, X, B) with the central value 
X giving the best approximation to the minimiser. FX will give the 
value of the function at X<!--hbox-->. The parameters REPS and AEPS specify 
the relative and absolute convergence criterion. 
The interval will be subdivided until 
&#124;<span class="roman">B</span>&#8722;<span class="roman">A</span>&#124; &lt; max(<span class="roman">REPS</span>&#124;<span class="roman">X</span>&#124;,<span class="roman">AEPS</span>). IER is the 
error parameter. 
IER=50 implies that the process 
of subdivision was terminated, because the function value is equal at 
all the three points. This is usually due to roundoff error as explained in 
Section 8.1. IER=51 implies that the required accuracy was not achieved, even after 
NIT (=100) subdivisions. This problem can arise if very high accuracy is required, 
or if the initial bracket is too large. 
IER=522 implies that the input values of A, B, X 
are not consistent, i.e., either they do not bracket a minimum or 
X is not between A and B<!--hbox-->. In this case, no calculations will be performed. 
F is the name of the function routine used to calculate the 
function to be minimised. FUNCTION F(X) must be supplied by the user. 

<div class="p"><!----></div>
 <br /><br /><a name="brentm"> </a>
 <b>93.&nbsp;BRENTM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/brentm.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/brentm.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to minimise a function in one dimension 
using the Brent's method. This subroutine is based on the procedure 
given by Brent&nbsp;(1973). Before calling this subroutine, the 
minimum should be bracketed by the triplet (A, X, B) with  
<span class="roman">F</span><span class="roman">(</span><span class="roman">X</span><span class="roman">)</span> &lt; min(<span class="roman">F</span><span class="roman">(</span><span class="roman">A</span><span class="roman">)</span><span class="roman">,</span><span class="roman">F</span><span class="roman">(</span><span class="roman">B</span><span class="roman">)</span>) and X between A and B<!--hbox-->. After execution, the 
final bracket will be overwritten on (A, X, B) with the central value 
X giving the best approximation to the minimiser. FX will give the 
value of the function at X<!--hbox-->. The parameters REPS and AEPS specify 
the relative and absolute convergence criterion. The minimiser X 
should be calculated with an accuracy of 
max(<span class="roman">REPS</span>&#124;<span class="roman">X</span>&#124;,<span class="roman">AEPS</span>). IER is the error parameter. 
IER=51 implies that the required accuracy was not achieved, even after 
NIT (=75) iterations. This failure can occur if very high accuracy is required 
or if the initial bracket is too large. 
IER=523 implies that the input values of A, B, X 
are not consistent, i.e., either they do not bracket a minimum or 
X is not between A and B<!--hbox-->. In this case, no calculations will be performed. 
No test for roundoff error is 
performed in this subroutine and the result may not be accurate to the 
specified accuracy, even if the interval has been reduced to the 
required size. 
F is the name of the function routine used to calculate the 
function to be minimised. FUNCTION F(X) must be supplied by the user. 

<div class="p"><!----></div>
 <br /><br /><a name="davidm"> </a>
 <b>94.&nbsp;DAVIDM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/davidm.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/davidm.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to minimise a function in one dimension 
using the Hermite cubic interpolation. This method requires the 
calculation of the first derivative in addition to the function value. 
X1 and X2 specify the two 
distinct starting values. These values need not bracket the minimum. 
After execution, X1 and X2 will contain the last two iterates with 
X2 giving the best approximation to the minimiser. F2 will give the 
value of the function at X2, while D2F gives the estimate for second 
derivative, which is used to distinguish between a minimum and a maximum. 
If D2F &gt; 0 then X2 should be a minimiser, otherwise X2 should 
be a maximiser. Since D2F is merely an estimate of second derivative, 
if it is close to zero the nature of extremum will be difficult to 
determine. 
The parameters REPS and AEPS specify 
the relative and absolute convergence criterion. The minimiser X2 
should be calculated with an accuracy of 
max(<span class="roman">REPS</span>&#124;<span class="roman">X</span><span class="roman">2</span>&#124;,<span class="roman">AEPS</span>). IER is the error parameter. 
IER=52 implies that the iteration has converged to a maximiser, rather 
than a minimiser. This distinction is made on the basis of the sign of 
the estimated second derivative and hence may not necessarily be correct 
if roundoff error is significant. In particular, a point of inflection 
can be passed on as either a minimiser or a maximiser. 
IER=502 implies that <span class="roman">X</span><span class="roman">1</span>=<span class="roman">X</span><span class="roman">2</span>, in which 
case, no calculations will be performed. 
IER=524 implies that the iteration cannot 
be continued further, since the Hermite cubic does not have a minimum 
and the corresponding parabolic interpolation yields a zero denominator. 
IER=525 implies that the required accuracy was not achieved, even after 
NIT (=75) iterations. The convergence failure can occur if very high accuracy is required, 
or if the starting values are far from the minimiser. 
F is the name of the function routine used to calculate the 
function to be minimised and its derivative. FUNCTION F(X, DF) must be 
supplied by the user. Here DF is the first derivative of F at X<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="bfgs"> </a>
 <b>95.&nbsp;BFGS&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bfgs.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bfgs.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to find minimum of a function of N variables 
using the quasi-Newton method, with BFGS formula for updating the Hessian matrix. 
This method requires the calculation of gradient vector in addition to 
the function value. 
X is a real array of length  N, containing the starting values 
for the independent variables. After execution, the minimiser will be 
returned in the same array X<!--hbox-->. F is a real variable giving the value of 
the function at X<!--hbox-->. G is a real array of length  N, which will 
contain the value of the gradient vector at X (<span class="roman">G</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>=[(&#8706;<span class="roman">F</span>)/(&#8706;<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>)]). H is a two-dimensional array of length at 
least <span class="roman">N</span>&times;<span class="roman">N</span>, which will 
contain an approximation to the inverse of the Hessian matrix at X<!--hbox-->. 
The first dimension of H must be equal to N<!--hbox-->. 
F, G and H are output parameters, which 
need not be initialised at the time of calling. 
NUM is an output parameter containing the number of function evaluations required by the 
subroutine. The parameters REPS and AEPS specify 
the relative and absolute convergence criterion. Each component of the 
minimiser X should be calculated with an accuracy of 
max(<span class="roman">REPS</span>&#124;<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>&#124;,<span class="roman">AEPS</span>). IER is the error parameter. 
IER=53 implies that the Hessian matrix 
is probably singular at the final point. In this case, the iteration 
could have converged to a saddle point and further investigation may 
be required to determine the nature of the stationary point. 
This is detected by considering the 
norm of the matrix H as explained in Section 8.5. This test is not very reliable, 
particularly if the required accuracy is too low or too high. 
IER=503 implies that <span class="roman">N</span> &lt; 1, in which case no 
calculations are performed. IER=526 implies that the iteration failed to 
converge to a satisfactory accuracy. 
Other 
values of IER may be set by the subroutine <a href="appendixb.htm#linmin"> LINMIN</a>, which is called to perform 
the line searches. FCN is the name of the subroutine which calculates the 
function F and the gradient vector G<!--hbox-->. 
WK is a real array of length  3N, which is used as a scratch space. 
SUBROUTINE FCN(N, X, F, G) must be supplied by the user. 
Here N is the number of variables, F is the function value, while 
X and G are real arrays of length N, containing the coordinates of 
the point X, where the function F and the gradient 
vector G are to be evaluated. 
Apart from FCN this subroutine requires the subroutine 
LINMIN to perform the line searches and the function <a href="appendixb.htm#flnm"> FLNM</a> to calculate 
the function and its derivative along the given line, as required by LINMIN. 

<div class="p"><!----></div>
 <br /><br /><a name="linmin"> </a>
 <b>96.&nbsp;LINMIN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/linmin.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bfgs.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform line search as required by 
the subroutine <a href="appendixb.htm#bfgs"> BFGS</a><!--hbox-->. It implements a crude, but reasonably efficient algorithm 
to find an acceptable minimum of a function of N variables 
along a given direction. Any point which satisfies the conditions (8.37) is acceptable. This subroutine requires the first derivative of the 
function in addition to the function value. 
This subroutine should only be used for line search as required by 
quasi-Newton methods and not for any other purpose, since the criterion 
for acceptance will not suffice for other purposes. 
X1 is the starting point from where the line search is to 
be performed. X2 is the first guess for the minimum. After execution, 
X1, F1 and DF1 will respectively contain the accepted point, the value of the function 
and its first derivative along 
the given direction at that point. The parameters REPS and AEPS specify 
the relative and absolute convergence criterion for the subroutine BFGS<!--hbox-->. 
These parameters are used here only to terminate the line search, once 
the interval has been reduced sufficiently. This situation should not arise 
normally, but occasionally because of roundoff error, or error in 
coding the derivatives, the subroutine may fail to find acceptable points. 
IER is the error parameter. 
IER=527 implies that the subroutine has 
failed to find any point, where the function value is less than 
or equal to that at the starting 
point. This failure could be due to roundoff error, or more likely due to some error 
in coding the derivatives. 
IER=55 or 528 implies that the subroutine failed to 
find an acceptable point, even though the interval has been reduced to 
specified tolerance. In this case, the last point is accepted if 
the function value is less than or equal to that at starting point (IER=55), otherwise 
IER=528. 
IER=54 implies that the  
subroutine failed to find an acceptable point in NIT (=15) iterations, but the 
function value at the last approximation is less than or equal to the value 
at the starting point and this point is accepted. The last two  
conditions are often encountered, when the iteration is close to convergence 
and the accuracy requirement is too high. The final point may be acceptable 
in such circumstances. This can be checked by verifying the value of the 
gradient vector in subroutine BFGS<!--hbox-->. The parameters F, V, XI, N and 
NUM are not used by this subroutine, but are simply passed on to the 
FUNCTION <a href="appendixb.htm#flnm"> FLNM</a>, for calculating the function value and the first derivative. 
F is the name of the subroutine used to calculate the function of N 
variables, V is a real array of length  3N, first N elements 
of which contain the direction along which the line search is to be 
carried out. After execution of FLNM the next N elements will contain the coordinates of the 
last point at which the function is evaluated, while the last N  
elements of this array will contain the gradient vector at the last point. 
XI is a real array of length  N, containing the coordinates of 
the starting point for the line search. NUM is an integer variable to 
keep count of the number of function evaluations. This subroutine 
requires the function FLNM and the subroutine F to calculate the function. 
SUBROUTINE F(N, X, FX, G) must be supplied by the user. 
Here N is the number of variables, FX is the function value, while 
X and G are real arrays of length N, containing the coordinates of 
the point X, where the function FX and the gradient 
vector G are to be evaluated. 

<div class="p"><!----></div>
 <br /><br /><a name="flnm"> </a>
 <b>97.&nbsp;FLNM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/flnm.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bfgs.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the function as required for the 
line search routine <a href="appendixb.htm#linmin"> LINMIN</a><!--hbox-->. FCN is the name of the subroutine used to calculate 
the function of N variables. X is a parameter along the line which specifies the point at which 
the function is to be evaluated. DF is the first derivative along the line. 
V is a real array of length 3N, the first N elements of which 
specify the direction along which the search is being carried out. 
Next N elements will contain the coordinates of the point at which 
function is evaluated, while the last N elements contain the gradient 
vector at this point. 
X0 is a real array of length  N, containing the coordinates of 
the starting point. NUM is an integer variable which keeps a count of 
function evaluations. The function will be evaluated at the point with 
coordinates <span class="roman">XI</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>=<span class="roman">X</span><span class="roman">0</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>+<span class="roman">X</span>&times;<span class="roman">V</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>. 
These coordinates are returned in <span class="roman">N</span>+1 to 2N element of array V<!--hbox-->. 
The SUBROUTINE FCN(N, XI, F, G) must be supplied 
by the user. Here XI is a real array of length  N, containing 
the coordinates of the required point. F is the function value at this point. 
G is a real array of length  N containing the gradient vector at 
XI.  

<div class="p"><!----></div>
 <br /><br /><a name="nminf"> </a>
 <b>98.&nbsp;NMINF&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/nminf.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/nminf.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to find minimum of a function of N variables, 
using a direction set method. This method does not require calculation 
of the derivatives. 
X is a real array of length  N, containing the starting values 
for the independent variables. After execution, the minimiser will be 
returned in the same array X<!--hbox-->. F is a real variable giving the value of 
the function at X<!--hbox-->. 
NUM is an output parameter containing the number of function evaluations required by the 
subroutine. The parameters REPS and AEPS specify 
the relative and absolute convergence criterion. The iteration is 
continued until the change in function value &#948;F during one 
complete cycle consisting of N iterations, satisfies 
&#124;&#948;F&#124; &lt; max(<span class="roman">REPS</span>&#124;<span class="roman">F</span>&#124;,<span class="roman">AEPS</span>). 
It may be noted that unlike subroutine <a href="appendixb.htm#bfgs"> BFGS</a>, here the convergence test 
is applied on function value, rather than the minimiser. 
This must be kept in mind while specifying REPS and AEPS<!--hbox-->. 
In general, relative change by REPS in function value will translate 
to relative variation by &#8730;{REPS} in coordinates of 
minimiser. 
IER is the 
error parameter. IER=504 implies that <span class="roman">N</span> &#8804; 1, in which case, no 
calculations are performed. IER=529 implies that the iteration failed to 
converge to a satisfactory accuracy. Other 
values of IER may be set by the subroutine <a href="appendixb.htm#linmnf"> LINMNF</a>, which is called to perform 
the line searches. FCN is the name of the subroutine which calculates the 
function F<!--hbox-->. SUBROUTINE FCN(N, X, F) must be supplied 
by the user. Here N is the number of variables, X is an array of length N containing 
the parameter values at which the function value is required. F is the 
calculated value of the function at X<!--hbox-->. 
WK is a real array of length <span class="roman">2</span><span class="roman">N</span><span class="roman">(</span><span class="roman">N</span><span class="roman">+</span><span class="roman">1</span><span class="roman">)</span>, which is used as 
a scratch space. Apart from FCN, this subroutine requires subroutine 
LINMNF to perform the line searches and function <a href="appendixb.htm#fln"> FLN</a> to calculate 
the function as required by LINMNF, and subroutine <a href="appendixb.htm#svd"> SVD</a> to perform the singular 
value decomposition. 

<div class="p"><!----></div>
 <br /><br /><a name="linmnf"> </a>
 <b>99.&nbsp;LINMNF&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/linmnf.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/nminf.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform line search as required by the 
subroutine <a href="appendixb.htm#nminf"> NMINF</a><!--hbox-->. It implements a crude, but reasonably efficient algorithm 
to find an acceptable minimum of a function of N variables 
along a given direction. This subroutine does not require any derivative. 
Any point, where the function value is less than that at the starting 
point is acceptable. This subroutine should only be used for line search 
as required by direction set methods. Because of the crude criterion 
for acceptance it is not suitable for a general minimisation along 
a given direction. 
X0 is the starting point, from where the line search is to 
be performed. X1 is the first guess for the minimum. After execution, X0 
and F0 will contain the accepted point and the corresponding function value. 
The parameters REPS and AEPS specify 
the relative and absolute convergence criterion for the subroutine NMINF<!--hbox-->. 
These parameters are used here only to terminate the line search, once 
the interval has been reduced sufficiently. This situation should not arise 
normally, but occasionally because of roundoff error, 
the subroutine may fail to find an acceptable point. 
IER is the error parameter. 
IER=56 implies that the subroutine failed to 
find an acceptable point and in this case, the starting point itself 
is accepted. The parameters F, V, XI, N and 
NUM are not used by this subroutine, but are simply passed on to the 
FUNCTION <a href="appendixb.htm#fln"> FLN</a>, to calculate the function value. 
F is the name of the subroutine used to calculate the function of N 
variables, V is a real array of length  N, containing 
the direction along which the line search is to be 
carried out. XI is a real array of length  2N, the first N 
elements contain the coordinates of the starting point for the line search. 
After execution of FLN, the next N elements will contain the coordinates of the 
last point at which the function is evaluated. 
NUM is an integer variable to 
keep count of the number of function evaluations. The subroutine LINMNF 
requires the function FLN and the subroutine F to calculate the function. 
SUBROUTINE F(N, X, FX) must be supplied 
by the user. Here N is the number of variables, X is an array of length N containing 
the parameter values at which the function value is required. FX is the 
calculated value of the function at X<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="fln"> </a>
 <b>100.&nbsp;FLN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/fln.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/nminf.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the function as required for the 
line search routine <a href="appendixb.htm#linmnf"> LINMNF</a><!--hbox-->. FCN is the name of the subroutine used to calculate 
the function of N variables. 
X is a parameter along the line which specifies the point at which 
the function is to be evaluated. 
V is a real array of length  N, containing 
the direction along which the search is being carried out. X0  
is a real array of length  2N, the first N elements of which 
specify the coordinates of 
the starting point. NUM is an integer variable which keeps a count of 
function evaluations. The function will be evaluated at a point with 
coordinates <span class="roman">XI</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>=<span class="roman">X</span><span class="roman">0</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>+<span class="roman">X</span>&times;<span class="roman">V</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>. 
The last N elements of X0 are used to store XI<!--hbox-->. 
The SUBROUTINE FCN(N, XI, F) must be supplied 
by the user. Here XI is a real array of length  N, containing 
the coordinates of the required point and F is the function value at this point. 

<div class="p"><!----></div>
 <br /><br /><a name="simplx"> </a>
 <b>101.&nbsp;SIMPLX&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/simplx.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/simplx.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a linear programming problem 
using the simplex method. N is the number of variables, each of which 
is constrained to be nonnegative. M1 is the number of constraints of the form 
<b>a</b><sup>T</sup><b>x</b> &#8804; b<sub>i</sub> &#8805; 0, M2 is the number of constraints of the form 
<b>a</b><sup>T</sup><b>x</b> &#8805; b<sub>i</sub> &#8805; 0, M3 is the number of constraints of the form 
<b>a</b><sup>T</sup><b>x</b> = b<sub>i</sub> &#8805; 0. A is a real array of length  <span class="roman">IA</span>&times;(<span class="roman">N</span><span class="roman">+</span><span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">1</span>). IA specifies the first dimension of A, exactly as 
in the calling program (<span class="roman">IA</span> &#8805; <span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">M</span><span class="roman">3</span><span class="roman">+</span><span class="roman">2</span>). The array A 
contains the tableau as explained in Section 8.7. At input the first 
row of A contains the cost coefficients <span class="roman">A</span><span class="roman">(</span><span class="roman">1</span><span class="roman">,</span><span class="roman">i</span><span class="roman">+</span><span class="roman">1</span><span class="roman">)</span>=c<sub>i</sub>, where 
c<sub>1</sub>x<sub>1</sub>+c<sub>2</sub>x<sub>2</sub>+&#8230;+c<sub>N</sub>x<sub>N</sub> is the function to be minimised. 
The next <span class="roman">M</span><span class="roman">=</span><span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">M</span><span class="roman">3</span> rows contain the coefficients for the 
constraints, with the rows 2 to <span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">1</span> containing the constraints 
of the first type, rows <span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">2</span> to <span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">1</span> containing the constraints 
of the second type and the remaining rows containing the constraints of the third type. 
<span class="roman">A</span><span class="roman">(</span><span class="roman">i</span><span class="roman">,</span><span class="roman">1</span><span class="roman">)</span>=b<sub>i</sub> and <span class="roman">A</span><span class="roman">(</span><span class="roman">i</span><span class="roman">,</span><span class="roman">j</span><span class="roman">+</span><span class="roman">1</span><span class="roman">)</span>=a<sub>j</sub> for the ith constraint. 
If <span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">M</span><span class="roman">3</span> &gt; 0, then the row <span class="roman">M</span><span class="roman">+</span><span class="roman">2</span> will be used by the 
subroutine to specify the cost coefficients for the auxiliary objective 
function to be minimised for finding a basic feasible vector. If only 
constraints of the first type are present, then this row will not be required. 
After the execution is complete, the optimal feasible vector will be 
returned in the real array X of length  N<!--hbox-->. F is an output parameter 
containing the optimum value of the objective function. IWK 
is an integer array of length  <span class="roman">N</span><span class="roman">+</span><span class="roman">M</span><span class="roman">+</span><span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">1</span>, which is used  
as a scratch space by the subroutine. This array will contain the permutation 
information about the variables. IWK(I), 2 &#8804; <span class="roman">I</span> &#8804; <span class="roman">M</span>+1 
gives the serial number of variable corresponding to the Ith row 
of the tableau. IWK(I), <span class="roman">I</span> &gt; <span class="roman">M</span>+1 gives the serial number of 
variable corresponding to (<span class="roman">I</span>&#8722;<span class="roman">M</span>)th column of the tableau. The variables 
are numbered as follows: the first N variables are the required variables, 
after that <span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">M</span><span class="roman">2</span> slack variables are introduced, and finally there are 
<span class="roman">M</span><span class="roman">2</span><span class="roman">+</span><span class="roman">M</span><span class="roman">3</span> artificial variables for the auxiliary problem. 
IER is the error parameter. 
IER=57 implies that the objective function is unbounded from below 
and no optimal feasible vector exists. 
IER=58 implies that, 
there is no basic feasible vector. Hence, the constraints are 
inconsistent or the problem is not properly formulated. 
IER=505 implies that at least one of the variables N, M1, M2 and M3 
is negative or IA &lt; <span class="roman">M</span>+2. IER=506 implies that at least one of the right-hand side 
coefficients in the constraints is negative. In both these cases, no 
calculations are performed. 
IER=531 implies that 
the simplex algorithm failed to find the optimal vector in a  
reasonable number of iterations. This failure can occur either because the 
number of iterations required are very large, or because the simplex 
iteration has gone into a nonterminating loop because of degeneracy. 
In principle, this failure can happen for the auxiliary problem for finding 
a basic feasible vector also. 
IER=532 implies that a basic feasible vector could not be found 
to start the simplex iteration. This situation can occur if the solution 
to the auxiliary problem is degenerate and the artificial variable on 
the left-hand side cannot be exchanged. This situation should not arise, 
unless the constraints are not linearly independent, or roundoff error 
is significant. 
AEPS is a real 
parameter to control roundoff error, any quantity less than AEPS in 
magnitude is assumed to be zero. This subroutine requires subroutine 
SIMPX to actually perform the simplex minimisation. 

<div class="p"><!----></div>
 <br /><br /><a name="simpx"> </a>
 <b>102.&nbsp;SIMPX&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/simpx.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/simplx.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve linear programming problems using 
the simplex method. The problem is assumed to be in the standard form and 
the initial tableau is supplied in the real array A of 
length  <span class="roman">IA</span>&times;(<span class="roman">N</span>&#8722;<span class="roman">M</span><span class="roman">+</span><span class="roman">1</span>) with <span class="roman">IA</span> &#8805; <span class="roman">M</span>+2. 
IA is the first dimension of A, exactly as specified in the calling  
program. N is the total number of variables in the given problem, 
including any slack or artificial variables that have been introduced. 
M is the number of constraints in the problem. NV is the number of 
variables excluding the artificial variables (if any). This parameter is used 
only for the auxiliary function, to check if any artificial variable 
is remaining on the left-hand side. QF is a logical variable, which 
should be set to .TRUE. if the main objective function specified by 
the first row of the tableau is to be minimised. QF should be set to 
.FALSE. if the auxiliary objective function specified by the last row 
of A is to be minimised for finding the initial basic feasible vector. 
In that case, attempt is made to remove the artificial variables from 
the set of left-hand side variables, before accepting the solution. 
ID and IV are integer arrays of length  <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> and  
<span class="roman">N</span>&#8722;<span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> respectively, used to store permutations of the original 
variables. IER is the error parameter. 
IER=57 implies that the objective function is unbounded from below and 
the optimal feasible vector does not exist. 
IER=531 implies that the 
simplex iteration has not converged in a reasonable number of iterations. 
This failure may be due to degeneracy, since that is not accounted for 
in this subroutine. 
AEPS is a real parameter used 
to control roundoff error. Any quantity less than AEPS in magnitude is assumed 
to be zero. 

<div class="p"><!----></div>
 

<br /><br />
<a name="Statistical Inferences"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.9&nbsp; STATISTICAL INFERENCES </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#shsort">SHSORT</a></td>
<td>&nbsp; <a href="#gammap">GAMMAP</a></td>
<td>&nbsp; <a href="#betap">BETAP</a></td>
<td>&nbsp; <a href="#betser">BETSER</a></td>
<td>&nbsp; <a href="#betcon1">BETCON1</a></td>
<td>&nbsp; <a href="#betcon">BETCON</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#betai">BETAI</a></td>
<td>&nbsp; <a href="#fbeta">FBETA</a></td>
<td>&nbsp; <a href="#rangau">RANGAU</a></td>
<td>&nbsp; <a href="#iranbin">IRANBIN</a></td>
<td>&nbsp; <a href="#iranpoi">IRANPOI</a></td>
<td>&nbsp; <a href="#pcor">PCOR</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="shsort"> </a>
 <b>103.&nbsp;SHSORT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/shsort.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/median.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to sort an array of length N in 
ascending order, using shell sort algorithm. A is a real array of length 
N, which is to be sorted. After execution the sorted elements will be 
returned in the same array. N is the number of elements of array A 
to be sorted. 

<div class="p"><!----></div>
 <br /><br /><a name="gammap"> </a>
 <b>104.&nbsp;GAMMAP&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gammap.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/betap.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the incomplete Gamma function 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 P(a,x)=</td><td nowrap="nowrap" align="center">
&#947;(a,x)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#915;(a)<br /></td><td nowrap="nowrap" align="center">
=</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#915;(a)<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>x</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
e<sup>&#8722;t</sup>t<sup>a&#8722;1</sup>&nbsp;&nbsp;dt&nbsp;&nbsp;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.32)</td></tr></table>
</td></tr></table>

 
It may be noted that sometimes the incomplete Gamma function is defined by 
&#947;(a,x). This should be accounted for while using the function routine. 
It is difficult to approximate this function over entire range of a,x values 
and it is possible that for some combination the value may not be reliable. 
A is the argument for the complete Gamma function and X is the upper limit 
of integration in the above equation. The function is not defined for 
<span class="roman">A</span> &#8804; 0 or <span class="roman">X</span> &lt; 0 and in these cases a value of &#8722;1 will be returned 
without any warning. 
For x &lt; 3 it uses the power series (DiDonato &amp; Morris 1986) to approximate 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 P(a,x)=</td><td nowrap="nowrap" align="center">
x<sup>a</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#915;(a+1)<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
1+a</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>n=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
(&#8722;x)<sup>n</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(a+n) n!<br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
&nbsp;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.33)</td></tr></table>
</td></tr></table>

 
For x &lt; 1.2a, a continued fraction approximation for complementary function 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 Q(a,x)=1&#8722;P(a,x)=</td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
e<sup>&#8722;x</sup>x<sup>a</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#915;(a)<br /></td></tr></table>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
x+</td><td nowrap="nowrap" align="center">
1&#8722;a
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
1+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x+ [(2&#8722;a)/(1+[2/(x+&#8230;)])]<br /></td></tr></table></td></tr></table></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.34)</td></tr></table>
</td></tr></table>

 
is used. For other values of parameter the power series 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 P(a,x)=</td><td nowrap="nowrap" align="center">
e<sup>&#8722;x</sup>x<sup>a</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#915;(a+1)<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
1+</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>n=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
x<sup>n</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(a+1)(a+2)&#8230;(a+n)<br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.35)</td></tr></table>
</td></tr></table>

 
is used. 
This function requires Functions <a href="appendixb.htm#gamma">GAMMA</a> and
<a href="appendixb.htm#gammal">GAMMAL</a> to calculate the (complete) 
Gamma function or its logarithm. 

<div class="p"><!----></div>
 <br /><br /><a name="betap"> </a>
 <b>105.&nbsp;BETAP&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/betap.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/betap.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function to calculate the incomplete Beta function 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 I<sub>x</sub>(a,b)=</td><td nowrap="nowrap" align="center">
B<sub>x</sub>(a,b)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>B(a,b)<br /></td><td nowrap="nowrap" align="center">
=</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>B(a,b)<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>x</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
t<sup>a&#8722;1</sup>(1&#8722;t)<sup>b&#8722;1</sup> &nbsp;&nbsp;dt&nbsp;&nbsp;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.36)
</td></tr></table>
</td></tr></table>

 
It may be noted that sometimes the incomplete Beta function is defined by 
B<sub>x</sub>(a,b). This should be accounted for while using the function routine. 
It is difficult to approximate this function over entire range of a,b,x values 
and it is possible that for some combination the value may not be reliable. 
A and B are the arguments for the complete Beta function and X is the upper limit 
of integration in the above equation. Here <span class="roman">A</span>&#8722;1 is the exponent of t 
and <span class="roman">B</span>&#8722;1 is that of 1&#8722;t in the integral. 
The function is not defined for <span class="roman">A</span> &#8804; 0 or <span class="roman">B</span> &#8804; 0 or 
<span class="roman">X</span> &lt; 0 or <span class="roman">X</span> &gt; 1 and in these cases a value of &#8722;1 will be returned 
without any warning. 
These function requires Functions <a href="appendixb.htm#betser">BETSER</a>,
<a href="appendixb.htm#betcon">BETCON</a>,
<a href="appendixb.htm#betcon1">BETCON1</a> and
<a href="appendixb.htm#betai">BETAI</a> for 
calculating the function using different approximations depending on the 
arguments. Apart from these, Function <a href="appendixb.htm#gammal">GAMMAL</a> is required to calculate logarithm 
of Gamma function and subroutines ADPINT,
<a href="appendixb.htm#kronrd">KRONRD</a> and
<a href="appendixb.htm#fbeta">FBETA</a> to calculate 
the integral for some argument range. 

<div class="p"><!----></div>
 <br /><br /><a name="betser"> </a>
 <b>106.&nbsp;BETSER&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/betser.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/betap.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the incomplete 
Beta function (<span class="roman">B</span>.36)&nbsp;using the infinite series 
(DiDonato &amp; Morris 1992) 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 I<sub>x</sub>(a,b)=</td><td nowrap="nowrap" align="center">
x<sup>a</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>a B(a,b)<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
1+a</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
(1&#8722;b)(2&#8722;b)&#8230;(j&#8722;b)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>j! (a+j)<br /></td><td nowrap="nowrap" align="center">
x<sup>j</sup></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.37)</td></tr></table>
</td></tr></table>

 
This series is 
useful for small values of x. This function is called by
<a href="appendixb.htm#betap">BETAP</a> for 
some range of arguments. This routine should not be used to calculate 
the function for arbitrary values of its arguments as the approximation may 
not be valid. 
A and B are the arguments for the complete Beta function and X is the upper limit 
of integration in Eq.&nbsp;(<span class="roman">B</span>.36). This function needs Function <a href="appendixb.htm#gammal">GAMMAL</a> to 
calculate the logarithm of Gamma function. 

<div class="p"><!----></div>
 <br /><br /><a name="betcon1"> </a>
 <b>107.&nbsp;BETCON1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/betcon1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/betap.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the incomplete 
Beta function (<span class="roman">B</span>.36)&nbsp;using a continued fraction (DiDonato &amp; Morris 1992) 
approximation 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 I<sub>x</sub>(a,b)=</td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
x<sup>a</sup>(1&#8722;x)<sup>b</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>aB(a,b)<br /></td></tr></table>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
1+</td><td nowrap="nowrap" align="center">
d<sub>1</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
1+</td><td nowrap="nowrap" align="center">
d<sub>2</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>1+&#8230;<br /></td></tr></table></td></tr></table></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.38)</td></tr></table>
</td></tr></table>

 
with 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 d<sub>2n</sub>=</td><td nowrap="nowrap" align="center">
n(b&#8722;n)x
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(a+2n&#8722;1)(a+2n)<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d<sub>2n+1</sub>=&#8722;</td><td nowrap="nowrap" align="center">
(a+n)(a+b+n)x
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(a+2n)(a+2n+1)<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.39)
</td></tr></table>
</td></tr></table>

 
This function is called by <a href="appendixb.htm#betap">BETAP</a> for 
some range of arguments. This routine should not be used to calculate 
the function for arbitrary values of its arguments as the approximation may 
not be valid. 
A and B are the arguments for the complete Beta function and X is the upper limit 
of integration in Eq.&nbsp;(<span class="roman">B</span>.36). This function needs Function <a href="appendixb.htm#gammal">GAMMAL</a> to 
calculate the logarithm of Gamma function. 

<div class="p"><!----></div>
 <br /><br /><a name="betcon"> </a>
 <b>108.&nbsp;BETCON&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/betcon.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/betap.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the incomplete 
Beta function (<span class="roman">B</span>.36)&nbsp;using a continued fraction (DiDonato &amp; Morris 1992) 
approximation 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 I<sub>x</sub>(a,b)=</td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
x<sup>a</sup>(1&#8722;x)<sup>b</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>aB(a,b)<br /></td><td nowrap="nowrap" align="center">
a<sub>1</sub></td></tr></table>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
b<sub>1</sub>+</td><td nowrap="nowrap" align="center">
a<sub>2</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
b<sub>2</sub>+</td><td nowrap="nowrap" align="center">
a<sub>3</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>b<sub>3</sub>+&#8230;<br /></td></tr></table></td></tr></table></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.40)</td></tr></table>
</td></tr></table>

 
where, coefficients a<sub>i</sub>,b<sub>i</sub> are defined using Eq.&nbsp;(<span class="roman">B</span>.39)&nbsp;

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 a<sub>1</sub>=1,&nbsp;&nbsp;&nbsp; b<sub>1</sub>=1+d<sub>1</sub>,&nbsp;&nbsp;&nbsp; a<sub>n+1</sub>=&#8722;d<sub>2n&#8722;1</sub>d<sub>2n</sub>,&nbsp;&nbsp;&nbsp; b<sub>n+1</sub>=1+d<sub>2n</sub>+d<sub>2n+1</sub>,&nbsp;&nbsp;&nbsp; (n &gt; 1). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.41)</td></tr></table>
</td></tr></table>

 
This function is called by <a href="appendixb.htm#betap">BETAP</a> for 
some range of arguments. This routine should not be used to calculate 
the function for arbitrary values of its arguments as the approximation may 
not be valid. 
A and B are the arguments for the complete Beta function and X is the upper limit 
of integration in Eq.&nbsp;(<span class="roman">B</span>.36). This function needs Function <a href="appendixb.htm#gammal">GAMMAL</a> to 
calculate the logarithm of Gamma function. 

<div class="p"><!----></div>
 <br /><br /><a name="betai"> </a>
 <b>109.&nbsp;BETAI&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/betai.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/betap.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the incomplete 
Beta function (<span class="roman">B</span>.36)&nbsp;by directly evaluating the integral. 
This function is called by <a href="appendixb.htm#betap">BETAP</a> for 
some range of arguments. This routine should not be used to calculate 
the function for arbitrary values of its arguments as it may not be very 
efficient for all values of the arguments. 
A and B are the arguments for the complete Beta function and X is the upper limit 
of integration in Eq.&nbsp;(<span class="roman">B</span>.36). This function needs Function <a href="appendixb.htm#gammal">GAMMAL</a> to 
calculate the logarithm of Gamma function, subroutines <a href="appendixb.htm#adpint">ADPINT</a>
and <a href="appendixb.htm#kronrd">KRONRD</a> 
to evaluate the integral. Further, the function <a href="appendixb.htm#fbeta">FBETA</a> is needed to define the integrand 
for the integral. 

<div class="p"><!----></div>
 <br /><br /><a name="fbeta"> </a>
 <b>110.&nbsp;FBETA&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/fbeta.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/betap.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
Function routine to calculate the integrand for 
calculating the incomplete beta function. This is used by Function
<a href=appendixb.htm#betai">BETAI</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="rangau"> </a>
 <b>111.&nbsp;RANGAU&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/rangau.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polfit.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to generate a sequence of random numbers 
with Normal distribution of probability, with zero mean and unit 
variance. 
This subroutine uses algorithm given by Knuth. 
SEED could be set to any positive value less than AN before 
first call to the routine. After the first call, this variable should not be 
changed in any other program, unless an independent sequence of random 
numbers is required.  

<div class="p"><!----></div>
 <br /><br /><a name="iranbin"> </a>
 <b>112.&nbsp;IRANBIN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/iranbin.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/binom.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to generate a sequence of 
random numbers with binomial distribution. 
SEED is the seed for generating random numbers. It should be negative for 
the first call to function and should not be changed in any other program, 
unless an independent sequence of random number with different n or p 
is required. It should be noted that although the random number is an integer 
in this case, the SEED is of type Real. 
N is the number of trials in the binomial distribution and 
P is the probability of the event in one trial. C is a real array of 
length N, which is used to store the cumulative probability table for 
use in calculations. This array should not be modified in any other program. 
This is used only if the mean (np) is less than RMAX, in which case 
C(I-1) will be the probability of having I or less events. 

<div class="p"><!----></div>
 <br /><br /><a name="iranpoi"> </a>
 <b>113.&nbsp;IRANPOI&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/iranpoi.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/poisson.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to generate a sequence of 
random numbers with Poisson distribution. 
SEED is the seed for generating random numbers. It should be negative for 
the first call to function and should not be changed in any other program, 
unless an independent sequence of random number with different mean 
is required. It should be noted that although the random number is an integer 
in this case, the SEED is of type Real. 
RMU is the mean of Poisson distribution. P is a real array of 
length NMAX (=200), which is used to store the cumulative probability table for 
use in calculations. This array should not be modified in any other program. 
This is used only if the mean (RMU) is less than some critical value, in which case 
P(I-1) will be the probability of having I or less counts. 

<div class="p"><!----></div>
  <br /><br /><a name="pcor"> </a>
 <b>114.&nbsp;PCOR&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/pcor.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/pcor.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the probability that 
two uncorrelated sequences of length (n+2) will give a correlation 
coefficient exceeding &#124;x&#124;. For large even values of n the series can 
give large roundoff errors in which case the distribution is approximate 
by normal distribution. N is the number of degrees of freedom, i.e., 
<span class="roman">N</span>+2 is the length of the sequences and XX is the value of correlation 
coefficient. Since the probability distribution of correlation coefficient 
for uncorrelated data is symmetric about x=0, the probability is 
calculated for &#124;x&#124;. This function requires Function
<a href="appendixb.htm#gammal">GAMMAL</a> to calculate 
the logarithm of Gamma function and Function
<a href="appendixb.htm#erf">ERF</a> to calculate the Error 
function. 

<div class="p"><!----></div>
 

<br /><br />
<a name="Functional Approximations"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.10&nbsp; FUNCTIONAL APPROXIMATIONS </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#polfit">POLFIT</a></td>
<td>&nbsp; <a href="#polevl">POLEVL</a></td>
<td>&nbsp; <a href="#polfit1">POLFIT1</a></td>
<td>&nbsp; <a href="#polort">POLORT</a></td>
<td>&nbsp; <a href="#polfit2">POLFIT2</a></td>
<td>&nbsp; <a href="#polev2">POLEV2</a></td>
<td>&nbsp; <a href="#polfitn">POLFITN</a></td>
<td>&nbsp; <a href="#polevn">POLEVN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#polevn1">POLEVN1</a></td>
<td>&nbsp; <a href="#polevn2">POLEVN2</a></td>
<td>&nbsp; <a href="#llsq">LLSQ</a></td>
<td>&nbsp; <a href="#bspfit">BSPFIT</a></td>
<td>&nbsp; <a href="#bspfit2">BSPFIT2</a></td>
<td>&nbsp; <a href="#bspfitw2">BSPFITW2</a></td>
<td>&nbsp; <a href="#bspfitn">BSPFITN</a></td>
<td>&nbsp; <a href="#bspfitwn">BSPFITWN</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#linfitxy">LINFITXY</a></td>
<td>&nbsp; <a href="#nllsq">NLLSQ</a></td>
<td>&nbsp; <a href="#dft">DFT</a></td>
<td>&nbsp; <a href="#fft">FFT</a></td>
<td>&nbsp; <a href="#fftr">FFTR</a></td>
<td>&nbsp; <a href="#fftn">FFTN</a></td>
<td>&nbsp; <a href="#lapinv">LAPINV</a></td>
<td>&nbsp; <a href="#pold">POLD</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#rmk">RMK</a></td>
<td>&nbsp; <a href="#rmk1">RMK1</a></td>
<td>&nbsp; <a href="#rmkd">RMKD</a></td>
<td>&nbsp; <a href="#rmkd1">RMKD1</a></td>
<td>&nbsp; <a href="#pade">PADE</a></td>
<td>&nbsp; <a href="#chebcf">CHEBCF</a></td>
<td>&nbsp; <a href="#chebex">CHEBEX</a></td>
<td>&nbsp; <a href="#chebap">CHEBAP</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#remes">REMES</a></td>
<td>&nbsp; <a href="#fm">FM</a></td>
<td>&nbsp; <a href="#gamma">GAMMA</a></td>
<td>&nbsp; <a href="#gamln">GAMLN</a></td>
<td>&nbsp; <a href="#erf">ERF</a></td>
<td>&nbsp; <a href="#erfc">ERFC</a></td>
<td>&nbsp; <a href="#bj0">BJ0</a></td>
<td>&nbsp; <a href="#bj1">BJ1</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bjn">BJN</a></td>
<td>&nbsp; <a href="#by0">BY0</a></td>
<td>&nbsp; <a href="#bjy0">BJY0</a></td>
<td>&nbsp; <a href="#by1">BY1</a></td>
<td>&nbsp; <a href="#bjy1">BJY1</a></td>
<td>&nbsp; <a href="#byn">BYN</a></td>
<td>&nbsp; <a href="#sphbjn">SPHBJN</a></td>
<td>&nbsp; <a href="#bi0">BI0</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#bi1">BI1</a></td>
<td>&nbsp; <a href="#bin">BIN</a></td>
<td>&nbsp; <a href="#bk0">BK0</a></td>
<td>&nbsp; <a href="#bk1">BK1</a></td>
<td>&nbsp; <a href="#bkn">BKN</a></td>
<td>&nbsp; <a href="#dawson">DAWSON</a></td>
<td>&nbsp; <a href="#fermmo5">FERMM05</a></td>
<td>&nbsp; <a href="#ferm05">FERM05</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#ferm15">FERM15</a></td>
<td>&nbsp; <a href="#ferm25">FERM25</a></td>
<td>&nbsp; <a href="#pleg">PLEG</a></td>
<td>&nbsp; <a href="#plm">PLM</a></td>
<td>&nbsp; <a href="#ylm">YLM</a></td>
<td>&nbsp; <a href="#minmax">MINMAX</a></td>
<td>&nbsp; <a href="#polyl1">POLYL1</a></td>
<td>&nbsp; <a href="#linl1">LINL1</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#simpl1">SIMPL1</a></td>
</tr>
</table>



<div class="p"><!----></div>
<br /><br /><a name="polfit"> </a>
 <b>115.&nbsp;POLFIT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polfit.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polfit.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform least squares polynomial fit 
using orthogonal polynomials. N is the number of data points, M is 
the degree of polynomial to be fitted. X, F and SIG are real arrays of length 
N containing the data points. F(I) is the value of function 
at X(I) and SIG(I) is the corresponding error estimate in F(I). 
If error estimates are not available then all SIG(I) can 
be set to one. 
A is a real array of length 
<span class="roman">M</span>+1, which will contain the coefficients of the orthogonal 
polynomials in the calculated fit. ALP and BETA are real arrays of length 
<span class="roman">M</span>+1, which will contain the coefficients &#945;<sub>i</sub> and 
&#946;<sub>i</sub> as defined in recurrence relation for orthogonal polynomials. 
ALP(I)=&#945;<sub>I</sub> and BETA(I+1)=&#946;<sub>I</sub>. 
Y is a real array of length  N, Y(I) will contain the calculated 
value of function at X(I) using the least squares fit. H is a real array 
of length  <span class="roman">M</span>+1 containing the &#967;<sup>2</sup>. 
H(I+1) will contain the &#967;<sup>2</sup> using polynomial of degree I<!--hbox-->, 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">H</span><span class="roman">(</span><span class="roman">M</span><span class="roman">+</span><span class="roman">1</span><span class="roman">)</span>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
<span class="roman">Y</span>(j)&#8722;<span class="roman">F</span>(j)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">SIG</span>(j)<br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.42)</td></tr></table>
</td></tr></table>

 
As explained in Section 10.2.2, this estimate of H(I) may have a significant roundoff 
error. GAM is 
a real array of length  <span class="roman">M</span>+1, which will contain the  quantity &#947;<sub>i</sub> for the orthogonal polynomials as defined in Section&nbsp;10.2.2. 
WK is a real array of length 2N, which is used as a scratch space 
to store intermediate quantities. IER is the error parameter. 
IER=601 implies that 
<span class="roman">M</span> &#8805; <span class="roman">N</span> or <span class="roman">M</span> &lt; 0, in which case, no calculations 
are performed.  <span class="roman">IER</span>=621 
implies that one of the &#947;<sub>i</sub>=0, which can happen if  
the points X(I) are not distinct. 
The fitted polynomial can be calculated at any point 
using the coefficients A, ALP and BETA by subroutine POLEVL. 

<div class="p"><!----></div>
 <br /><br /><a name="polevl"> </a>
 <b>116.&nbsp;POLEVL&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polevl.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polfit.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to evaluate the approximating polynomial, 
and its derivatives using Clenshaw's recurrences. 
This subroutine can be used to 
calculate the value of approximating polynomial at any point X, after the 
required coefficients a<sub>j</sub>, &#945;<sub>j</sub> and &#946;<sub>j</sub> have been calculated 
by subroutine <a href="appendixb.htm#polfit"> POLFIT</a><!--hbox-->. M ( &gt; 0) is the degree of polynomial.  
A, ALP and BETA 
are real arrays of length  <span class="roman">M</span>+1, with <span class="roman">A</span>(j+1)=a<sub>j</sub>, 
<span class="roman">ALP</span>(j)=&#945;<sub>j</sub> and <span class="roman">BETA</span>(j+1)=&#946;<sub>j</sub>. These coefficients 
must be calculated before calling the subroutine POLEVL<!--hbox-->. X is the value 
of the independent variable, at which the approximation has to be evaluated. 
F,  DF and DDF are output parameters containing 
the calculated values of the function and its 
first and second derivatives, respectively. 

<div class="p"><!----></div>
 <br /><br /><a name="polfit1"> </a>
 <b>117.&nbsp;POLFIT1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polfit1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polfit2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform least squares polynomial fit 
using orthogonal polynomials. This is a version of <a href="appendixb.htm#polfit"> POLFIT</a> which can 
handle multiple fits, i.e., multiple sets of function values over the 
same set of abscissas and errors. This is useful for recursive use in 
multiple dimensions. 
N is the number of data points, M is 
the degree of polynomial to be fitted. NUM is the number of different 
right hand sides (function values) to be fitted. 
X and SIG are real arrays of length 
N containing the data points and errors. 
F is a real array of length <span class="roman">N</span>&times;<span class="roman">NUM</span> containing the 
function values for each set of points.  
F(I, J) is the value of function in Jth set 
at X(I) and SIG(I) is the corresponding error. The errors are assumed 
to be the same in all sets. 
If error estimates are not available then all SIG(I) can 
be set to one. 
The first dimension of F in the calling program must be equal to 
N<!--hbox-->. 
A is a real array of length (<span class="roman">M</span>+1)&times;<span class="roman">NUM</span>, 
which will contain the coefficients of the orthogonal 
polynomials in the calculated fit for each set. 
The first dimension of A in the calling program must be equal to 
<span class="roman">M</span>+1. 
ALP and BETA are real arrays of length 
<span class="roman">M</span>+1, which will contain the coefficients &#945;<sub>i</sub> and 
&#946;<sub>i</sub> as defined in recurrence relation for orthogonal polynomials. 
GAM is 
a real array of length  <span class="roman">M</span>+1, which will contain the quantity &#947;<sub>i</sub> for the orthogonal polynomials as defined in Section&nbsp;10.2.2. 
WK is a real array of length 2N, which is used as a scratch space 
to store intermediate quantities. IER is the error parameter. 
IER=601 implies that 
<span class="roman">M</span> &#8805; <span class="roman">N</span> or <span class="roman">M</span> &lt; 0, in which case, no calculations 
are performed. 
<span class="roman">IER</span>=621 
implies that one of the &#947;<sub>i</sub>=0, which can happen if  
the points X(I) are not distinct. 
The fitted polynomial can be calculated at any point 
using the coefficients A, ALP and BETA by subroutine <a href="appendixb.htm#polevl"> POLEVL</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="polort"> </a>
 <b>118.&nbsp;POLORT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polort.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polfit2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to evaluate the orthogonal polynomials, 
and its derivatives. It may be noted that this subroutine calculates 
the value of orthogonal polynomials at the given point as opposed 
to <a href="appendixb.htm#polevl"> POLEVL</a> which calculates the value of fitted function using the 
coefficients of these polynomials. 
This subroutine can be used to 
calculate the value of orthogonal polynomial basis functions 
at any point X, after the 
required coefficients &#945;<sub>j</sub> and &#946;<sub>j</sub> have been calculated 
by subroutine <a href="appendixb.htm#polfit"> POLFIT</a><!--hbox--> or <a href="appendixb.htm#polfit1"> POLFIT1</a><!--hbox-->. 
M ( &gt; 0) is the degree of polynomial.  
ALP and BETA 
are real arrays of length  <span class="roman">M</span>+1, with 
<span class="roman">ALP</span>(j)=&#945;<sub>j</sub> and <span class="roman">BETA</span>(j+1)=&#946;<sub>j</sub>. These coefficients 
must be calculated before calling the subroutine POLORT<!--hbox-->. X is the value 
of the independent variable, at which the polynomials have to be evaluated. 
F,  DF and DDF are real arrays of length <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span>, which will contain 
the calculated values of the <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> orthogonal polynomials and its 
first and second derivatives, respectively at X<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="polfit2"> </a>
 <b>119.&nbsp;POLFIT2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polfit2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polfit2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform least squares polynomial fit 
using orthogonal polynomials in two dimensions. 
The data values must be available at a rectangular grid of points 
and weights are assumed to be equal for all points. 
NX is the number of data points along X axis, 
NY is the number of data points along Y axis. 
X is a real array of length NX containing 
the points along X axis, while Y is a real array of length NY 
containing the points along the Y axis. 
F is a real array of length <span class="roman">LA</span>&times;<span class="roman">NY</span> containing the 
function values. F(I, J) is the value at X(I), Y(J). 
AX is a real array of length <span class="roman">IC</span>&times;3 containing information 
about the fit along X direction. AX(I, 1), AX(I+1, 2), AX(I+1, 3) will 
respectively contain the coefficients &#945;<sub>i</sub>, &#946;<sub>i</sub>, &#947;<sub>i</sub> 
for the orthogonal polynomials. 
AY is a real array of length <span class="roman">IC</span>&times;3 containing information 
about the fit along Y direction. AY(I, 1), AY(I+1, 2), AY(I+1, 3) will 
respectively contain the coefficients &#945;<sub>i</sub>, &#946;<sub>i</sub>, &#947;<sub>i</sub> 
for the orthogonal polynomials. The arrays AX and AY will be calculated 
by the subroutine. 
LA is the first dimension of arrays  F and FY as declared in 
the calling program, <span class="roman">LA</span> &#8805; max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>). 
C is a real array of length <span class="roman">IC</span>&times;(<span class="roman">MY</span><span class="roman">+</span><span class="roman">1</span>) containing the 
fitted coefficients for the polynomial fit in two dimensions. The 
fitted polynomial would be 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">MX</span><span class="roman">+</span><span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;</td><td nowrap="nowrap" align="center">
<small><span class="roman">MY</span><span class="roman">+</span><span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">C</span>(i,j)&#981;<sub>i</sub>(x)&#968;<sub>j</sub>(y), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.43)</td></tr></table>
</td></tr></table>

 
where &#981;<sub>i</sub>(x) and &#968;<sub>j</sub>(y) are the orthogonal polynomials in x 
and y respectively. 
IC is the first dimension of arrays AX, AY and C as declared in the calling program, 
<span class="roman">IC</span> &gt; max(<span class="roman">MX</span><span class="roman">,</span> <span class="roman">MY</span>). 
MX is the required degree of polynomial in X<!--hbox-->. 
MY is the required degree of polynomial in Y<!--hbox-->. 
FY is a real array of length <span class="roman">LA</span>&times;<span class="roman">NY</span> containing the 
fitted values of the function at each of the tabular points. 
WK is a real array of length max(<span class="roman">NX</span>&times;(<span class="roman">NY</span><span class="roman">+</span><span class="roman">MY</span>+1), 6(max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>)+2)), which is used as a scratch space 
to store intermediate quantities. 
AW is a real array of length <span class="roman">LA</span>&times;3, 
which is used as a scratch space to store intermediate quantities. 
CHISQ is calculated value of &#967;<sup>2</sup> for the fit. 
IER is the error parameter. 
<span class="roman">IER</span>=602 
implies that <span class="roman">IC</span> &lt; <span class="roman">MX</span>+1 or <span class="roman">LA</span> &lt; max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>). 
IER=603 implies that <span class="roman">NX</span> &#8804; <span class="roman">MX</span>, 
<span class="roman">NY</span> &#8804; <span class="roman">MY</span>, <span class="roman">MX</span> &lt; 0 
or <span class="roman">MY</span> &lt; 0. 
In all these cases, no calculations 
are performed. The fitted polynomial can be calculated at any point 
using the coefficients AX, AY, C by subroutine POLEV2. 
This subroutine requires subroutines <a href="appendixb.htm#polfit1"> POLFIT1</a>, <a href="appendixb.htm#polev2"> POLEV2</a> and <a href="appendixb.htm#polort"> POLORT</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="polev2"> </a>
 <b>120.&nbsp;POLEV2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polev2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polfit2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to evaluate the approximating polynomial, 
and its derivatives using expansion in orthogonal polynomials in 
2 dimensions. 
This subroutine can be used to 
calculate the value of approximating polynomial at any point, after the 
required coefficients c<sub>ij</sub> as well as other auxiliary coefficients 
needed to define the orthogonal polynomials have been calculated 
by subroutine <a href="appendixb.htm#polfit2"> POLFIT2</a><!--hbox-->.  
NX is the degree of polynomial in X, 
NY is the degree of polynomial in Y<!--hbox-->. 
AX is a real array of length <span class="roman">LA</span>&times;2 containing the 
coefficients &#945;<sub>i</sub> and &#946;<sub>i</sub> for orthogonal polynomials in X<!--hbox-->. 
AX(I, 1) contains &#945;<sub>i</sub> and AX(I+1, 2) contains &#946;<sub>i</sub>. 
AY is a real array of length <span class="roman">LA</span>&times;2 containing the 
coefficients &#945;<sub>i</sub> and &#946;<sub>i</sub> for orthogonal polynomials in Y<!--hbox-->. 
AY(I, 1) contains &#945;<sub>i</sub> and AY(I+1, 2) contains &#946;<sub>i</sub>. 
These coefficients 
must be calculated before calling the subroutine POLEV2<!--hbox--> using 
POLFIT2. 
LA is the first dimension of arrays AX, AY and WT in the calling program, 
<span class="roman">LA</span> &gt; max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>). 
WT is a real array of length  <span class="roman">LA</span>&times;(<span class="roman">NY</span>+1), 
containing the coefficients of the fit. 
X0, Y0 are the coordinates of the point at which function value needs to 
be calculated. 
F is the output parameter containing 
the calculated values of the function at (X0, Y0). 
DFX and DFY are respectively, &#8706;F/&#8706;x and 
&#8706;F/&#8706;y, while DFXX, DFXY, DFYY are the 
second derivative &#8706;<sup>2</sup>F/&#8706;x<sup>2</sup>, 
&#8706;<sup>2</sup>F/&#8706;x&#8706;y, 
&#8706;<sup>2</sup>F/&#8706;y<sup>2</sup>. WK is a real array of length 
6(max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>)+2) used as scratch space to store intermediate 
quantities. IER is the error parameter. 
IER=604 implies that max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>) &#8805; <span class="roman">LA</span>, 
in which case no calculations are done. 
The subroutine requires <a href="appendixb.htm#polort"> POLORT</a> 
to calculate the orthogonal basis functions in one dimensions. 

<div class="p"><!----></div>
 <br /><br /><a name="polfitn"> </a>
 <b>121.&nbsp;POLFITN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polfitn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polfitn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform least squares polynomial fit 
using orthogonal polynomials in N dimensions. 
The data values must be available at a hyper-rectangular grid of points 
and weights are assumed to be equal for all points. 
N is the number of dimensions. 
NK is an integer array of length N containing the number of data points 
along each axis. NK(I) is the number of points along Ith axis. 
X is a real array of length <span class="roman">LA</span>&times;<span class="roman">N</span> containing 
the points along each axis, X(I, J) is the Ith point along the Jth 
dimension. 
F is a real array of length <span class="roman">NK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span>&times;<span class="roman">NK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span>&times;&#8230;&times;<span class="roman">NK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span> containing the 
function values. F is treated as a one dimensional array in this 
routine and hence the dimensions of array in the calling program must 
exactly match the number of points in each dimension, e.g., 
F(NK(1), NK(2), &#8230;, NK(N)). 
Alternately, F can be treated as a one dimensional array of required length 
in the calling program also. 
AX is a real array of length <span class="roman">LA</span>&times;(3<span class="roman">N</span>+3) containing information 
about the fit along each direction. AX(I, 3J&#8722;2), AX(I+1, 3J&#8722;1), AX(I, 3J) will 
respectively contain the coefficients &#945;<sub>i</sub>, &#946;<sub>i</sub>, &#947;<sub>i</sub> 
for the orthogonal polynomials along Jth dimension. 
The rest of the array is used as 
scratch space while calculating fits in one dimension. 
LA is the first dimension of arrays X and AX as declared in 
the calling program, <span class="roman">LA</span> &#8805; max(<span class="roman">NK</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>). 
C is a real array of length (<span class="roman">MK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span>+1)(<span class="roman">MK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span><span class="roman">+</span><span class="roman">1</span>)&#8230;(<span class="roman">MK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span>+1) containing the 
fitted coefficients for the polynomial fit in N dimensions. The 
fitted polynomial would be 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">MK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>1</sub>=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;</td><td nowrap="nowrap" align="center">
<small><span class="roman">MK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>2</sub>=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#8230;</td><td nowrap="nowrap" align="center">
<small><span class="roman">MK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i<sub>N</sub>=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">C</span>(i<sub>1</sub>,i<sub>2</sub>,&#8230;,i<sub>N</sub>)&#981;<sub>i<sub>1</sub></sub>(x<sub>1</sub>)&#981;<sub>i<sub>2</sub></sub>(x<sub>2</sub>)&#8230;&#981;<sub>i<sub>N</sub></sub>(x<sub>N</sub>), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.44)</td></tr></table>
</td></tr></table>

 
where &#981;<sub>i<sub>j</sub></sub>(x<sub>j</sub>) are the orthogonal polynomials along jth dimension. 
C is treated as a one dimensional array in this 
routine and hence the dimensions of array in the calling program must 
exactly match the number of polynomials in each dimension, e.g. 
C(MK(1)+1, MK(2)+1, &#8230;, MK(N)+1). 
MK is an integer array of length N containing the required degree 
of polynomial in each direction. 
FY is a real array of the same length and shape as F which will contain the 
fitted value of the function at each of the tabular points. 
WK is a real array of length 2<span class="roman">NK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span>&times;<span class="roman">NK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span>&times;&#8230;&times;<span class="roman">NK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span>, which is used as a scratch space 
to store intermediate quantities. 
IWK is an integer array of length N used as scratch space. 
CHISQ is calculated value of &#967;<sup>2</sup> for the fit. 
IER is the error parameter. <span class="roman">IER</span>=605 
implies that <span class="roman">LA</span> &lt; max(<span class="roman">NK</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>). 
In this case, no calculations 
are performed. The fitted polynomial can be calculated at any point 
using the coefficients C and AX by subroutine POLEVN, POLEVN1 or 
POLEVN2. This subroutine requires subroutines <a href="appendixb.htm#polfit1"> POLFIT1</a>, POLEVN, <a href="appendixb.htm#polort"> POLORT</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="polevn"> </a>
 <b>122.&nbsp;POLEVN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polevn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polfitn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to evaluate the approximating polynomial 
using expansion in orthogonal polynomials in N dimensions. 
This subroutine can be used to 
calculate the value of approximating polynomial at any point, after the 
required coefficients as well as other auxiliary coefficients 
needed to define the orthogonal polynomials have been calculated 
by subroutine <a href="appendixb.htm#polfitn"> POLFITN</a><!--hbox-->.  
N is the number of dimensions. 
NK is an integer array of length N containing the degree of polynomial 
in each dimension. 
AX is a real array of length <span class="roman">LA</span>&times;(3<span class="roman">N</span>+3) containing the 
coefficients &#945;<sub>i</sub> and &#946;<sub>i</sub> for orthogonal polynomials in X<!--hbox-->. 
AX(I, 3J&#8722;2) contains &#945;<sub>i</sub> and AX(I+1, 3J&#8722;1) contains &#946;<sub>i</sub> 
for orthogonal polynomials along Jth dimension. 
These coefficients 
must be calculated before calling the subroutine POLEVN<!--hbox--> using 
POLFITN<!--hbox-->. 
LA is the first dimension of array AX in the calling program, 
This must be the same as what was used in call to POLFITN while calculating 
the coefficients. 
WT is a real array of length  (<span class="roman">MK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span>+1)(<span class="roman">MK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span>+1) &#8230;(<span class="roman">MK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span>+1), 
containing the coefficients of the fit. 
This array is treated as one-dimensional array in the subroutine and 
hence its dimensions in the calling program must exactly match the 
number of orthogonal polynomials in each dimension. 
X0 is a real array of length N containing the coordinates of the point 
at which function value needs to be calculated. 
F is the output parameter containing 
the calculated values of the function at X0. 
WK is a real array of length 3<span class="roman">N</span>&times;<span class="roman">LA</span> used as scratch 
space. IWK is an integer array of length N used as scratch space. 
This subroutine requires <a href="appendixb.htm#polort"> POLORT</a> 
to calculate the orthogonal basis functions in one dimensions. 
This subroutine does not calculate the derivatives of F<!--hbox-->. 
If first derivatives 
are required then one can use POLEVN1, while for second derivatives 
use POLEVN2. 

<div class="p"><!----></div>
 <br /><br /><a name="polevn1"> </a>
 <b>123.&nbsp;POLEVN1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polevn1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polfitn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to evaluate the approximating polynomial 
and its first derivative 
using expansion in orthogonal polynomials in N dimensions. 
This subroutine can be used to 
calculate the value of approximating polynomial at any point, after the 
required coefficients as well as other auxiliary coefficients 
needed to define the orthogonal polynomials have been calculated 
by subroutine <a href="appendixb.htm#polfitn"> POLFITN</a><!--hbox-->.  
This is the version of <a href="appendixb.htm#polevn"> POLEVN</a> which also calculates the first derivatives. 
The arguments are same as those for POLEVN, except for array DF 
of length N, which will contain the calculated derivatives with 
respect to each of the dimensions. 
DF(i) will contain &#8706;F/&#8706;x<sub>i</sub>. 
The scratch array WK should have a length of at least 
3<span class="roman">N</span>&times;<span class="roman">LA</span>+<span class="roman">N</span>. 
This subroutine does not calculate the second derivatives of F<!--hbox-->. 
If second derivatives 
are required then one can use POLEVN2, while if no derivatives are 
required then use <a href="appendixb.htm#polevn"> POLEVN</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="polevn2"> </a>
 <b>124.&nbsp;POLEVN2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polevn2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polfitn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to evaluate the approximating polynomial 
and its first and second derivatives 
using expansion in orthogonal polynomials in N dimensions. 
This subroutine can be used to 
calculate the value of approximating polynomial at any point, after the 
required coefficients as well as other auxiliary coefficients 
needed to define the orthogonal polynomials have been calculated 
by subroutine <a href="appendixb.htm#polfitn"> POLFITN</a><!--hbox-->.  
This is the version of <a href="appendixb.htm#polevn"> POLEVN</a> which also calculates the first and 
second derivatives. 
The arguments are same as those for POLEVN, except for arrays DF and 
DDF. 
DF is a real array of length N which will contain the first derivatives 
of F at X0. DF(i) will contain &#8706;F/&#8706;x<sub>i</sub>. 
DDF is a real array of length <span class="roman">N</span><sup>2</sup> which will contain the 
second derivatives 
of F at X0. DDF(i, j) will contain &#8706;<sup>2</sup>F/&#8706;x<sub>i</sub>&#8706;x<sub>j</sub>. 
The first dimension of DDF in the calling program must be equal to N<!--hbox-->. 
Further, in this case 
WK is a real array of length 3<span class="roman">N</span>&times;<span class="roman">LA</span>+<span class="roman">N</span>+<span class="roman">N</span><sup>2</sup> used as scratch 
space. 
This subroutine calculates the first and second derivatives of F<!--hbox-->. 
If second derivatives 
are not required then one can use
<a href="appendixb.htm#polevn1">POLEVN1</a>, while if no derivatives are 
required then use
<a href="appendixb.htm#polevn">POLEVN</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="llsq"> </a>
 <b>125.&nbsp;LLSQ&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/llsq.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/llsq.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate a general linear least squares 
fit in K dimensions. It uses singular value decomposition (SVD) to 
solve the system of equations. 
The tabular points could have arbitrary distribution 
in K-space and the basis functions also are arbitrary functions to be 
defined by the user. N is the number of tabular points, M is the number 
of basis functions, K is the number of dimensions. X is a real array 
of length <span class="roman">IX</span>&times;<span class="roman">N</span> containing the coordinates of tabular 
points. X(I, J) is the Ith coordinate of Jth tabular point. IX is the 
first dimension of X in the calling program (<span class="roman">IX</span> &#8805; <span class="roman">K</span>). 
For fitting in one dimension, IX can be set to 1 and array X can be 
passed on as a one dimensional array of length N<!--hbox-->. F is a real array 
of length N, containing the function values. F(I) is the function value 
at (X(1, I), X(2, I), &#8230;, X(K, I)). This is treated as one dimensional 
array in the subroutine and hence should not have any gaps in storage. 
This allows the routine to be used for a general distribution of points 
not necessarily along a hyper-rectangular mesh. EF is a real array of 
length N, containing the estimated error in F<!--hbox-->. This is only used for 
determining the weights associated with each points. Thus, it solves 
the following system of equations 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">M</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">A</span>(i)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>(j)<br /></td><td nowrap="nowrap" align="center">
&#981;<sub>i</sub>(<span class="roman">X</span>(1,j), &#8230;,<span class="roman">X</span>(<span class="roman">K</span>,j))=</td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(j)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>(j)<br /></td><td nowrap="nowrap" align="center">
, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j=1,2,&#8230;,<span class="roman">N</span>; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.45)</td></tr></table>
</td></tr></table>

 
using SVD<!--hbox-->. A is a real array of length N, which will contain the 
fitted coefficients. Although, there are only M coefficients the 
array must have a length of at least N, since the remaining elements 
are used as scratch space. 
U is a real array of length <span class="roman">IU</span>&times;<span class="roman">M</span> which will contain 
the matrix U from SVD of the design matrix. 
V is a real array of length <span class="roman">IV</span>&times;<span class="roman">M</span> which will contain 
the matrix V from SVD of the design matrix, (G=U&#931;V<sup>T</sup>). 
IU is the first dimension of U in the calling program (<span class="roman">IU</span> &#8805; <span class="roman">N</span>). 
IV is the first dimension of V and COV in the calling program (<span class="roman">IV</span> &#8805; <span class="roman">M</span>). 
SIGMA is a real array of length M, which will contain the singular 
values of the design matrix. Y is a real array of length N which will 
contain the fitted values of the function at the tabular points. 
WK is a real array of length M used as scratch space. PHI is the name 
of the subroutine to calculate the basis functions at a given point. 
REPS is the required accuracy for the solution of equations. All singular 
values less than REPS times the largest singular value will be set to zero 
during solution. This parameter can be used to eliminate the linear 
combinations of basis functions that contribute little to the fit. 
CHISQ is the minimum value of &#967;<sup>2</sup> defined by 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#967;<sup>2</sup>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(i)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>(i)<br /></td><td nowrap="nowrap" align="center">
&#8722; </td><td nowrap="nowrap" align="center">
<small><span class="roman">M</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">A</span>(j)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>(i)<br /></td><td nowrap="nowrap" align="center">
&#981;<sub>j</sub>(<span class="roman">X</span>(1,i), &#8230;,<span class="roman">X</span>(<span class="roman">K</span>,i))</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.46)</td></tr></table>
</td></tr></table>

 
COV is an array of length <span class="roman">IV</span>&times;<span class="roman">M</span> which will contain the covariance matrix 
between fitted parameters. COV(I, J) is the covariance between A(I) and A(J). 
The diagonal elements are the variance in fitted parameters.  
IER is the error parameter, IER=606 implies that <span class="roman">M</span> &gt; <span class="roman">N</span>, 
<span class="roman">M</span> &#8804; 0, <span class="roman">N</span> &#8804; 0 or <span class="roman">K</span> &gt; <span class="roman">IX</span>. 
IER=607 implies that EF(I) are not all positive. In both these cases 
no calculations are done. The SUBROUTINE PHI(M, X, FX) must be supplied 
by the user to calculate the required basis functions at a given point. 
Here M is the number of basis functions, X is a real array of length K 
containing the coordinates of the point at which the basis functions 
need to be calculated. FX is a real array of length M containing the 
calculated basis functions at X<!--hbox-->. FX(I) should give &#981;<sub>I</sub>(<span class="roman">X</span>). 
For polynomial fits in one dimension &#981;<sub>i</sub>(x)=x<sup>i&#8722;1</sup>, but in that 
case it may be better to use <a href="appendixb.htm#polfit"> POLFIT</a> to calculate the fit. 
Apart from PHI it also needs subroutines <a href="appendixb.htm#svd"> SVD</a> and <a href="appendixb.htm#svdevl"> SVDEVL</a><!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="bspfit"> </a>
 <b>126.&nbsp;BSPFIT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspfit.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bspfit.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate linear least squares 
fit to B-spline basis functions in one dimension. 
It uses singular value decomposition (SVD) to 
solve the system of equations and also allows 
regularisation to be incorporated. 
N is the number of tabular points, X is a real array 
of length  N containing the coordinates of tabular 
points. F is a real array 
of length N, containing the function values. F(I) is the function value 
at X(I).  EF is a real array of 
length N, containing the estimated error in F<!--hbox-->. This is only used for 
determining the weights associated with each points. Thus, it solves 
the following system of equations 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">C</span>(i)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>(j)<br /></td><td nowrap="nowrap" align="center">
&#981;<sub>i</sub>(<span class="roman">X</span>(j)) = </td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(j)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>(j)<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j=1,2,&#8230;,<span class="roman">N</span>; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.47)</td></tr></table>
</td></tr></table>

 
using SVD<!--hbox-->. Here &#981;<sub>i</sub>(x) are the B-spline basis functions. 
K is the order of B-splines required, <span class="roman">K</span>=4 for cubic B-splines 
and <span class="roman">K</span>=2 for linear B-splines, etc. 
A is a real array of length <span class="roman">LA</span>&times;(<span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) which will 
contain the matrix U from SVD of the design matrix. 
V is a real array of length <span class="roman">IV</span>&times;(<span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) which will contain 
the matrix V from SVD of the design matrix, (G=U&#931;V<sup>T</sup>). 
LA is the first dimension of A in the calling program, 
<span class="roman">LA</span> &#8805; <span class="roman">N</span>, when RLM &#8804; 0 and 
<span class="roman">LA</span> &#8805; 2<span class="roman">N</span>, when RLM &gt; 0. 
IV is the first dimension of V and COV in the calling program 
(<span class="roman">IV</span> &#8805; <span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2). 
SIGMA is a real array of length <span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, which will contain the 
singular values of the design matrix. 
C is a real array of length 2N, which will contain the 
fitted coefficients. Although, there are only <span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2 coefficients the 
array must have a length of at least 2N, since the remaining elements 
are used as scratch space. 
XF is a real array of length NO containing the 
knots required to define the B-spline basis functions. 
NO is the number of knots for defining B-splines. The knots must be 
distinct and in ascending order with XF(1) containing the first knot. 
This will yield (<span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) 
B-spline basis functions for fitting. 
Y is a real array of length N which will 
contain the fitted values of the function at the tabular points. 
IFLG is an integer variable that specifies what 
calculation is to be done. For IFLG &#8804; 1 the matrix is calculated 
and its SVD is computed. If execution is 
successful, IFLG will be set to 2, so that next time the matrix 
calculations will be skipped. If IFLG &#8804; 0 the coefficients of 
expansion are also calculated and the fitted values Y as well as the 
CHISQ and COV are computed. 
If IFLG=2, only the coefficients of 
expansion will be calculated using the old SVD  
available in arrays A, V and SIGMA and the (hopefully new) function values F<!--hbox-->. 
For IFLG=2 the fitted values Y, CHISQ and COV are not calculated. 
If IFLG=3, the coefficients of 
expansion as well as the fitted values Y and CHISQ are calculated 
using the old SVD<!--hbox-->. 
WK is a real array of length <span class="roman">4</span><span class="roman">NO</span><span class="roman">+</span><span class="roman">5</span><span class="roman">K</span><span class="roman">+</span><span class="roman">2</span> used as scratch space. 
REPS is the required accuracy for the solution of equations. All singular 
values less than REPS times the largest singular value will be set to zero 
during solution. This parameter can be used to eliminate the linear 
combinations of basis functions that contribute little to the fit. 
RLM is the regularisation parameter &#955; for smoothing. If 
&#955; &#8804; 0 no regularisation is applied, while for &#955; &gt; 0 
regularisation is applied using either first or second derivative. 
IDE is the integer parameter which specifies the order of derivative to be 
used for regularisation. This is used only if &#955; &gt; 0, in which 
case it must be either 1 or 2. For IDE=1 first derivative smoothing 
is used, while for IDE=2 second derivative smoothing is applied. 
The regularisation is applied at all tabular points, making the number 
of equations 2N<!--hbox-->. 
CHISQ is the minimum value of &#967;<sup>2</sup> defined by 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#967;<sup>2</sup>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(i)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>(i)<br /></td><td nowrap="nowrap" align="center">
&#8722; </td><td nowrap="nowrap" align="center">
<small><span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">C</span>(j)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>(i)<br /></td><td nowrap="nowrap" align="center">
&#981;<sub>j</sub>(<span class="roman">X</span>(i)) </td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.48)</td></tr></table>
</td></tr></table>

 
COV is an array of length <span class="roman">IV</span>&times;<span class="roman">M</span> which will contain the covariance matrix 
between fitted parameters. COV(I, J) is the covariance between C(I) and C(J). 
The diagonal elements are the variance in fitted parameters.  
IER is the error parameter, IER=608 implies that <span class="roman">NO</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span> &gt; <span class="roman">N</span>, 
or <span class="roman">K</span> &lt; 2. 
IER=609 implies that RLM &gt; 0 but IDE is not 1 or 2. 
IER=610 implies that EF(I) are not all positive. In all these cases 
no calculations are done. Other values of IER may be set by <a href="appendixb.htm#svd"> SVD</a> or 
BSPLIN<!--hbox-->. This subroutine requires subroutines <a href="appendixb.htm#bsplin"> BSPLIN</a>, <a href="appendixb.htm#bspevl"> BSPEVL</a>, SVD, 
and <a href="appendixb.htm#svdevl"> SVDEVL</a><!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="bspfit2"> </a>
 <b>127.&nbsp;BSPFIT2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspfit2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bspfit2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate linear least squares 
fit to B-spline basis functions in two dimensions. 
It uses singular value decomposition (SVD) to 
solve the system of equations and also allows regularisation to be incorporated, 
but it is restricted to equal weights for all points. The subroutine 
solves the system of equations in one dimension at a time, that is why the weights 
have to be equal. For general least squares solution with varying weights 
users can try <a href="appendixb.htm#bspfitw2"> BSPFITW2</a>, which solves the system of equations for 2 dimensions directly and 
hence will require much more time. 
NX is the number of tabular points along x-axis.  
NY is the number of tabular points along y-axis.  
X and Y are real arrays  
of length  NX, NY containing the coordinates of tabular 
points. F is a real array 
of length <span class="roman">LA</span>&times;<span class="roman">NY</span>, containing the function values. 
F(I, J) is the function value at (X(I), Y(J)). 
K is the order of B-splines required, <span class="roman">K</span>=4 for cubic B-splines 
and <span class="roman">K</span>=2 for linear B-splines, etc. 
For simplicity, the order is assumed to be the same in both directions. 
AX is a real array of length <span class="roman">LA</span>&times;(<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) which will 
contain the matrix U from SVD of the design matrix for fit along x-axis. 
AY is a real array of length <span class="roman">LA</span>&times;(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) which will 
contain the matrix U from SVD of the design matrix for fit along y-axis. 
LA is the first dimension of arrays F, AX, AY, C and FY as declared in 
the calling program. All these arrays should have the same first dimension. 
LA must be at least 2&times;max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>) when RLM &gt; 0, otherwise 
LA must be at least max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>). 
VX is a real array of length <span class="roman">IV</span>&times;(<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) which will contain 
the matrix V from SVD of the design matrix for fit along the x-axis. 
VY is a real array of length <span class="roman">IV</span>&times;(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) which will contain 
the matrix V from SVD of the design matrix for fit along the y-axis. 
IV is the first dimension of VX and VY in the calling program 
(<span class="roman">IV</span> &#8805; max(<span class="roman">MX</span><span class="roman">,</span> <span class="roman">MY</span>)+<span class="roman">K</span>&#8722;2). 
SIGMAX is a real array of length <span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, which will contain the 
singular values of the design matrix for fit along the x-axis. 
SIGMAY is a real array of length <span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, which will contain the 
singular values of the design matrix for fit along the y-axis. 
C is a real array of length <span class="roman">LA</span>&times;<span class="roman">NY</span>, which will contain the 
fitted coefficients. Although, there are only (<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) 
coefficients the 
array must have a larger length, since the remaining elements 
are used as scratch space. 
XF is a real array of length MX containing the 
knots required to define the B-spline basis functions along x. 
YF is a real array of length MY containing the 
knots required to define the B-spline basis functions along y. 
MX is the number of knots for defining B-splines along x-axis. 
MY is the number of knots for defining B-splines along y-axis. 
The knots must be distinct and in ascending order with XF(1), YF(1) 
containing the first knot. 
FY is a real array of length <span class="roman">LA</span>&times;<span class="roman">NY</span> which will 
contain the fitted values of the function at the tabular points. 
WK is a real array of length <span class="roman">LA</span>&times;<span class="roman">NX</span>+<span class="roman">NX</span><span class="roman">+</span><span class="roman">NY</span> 
used as scratch space. 
REPS is the required accuracy for the solution of equations. All singular 
values less than REPS times the largest singular value will be set to zero 
during solution. This parameter can be used to eliminate the linear 
combinations of basis functions that contribute little to the fit. 
RLM is the regularisation parameter &#955; for smoothing. If 
&#955; &#8804; 0 no regularisation is applied, while for &#955; &gt; 0 
regularisation is applied using either first or second derivative. 
IDE is the integer parameter which specifies the order of derivative to be 
used for regularisation. This is used only if &#955; &gt; 0, in which 
case it must be either 1 or 2. For IDE=1 first derivative smoothing 
is used, while for IDE=2 second derivative smoothing is applied. 
The regularisation is applied at all tabular points, making the number 
of equations 2 times larger. 
CHISQ is the minimum value of &#967;<sup>2</sup> defined by 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#967;<sup>2</sup>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">NX</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">NY</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
<span class="roman">F</span>(i,j)&#8722; </td><td nowrap="nowrap" align="center">
<small><span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j1=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;</td><td nowrap="nowrap" align="center">
<small><span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j2=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">C</span>(j1,j2) &#981;<sub>j1</sub>(<span class="roman">X</span>(i)) &#968;<sub>j2</sub>(<span class="roman">Y</span>(j)) </td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.49)</td></tr></table>
</td></tr></table>

 
Here &#981;<sub>j</sub>(x) are the basis functions in x and &#968;<sub>j</sub>(y) 
are those in y. 
IER is the error parameter, IER=608 implies that <span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span> &gt; <span class="roman">NX</span>, 
<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span> &gt; <span class="roman">NY</span>, or <span class="roman">K</span> &lt; 2. 
IER=609 implies that RLM &gt; 0 but IDE is not 1 or 2. 
In all these cases 
no calculations are done. Other values of IER may be set by BSPFIT, SVD or 
BSPLIN<!--hbox-->. This subroutine requires subroutines 
<a href="appendixb.htm#bspfit"> BSPFIT</a>, <a href="appendixb.htm#bsplin"> BSPLIN</a>, <a href="appendixb.htm#bspevl"> BSPEVL</a>, <a href="appendixb.htm#bspev2"> BSPEV2</a>, <a href="appendixb.htm#svd"> SVD</a> and
<a href="appendixb.htm#svdevl">SVDEVL</a>. 

<div class="p"><!----></div>
 <br /><br /><a name="bspfitw2"> </a>
 <b>128.&nbsp;BSPFITW2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspfitw2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bspfit2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate linear least squares 
fit to B-spline basis functions in two dimensions. 
It uses singular value decomposition (SVD) to 
solve the system of equations and also allows regularisation as well 
as nonuniform weights to be incorporated. 
This subroutine solves the system of equations directly in two dimensions 
and hence will require much more time as compared to <a href="appendixb.htm#bspfit2"> BSPFIT2</a>. 
NX is the number of tabular points along x-axis.  
NY is the number of tabular points along y-axis.  
X and Y are real arrays  
of length  NX, NY containing the coordinates of tabular 
points. F is a real array 
of length <span class="roman">IC</span>&times;<span class="roman">NY</span>, containing the function values. 
F(I, J) is the function value at (X(I), Y(J)). 
EF is a real array 
of length <span class="roman">IC</span>&times;<span class="roman">NY</span>, containing the estimated errors 
in F<!--hbox-->. These values are used to choose the weight for each 
equation for least squares solution. 
K is the order of B-splines required, <span class="roman">K</span>=4 for cubic B-splines 
and <span class="roman">K</span>=2 for linear B-splines, etc. 
For simplicity, order of B-splines is assumed to be the same along 
each axes. 
A is a real array of length <span class="roman">LA</span>&times;(<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) 
which will 
contain the matrix U from SVD of the design matrix. 
LA is the first dimension of array A as declared in 
the calling program. 
LA must be at least 3<span class="roman">NX</span>&times;<span class="roman">NY</span> when RLM &gt; 0, otherwise 
LA must be at least <span class="roman">NX</span>&times;<span class="roman">NY</span>. 
V is a real array of length <span class="roman">IV</span>&times;(<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) 
which will contain 
the matrix V from SVD of the design matrix. 
IV is the first dimension of V in the calling program, 
<span class="roman">IV</span> &#8805; (<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2). 
SIGMA is a real array of length (<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2), 
which will contain the singular values of the design matrix. 
C is a real array of length <span class="roman">IC</span>&times;(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;2), which will contain the 
fitted coefficients. 
IC is the first dimension of arrays C, F, EF, FY as declared in the 
calling program, IC must be at least NX<!--hbox-->. 
XF is a real array of length MX containing the 
knots required to define the B-spline basis functions along x. 
YF is a real array of length MY containing the 
knots required to define the B-spline basis functions along y. 
MX is the number of knots for defining B-splines along x-axis. 
MY is the number of knots for defining B-splines along y-axis. 
The knots must be distinct and in ascending order with XF(1), YF(1) 
containing the first knot. 
FY is a real array of length <span class="roman">IC</span>&times;<span class="roman">NY</span> which will 
contain the fitted values of the function at the tabular points. 
WK is a real array of length 
3<span class="roman">NX</span>&times;<span class="roman">NY</span>+(<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>)(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>) 
used as scratch space, when RLM &gt; 0. If RLM &lt; 0 the 
required length of WK is <span class="roman">NX</span>&times;<span class="roman">NY</span>+(<span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>)(<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>). 
REPS is the required accuracy for the solution of equations. All singular 
values less than REPS times the largest singular value will be set to zero 
during solution. This parameter can be used to eliminate the linear 
combinations of basis functions that contribute little to the fit. 
RLM is the regularisation parameter &#955; for smoothing. If 
&#955; &#8804; 0 no regularisation is applied, while for &#955; &gt; 0 
regularisation is applied using either first or second derivative. 
IDE is the integer parameter which specifies the order of derivative to be 
used for regularisation. This is used only if &#955; &gt; 0, in which 
case it must be either 1 or 2. For IDE=1 first derivative smoothing 
is used, while for IDE=2 second derivative smoothing is applied. 
The regularisation is applied at all tabular points, making the number 
of equations 3 times larger. 
CHISQ is the minimum value of &#967;<sup>2</sup> defined by 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">NX</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">NY</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239C;<br />
&#x239D;
</td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">F</span>(i,j)&#8722; </td><td nowrap="nowrap" align="center">
<small><span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j1=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;</td><td nowrap="nowrap" align="center">
<small><span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j2=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">C</span>(j1,j2) &#981;<sub>j1</sub>(<span class="roman">X</span>(i)) &#968;<sub>j2</sub>(<span class="roman">Y</span>(j))</td></tr></table>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">EF</span>(i,j) <br /></td><td align="left" class="cl">&#x239E;<br />&#x239F;<br />
&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.50)</td></tr></table>
</td></tr></table>

 
Here &#981;<sub>j</sub>(x) are the basis functions in x and &#968;<sub>j</sub>(y) 
are those in y. 
This routine does not calculate the covariance matrix, but this can be 
easily added following BSPFIT<!--hbox-->. 
IER is the error parameter, IER=608 implies that <span class="roman">MX</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span> &gt; <span class="roman">NX</span>, 
<span class="roman">MY</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span> &gt; <span class="roman">NY</span>, or <span class="roman">K</span> &lt; 2. 
IER=609 implies that RLM &gt; 0 but IDE is not 1 or 2. 
IER=610 implies that EF(I, J) are not all positive. In all these cases 
no calculations are done. Other values of IER may be set by SVD or 
BSPLIN<!--hbox-->. This subroutine requires subroutines 
<a href="appendixb.htm#bsplin"> BSPLIN</a>, <a href="appendixb.htm#bspev2"> BSPEV2</a>, <a href="appendixb.htm#svd"> SVD</a> and <a href="appendixb.htm#svdevl"> SVDEVL</a><!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="bspfitn"> </a>
 <b>129.&nbsp;BSPFITN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspfitn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bspfitn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate linear least squares 
fit to B-spline basis functions in N dimensions. 
It uses singular value decomposition (SVD) to 
solve the system of equations and also allows regularisation to be incorporated, 
but it is restricted to equal weights for all points. The subroutine 
solves the system of equations in one dimension at a time, that is why the weights 
have to be equal. For general least squares solution with varying weights 
users can try <a href="appendixb.htm#bspfitwn"> BSPFITWN</a>, which solves the system of equations for N dimensions directly and 
hence will require much more time. 
N is the number of dimensions. 
NK is an integer array of length N containing the number of tabular 
points along each axis.  
X is a real array of length  <span class="roman">LA</span>&times;<span class="roman">N</span> 
containing the coordinates of tabular 
points. X(I, J) is the Ith point along Jth axis. 
F is a real array of length <span class="roman">NK</span>(1)&times;<span class="roman">NK</span>(2)&times;&#8230;&times;<span class="roman">NK</span>(<span class="roman">N</span>), containing the function values. 
F(i<sub>1</sub>,i<sub>2</sub>,&#8230;,i<sub>N</sub>) is the function value at (X(i<sub>1</sub>,1), X(i<sub>2</sub>, 2), 
&#8230;, X(i<sub>N</sub>, N)). 
This is treated as a one-dimensional array and 
hence its dimensions in the calling program must exactly match the 
size in each dimension, e.g., the dimensions could be 
F(NK(1), NK(2), &#8230;, NK(N)).  
Alternately, it could be treated as a one dimensional array in the calling 
program also. 
K is the order of B-splines required, <span class="roman">K</span>=4 for cubic B-splines 
and <span class="roman">K</span>=2 for linear B-splines, etc. 
For simplicity, the order is assumed to be the same along each dimension. 
A is a real array of length <span class="roman">LA</span>&times;<span class="roman">IV</span>&times;<span class="roman">N</span> which will 
contain the matrix U from SVD of the design matrix for fit along each 
axis. 
LA is the first dimension of array X,  as declared in 
the calling program. The first dimension of A should be <span class="roman">LA</span>&times;<span class="roman">IV</span>. 
LA must be at least 2&times;max(<span class="roman">NK</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>) when 
RLM &gt; 0, otherwise 
LA must be at least max(<span class="roman">NK</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>). 
V is a real array of length <span class="roman">IV</span><sup>2</sup>&times;<span class="roman">N</span> which will contain 
the matrix V from SVD of the design matrix for fit along each axis. 
IV is the first dimension of XF and SIGMA in the calling program 
(<span class="roman">IV</span> &#8805; <span class="roman">K</span>&#8722;2+max(<span class="roman">MK</span><span class="roman">(</span><span class="roman">I</span><span class="roman">))</span>). The first dimension of 
V in calling program is <span class="roman">IV</span><sup>2</sup>. 
SIGMA is a real array of length <span class="roman">IV</span>&times;<span class="roman">N</span>, 
which will contain the 
singular values of the design matrix for fit along each axis. 
C is a real array of length <span class="roman">NK</span>(1)&times;<span class="roman">NK</span>(2)&times;&#8230;&times;<span class="roman">NK</span>(<span class="roman">N</span>), which will contain the 
fitted coefficients. If RLM &gt; 0 this length must be 2 
times larger. Note that 
although there are only (<span class="roman">MK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)&#8230;(<span class="roman">MK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) coefficients the 
array must have a larger length, since the remaining elements 
are used as scratch space. 
This is treated as a one-dimensional array and 
hence its dimensions in the calling program must exactly match the 
size in each dimension, e.g., the dimensions could be 
C(<span class="roman">MK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, <span class="roman">MK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, &#8230;, <span class="roman">MK</span><span class="roman">(</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, <span class="roman">NX</span>).  
Here the last dimension has to be increased suitably to accommodate the 
scratch space required. The last dimension NX should be chosen such that 
the total size is greater than the required value. 
If this array is only passed on to <a href="appendixb.htm#bspevn"> BSPEVN</a> or equivalent routines to 
calculate the function value at any required point, then the exact 
dimensions in calling program are immaterial as long as the total length 
is larger than the required value. 
XF is a real array of length <span class="roman">IV</span>&times;<span class="roman">N</span> containing the 
knots required to define the B-spline basis functions in each dimension. 
The knots must be distinct and in ascending order. 
XF(I, J) is the Ith knot along Jth dimension.  
MK is an integer array of length N containing the number of knots 
for defining B-splines along each axis. 
FY is a real array of same size and shape as F which will 
contain the fitted values of the function at the tabular points. 
WK is a real array of length <span class="roman">LA</span>+<span class="roman">NK</span>(1)&times;<span class="roman">NK</span>(2) &times;&#8230;&times;<span class="roman">NK</span>(<span class="roman">N</span>) 
used as scratch space. If RLM &gt; 0 then this size must be 
twice as large. 
IWK is an integer array of length 3N used as scratch space. 
REPS is the required accuracy for the solution of equations. All singular 
values less than REPS times the largest singular value will be set to zero 
during solution. This parameter can be used to eliminate the linear 
combinations of basis functions that contribute little to the fit. 
RLM is the regularisation parameter &#955; for smoothing. If 
&#955; &#8804; 0 no regularisation is applied, while for &#955; &gt; 0 
regularisation is applied using either first or second derivative. 
IDE is the integer parameter which specifies the order of derivative to be 
used for regularisation. This is used only if &#955; &gt; 0, in which 
case it must be either 1 or 2. For IDE=1 first derivative smoothing 
is used, while for IDE=2 second derivative smoothing is applied. 
The regularisation is applied at all tabular points, making the number 
of equations 2 times larger. 
CHISQ is the minimum value of &#967;<sup>2</sup> obtained using the fitted 
coefficients. 
IER is the error parameter. 
IER=609 implies that RLM &gt; 0 but IDE is not 1 or 2. 
In this case 
no calculations are done. Other values of IER may be set by BSPFIT, SVD or 
BSPLIN<!--hbox-->. This subroutine requires subroutines 
<a href="appendixb.htm#bspfit"> BSPFIT</a>, <a href="appendixb.htm#bsplin"> BSPLIN</a>, <a href="appendixb.htm#bspevl"> BSPEVL</a>, <a href="appendixb.htm#bspevn"> BSPEVN</a>, <a href="appendixb.htm#svd"> SVD</a> and <a href="appendixb.htm#svdevl"> SVDEVL</a><!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="bspfitwn"> </a>
 <b>130.&nbsp;BSPFITWN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspfitwn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bspfitn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate linear least squares 
fit to B-spline basis functions in N dimensions. 
It uses singular value decomposition (SVD) of the full set of 
equations to obtain the fits 
and also allows regularisation to be incorporated. 
It incorporates unequal weights, but can require several orders of 
magnitude larger time as compared to <a href="appendixb.htm#bspfitn"> BSPFITN</a> for the same size of 
table. The memory required is also much larger. 
Hence, it should be used only if BSPFITN is not suitable 
because of highly varying weights. 
N is the number of dimensions. 
NK is an integer array of length N containing the number of tabular 
points along each axis.  
X is a real array of length  <span class="roman">LA</span>&times;<span class="roman">N</span> 
containing the coordinates of tabular 
points. X(I, J) is the Ith point along Jth axis. 
F is a real array of length <span class="roman">NK</span>(1)&times;<span class="roman">NK</span>(2)&times;&#8230;&times;<span class="roman">NK</span>(<span class="roman">N</span>), containing the function values. 
F(i<sub>1</sub>,i<sub>2</sub>,&#8230;,i<sub>N</sub>) is the function value at (X(i<sub>1</sub>, 1), X(i<sub>2</sub>, 2), 
&#8230;, X(i<sub>N</sub>, N)). 
This is treated as an one-dimensional array and 
hence its dimensions in the calling program must exactly match the 
size in each dimension, e.g., the dimensions could be 
F(NK(1), NK(2), &#8230;, NK(N)).  
EF is a real array of same size and shape as F, containing the estimated 
errors in F<!--hbox-->. 
K is the order of B-splines required, <span class="roman">K</span>=4 for cubic B-splines 
and <span class="roman">K</span>=2 for linear B-splines, etc. 
For simplicity, the order is assumed to be the same along each dimension. 
A is a real array of length 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">NK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span><span class="roman">NK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span>&#8230;<span class="roman">NK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span>&times;(<span class="roman">MK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>) (<span class="roman">MK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>)&#8230;(<span class="roman">MK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.51)</td></tr></table>
</td></tr></table>
 
which will 
contain the matrix U from SVD of the design matrix. 
If RLM &gt; 0 the required size will be <span class="roman">N</span><span class="roman">+</span><span class="roman">1</span> times larger. 
LA is the first dimension of array X,  as declared in 
the calling program. LA must be at least max(<span class="roman">NK</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>). 
V is a real array of length 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
[(<span class="roman">MK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>)(<span class="roman">MK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>)&#8230;(<span class="roman">MK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>)]<sup>2</sup>, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.52)</td></tr></table>
</td></tr></table>

 
which will contain 
the matrix V from SVD of the design matrix. 
IV is the first dimension of XF in the calling program 
(<span class="roman">IV</span> &#8805; max(<span class="roman">MK</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>)). 
SIGMA is a real array of length (<span class="roman">MK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) &#8230;(<span class="roman">MK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2), which will contain the 
singular values of the design matrix. 
C is a real array of length <span class="roman">NK</span>(1)&times;<span class="roman">NK</span>(2)&times;&#8230;&times;<span class="roman">NK</span>(<span class="roman">N</span>), which will contain the 
fitted coefficients. If RLM &gt; 0 this length must be <span class="roman">N</span><span class="roman">+</span><span class="roman">1</span> 
times larger. Note that 
although there are only (<span class="roman">MK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)(<span class="roman">MK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)&#8230;(<span class="roman">MK</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) coefficients the 
array must have a larger length, since the remaining elements 
are used as scratch space. 
This is treated as a one-dimensional array and 
hence its dimensions in the calling program must exactly match the 
size in each dimension, e.g., the dimensions could be
C(<span class="roman">MK</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, <span class="roman">MK</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, &#8230;, <span class="roman">MK</span><span class="roman">(</span><span class="roman">N</span>&#8722;<span class="roman">1</span><span class="roman">)</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, <span class="roman">NX</span>).
Here the last dimension has to be increased suitably to accommodate the 
scratch space required. The last dimension NX should be chosen such that 
the total size is greater than the required value. 
If this array is only passed on to <a href="appendixb.htm#bspevn"> BSPEVN</a> or equivalent routines to 
calculate the function value at any required point, then the exact 
dimensions in calling program are immaterial as long as the total length 
is larger than the required value. 
XF is a real array of length <span class="roman">IV</span>&times;<span class="roman">N</span> containing the 
knots required to define the B-spline basis functions in each dimension. 
The knots must be distinct and in ascending order. 
XF(I, J) is the Ith knot along Jth dimension. 
MK is an integer array of length N containing the number of knots 
for defining B-splines along each axis. 
FY is a real array of the same size and shape as F which will 
contain the fitted values of the function at the tabular points. 
WK is a real array of length <span class="roman">N</span>&times;(<span class="roman">LA</span>+6)+<span class="roman">LA</span><span class="roman">+</span><span class="roman">2</span><span class="roman">K</span>+2 
used as scratch space. 
IWK is an integer array of length 3N used as scratch space. 
REPS is the required accuracy for the solution of equations. All singular 
values less than REPS times the largest singular value will be set to zero 
during solution. This parameter can be used to eliminate the linear 
combinations of basis functions that contribute little to the fit. 
RLM is the regularisation parameter &#955; for smoothing. If 
&#955; &#8804; 0 no regularisation is applied, while for &#955; &gt; 0 
regularisation is applied using either first or second derivative. 
IDE is the integer parameter which specifies the order of derivative to be 
used for regularisation. This is used only if &#955; &gt; 0, in which 
case it must be either 1 or 2. For IDE=1 first derivative smoothing 
is used, while for IDE=2 second derivative smoothing is applied. 
The regularisation is applied at all tabular points, making the number 
of equations <span class="roman">N</span><span class="roman">+</span><span class="roman">1</span> times larger. 
CHISQ is the minimum value of &#967;<sup>2</sup> obtained using the fitted 
coefficients. 
IER is the error parameter. IER=608 implies that LA or IV are not 
large enough to store the required quantities. 
IER=609 implies that RLM &gt; 0 but IDE is not 1 or 2. 
In these cases 
no calculations are done. Other values of IER may be set by SVD or 
BSPLIN<!--hbox-->. This subroutine requires subroutines 
<a href="appendixb.htm#bsplin"> BSPLIN</a>, <a href="appendixb.htm#bspevn"> BSPEVN</a>, <a href="appendixb.htm#svd"> SVD</a> and <a href="appendixb.htm#svdevl"> SVDEVL</a><!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="linfitxy"> </a>
 <b>131.&nbsp;LINFITXY&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/linfitxy.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/linfitxy.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the least squares 
straight line fit when there is error in both x and y values, using 
the technique described in Section 10.2.4. For simplicity it is assumed 
that all data points have the same errors and correlation. N is the number 
of data points. X and Y are real arrays of length N, specifying the data 
values. Fit of the form <span class="roman">Y</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>=a+b&times;<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> is to be calculated. 
SIGX and SIGY are the estimated errors in X and Y values, while RHO is 
the correlation between the errors in X and Y<!--hbox-->. XI and YI are the arrays 
which will contain the fitted values of X and Y. Since both X and Y have 
errors fitted values of both need to be calculated. A and B are the 
fitted values of the intercept and slope, respectively. Thus 
<span class="roman">YI</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>=<span class="roman">A</span>+<span class="roman">B</span>&times;<span class="roman">XI</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span>. CHI is the value of 
&#967;<sup>2</sup> at the fit as defined by Eq.&nbsp;(10.49). IER is the error 
parameter. <span class="roman">IER</span>=617 implies that the discriminant of the quadratic 
(10.59)
is negative and the calculations are aborted. 

<div class="p"><!----></div>
 <br /><br /><a name="nllsq"> </a>
 <b>132.&nbsp;NLLSQ&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/nllsq.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/nllsq.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the &#967;<sup>2</sup> function for 
a nonlinear least squares fit for use with subroutine <a href="appendixb.htm#bfgs"> BFGS</a><!--hbox-->. 
By suppressing the gradient calculations it can also be used with 
subroutine <a href="appendixb.htm#nminf"> NMINF</a><!--hbox-->. This is the function to be minimised by 
BFGS<!--hbox-->. 
N is the number of parameters to be fitted, A is a real array of 
length N containing the values of the parameters at which the function 
is required to be calculated. F is the calculated value of the function. 
G is a real array of length N, containing the calculated derivatives. 
G(i) will contain [(&#8706;F)/(&#8706;a<sub>i</sub>)]. The data points 
are passed through common block ZZFUN, which must be initialised in the 
calling program before calling BFGS<!--hbox-->. The parameter NP must be set to 
a value matching the array sizes in the calling program. The common block 
contains the following variables: X, FX, EF are real arrays of length 
NP containing respectively, the values of abscissas, function values 
and estimated errors in function values at each point. NN is the 
number of data points in the table, <span class="roman">NN</span> &#8804; <span class="roman">NP</span>. FX1 is a 
real array of length NP which will contain the fitted value of the 
function at all points. Although EF(I) should contain the estimated 
error in FX(I), in many cases it is found that multiplying all elements 
of EF by suitable constant improves the convergence of BFGS significantly 
without changing the minimum. Only the value of &#967;<sup>2</sup> will need to be 
scaled suitably. This subroutine needs FCN to calculate the function 
value at any X for specified values of the parameters.  It may be 
noted that there is no provision to pass on the name of a subroutine 
to this subprogram and hence the name has to be explicitly changed 
in the subroutine. 
SUBROUTINE FCN(N, A, X, F, DF) must be supplied by the user. 
Here N is the number of parameters, A is a real array of length 
N containing the values of parameters. X is a real variable specifying 
the point where the function value needs to be calculated. F is a 
real variable which should contain the calculated function value 
F(X, A), while DF is a real array of length N containing the derivatives 
of F<!--hbox-->. DF(I) should give [(&#8706;F)/(&#8706;A<sub>i</sub>)]. 
By suppressing the derivative calculations NLLSQ can also be used with 
subroutine <a href="appendixb.htm#nminf"> NMINF</a><!--hbox-->. The corresponding version may be found in NLLSQ<tt>_</tt>F. 

<div class="p"><!----></div>
 <br /><br /><a name="dft"> </a>
 <b>133.&nbsp;DFT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/dft.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fft.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the discrete Fourier transform (DFT) 
using normal sum. This program is applicable to arbitrary number of 
points, but it requires O(N<sup>2</sup>) arithmetic operations, and hence 
should be used only when N is relatively small. 
N is the number of data points. 
CG is a complex array of length  N, 
which should contain the data 
points. CF is a complex array of length N which will contain the 
Fourier transform of CG<!--hbox-->. 
IFLG is a flag, if IFLG &#8805; 0 the DFT is calculated, while if 
IFLG &lt; 0 the inverse DFT will be calculated. IER is the error parameter. 
IER=611 implies that <span class="roman">N</span> &lt; 2, in which case, 
no calculations are performed. 
It may be noted that when inverse transform is calculated the 
result will need to be divided by N to match the original data. 
The subroutine does not perform the division. It may be noted that 
even while calculating the inverse transform the input should be provided 
in array CG and calculated transform will be available in array CF. 

<div class="p"><!----></div>
  <br /><br /><a name="fft"> </a>
 <b>134.&nbsp;FFT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/fft.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fft.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the discrete Fourier transform (DFT) 
using a FFT algorithm. N is the number of data points which must be equal 
to a power of 2. CG is a complex array of length  N, 
which should contain the data 
points when calling the subroutine. After execution, the DFT will be 
overwritten on the same array CG<!--hbox-->. Hence, if necessary a copy of 
the original 
data should be preserved for later use before calling the subroutine. 
IFLG is a flag, if IFLG &#8805; 0 the DFT is calculated, while if 
IFLG &lt; 0 the inverse DFT will be calculated. IER is the error parameter. 
IER=611 implies that <span class="roman">N</span> &lt; 2, in which case, 
no calculations are performed. 
IER=631 implies that N is not a power of 2. This test is performed 
towards the end of the calculation and hence in this case, the contents of array 
CG will be destroyed. 
It may be noted that when inverse transform is calculated the 
result will need to be divided by N to match the original data. 
The subroutine does not perform the division. 

<div class="p"><!----></div>
 <br /><br /><a name="fftr"> </a>
 <b>135.&nbsp;FFTR&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/fftr.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fftr.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the discrete Fourier transform (DFT) 
of real data 
using a FFT algorithm. N is the number of data points which must be equal 
to a power of 2. CG is a complex array of length  N/2, 
which should contain the data points when calling the subroutine.  
The data should be stored in the natural order with REAL(CG(j+1)) = g<sub>2j</sub> and AIMAG(CG(j+1))=g<sub>2j+1</sub> for j=0,1,&#8230;,<span class="roman">N</span>/2&#8722;1. 
In fact, in the calling program, 
the array CG can be treated as a real array of length N<!--hbox-->. 
After execution, the DFT will be 
overwritten on the same array CG as explained in Section&nbsp;10.6.  If necessary, another copy of the original 
data should be preserved for later use before calling the subroutine. 
IFLG is a flag. If IFLG &#8805; 0 the DFT is calculated, while if 
IFLG &lt; 0 the inverse DFT will be calculated. IER is the error parameter. 
IER=611 implies that <span class="roman">N</span>  &lt; 4 and no calculations are done. 
IER=631 implies that N is not a power of 2. 
Since this test is performed towards the end of calculations, the 
contents of array CG will be destroyed. 
It may be noted that when inverse transform is calculated the 
result will need to be divided by N/2 to match the original data. 
The subroutine does not perform the division. This subroutine 
requires subroutine <a href="appendixb.htm#fft"> FFT</a> for calculating the DFT of complex data. 

<div class="p"><!----></div>
 <br /><br /><a name="fftn"> </a>
 <b>136.&nbsp;FFTN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/fftn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fftn.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the discrete Fourier transform (DFT) 
in n&nbsp;dimensions using a FFT algorithm. ND is the number of dimensions. 
NN is an integer array of length  ND<!--hbox-->. 
NN(I) is the number of data points along the Ith coordinate, 
which must be equal to a power of 2. CG is a complex array of length   
<span class="roman">NN</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span>&times;<span class="roman">NN</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span>&times;&#8230;&times;<span class="roman">NN</span><span class="roman">(</span><span class="roman">ND</span><span class="roman">)</span>, 
which should contain the data 
points when calling the subroutine. The data should be stored in the normal 
Fortran order with 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">CG</span>(1+j<sub>1</sub>+j<sub>2</sub><span class="roman">NN</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span>+j<sub>3</sub><span class="roman">NN</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span><span class="roman">NN</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span>+&#8230;+ j<sub>ND</sub><span class="roman">NN</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span>&#8230;<span class="roman">NN</span>(<span class="roman">ND</span>&#8722;1)) = g<sub>j<sub>1</sub>,j<sub>2</sub>,&#8230;,j<sub>ND</sub></sub>&nbsp;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.53)</td></tr></table>
</td></tr></table>

 
for 0 &#8804; j<sub>r</sub> &lt; <span class="roman">NN</span>(r)&#8722;1. 
In fact, in the calling program CG can be treated as a ND-dimensional 
complex array with dimension CG(NN(1), NN(2), &#8230;, NN(ND)) and 
<span class="roman">CG</span>(j<sub>1</sub>+1,j<sub>2</sub>+1,&#8230;,j<sub>n</sub>+1)=g<sub>j<sub>1</sub>,j<sub>2</sub>,&#8230;,j<sub>n</sub></sub>. 
It may be noted that the dimensions of this ND-dimensional array must 
be exactly equal to the number of data points in the corresponding variables. 
After execution, the DFT will be 
overwritten on the same array CG<!--hbox-->. Hence, if necessary a copy of original 
data should be preserved for later use, before calling the subroutine. 
IFLG is a flag. If IFLG &#8805; 0 the DFT is calculated, while if 
IFLG &lt; 0 the inverse DFT will be calculated. IER is the error parameter. 
IER=631 implies that at least one of the NN(I), 
(<span class="roman">I</span>=1,2,&#8230;,<span class="roman">ND</span>) is not a power of 2. 
Since this test is performed towards the end of calculations, the 
contents of array CG will be destroyed. 
It may be noted that when inverse transform is calculated the 
result will need to be divided by 
<span class="roman">NN</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span>&times;<span class="roman">NN</span><span class="roman">(</span><span class="roman">2</span><span class="roman">)</span>&times;&#8230;&times;<span class="roman">NN</span><span class="roman">(</span><span class="roman">ND</span><span class="roman">)</span> 
to match the original data. 
The subroutine does not perform the division. 

<div class="p"><!----></div>
 <br /><br /><a name="lapinv"> </a>
 <b>137.&nbsp;LAPINV&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/lapinv.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/lapinv.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the inverse Laplace transform 
of a given function F(s). N is the number of points at which the value of 
the inverse function is required. T is a real array of length  
N containing the points t<sub>i</sub>, at which the inverse transform is required. 
The elements t<sub>i</sub> need not be in any order, but the last element <span class="roman">t</span><sub><span class="roman">N</span></sub> 
should be the largest or close to the largest, since this element is 
used to control the value of T<sub>0</sub> as explained in Section 10.8. F is a real array of length  N, which will contain the value of 
the required function at t<sub>i</sub> after execution of the subroutine. CFS 
is the name of the function routine used to calculate the function F(s). 
ALPHA is an estimate for the exponential order of the function f(t) as 
explained in Section 10.8. REPS is the convergence parameter. The results 
are normally expected to have a relative accuracy of REPS<!--hbox-->. However, 
as explained in the text, this is not guaranteed when the convergence 
is slow. The results can be improved by either increasing the value 
of the parameter NMAX in the subroutine, or by removing the discontinuity 
which is causing the slow convergence. The second alternative will be 
more effective.  IER is the error parameter. IER=61 implies that the 
&#1013;-algorithm failed to converge for at least one of the points. 
IER=62 implies that the &#1013;-algorithm encountered a zero denominator 
at some stage. Since only the last value of IER will be retained, the error 
flag may be misleading in those cases, where failure has occurred at more 
than one points. FUNCTION CFS(CS) must be supplied by the user. Here 
both CFS and CS are complex variables. 

<div class="p"><!----></div>
 <br /><br /><a name="pold"> </a>
 <b>138.&nbsp;POLD&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/pold.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/pold.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to evaluate a polynomial and its 
derivatives at any point. N is the degree of polynomial. A is a real 
array of length <span class="roman">N</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial. 
A(1) should contain the constant term and A(N+1) should be the 
coefficient of <span class="roman">X</span><sup><span class="roman">N</span></sup>. X is the point at which polynomial 
is to be evaluated. ND is the number of derivatives to be evaluated. 
It would evaluate the first ND derivatives. The first derivative is 
always evaluated, irrespective of the value of ND<!--hbox-->. PD is a real array 
of length ND, which will contain the computed values of the derivatives. 
PD(I) will contain the Ith derivative of polynomial. The value of 
polynomial is returned as POLD. 

<div class="p"><!----></div>
 <br /><br /><a name="rmk"> </a>
 <b>139.&nbsp;RMK&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/rmk.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/rmk.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to evaluate a rational function at 
any point. M is the degree of numerator, while K is the degree of 
denominator. A is a real 
array of length <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial in 
the numerator. 
A(1) should contain the constant term and A(M+1) should be the 
coefficient of <span class="roman">X</span><sup><span class="roman">M</span></sup>. B is a real 
array of length <span class="roman">K</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial in 
the denominator. 
B(1) should contain the constant term and B(K+1) should be the 
coefficient of <span class="roman">X</span><sup><span class="roman">K</span></sup>. 
X is the point at which the rational function is to be evaluated. 
The value of rational function is returned as RMK<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="rmk1"> </a>
 <b>140.&nbsp;RMK1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/rmk1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/rmk1.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to evaluate a rational function at 
any point. This is the same as <a href="appendixb.htm#rmk"> RMK</a>, except that the constant term for 
polynomial in the denominator is assumed to be one and hence is not 
supplied. 
M is the degree of numerator, while K is the degree of 
denominator. A is a real 
array of length <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial in 
the numerator. 
A(1) should contain the constant term and A(M+1) should be the 
coefficient of <span class="roman">X</span><sup><span class="roman">M</span></sup>. B is a real 
array of length K containing the coefficients of the polynomial in 
the denominator. 
B(I) should contain the coefficient of <span class="roman">X</span><sup><span class="roman">I</span></sup>. 
X is the point at which the rational function is to be evaluated. 
The value of rational function is returned as RMK1<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="rmkd"> </a>
 <b>141.&nbsp;RMKD&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/rmkd.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/rmk.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to evaluate a rational function 
and its first derivative at 
any point. M is the degree of numerator, while K is the degree of 
denominator. A is a real 
array of length <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial in 
the numerator. 
A(1) should contain the constant term and A(M+1) should be the 
coefficient of <span class="roman">X</span><sup><span class="roman">M</span></sup>. B is a real 
array of length <span class="roman">K</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial in 
the denominator. 
B(1) should contain the constant term and B(K+1) should be the 
coefficient of <span class="roman">X</span><sup><span class="roman">K</span></sup>. 
X is the point at which the rational function is to be evaluated. 
DF will contain the computed value of the derivative. 
The value of rational function is returned as RMKD<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="rmkd1"> </a>
 <b>142.&nbsp;RMKD1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/rmkd1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/rmk1.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to evaluate a rational function 
and its first derivative at 
any point. This is the same as <a href="appendixb.htm#rmkd"> RMKD</a>, except that the constant term for 
polynomial in the denominator is assumed to be one and hence is not 
supplied. 
M is the degree of numerator, while K is the degree of 
denominator. A is a real 
array of length <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> containing the coefficients of the polynomial in 
the numerator. 
A(1) should contain the constant term and A(M+1) should be the 
coefficient of <span class="roman">X</span><sup><span class="roman">M</span></sup>. B is a real 
array of length K containing the coefficients of the polynomial in 
the denominator. 
B(I) should contain the coefficient of <span class="roman">X</span><sup><span class="roman">I</span></sup>. 
X is the point at which the rational function is to be evaluated. 
DF will contain the computed value of the derivative. 
The value of rational function is returned as RMKD1<!--hbox-->. 

<div class="p"><!----></div>
 <br /><br /><a name="pade"> </a>
 <b>143.&nbsp;PADE&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/pade.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/pade.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the coefficients of Pad&#233; 
approximation R<sub>mk</sub>(x) from the known coefficients of Maclaurin 
series. M and K are the degrees of polynomials in the numerator and the 
denominator, respectively. A is a real array of length   
<span class="roman">M</span>+<span class="roman">K</span>+1, which will contain the coefficients of the Pad&#233; 
approximation. <span class="roman">A</span>(i), (i=1,&#8230;,<span class="roman">K</span>) is the coefficient of x<sup>i</sup> in the 
denominator, the constant term being assumed to be unity, <span class="roman">A</span><span class="roman">(</span><span class="roman">K</span>+i+1), 
(i=0,1,&#8230;,<span class="roman">M</span><span class="roman">)</span> is the coefficient of x<sup>i</sup> in the numerator, which 
gives the Pad&#233; approximation 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
R<sub><span class="roman">MK</span></sub>(x)=</td><td nowrap="nowrap" align="center">
<span class="roman">A</span><span class="roman">(</span><span class="roman">K</span>+1)+<span class="roman">A</span><span class="roman">(</span><span class="roman">K</span>+2)x+<span class="roman">A</span><span class="roman">(</span><span class="roman">K</span>+3)x<sup>2</sup>+&#8230;+ <span class="roman">A</span><span class="roman">(</span><span class="roman">K</span><span class="roman">+</span><span class="roman">M</span>+1)x<sup><span class="roman">M</span></sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>1+<span class="roman">A</span>(1)x+<span class="roman">A</span>(2)x<sup>2</sup>+&#8230;+ <span class="roman">A</span><span class="roman">(</span><span class="roman">K</span><span class="roman">)</span>x<sup><span class="roman">K</span></sup><br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.54)</td></tr></table>
</td></tr></table>

 
C is a real array of length  <span class="roman">M</span>+<span class="roman">K</span>+1 containing the 
coefficients of the Maclaurin series for the required function. 
<span class="roman">C</span>(i+1) should contain the coefficient of x<sup>i</sup> in the Maclaurin 
series. These coefficients must be supplied by the user. IER is the 
error parameter. IER=612 implies that either <span class="roman">M</span> &lt; 0 or <span class="roman">K</span> &lt; 0, in which case 
no calculations are performed. Other values of IER may be set by the subroutine 
<a href="appendixb.htm#gauelm"> GAUELM</a>, which is called to solve the system of linear equations. WK is 
a real array of length  <span class="roman">K</span><sup>2</sup> used as a scratch space to 
store intermediate quantities. IWK is an integer array of length  
K, used as a scratch space to store intermediate quantities. 
This subroutine requires subroutine GAUELM to solve the system of linear 
equations. 

<div class="p"><!----></div>
 <br /><br /><a name="chebcf"> </a>
 <b>144.&nbsp;CHEBCF&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/chebcf.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/chebcf.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to convert a power series into a series of 
Chebyshev polynomials and vice versa. N is the degree of polynomial. 
C and P are real arrays of length  <span class="roman">N</span>+2 containing  
respectively, the coefficients of the Chebyshev and the power series expansions. 
<span class="roman">C</span>(i+1) is the coefficient of T<sub>i</sub>(x) in Chebyshev expansion, while 
<span class="roman">P</span>(i+1) is the coefficient of x<sup>i</sup> in the power series.  
It should be noted that C(1) is the coefficient of T<sub>0</sub>(x) and is not doubled 
as in the normal Chebyshev expansions. IFLG is the 
flag which decides the type of conversion required. If IFLG=0, 
then coefficients of Chebyshev expansion will be calculated. In 
that case, the power series coefficients must be supplied. After  
execution, the array C will contain the coefficients of Chebyshev expansion, 
while the array P is unaffected. If IFLG &#8800; 0, then the coefficients 
of power series will be calculated. In that case, the coefficients of 
Chebyshev expansion must be supplied and after execution, the array P 
will contain the coefficients of power series, while the contents of C 
will be destroyed, since this array is used as a scratch space by the subroutine. 

<div class="p"><!----></div>
 <br /><br /><a name="chebex"> </a>
 <b>145.&nbsp;CHEBEX&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/chebex.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/chebex.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the coefficients of Chebyshev 
expansion of a function that can be evaluated at any required point. 
It uses orthogonality of Chebyshev polynomials over a set of discrete 
points to find the coefficients and the value will only be approximately 
correct. 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">FUN</span>(x)=</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
c<sub>0</sub>+</td><td nowrap="nowrap" align="center">
<small><span class="roman">N</span>&#8722;<span class="roman">1</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
c<sub>i</sub>T<sub>i</sub>(x). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.55)</td></tr></table>
</td></tr></table>

 
N is the number of coefficients 
required. This number should be much larger than the actual number of 
coefficients needed. The accuracy of computed coefficients increases 
with N<!--hbox-->. There is no check to test the accuracy and it has to be 
ascertained by recomputing the coefficients with larger N (say 2N) 
and comparing the two values. C is a real array of length N, which 
will contain the computed coefficients. FUN is the name of the function 
routine supplied to calculate the required function. IER is the error 
parameter. IER=613 implies that <span class="roman">N</span> &lt; 10, in which case no 
calculations are done. Function FUN(X) must be supplied by the user. 

<div class="p"><!----></div>
 <br /><br /><a name="chebap"> </a>
 <b>146.&nbsp;CHEBAP&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/chebap.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/chebap.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the coefficients of Rational function 
Chebyshev 
approximations T<sub>mk</sub>(x) from the known coefficients of expansion in 
Chebyshev polynomials. It should be noted that, this subroutine does not 
generate minimax approximations, but if the coefficients of Chebyshev 
expansion fall off rapidly, then the approximation will be close to 
minimax. M and K are the degrees of polynomials in the numerator and the 
denominator, respectively. A is a real array of length   
<span class="roman">M</span>+<span class="roman">K</span>+1, which will contain the coefficients of the rational 
function 
approximation. <span class="roman">A</span>(i), (i=1,&#8230;,<span class="roman">K</span>) is the coefficient of  
T<sub>i</sub>(x) in the 
denominator, the constant term being assumed to be unity, <span class="roman">A</span><span class="roman">(</span><span class="roman">K</span>+i+1), 
(i=0,1,&#8230;,<span class="roman">M</span>) is the coefficient of T<sub>i</sub>(x) in the numerator, which 
gives the  approximation R<sub><span class="roman">MK</span></sub>(x) as 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<span class="roman">A</span><span class="roman">(</span><span class="roman">K</span>+1)+<span class="roman">A</span><span class="roman">(</span><span class="roman">K</span>+2)T<sub>1</sub>(x)+<span class="roman">A</span><span class="roman">(</span><span class="roman">K</span>+3)T<sub>2</sub>(x)+&#8230;+ <span class="roman">A</span><span class="roman">(</span><span class="roman">K</span><span class="roman">+</span><span class="roman">M</span>+1)T<sub><span class="roman">M</span></sub>(x)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>1+<span class="roman">A</span>(1)T<sub>1</sub>(x)+<span class="roman">A</span>(2)T<sub>2</sub>(x)+&#8230;+ <span class="roman">A</span><span class="roman">(</span><span class="roman">K</span><span class="roman">)</span>T<sub><span class="roman">K</span></sub>(x)<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.56)</td></tr></table>
</td></tr></table>

 
C is a real array of length  <span class="roman">M</span>+2<span class="roman">K</span>+1, containing 
coefficients of the Chebyshev series for the required function. 
<span class="roman">C</span>(i+1) should contain the coefficient of T<sub>i</sub>(x) in the Chebyshev 
series. These coefficients must be supplied by the user.  
Following the usual convention of Chebyshev expansion, the coefficient 
of T<sub>0</sub>(x) in the expansion is C(1)/2. IER is the 
error parameter. IER=612 implies that either <span class="roman">M</span> &lt; <span class="roman">0</span> 
or <span class="roman">K</span> &lt; 0, in which case, 
no calculations are performed. Other values of IER may be set by the subroutine 
GAUELM, which is called to solve the system of linear equations. WK is 
a real array of length  <span class="roman">K</span><sup>2</sup>, used as a scratch space to 
store intermediate quantities. IWK is an integer array of length  
K, used as a scratch space to store intermediate quantities. This subroutine 
requires subroutine <a href="appendixb.htm#gauelm"> GAUELM</a> to solve the system of linear equations. 

<div class="p"><!----></div>
 <br /><br /><a name="remes"> </a>
 <b>147.&nbsp;REMES&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/remes.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/remes.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the minimax rational function 
approximation for a given function over a finite interval, 
using the second algorithm of Remes. 
M and K are the degrees of polynomials 
in the numerator and the denominator, respectively. N is the number of points 
which will be used for initial scan of extrema in the error curve. This 
number should be at least 3(<span class="roman">M</span>+<span class="roman">K</span>+1), in order to be able to 
isolate different extrema. XL and XU are respectively, 
the lower and upper limits of the interval over which the approximation 
is required. A is a real array of length  <span class="roman">M</span>+<span class="roman">K</span>+2, which 
will contain the coefficients in the same form as that given by the 
subroutine <a href="appendixb.htm#pade"> PADE</a><!--hbox-->. <span class="roman">A</span>(i), (i=1,2,&#8230;,<span class="roman">K</span>) is the coefficient 
of x<sup>i</sup> in the denominator, the constant term being unity, 
while <span class="roman">A</span><span class="roman">(</span><span class="roman">K</span>+i+1), (i=0,1,&#8230;,<span class="roman">M</span>) 
is the coefficient of x<sup>i</sup> in the numerator. 
If IFLG=0, then the initial guess for these coefficients 
must be supplied. 
X and F are arrays of length 
N with F(I) containing the value of the function at X(I). These 
values need not be stored before calling the subroutine, since the subroutine 
itself selects a uniform mesh and calculates the value of the function at the 
required points. EX is a real array of length  <span class="roman">M</span>+<span class="roman">K</span>+5 
containing the extrema of the error curve. If IFLG=2, then the 
initial guess for the extrema must be supplied, otherwise these values 
are not required. In all cases, after execution, EX will contain 
the extrema of the error curve for the final approximation. IE is the 
number of extrema, which should be <span class="roman">M</span>+<span class="roman">K</span>+2, if the error curve 
is of the standard form. Some types of nonstandard error curves can be handled 
by this subroutine (Example&nbsp;10.11). EMAX is the maximum error 
in the final approximation calculated by the subroutine. EPS is the 
required tolerance. The iteration for calculating the coefficients of 
rational function is continued until the maximum error differs by less 
than EPS<!--hbox-->. The 
Remes iteration is continued until the difference between different 
extrema of error curve is less than 1% of the maximum error. 
EPSM specifies the tolerance for finding the 
extrema of the error curve. In general, it is found that a moderate 
value for EPS and EPSM is enough to find approximations even to very 
high accuracy. 
IFLG is an integer parameter, which 
specifies the nature of initial approximation for the Remes algorithm. 
If IFLG=0, then the 
iteration is started from a known initial approximation. In this case, 
the coefficients of initial approximation must be supplied in the array 
A<!--hbox-->. If IFLG=1, then no initial approximation is required and the 
first iteration is performed by assuming that the extrema of error 
curves are given by those of T<sub><span class="roman">M</span>+<span class="roman">K</span>+1</sub>(x). This is 
the most useful case, if no approximation of the right form and with the 
correct number of extrema is known. If IFLG=2, then iteration 
is started with an initial approximation for the extrema of the error 
curve. In this case, the approximate location of the extrema must be 
supplied in the array EX and IE ( &#8805; <span class="roman">M</span>+<span class="roman">K</span>+2) 
should be set equal to the number of extrema. If the error curve is expected to 
be nonstandard, then it will be preferable to supply only <span class="roman">M</span>+<span class="roman">K</span>+2 
extrema, where the error is expected to be the largest and is 
alternating in sign. IER is the error 
parameter. IER=614 implies that either <span class="roman">M</span> &lt; 0, or 
<span class="roman">K</span> &lt; 0, or  XU &#8804; XL, or <span class="roman">M</span>+<span class="roman">K</span>+2 &gt; NMAX, 
in which case, no calculations are performed. 
The last requirement arises because of the dimensions of array AA in 
the common block, which is used to transfer the coefficients to an 
auxiliary function routine for finding extrema of the function. 
IER=632 implies that the Remes 
iteration failed to converge to the specified accuracy in NIT (=30) 
iterations. This failure could be due to roundoff error, or because the 
starting values are not sufficiently close. 
IER=633 implies that at some stage the error curve does not 
have the required number of extrema and hence the iteration cannot  
proceed further. This condition does not necessarily imply that the 
error curve is nonstandard. 
Apart from these, other 
values of IER may be set by the subroutine BRENTM which is called to 
find the extrema, or the subroutine GAUELM which is called to solve 
the system of linear equations. WK is a real array of length  
(<span class="roman">K</span>+<span class="roman">M</span>+2)<sup>2</sup> used as a scratch space. IWK is an integer array 
of length  <span class="roman">M</span>+<span class="roman">K</span>+2, used as a scratch space to store 
intermediate numbers. This subroutine requires the subroutines 
<a href="appendixb.htm#brentm"> BRENTM</a> and <a href="appendixb.htm#gauelm"> GAUELM</a> and function routines <a href="appendixb.htm#fm"> FM</a>, FUN and FUND<!--hbox-->. 
FUNCTION FUN(X) calculates the required function, while FUNCTION FUND(X) 
calculates the weight function. Here X, FUN and FUND are real variables. 
The subroutine generates approximation of the form FUN(X) &#8776; FUND(X) R<sub><span class="roman">MK</span></sub>(X). If FUND(x)=1 and FUN(x)=f(x), then 
the subroutine will calculate minimax approximation to f(x) with respect to 
the absolute error, while if FUND(x)=1/f(x) and FUN(x)=1, 
then the approximation will be obtained with respect to the relative error, 
provided f(x) &#8800; 0 throughout the required interval. It should be noted 
that the names of the function routines FUN and FUND are fixed and cannot 
be changed. This is forced by the fact that Fortran does not allow 
external function names to be passed via the common block and the 
subroutine BRENTM does not pass any other argument to the function routine, 
which it uses for minimisation. This defect can be corrected by modifying 
BRENTM to pass on extra 
arguments to the function routine which is called for minimisation. 
(This approach has been followed in subroutine <a href="appendixb.htm#bfgs"> BFGS</a>, which needs to call 
line search routine <a href="appendixb.htm#linmin"> LINMIN</a>.) The functions FUN and FUND must be supplied 
by the user. The common block ZZFN is used to pass on parameters to 
FUNCTION FM(X), which calculates the function to be minimised. In the 
common block AA is a real array of length NMAX which contains the 
coefficients of rational function approximation. SI is a real variable 
which is set to positive value if minimum is to be found and to 
negative value when maximum is to be found. While SI &gt; 10 
implies that function value, FUN(X), is known and need not be calculated. 
MM and KK are integer variables which are equal to M and K respectively. 
The rational function approximation can be computed at any required value 
of X, using function <a href="appendixb.htm#rmk1"> RMK1</a>(M, K, A(K+1), A, X). 

<div class="p"><!----></div>
 <br /><br /><a name="fm"> </a>
 <b>148.&nbsp;FM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/fm.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/remes.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function subroutine to be used with subroutine <a href="appendixb.htm#remes"> REMES</a><!--hbox-->.  
This routine is called by <a href="appendixb.htm#brentm"> BRENTM</a> to locate the extrema of error curve. 
It calculates the difference between the actual function and the rational 
function approximation weighted by the required weight function.  
This difference is multiplied by SI which is set to a negative value 
if we want to find a maxima. For initial scan <span class="roman">SI</span> &#8805; 10, in which 
case, function value is not calculated, since it is already known. 

<div class="p"><!----></div>
 <br /><br /><a name="gamma"> </a>
 <b>149.&nbsp;GAMMA&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gamma.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gamma.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the Gamma function 
for a real argument 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#915;(x)=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
t<sup>x&#8722;1</sup>e<sup>&#8722;t</sup>&nbsp;&nbsp;dt&nbsp;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x &gt; 0). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.57)</td></tr></table>
</td></tr></table>

 
The computed value should generally have relative accuracy of 10<sup>&#8722;15</sup>. 
The routine first calculates the value of Gamma function at &#124;x&#124;.  
The values for negative argument are then calculated using 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
&#8722;x&#915;(&#8722;x)&#915;(x)=</td><td nowrap="nowrap" align="center">
&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>sin(&#960;x)<br /></td><td nowrap="nowrap" align="center">
&nbsp;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.58)</td></tr></table>
</td></tr></table>

 
For x &gt; 1000 the Stirling's formula is used to calculate the function 
value. For 8 &lt; x &#8804; 1000 a rational function approximation of 
form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
log&#915;(x)=(x&#8722;</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
)logx &#8722; x +log(</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">2&#960;<br /></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
) +</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
R<sub>mk</sub>(1/x<sup>2</sup>), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.59)</td></tr></table>
</td></tr></table>

 
is used. 
For 0 &lt; x &#8804; 8 the range is first translated to [2,3] using 
&#915;(x+1)=x&#915;(x) and then a rational function approximation 
over [2,3] is used to approximate the function value. 
This routine does not check for overflow or invalid arithmetic 
operations. Since &#915;(x) increases very rapidly with x, 
the function evaluation will lead to overflow for x larger than 
approximately 170 on a 53 bit (REAL*8) arithmetic. Similarly, 
&#915;(x) diverges when x is a negative integer or zero. 
If overflow is expected, then it may be better to use GAMMAL instead 
which gives the logarithm of &#915;(x). 

<div class="p"><!----></div>
 <br /><br /><a name="gammal"> </a>
 <b>150.&nbsp;GAMMAL&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gammal.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gamma.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the natural 
logarithm of Gamma function for a real argument. It uses the same 
approximations as those used by Function <a href="appendixb.htm#gamma"> GAMMA</a>, except that for large 
arguments (&#124;x&#124; &gt; 8), it directly calculates the logarithm and hence 
should not give overflow. It gives log(&#124;&#915;(X)&#124;) and hence 
sign should be accounted separately. 

<div class="p"><!----></div>
 <br /><br /><a name="erf"> </a>
 <b>151.&nbsp;ERF&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/erf.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/erf.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the Error function 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">erf</span>(x)=</td><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">&#960;<br /></div>                                </td></tr></table></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>x</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
e<sup>&#8722;t<sup>2</sup></sup>&nbsp;&nbsp;dt&nbsp;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.60)</td></tr></table>
</td></tr></table>

 
for a real argument. This routine uses rational function approximations 
of the form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">erf</span>(x) &#8776; </td><td align="left" class="cl">&#x23A7;<br />&#x23AA;<br />&#x23AA;<br />&#x23A8;<br />
&#x23AA;<br />&#x23AA;<br />&#x23A9;
</td><td nowrap="nowrap"><table border="0" align="left" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">xR</span><sub><span class="roman">mk</span></sub><span class="roman">(</span><span class="roman">x</span><sup><span class="roman">2</span></sup><span class="roman">)</span><span class="roman">,</span></td></tr></table></td><td nowrap="nowrap" align="center">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
<span class="roman">(</span><span class="roman">0</span> &#8804; <span class="roman">x</span> &lt;  <span class="roman">2</span><span class="roman">)</span><span class="roman">;</span></td></tr></table></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td nowrap="nowrap" align="center" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="center">
 <span class="roman">1</span>&#8722;</td><td nowrap="nowrap" align="center">
<span class="roman">e</span><sup>&#8722;<span class="roman">x</span><sup><span class="roman">2</span></sup></sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">x</span><br /></td><td nowrap="nowrap" align="center">
<span class="roman">R</span>&#8242;<sub><span class="roman">m</span>&#8242;<span class="roman">k</span>&#8242;</sub><span class="roman">(</span></td><td nowrap="nowrap" align="center">
<span class="roman">1</span>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">x</span><sup><span class="roman">2</span></sup><br /></td><td nowrap="nowrap" align="center">
<span class="roman">)</span><span class="roman">,</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </td></tr></table></td><td nowrap="nowrap" align="center">
<table><tr><td nowrap="nowrap" align="center" colspan="1"><span class="roman">(</span><span class="roman">2</span> &#8804; <span class="roman">x</span> &lt;  &#8734;<span class="roman">)</span><span class="roman">.</span></td></tr></table></td></tr></table>
</td><td nowrap="nowrap"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.61)</td></tr></table>
</td></tr></table>

 
While for x &lt; 0 it uses <span class="roman">erf</span>(&#8722;x)=&#8722;<span class="roman">erf</span>(x) to evaluate 
the function value. Each of the rational function approximation 
has relative accuracy of better than 10<sup>&#8722;15</sup>. For large x the 
value may be indistinguishable from 1. 

<div class="p"><!----></div>
 <br /><br /><a name="erfc"> </a>
 <b>152.&nbsp;ERFC&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/erfc.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/erf.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the complementary 
Error function 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">erfc</span>(x)=1&#8722;<span class="roman">erf</span>(x)=</td><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">&#960;<br /></div>                                </td></tr></table></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><br />
<small>x</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
e<sup>&#8722;t<sup>2</sup></sup>&nbsp;&nbsp;dt&nbsp;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.62)</td></tr></table>
</td></tr></table>

 
for a real argument. This routine uses the same approximations as 
those used by ERF(X). The value should generally have relative 
accuracy of 10<sup>&#8722;15</sup>. 
For small arguments the value of function may 
not be distinguishable from unity, while for large negative arguments 
it may be indistinguishable from 2.  

<div class="p"><!----></div>
 <br /><br /><a name="bj0"> </a>
 <b>153.&nbsp;BJ0&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bj0.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the Bessel function of 
the first kind of order zero, J<sub>0</sub>(x) for a real argument. 
For &#124;x&#124; &lt; 8 it uses a rational function approximation to 
J<sub>0</sub>(x) &#8776; R<sub>mk</sub>(x<sup>2</sup>), 
while for larger arguments it uses the asymptotic form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
J<sub>0</sub>(x)=</td><td align="left" class="cl">
<font size="+2">&nbsp;&nbsp;&#x239B;<br />&#8730;<br /></font></td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;x<br /></td></tr></table></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
P<sub>0</sub>(x)cos(x&#8722;</td><td nowrap="nowrap" align="center">
&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
) &#8722;Q<sub>0</sub>(x)sin(x&#8722;</td><td nowrap="nowrap" align="center">
&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
)</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.63)</td></tr></table>
</td></tr></table>

 
The functions P<sub>0</sub>(x) and Q<sub>0</sub>(x) are approximated by rational 
function approximations of form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P<sub>0</sub>(x) &#8776; R<sub>mk</sub>(1/x<sup>2</sup>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q<sub>0</sub>(x) &#8776; </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
R<sub>m&#8242;k&#8242;</sub>(1/x<sup>2</sup>). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.64)</td></tr></table>
</td></tr></table>

 
All the rational function approximations have absolute accuracy of 
better than 10<sup>&#8722;15</sup>, but the resulting function values may not 
have the same relative accuracy at all points. Near the zeros of 
J<sub>0</sub>(x) the relative accuracy would be lower. For large 
arguments, &#124;x&#124; &gt; 8, where the asymptotic formula is used there 
could be some cancellation between the two terms and consequent 
loss of significant figures close to zeros of J<sub>0</sub>(x). 

<div class="p"><!----></div>
 <br /><br /><a name="bj1"> </a>
 <b>154.&nbsp;BJ1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bj1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the Bessel function of 
the first kind of order one, J<sub>1</sub>(x) for a real argument. 
For &#124;x&#124; &lt; 8 it uses a rational function approximation to 
J<sub>1</sub>(x) &#8776; xR<sub>mk</sub>(x<sup>2</sup>), 
while for larger arguments it uses the asymptotic form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
J<sub>1</sub>(x)=</td><td align="left" class="cl">
<font size="+2">&nbsp;&nbsp;&#x239B;<br />&#8730;<br /></font></td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;x<br /></td></tr></table></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
P<sub>1</sub>(x)cos(x&#8722;</td><td nowrap="nowrap" align="center">
3&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
) &#8722;Q<sub>1</sub>(x)sin(x&#8722;</td><td nowrap="nowrap" align="center">
3&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
)</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.65)</td></tr></table>
</td></tr></table>

 
The functions P<sub>1</sub>(x) and Q<sub>1</sub>(x) are approximated by rational 
function approximations of form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P<sub>1</sub>(x) &#8776; R<sub>mk</sub>(1/x<sup>2</sup>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q<sub>1</sub>(x) &#8776; </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
R<sub>m&#8242;k&#8242;</sub>(1/x<sup>2</sup>). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.66)</td></tr></table>
</td></tr></table>

 
All the rational function approximations have absolute accuracy of 
better than 10<sup>&#8722;15</sup>, but the resulting function values may not 
have the same relative accuracy at all points. Near the zeros of 
J<sub>1</sub>(x) the relative accuracy would be lower. For large 
arguments, &#124;x&#124; &gt; 8, where the asymptotic formula is used there 
could be some cancellation between the two terms and consequent 
loss of significant figures close to zeros of J<sub>1</sub>(x). 

<div class="p"><!----></div>
 <br /><br /><a name="bjn"> </a>
 <b>155.&nbsp;BJN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bjn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the Bessel function of 
the first kind of integral order, J<sub>n</sub>(x) for a real argument. 
This routine calculates J<sub>k</sub>(x) for k between 0 and n. 
Since a recurrence relation is used to calculate these values, all 
the values are returned. Here N is the maximum order of Bessel functions 
required. For positive N, J<sub>k</sub>(x) with positive k=0,1,&#8230;,<span class="roman">N</span> 
will be calculated. For negative N, J<sub>k</sub>(x) with negative 
k=0,&#8722;1,&#8230;,&#8722;<span class="roman">N</span> are calculated. XB is the argument at which 
the function values are required. BJ is a real array which will 
contain the computed values of the Bessel functions. 
<span class="roman">BJ</span>(&#124;i&#124;+1)=J<sub>i</sub>(<span class="roman">XB</span>). Since this array is also used as 
scratch space the length of the array must be at least, 
&#124;<span class="roman">N</span>&#124;+16+max(25, 5&#8730;{&#124;N&#124;}).  
For &#124;<span class="roman">N</span>&#124; &lt; &#124;<span class="roman">XB</span>&#124; the recurrence relation is stable in forward 
direction and hence it is used to calculate J<sub>k</sub>(x) in a straightforward 
manner using the values of J<sub>0</sub>(x) and J<sub>1</sub>(x). 
For smaller XB, the recurrence relation is unstable in forward direction 
and hence is used in backward direction as explained in {2.38} In this case for some suitable n<sub>1</sub>, we start using J<sub>n<sub>1</sub></sub>=0 and 
J<sub>n<sub>1</sub>&#8722;1</sub>=1 and calculate lower order functions using the recurrence 
relation 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
J<sub>k&#8722;1</sub>(x)=</td><td nowrap="nowrap" align="center">
2k
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
J<sub>k</sub>(x)&#8722;J<sub>k+1</sub>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k=n<sub>1</sub>&#8722;1,&#8230;,2,1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.67)</td></tr></table>
</td></tr></table>

 
The normalisation is then found using the relation 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 J<sub>0</sub>(x)+2</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>k=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
J<sub>2k</sub>(x)=1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.68)</td></tr></table>
</td></tr></table>

 
Thus we can divide all values by the calculated sum to obtain the 
correct values for J<sub>k</sub>(x). 
To use this technique we need to select a suitably large value of 
n<sub>1</sub> to start the recurrence relation. Accuracy of resulting 
function values can be checked by comparing the value of J<sub>n+1</sub>(x) 
without normalisation. The reciprocal of this value will give an estimate 
of accuracy achieved by this process. Thus if the computed value of 
J<sub>n+1</sub>(x) is not large enough an error message is printed out by the 
routine. This should not normally happen, but in case for some 
combination of N and XB, the chosen value of n<sub>1</sub> is not large 
enough, the error message will be printed out. In such cases the 
choice of N1 in the routine should be increased suitably. 
In principle, this technique can be used for all values of x, but 
n<sub>1</sub> has to be larger than x and hence for large x, we will need 
lot of computation using this technique. Further, the use of the 
recurrence relation in this form results in overflow even when the 
required values are within the range of computer arithmetic. This 
problem is more severe at low x, where the values can be easily 
computed using the series expansion. Thus we use the series expansion 
for x &#8804; 4 for computing J<sub>n</sub>(x) and J<sub>n&#8722;1</sub>(x). After that 
the recurrence relation is used in backward direction to get other 
values.  The overflow problem becomes very 
acute when single precision arithmetic is used and it is not 
recommended to use this routine in single precision. 
The accuracy attained by this routine will depend on the values of 
N and XB, but in general we expect accuracy of order of 10<sup>&#8722;15</sup> 
which is the accuracy with which J<sub>0</sub>(x) and J<sub>1</sub>(x) are calculated. 
This routine needs <a href="appendixb.htm#bj0"> BJ0</a> and <a href="appendixb.htm#bj1"> BJ1</a> to calculate J<sub>0</sub>(x) and J<sub>1</sub>(x). 

<div class="p"><!----></div>
 <br /><br /><a name="by0"> </a>
 <b>156.&nbsp;BY0&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/by0.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the Bessel function of 
the second kind of order zero, Y<sub>0</sub>(x) for a real argument. 
This function is not defined for x &#8804; 0, and the routine simply 
returns a value of zero without any warning or error flag. 
User must ensure that x is positive. 
For x &lt; 8 it uses a rational function approximation of the form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
Y<sub>0</sub>(x)=</td><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;<br /></td><td nowrap="nowrap" align="center">
{J<sub>0</sub>(x)(log(x/2)+&#947;) +x<sup>2</sup>R<sub>mk</sub>(x<sup>2</sup>)}, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.69)</td></tr></table>
</td></tr></table>

 
where &#947; is the Euler's constant. 
J<sub>0</sub>(x) is computed using a rational function approximation. 
For larger arguments the asymptotic form is used: 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
Y<sub>0</sub>(x)=</td><td align="left" class="cl">
<font size="+2">&nbsp;&nbsp;&#x239B;<br />&#8730;<br /></font></td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;x<br /></td></tr></table></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
P<sub>0</sub>(x)sin(x&#8722;</td><td nowrap="nowrap" align="center">
&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
) +Q<sub>0</sub>(x)cos(x&#8722;</td><td nowrap="nowrap" align="center">
&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
)</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.70)</td></tr></table>
</td></tr></table>

 
The functions P<sub>0</sub>(x) and Q<sub>0</sub>(x) are approximated by rational 
function approximations of form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P<sub>0</sub>(x) &#8776; R<sub>mk</sub>(1/x<sup>2</sup>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q<sub>0</sub>(x) &#8776; </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
R<sub>m&#8242;k&#8242;</sub>(1/x<sup>2</sup>). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.71)</td></tr></table>
</td></tr></table>

 
All the rational function approximations have absolute accuracy of 
better than 10<sup>&#8722;15</sup>, but the resulting function values may not 
have the same relative accuracy at all points. Near the zeros of 
Y<sub>0</sub>(x) the relative accuracy would be lower. For large 
arguments, x &gt; 8, where the asymptotic formula is used there 
could be some cancellation between the two terms and consequent 
loss of significant figures close to zeros of Y<sub>0</sub>(x). 

<div class="p"><!----></div>
 <br /><br /><a name="bjy0"> </a>
 <b>157.&nbsp;BJY0&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bjy0.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the Bessel function of 
the first and second kind of order zero, J<sub>0</sub>(x),Y<sub>0</sub>(x) for a 
real argument. Since computation of Y<sub>0</sub>(x) involves J<sub>0</sub>(x) 
also, this subroutine is provided to give both values together 
and can be used if both functions are required. 
The function of the second kind is not defined for x &#8804; 0, 
and the routine simply 
returns a value of zero without any warning or error flag. 
The value of J<sub>0</sub>(x) should be calculated even in this case. 
User must ensure that x is positive if Y<sub>0</sub>(x) is also required. 
For calculating J<sub>0</sub>(x) alone it will be more efficient to use <a href="appendixb.htm#bj0"> BJ0</a>. 
This routine is essentially same as <a href="appendixb.htm#by0"> BY0</a>, except that in this case 
the function values have to appear as arguments while calling the 
subroutine. The FUNCTION BY0 can also be modified to include BJ0 
in its argument list, in which case it can return that value also. 
In that case the line computing BJ0 should be uncommented. 
Here XB is the argument at which the function values are 
required. BJ0 and BY0 are the computed values of J<sub>0</sub>(<span class="roman">XB</span>) and 
Y<sub>0</sub>(<span class="roman">XB</span>). 

<div class="p"><!----></div>
 <br /><br /><a name="by1"> </a>
 <b>158.&nbsp;BY1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/by1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the Bessel function of 
the second kind of order one, Y<sub>1</sub>(x) for a real argument. 
This function is not defined for x &#8804; 0, and the routine simply 
returns a value of zero without any warning or error flag. 
User must ensure that x is positive. 
For x &lt; 8 it uses a rational function approximation of the form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
Y<sub>1</sub>(x)=</td><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x23A7;<br />&#x23A8;<br />
&#x23A9;
</td><td nowrap="nowrap" align="center">
J<sub>1</sub>(x)(log(x/2)+&#947;)&#8722;</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
&#8722;xR<sub>mk</sub>(x<sup>2</sup>)</td><td align="left" class="cl">&#x23AB;<br />&#x23AC;<br />
&#x23AD;
</td><td nowrap="nowrap" align="center">
, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.72)</td></tr></table>
</td></tr></table>

 
where &#947; is the Euler's constant. 
J<sub>1</sub>(x) is computed using a rational function approximation. 
For larger arguments the asymptotic form is used: 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
Y<sub>1</sub>(x)=</td><td align="left" class="cl">
<font size="+2">&nbsp;&nbsp;&#x239B;<br />&#8730;<br /></font></td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
2
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;x<br /></td></tr></table></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
P<sub>1</sub>(x)sin(x&#8722;</td><td nowrap="nowrap" align="center">
3&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
) +Q<sub>1</sub>(x)cos(x&#8722;</td><td nowrap="nowrap" align="center">
3&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
)</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.73)</td></tr></table>
</td></tr></table>

 
The functions P<sub>1</sub>(x) and Q<sub>1</sub>(x) are approximated by rational 
function approximations of form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P<sub>1</sub>(x) &#8776; R<sub>mk</sub>(1/x<sup>2</sup>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q<sub>1</sub>(x) &#8776; </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
R<sub>m&#8242;k&#8242;</sub>(1/x<sup>2</sup>). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.74)</td></tr></table>
</td></tr></table>

 
All the rational function approximations have absolute accuracy of 
better than 10<sup>&#8722;15</sup>, but the resulting function values may not 
have the same relative accuracy at all points. Near the zeros of 
Y<sub>1</sub>(x) the relative accuracy would be lower. For large 
arguments, x &gt; 8, where the asymptotic formula is used there 
could be some cancellation between the two terms and consequent 
loss of significant figures close to zeros of Y<sub>1</sub>(x). 

<div class="p"><!----></div>
 <br /><br /><a name="bjy1"> </a>
 <b>159.&nbsp;BJY1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bjy1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the Bessel function of 
the first and second kind of order one, J<sub>1</sub>(x),Y<sub>1</sub>(x) for a 
real argument. Since computation of Y<sub>1</sub>(x) involves J<sub>1</sub>(x) 
also, this subroutine is provided to give both values together 
and can be used if both functions are required. 
The function of the second kind is not defined for x &#8804; 0, 
and the routine simply 
returns a value of zero without any warning or error flag. 
The value of J<sub>1</sub>(x) should be calculated even in this case. 
User must ensure that x is positive if Y<sub>1</sub>(x) is also required. 
For calculating J<sub>1</sub>(x) alone it will be more efficient to use <a href="appendixb.htm#bj1"> BJ1</a>. 
This routine is essentially same as <a href="appendixb.htm#by1"> BY1</a>, except that in this case 
the function values have to appear as arguments while calling the 
subroutine. The FUNCTION BY1 can also be modified to include BJ1 
in its argument list, in which case it can return that value also. 
In that case the line computing BJ1 should be uncommented. 
Here XB is the argument at which the function values are 
required. BJ1 and BY1 are the computed values of J<sub>1</sub>(<span class="roman">XB</span>) and 
Y<sub>1</sub>(<span class="roman">XB</span>). 

<div class="p"><!----></div>
 <br /><br /><a name="byn"> </a>
 <b>160.&nbsp;BYN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/byn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the Bessel function of 
the second kind of integral order, Y<sub>n</sub>(x) for a real argument. 
This routine calculates Y<sub>k</sub>(x) for k between 0 and n. 
This function is not defined for x &#8804; 0, and the routine  
does not calculate the value and does not give any warning or error 
flag. In this case values in array BY will be preserved and may 
be misinterpreted as calculated value. 
User must ensure that x is positive. 
Since a recurrence relation is used to calculate these values, all 
the values are returned. Here N is the maximum order of Bessel functions 
required. For positive N, Y<sub>k</sub>(x) with positive k=0,1,&#8230;,<span class="roman">N</span> 
will be calculated. For negative N, Y<sub>k</sub>(x) with negative 
k=0,&#8722;1,&#8230;,&#8722;<span class="roman">N</span> are calculated. XB is the argument at which 
the function values are required. BY is a real array of length 
&#124;<span class="roman">N</span>&#124;+1 which will 
contain the computed values of the Bessel functions. 
<span class="roman">BY</span>(&#124;i&#124;+1)=Y<sub>i</sub>(<span class="roman">XB</span>).  
Since the recurrence relation for Y<sub>n</sub>(x) 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 Y<sub>n+1</sub>(x)=</td><td nowrap="nowrap" align="center">
2n
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
Y<sub>n</sub>(x)&#8722;Y<sub>n&#8722;1</sub>(x), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.75)</td></tr></table>
</td></tr></table>

 
is stable in the forward 
direction for all x, these values are computed in a straightforward 
manner using the values of Y<sub>0</sub>(x) and Y<sub>1</sub>(x). 
This routine needs <a href="appendixb.htm#by0"> BY0</a> and <a href="appendixb.htm#by1"> BY1</a> to calculate Y<sub>0</sub>(x) and Y<sub>1</sub>(x). 

<div class="p"><!----></div>
 <br /><br /><a name="sphbjn"> </a>
 <b>161.&nbsp;SPHBJN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/sphbjn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the spherical Bessel function 
of integral order, 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
j<sub>n</sub>(x)=</td><td align="left" class="cl">
<font size="+2">&nbsp;&nbsp;&#x239B;<br />&#8730;<br /></font></td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#960;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2x<br /></td></tr></table></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
J<sub>n+1/2</sub>(x), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.76)</td></tr></table>
</td></tr></table>

 
for a real argument. 
This routine calculates j<sub>k</sub>(x) for k between 0 and n. 
Since a recurrence relation is used to calculate these values, all 
the values are returned. Here N is the maximum order of Bessel functions 
required. For positive N, j<sub>k</sub>(x) with positive k=0,1,&#8230;,<span class="roman">N</span> 
will be calculated. For negative N, j<sub>k</sub>(x) with negative 
k=0,&#8722;1,&#8230;,&#8722;<span class="roman">N</span> are calculated. XB is the argument at which 
the function values are required. BJ is a real array which will 
contain the computed values of the Bessel functions. 
<span class="roman">BJ</span>(&#124;i&#124;+1)=j<sub>i</sub>(<span class="roman">XB</span>). Since this array is also used as 
scratch space the length of the array must be at least, 
&#124;<span class="roman">N</span>&#124;+16+max(25, 5&#8730;{&#124;N&#124;}).  
For &#124;<span class="roman">N</span>&#124; &lt; &#124;<span class="roman">XB</span>&#124; or for <span class="roman">N</span> &lt; 0 the recurrence relation 
is stable in forward 
direction and hence it is used to calculate j<sub>k</sub>(x) in a straightforward 
manner using the values of 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
j<sub>0</sub>(x)=</td><td nowrap="nowrap" align="center">
sinx
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j<sub>1</sub>(x)=</td><td nowrap="nowrap" align="center">
sinx
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
&#8722;</td><td nowrap="nowrap" align="center">
cosx
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="roman">or</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j<sub>&#8722;1</sub>(x)=</td><td nowrap="nowrap" align="center">
cosx
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
&nbsp;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.77)</td></tr></table>
</td></tr></table>

 
For smaller XB and <span class="roman">N</span> &gt; 0, the recurrence is unstable 
in forward direction 
and hence is used in backward direction as explained in {2.38} In this case for some suitable n<sub>1</sub>, we start using j<sub>n<sub>1</sub></sub>=0 and 
j<sub>n<sub>1</sub>&#8722;1</sub>=1 and calculate lower order functions using the recurrence 
relation 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
j<sub>k&#8722;1</sub>(x)=</td><td nowrap="nowrap" align="center">
2k+1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
j<sub>k</sub>(x)&#8722;j<sub>k+1</sub>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k=n<sub>1</sub>&#8722;1,&#8230;,2,1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.78)</td></tr></table>
</td></tr></table>

 
The normalisation is then found using the value of j<sub>0</sub>(x). 
Thus we can divide all values by the calculated ratio S of  
j<sub>0</sub>(x) as computed from recurrence relation to its actual value, 
to obtain the correct values for j<sub>k</sub>(x). 
To use this technique we need to select a suitably large value of 
n<sub>1</sub> to start the recurrence relation. Accuracy of resulting 
function values can be checked by comparing the value of j<sub>n+1</sub>(x) 
before normalisation.  Its reciprocal will give an estimate 
of accuracy achieved by this process. Thus if the computed value of 
j<sub>n+1</sub>(x) is not large enough an error message is printed out by the 
routine. This should not normally happen, but in case for some 
combination of N and XB, the chosen value of n<sub>1</sub> is not large 
enough, the error message will be printed out. In such cases the 
choice of N1 in the routine should be increased suitably. 
In principle, this technique can be used for all values of x, but 
n<sub>1</sub> has to be larger than x and hence for large x, we will need 
lot of computation using this technique. Further, the use of the 
recurrence relation in this form results in overflow even when the 
required values are within the range of computer arithmetic. This 
problem is more severe at low x, where the values can be easily 
computed using the series expansion. Thus we use the series expansion 
for x &#8804; 4 for computing j<sub>n</sub>(x) and j<sub>n&#8722;1</sub>(x). After that 
the recurrence relation is used in backward direction to get other 
values.  The overflow problem becomes very 
acute when single precision arithmetic is used and it is not 
recommended to use this routine in single precision. 
The accuracy attained by this routine will depend on the arithmetic 
used. In general, we expect to achieve accuracy of order of &#295; 
in these computations, since j<sub>0</sub>(x) and j<sub>1</sub>(x) can be expressed 
in terms of trigonometric functions. 

<div class="p"><!----></div>
 <br /><br /><a name="bi0"> </a>
 <b>162.&nbsp;BI0&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bi0.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the modified Bessel function of 
the first kind of order zero, I<sub>0</sub>(x) for a real argument. 
For &#124;x&#124; &lt; 8 it uses a rational function approximation to 
I<sub>0</sub>(x) &#8776; R<sub>mk</sub>(x<sup>2</sup>), 
while for larger arguments it uses the asymptotic form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
I<sub>0</sub>(x)=</td><td nowrap="nowrap" align="center">
e<sup>&#124;x&#124;</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">&#124;x&#124;<br /></div>                                </td></tr></table></td><td nowrap="nowrap" align="center">
R<sub>mk</sub>(1/&#124;x&#124;). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.79)</td></tr></table>
</td></tr></table>

 
All the rational function approximations have absolute accuracy of 
better than 10<sup>&#8722;15</sup>, but the resulting function values may not 
have the same relative accuracy at all points. 

<div class="p"><!----></div>
 <br /><br /><a name="bi1"> </a>
 <b>163.&nbsp;BI1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bi1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the modified Bessel function of 
the first kind of order one, I<sub>1</sub>(x) for a real argument. 
For &#124;x&#124; &lt; 8 it uses a rational function approximation to 
I<sub>1</sub>(x) &#8776; xR<sub>mk</sub>(x<sup>2</sup>), 
while for larger arguments it uses the asymptotic form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
I<sub>1</sub>(x)=</td><td nowrap="nowrap" align="center">
e<sup>&#124;x&#124;</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><br /><font size="+2">&#8730;</font><br />                                </td><td nowrap="nowrap" align="center">

<div class="hrcomp"><hr noshade="noshade" size="1"/></div>
<div class="norm">&#124;x&#124;<br /></div>                                </td></tr></table></td><td nowrap="nowrap" align="center">
R<sub>mk</sub>(1/&#124;x&#124;). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.80)</td></tr></table>
</td></tr></table>

 
All the rational function approximations have absolute accuracy of 
better than 10<sup>&#8722;15</sup>, but the resulting function values may not 
have the same relative accuracy at all points. 

<div class="p"><!----></div>
 <br /><br /><a name="bin"> </a>
 <b>164.&nbsp;BIN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bin.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the modified Bessel function of 
the first kind of positive integral order, I<sub>n</sub>(x) for a real argument. 
This routine calculates I<sub>k</sub>(x) for k between 0 and n. 
Since a recurrence relation is used to calculate these values, all 
the values are returned. Here N is the maximum order of Bessel functions 
required, I<sub>k</sub>(x) with k=0,1,&#8230;,<span class="roman">N</span> 
will be calculated. N must be positive, otherwise &#124;<span class="roman">N</span>&#124; will be used. 
XB is the argument at which 
the function values are required. BI is a real array which will 
contain the computed values of the Bessel functions. 
<span class="roman">BI</span>(i+1)=I<sub>i</sub>(<span class="roman">XB</span>). Since this array is also used as 
scratch space the length of the array must be at least, 
<span class="roman">N</span>+16+max(25, 5&#8730;N).  
For <span class="roman">N</span> &lt; <span class="roman">XB</span>&#8722;10 the recurrence relation is stable in forward 
direction and hence it is used to calculate I<sub>k</sub>(x) in a straightforward 
manner using the values of I<sub>0</sub>(x) and I<sub>1</sub>(x). 
For smaller XB, the recurrence is unstable in forward direction 
and hence is used in backward direction as explained in {2.38} In this case for some suitable n<sub>1</sub>, we start using I<sub>n<sub>1</sub></sub>=0 and 
I<sub>n<sub>1</sub>&#8722;1</sub>=1 and calculate lower order functions using the recurrence 
relation 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
I<sub>k&#8722;1</sub>(x)=</td><td nowrap="nowrap" align="center">
2k
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
I<sub>k</sub>(x)+I<sub>k+1</sub>(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k=n<sub>1</sub>&#8722;1,&#8230;,2,1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.81)</td></tr></table>
</td></tr></table>

 
The normalisation is then found using the directly computed value 
of I<sub>0</sub>(x). 
Thus we can divide all values by the calculated ratio for I<sub>0</sub>(x) 
to obtain the correct values for I<sub>k</sub>(x). 
To use this technique we need to select a suitably large value of 
n<sub>1</sub> to start the recurrence relation. Accuracy of resulting 
function values can be checked by comparing the value of I<sub>n+1</sub>(x) 
before normalisation. Its reciprocal will give an estimate 
of accuracy achieved by this process. Thus if the computed value of 
I<sub>n+1</sub>(x) is not large enough an error message is printed out by the 
routine. This should not normally happen, but in case for some 
combination of N and XB, the chosen value of n<sub>1</sub> is not large 
enough, the error message will be printed out. In such cases the 
choice of N1 in the routine should be increased suitably. 
In principle, this technique can be used for all values of x, but 
n<sub>1</sub> has to be larger than x and hence for large x, we will need 
lot of computation using this technique. Further, the use of the 
recurrence relation in this form results in overflow even when the 
required values are within the range of computer arithmetic. This 
problem is more severe at low x, where the values can be easily 
computed using the series expansion. Thus we use the series expansion 
for x &#8804; 4 for computing I<sub>n</sub>(x) and I<sub>n&#8722;1</sub>(x). After that 
the recurrence relation is used in backward direction to get other 
values.  The overflow problem becomes very 
acute when single precision arithmetic is used and it is not 
recommended to use this routine in single precision. 
The accuracy attained by this routine will depend on the values of 
N and XB, but in general, we expect accuracy of order of 10<sup>&#8722;15</sup> 
which is the accuracy with which I<sub>0</sub>(x) and I<sub>1</sub>(x) are calculated. 
This routine needs <a href="appendixb.htm#bi0"> BI0</a> and <a href="appendixb.htm#bi1"> BI1</a> to calculate I<sub>0</sub>(x) and I<sub>1</sub>(x). 

<div class="p"><!----></div>
 <br /><br /><a name="bk0"> </a>
 <b>165.&nbsp;BK0&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bk0.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the modified Bessel function of 
the second kind of order zero, K<sub>0</sub>(x) for a real argument. 
This function is not defined for x &#8804; 0, and the routine simply 
returns a value of zero without any warning or error flag. 
User must ensure that x is positive. 
For x &lt; 8 it uses a rational function approximation of the form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
K<sub>0</sub>(x)=&#8722;I<sub>0</sub>(x)(&#947;+log(x/2))+x<sup>2</sup>R<sub>mk</sub>(x<sup>2</sup>), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.82)</td></tr></table>
</td></tr></table>

 
where &#947; is the Euler's constant and I<sub>0</sub>(x) is computed 
using appropriate rational function approximation. 
For larger arguments the asymptotic form is used: 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
K<sub>0</sub>(x)=</td><td nowrap="nowrap" align="center">
e<sup>&#8722;x</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8730;x<br /></td><td nowrap="nowrap" align="center">
R<sub>mk</sub>(1/x). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.83)</td></tr></table>
</td></tr></table>

 
All the rational function approximations have absolute accuracy of 
better than 10<sup>&#8722;15</sup>, but the resulting function values may not 
have the same relative accuracy at all points when different terms 
are combined. 

<div class="p"><!----></div>
 <br /><br /><a name="bk1"> </a>
 <b>166.&nbsp;BK1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bk1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the modified Bessel function of 
the second kind of order one, K<sub>1</sub>(x) for a real argument. 
This function is not defined for x &#8804; 0, and the routine simply 
returns a value of zero without any warning or error flag. 
User must ensure that x is positive. 
For x &lt; 8 it uses a rational function approximation of the form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
K<sub>1</sub>(x)=I<sub>1</sub>(x)(&#947;+log(x/2))+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>x<br /></td><td nowrap="nowrap" align="center">
&#8722;xR<sub>mk</sub>(x<sup>2</sup>), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.84)</td></tr></table>
</td></tr></table>

 
where &#947; is the Euler's constant and I<sub>1</sub>(x) is computed 
using appropriate rational function approximation. 
For larger arguments the asymptotic form is used: 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
K<sub>1</sub>(x)=</td><td nowrap="nowrap" align="center">
e<sup>&#8722;x</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8730;x<br /></td><td nowrap="nowrap" align="center">
R<sub>mk</sub>(1/x). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.85)</td></tr></table>
</td></tr></table>

 
All the rational function approximations have absolute accuracy of 
better than 10<sup>&#8722;15</sup>, but the resulting function values may not 
have the same relative accuracy at all points when different terms 
are combined. 

<div class="p"><!----></div>
 <br /><br /><a name="bkn"> </a>
 <b>167.&nbsp;BKN&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bkn.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bessel.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate the modified Bessel function of 
the second kind of positive integral order, K<sub>n</sub>(x) for a real argument. 
This routine calculates K<sub>j</sub>(x) for j between 0 and n. 
This function is not defined for x &#8804; 0, and the routine simply 
returns without any warning or error flag. 
In this case values in array BK will be preserved and may 
be misinterpreted as calculated value. 
User must ensure that x is positive. 
Since a recurrence relation is used to calculate these values, all 
the values are returned. Here N is the maximum order of Bessel functions 
required, K<sub>j</sub>(x) with j=0,1,&#8230;,<span class="roman">N</span> 
will be calculated. N must be positive, otherwise &#124;<span class="roman">N</span>&#124; will be used. 
X is the argument at which 
the function values are required. BK is a real array of length 
<span class="roman">N</span>+1 which will 
contain the computed values of the Bessel functions. 
<span class="roman">BK</span>(i+1)=K<sub>i</sub>(<span class="roman">XB</span>).  
Since the recurrence relation is stable in forward direction for all 
x, it is used in a straightforward 
manner using the values of K<sub>0</sub>(x) and K<sub>1</sub>(x). 
This routine needs <a href="appendixb.htm#bk0"> BK0</a> and <a href="appendixb.htm#bk1"> BK1</a> to calculate K<sub>0</sub>(x) and K<sub>1</sub>(x). 

<div class="p"><!----></div>
 <br /><br /><a name="dawson"> </a>
 <b>168.&nbsp;DAWSON&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/dawson.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/dawson.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the Dawson's integral 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
D(x)=e<sup>&#8722;x<sup>2</sup></sup></td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>x</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
e<sup>t<sup>2</sup></sup>&nbsp;&nbsp;dt&nbsp;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.86)</td></tr></table>
</td></tr></table>

 
using rational function approximation. The range is split into 4 parts. 
In [0,2.5), [2.5,4.0), [4.0,5.5) approximation of the form 
D(x)=xR<sub>mk</sub>(x<sup>2</sup>) is used while for higher values an approximation 
of the form D(x)=(1/x)R<sub>mk</sub>(1/x<sup>2</sup>) is used. All approximations 
have a relative accuracy of 10<sup>&#8722;15</sup>. 

<div class="p"><!----></div>
 <br /><br /><a name="fermm05"> </a>
 <b>169.&nbsp;FERMM05&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/fermm05.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fermi.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the Fermi integrals 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
F<sub>k</sub>(x)=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>&#8734;</small><!--sup
--><br /><br />
<small>0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
t<sup>k</sup>&nbsp;&nbsp;dt
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>e<sup>t&#8722;x</sup>+1<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.87)</td></tr></table>
</td></tr></table>

 
for k=&#8722;1/2 using rational function approximations. The range is split 
into 3 parts. For x &lt; 2 (including all negative values) an approximation 
of the form F<sub>k</sub>(x)=e<sup>x</sup>R<sub>mk</sub>(e<sup>x</sup>) is used. For 2 &#8804; x &lt; 10 an 
approximation of form F<sub>k</sub>(x)=R<sub>mk</sub>(x) is used, while for higher values 
of x an approximation of the form F<sub>k</sub>(x)=x<sup>k+1</sup>R<sub>mk</sub>(1/x<sup>2</sup>) is 
used. All the approximations have a relative accuracy of approximately 
10<sup>&#8722;15</sup>. 

<div class="p"><!----></div>
 <br /><br /><a name="ferm05"> </a>
 <b>170.&nbsp;FERM05&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/ferm05.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fermi.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the Fermi integrals 
for k=1/2 using approximations similar to those for k=&#8722;1/2. 

<div class="p"><!----></div>
 <br /><br /><a name="ferm15"> </a>
 <b>171.&nbsp;FERM15&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/ferm15.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fermi.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the Fermi integrals 
for k=3/2 using approximations similar to those for k=&#8722;1/2. 

<div class="p"><!----></div>
 <br /><br /><a name="ferm25"> </a>
 <b>172.&nbsp;FERM25&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/ferm25.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fermi.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the Fermi integrals 
for k=5/2 using approximations similar to those for k=&#8722;1/2. 

<div class="p"><!----></div>
 <br /><br /><a name="pleg"> </a>
 <b>173.&nbsp;PLEG&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/pleg.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/plm.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate Legendre polynomial for a 
specified value of x. L is the order of polynomial and X is the 
argument at which the polynomial value is required. P is a real 
array of length <span class="roman">L</span><span class="roman">+</span><span class="roman">1</span>, which will contain the computed values of 
the Legendre polynomials for all orders up to L, 
<span class="roman">P</span>(j+1)=P<sub>j</sub>(X). The recurrence relation is used to compute 
the values. 

<div class="p"><!----></div>
 <br /><br /><a name="plm"> </a>
 <b>174.&nbsp;PLM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/plm.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/plm.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate associated Legendre functions, 
P<sub>l</sub><sup>m</sup>(x) for a 
specified value of x. L, M define the order of Legendre functions, 
<span class="roman">L</span> &gt; 0 and &#124;<span class="roman">M</span>&#124; &#8804; <span class="roman">L</span>. 
No error message is issued if L, M do not satisfy these constraints. 
X is the 
argument at which the function value is required. P is a real 
array of length <span class="roman">L</span><span class="roman">+</span><span class="roman">1</span>, which will contain the computed values of 
the associated Legendre functions. 
<span class="roman">P</span>(j+1)=P<sub>j</sub><sup><span class="roman">M</span></sup>(X) for j &#8805; <span class="roman">M</span>. 
The routine first computes the value of P<sub><span class="roman">M</span></sub><sup><span class="roman">M</span></sup>. 
For positive m, 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P<sub>m</sub><sup>m</sup>=</td><td nowrap="nowrap" align="center">
<small>m</small><!--sup
--><br /><font size="+3">&#8719;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
(2i&#8722;1) (1&#8722;x<sup>2</sup>)<sup>m/2</sup>. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.88)</td></tr></table>
</td></tr></table>

 
For negative m there is extra normalisation factor. 
Using this value the recurrence relation 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
(n&#8722;m)P<sub>n</sub><sup>m</sup>(x)=(2n&#8722;1)xP<sub>n&#8722;1</sub><sup>m</sup>(x)&#8722;(n&#8722;1+m)P<sub>n&#8722;2</sub><sup>m</sup>(x), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.89)</td></tr></table>
</td></tr></table>

 
is used to compute the value of P<sub><span class="roman">L</span></sub><sup><span class="roman">M</span></sup>. 

<div class="p"><!----></div>
 <br /><br /><a name="ylm"> </a>
 <b>175.&nbsp;YLM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/ylm.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/ylm.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the Spherical harmonic, 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
Y<sub>l</sub><sup>m</sup>(&#952;,&#981;)=(&#8722;1)<sup>m</sup>c<sub>lm</sub>P<sub>l</sub><sup>m</sup>(cos&#952;)e<sup>im&#981;</sup>, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.90)</td></tr></table>
</td></tr></table>

 
where 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
c<sub>lm</sub><sup>2</sup>=</td><td nowrap="nowrap" align="center">
(2l+1)(l&#8722;m)!
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4&#960;(l+m)!<br /></td><td nowrap="nowrap" align="center">
&nbsp;&nbsp;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.91)</td></tr></table>
</td></tr></table>

 
is chosen to ensure that integral of &#124;Y<sub>l</sub><sup>m</sup>&#124;<sup>2</sup> over the unit 
sphere is 1. L is the degree, M is the azimuthal order. <span class="roman">L</span> &gt; 0, 
&#124;<span class="roman">M</span>&#124; &#8804; <span class="roman">L</span> and <span class="roman">L</span> &lt; <span class="roman">LMAX</span>=5001. The last 
requirement arises from the dimensions of the array P in the 
function routine. The value of LMAX can be increased if needed. 
THETA 
and PHI are real variables specifying the angular coordinates 
&#952; and &#981;  respectively. 
YLM is the complex value of spherical harmonic, and must be declared 
to be complex in the calling program. 
It is possible to use the argument x=cos&#952; instead of &#952; 
by commenting out the line computing X<!--hbox-->. 
This routine requires <a href="appendixb.htm#plm"> PLM</a> to compute the associated Legendre functions. 
YLM<tt>_</tt>X is the version of YLM with x=cos&#952; as the argument. 

<div class="p"><!----></div>
 <br /><br /><a name="minmax"> </a>
 <b>176.&nbsp;MINMAX&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/minmax.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/minmax.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate minimax rational function approximation 
of discrete data using a differential correction algorithm. 
M and K are the degrees of polynomials 
in the numerator and the denominator, respectively. N is the number of data 
points which should be at least <span class="roman">M</span>+<span class="roman">K</span>+2. 
A is a real array of length  <span class="roman">M</span>+<span class="roman">K</span>+2, which 
will contain the coefficients in the same form as that given by the 
subroutine <a href="appendixb.htm#pade"> PADE</a><!--hbox-->. <span class="roman">A</span>(i), (i=1,2,&#8230;,<span class="roman">K</span>) is the coefficient 
of x<sup>i</sup> in the denominator, the constant term being unity, 
while <span class="roman">A</span><span class="roman">(</span><span class="roman">K</span>+i+1), (i=0,1,&#8230;,<span class="roman">M</span>) 
is the coefficient of x<sup>i</sup> in the numerator. At the time of calling the 
subroutine, this array should contain the initial approximation for the 
coefficients. If <span class="roman">K</span>=0, then the algorithm will converge from 
arbitrary initial approximation and hence all elements of A may be 
set to zero or any other suitable value. For <span class="roman">K</span> &#8800; 0 the 
iteration is unlikely to converge, unless the starting values 
are close to the actual values of the coefficients. 
X and F are real arrays of length N, containing the input data, 
with F(I) giving the value of the function at X(I). These 
values must be supplied. EMAX is the maximum error 
in the final approximation calculated by the subroutine. EPS is the 
required tolerance, the iteration is continued until the change in EMAX 
is less than EPS<!--hbox-->. IER is the error 
parameter. IER=615 implies that either <span class="roman">M</span> &lt; 0, or 
<span class="roman">K</span> &lt; 0, or <span class="roman">M</span>+<span class="roman">K</span>+2 &gt; <span class="roman">N</span>, in which case, no calculations are 
performed. IER=634 implies that the iteration failed to converge 
to the specified accuracy. Other values of IER may be set by the subroutine 
SIMPX<!--hbox-->. WK is a real array of length 
(3<span class="roman">N</span>+1)(<span class="roman">M</span>+<span class="roman">K</span>+5), which is used as a scratch space to 
store intermediate results. IWK is an integer array of length  
3<span class="roman">N</span>+<span class="roman">M</span>+<span class="roman">K</span>+3, used as a scratch space. This subroutine 
requires the subroutine <a href="appendixb.htm#simpx"> SIMPX</a> to solve the LP problem. 

<div class="p"><!----></div>
 <br /><br /><a name="polyl1"> </a>
 <b>177.&nbsp;POLYL1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/polyl1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polyl1.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate polynomial L<sub>1</sub>-approximation 
of discrete data. M is the degree of polynomial. N is the number of data 
points, which should be at least <span class="roman">M</span>+2. 
A is a real array of length  <span class="roman">M</span>+2, which 
will contain the coefficients. <span class="roman">A</span>(i+1), 
(i=0,1,2,&#8230;,<span class="roman">M</span>) is the coefficient of x<sup>i</sup>. 
X and F are real arrays of length N, containing the input data, 
with F(I) containing the value of the function at X(I). These 
values must be supplied by the user. ESUM is the sum of the magnitude of the error 
at all points (i.e., the L<sub>1</sub> norm of the residual) 
in the final approximation calculated by the subroutine. EPS is the 
expected level of roundoff error, this parameter is passed on to the 
subroutine <a href="appendixb.htm#simpl1"> SIMPL1</a> for simplex iteration. It is used to decide the sign 
of cost coefficients and pivot elements. IER is the error 
parameter. IER=616 implies that either <span class="roman">M</span> &lt; 0, or 
<span class="roman">M</span>+2 &gt; <span class="roman">N</span>, in which case no calculations are 
performed. Other values of IER may be set by the subroutine SIMPL1. 
WK is a real array of length  
(<span class="roman">N</span>+2)(<span class="roman">M</span>+3), which is used as a scratch space to 
store intermediate results. IWK is an integer array of length  
<span class="roman">N</span>+<span class="roman">M</span>+3 used as a scratch space. This subroutine 
requires the subroutine <a href="appendixb.htm#simpl1"> SIMPL1</a> to solve the LP problem using a 
slightly modified simplex algorithm. 

<div class="p"><!----></div>
 <br /><br /><a name="linl1"> </a>
 <b>178.&nbsp;LINL1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/linl1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polyl1.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to calculate a general linear L<sub>1</sub>-approximation 
in terms of arbitrary basis functions for 
discrete data. Approximation of the form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
f(x) &#8776; </td><td nowrap="nowrap" align="center">
<small><span class="roman">M</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
a<sub>i</sub>&#981;<sub>i</sub>(x), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.92)</td></tr></table>
</td></tr></table>

 
are sought, where &#981;<sub>i</sub>(x) are the basis functions. There is 
no restriction on the basis functions, apart from the fact that they 
should be independent on the set of points in the table. 
This program can be used for approximation in multiple dimensions 
as points need not be restricted to one dimension. 
M is the number of basis functions. N is the number of data 
points, which should be at least <span class="roman">M</span>+1. 
A is a real array of length  <span class="roman">M</span>+1, which 
will contain the coefficients of approximation. <span class="roman">A</span>(i), 
(i=1,2,&#8230;,<span class="roman">M</span>) is the coefficient of &#981;<sub>i</sub>. 
F is a real array of length N, containing the input data, 
F(I) should contain the value of the function at Ith point. These 
values must be supplied by the user. 
G is a real array of length <span class="roman">IG</span>&times;<span class="roman">N</span> containing the 
values of basis functions at each point in the table, <span class="roman">G</span>(i,j) = &#981;<sub>i</sub>(x<sub>j</sub>). These values must be supplied by the user. It may 
be noted that in this case the coordinates x<sub>j</sub> are not required by 
the routine and it could even be a vector for approximation in multiple 
dimension. It is users responsibility to calculate the values 
&#981;<sub>i</sub>(x<sub>j</sub>) accordingly. IG is the first dimension of G as specified 
in the calling program (<span class="roman">IG</span> &#8805; <span class="roman">M</span>). 
ESUM is the sum of the magnitude of the error 
at all points (i.e., the L<sub>1</sub> norm of the residual) 
in the final approximation calculated by the subroutine. EPS is the 
expected level of roundoff error, this parameter is passed on to the 
subroutine <a href="appendixb.htm#simpl1"> SIMPL1</a> for simplex iteration. It is used to decide the sign 
of cost coefficients and pivot elements. IER is the error 
parameter. IER=616 implies that either <span class="roman">M</span> &#8804; 0, or 
<span class="roman">M</span>+1 &gt; <span class="roman">N</span>, in which case no calculations are 
performed. Other values of IER may be set by the subroutine SIMPL1. 
WK is a real array of length  
(<span class="roman">N</span>+2)(<span class="roman">M</span>+3), which is used as a scratch space to 
store intermediate results. IWK is an integer array of length  
<span class="roman">N</span>+<span class="roman">M</span>+3 used as a scratch space. This subroutine 
requires the subroutine SIMPL1 to solve the LP problem using a 
slightly modified simplex algorithm. 

<div class="p"><!----></div>
 <br /><br /><a name="simpl1"> </a>
 <b>179.&nbsp;SIMPL1&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/simpl1.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/polyl1.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve LP problems using a modified 
version of the simplex algorithm, specially suitable for LP problems 
arising in L<sub>1</sub>-approximations. This subroutine is called by subroutine 
<a href="appendixb.htm#polyl1"> POLYL1</a> or <a href="appendixb.htm#linl1"> LINL1</a> and is similar to subroutine <a href="appendixb.htm#simpx"> SIMPX</a><!--hbox-->. 
The LP problem is assumed to be in the standard form and 
the initial tableau is supplied in the real array A of 
length  <span class="roman">IA</span>&times;(<span class="roman">N</span>&#8722;<span class="roman">M</span><span class="roman">+</span><span class="roman">1</span>) with <span class="roman">IA</span> &#8805; <span class="roman">M</span>+2. 
IA is the first dimension of A, exactly as specified in the calling  
program. N is the total number of variables in the given problem. 
M is the number of constraints in the problem. 
ID and IV are integer arrays of length  <span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> and  
<span class="roman">N</span>&#8722;<span class="roman">M</span><span class="roman">+</span><span class="roman">1</span> respectively, used to store permutations of the original 
variables. IER is the error parameter. 
IER=63 implies that the objective function is unbounded from below and 
the optimal feasible vector does not exist. 
IER=635 implies that the 
simplex iteration has not converged in a reasonable number of iterations. 
This failure may be due to degeneracy, since that is not accounted for 
in this subroutine. 
AEPS is a real parameter used 
to control roundoff error. Any quantity less than AEPS in magnitude is assumed 
to be zero. 
It should be noted that, this subroutine does not explicitly take care 
of degeneracy. Since the problems arising out of L<sub>1</sub>-approximation 
have very high degree of degeneracy, this subroutine may fail to converge 
in some cases, because of cycling as explained in Section&nbsp;8.7. 
<div class="p"><!----></div>
 

<br /><br />
<a name="Algebraic Eigenvalue Problem"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.11&nbsp; ALGEBRAIC EIGENVALUE PROBLEM </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#invit">INVIT</a></td>
<td>&nbsp; <a href="#tred2">TRED2</a></td>
<td>&nbsp; <a href="#trbak">TRBAK</a></td>
<td>&nbsp; <a href="#tql2">TQL2</a></td>
<td>&nbsp; <a href="#tridia">TRIDIA</a></td>
<td>&nbsp; <a href="#sturm">STURM</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#tinvit">TINVIT</a></td>
<td>&nbsp; <a href="#herevp">HEREVP</a></td>
<td>&nbsp; <a href="#balanc">BALANC</a></td>
<td>&nbsp; <a href="#balbak">BALBAK</a></td>
<td>&nbsp; <a href="#elmhes">ELMHES</a></td>
<td>&nbsp; <a href="#hqr">HQR</a></td>
</tr>
</table>


<div class="p"><!----></div>
<br /><br /><a name="invit"> </a>
 <b>180.&nbsp;INVIT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/invit.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/invit.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to find a real eigenvalue and the corresponding 
eigenvector of a general real matrix using inverse iteration. M is the 
order of the matrix. A is 
a real array of length <span class="roman">IA</span>&times;<span class="roman">M</span> containing the input matrix. 
IA is the first dimension of A as specified in the calling program. 
P is a real variable specifying the initial shift to be used. 
This shift should be close to the 
required eigenvalue. U is a real array of length  M, which should 
contain an initial approximation to the eigenvector. This approximation 
need not be close to the required eigenvector, but must be nonzero. 
The initial vector U need not be normalised. 
In most cases setting all components of U to 1 will be enough, but if 
the initial vector so chosen is orthogonal to the required eigenvector 
there may be some problem in convergence. In that case an arbitrary 
choice which is not orthogonal to eigenvector will be required. For 
multiple eigenvalues if more than one eigenvectors are required, then initial 
vector should be chosen to be orthogonal to all known eigenvectors with 
same eigenvalue to ensure that an independent eigenvector is found. 
After execution, the array U will contain the required eigenvector, which 
is normalised such that the maximum component is unity. 
IFLG is a flag to decide the kind of iteration required. If IFLG=0, 
then the shift P is kept fixed. If IFLG=1, then the shift 
is varied after each iteration, using the computed Rayleigh quotient. 
If IFLG=2, then the shift is varied using max(<b>v</b><sub><b>s</b><b>+</b><b>1</b></sub>) 
at each iteration. IFLG=0 should be used when the eigenvalue 
is already known accurately, or when iteration is strictly required to 
converge to the eigenvalue nearest to P<!--hbox-->. In other cases, we may 
use IFLG=1, if the matrix is Hermitian and IFLG=2 otherwise. 
In practice, it is found that, even for some non-Hermitian matrices, 
IFLG=1 often gives faster convergence, but that cannot be assumed. 
After execution, EI and ERC give the estimated eigenvalue (corrected for 
the shift P). ERC is the estimate using Rayleigh quotient, 
while EI is the estimate 
given by simple inverse iteration. ERC is relevant only for Hermitian 
matrices, while EI is applicable to all matrices. 
REPS is the required (absolute) 
tolerance. The iteration is continued until the maximum change 
in the eigenvalue and the M components of the eigenvector 
is less than REPS<!--hbox-->. WK is a real array of length  <span class="roman">M</span><sup>2</sup>+<span class="roman">M</span> 
used as a scratch space. IWK is an integer array of length  M 
used as a scratch space. NIT is an integer variable specifying the maximum 
number of iterations required to be performed. If NIT &#8804; 0, then 
a default value of NIT0 (=100) will be used. 
IER is the error parameter. IER=106 implies that <span class="roman">M</span> &#8804; 1 
or <span class="roman">M</span> &gt; <span class="roman">IA</span>, in which case, no calculations are performed. 
IER=141 
implies that the vector is zero at some stage, which is usually due to 
either the matrix A or the initial vector U being zero. If the matrix 
is nonzero, then using a different initial vector or changing the shift P 
may overcome this problem. IER=142 implies that the inverse 
iteration has failed to converge, which could be either because the  
starting shift P is not sufficiently close to an eigenvalue, or  
because REPS is too small, or because the corresponding eigenvalue 
has a nonlinear divisor. Apart from these, other values of IER may be 
set by subroutine <a href="appendixb.htm#gauelm"> GAUELM</a>, which is called to solve the system of linear 
equations. In particular, IER=121 implies that one of pivots 
during the Gaussian elimination is zero. This problem can usually be overcome 
by perturbing the shift slightly. If this problem occurs 
persistently, it may be better to modify the Gaussian elimination routine, 
such that zero pivots are replaced by a suitably chosen small number. 
To find complex 
eigenvalues of a real matrix, all normal Fortran real variables 
except those starting with A and R should be treated as complex, 
which can be achieved by using an IMPLICIT COMPLEX(B-H, P, S-Z) 
statement. Apart from 
this, the definition of Rayleigh quotient will need to be modified 
as indicated in the program. This modification is required only 
if IFLG=1, since in other cases, the value of Rayleigh quotient 
is not used. This is implemented in INVIT<tt>_</tt>C<!--hbox-->. 
To find 
eigenvalues of a complex matrix, the array A should also be declared as complex. 
This case is implemented in INVIT<tt>_</tt>CC<!--hbox-->. 
In both these cases, a complex version of GAUELM (GAUELM<tt>_</tt>C) will be required. 
To find an eigenvector of a generalised eigenvalue problem 
A(&#955;)<b>x</b>=<b>0</b>, use <span class="roman">P</span>=0, <span class="roman">IFLG</span>=0, 
and the matrix A should be set to A(&#955;) with &#955; equal 
to the known eigenvalue. In this case the eigenvalue has to be determined 
before finding the eigenvector. To find the left eigenvector of the 
matrix take transpose of the matrix while applying the shift. This 
is implemented in INVIT<tt>_</tt>L, for real eigenvalues and 
INVIT<tt>_</tt>CL for complex eigenvalues. 

<div class="p"><!----></div>
 <br /><br /><a name="tred2"> </a>
 <b>181.&nbsp;TRED2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/tred2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/realsy.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to reduce a real symmetric matrix to tridiagonal 
form using Householder's method. This subroutine is based on the 
procedure <i>tred2</i>  in the <i>Handbook</i>. 
A is a real array of length <span class="roman">IA</span>&times;<span class="roman">N</span> containing the matrix. 
After execution, the array A will be overwritten by the transformation 
matrix Q, such that Q<sup>T</sup><span class="roman">A</span>Q is tridiagonal. This matrix may be required 
for back-transforming the eigenvectors of tridiagonal matrix to that of 
the original input matrix A<!--hbox-->. 
N is the order of the matrix. IA is the first dimension of the array A, as 
specified in the calling program, <span class="roman">IA</span> &#8805; <span class="roman">N</span>. 
D and E are real arrays of length  
N, giving the diagonal and off-diagonal elements of the reduced tridiagonal 
matrix with <span class="roman">D</span>(i)=a<sub>ii</sub> and <span class="roman">E</span>(i+1)=a<sub>i,i+1</sub>=a<sub>i+1,i</sub>. 
REPS is the tolerance which should be equal to &#951;/&#295;, where 
&#951; is the smallest positive number that is representable in the computer 
and &#295; is the machine accuracy. 
For single precision (REAL*4) arithmetic use REPS=10<sup>&#8722;30</sup>. 
For double precision (REAL*8) arithmetic use REPS=10<sup>&#8722;300</sup>. 
IER is the error parameter. IER=107 implies that <span class="roman">N</span> &#8804; 1 or 
<span class="roman">N</span> &gt; <span class="roman">IA</span>, in which case, no calculations are performed.  

<div class="p"><!----></div>
 <br /><br /><a name="trbak"> </a>
 <b>182.&nbsp;TRBAK&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/trbak.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/realsy.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform back-transformation on eigenvectors 
of reduced tridiagonal matrix to obtain the eigenvectors of the original 
real symmetric matrix reduced by <a href="appendixb.htm#tred2"> TRED2</a>. This back-transformation is 
not required if the eigenvectors are calculated using the subroutine 
<a href="appendixb.htm#tql2"> TQL2</a>, but will be required 
if the eigenvectors are calculated by the subroutine <a href="appendixb.htm#tridia"> TRIDIA</a><!--hbox-->. A is a real 
array of length <span class="roman">IA</span>&times;<span class="roman">N</span> 
containing the transformation matrix Q generated by the subroutine 
TRED2. The last column of A is used as a scratch space by the subroutine 
and hence its contents will be destroyed during execution. 
IA is the first dimension of A, as specified in the calling routine. 
N is the order of the matrix. Z is a real array of length <span class="roman">IZ</span>&times;<span class="roman">NZ</span> containing the eigenvectors 
of the reduced tridiagonal matrix. After execution, this array will be 
overwritten by the eigenvectors of the original matrix A<!--hbox-->. IZ is the first 
dimension of array Z, as specified in the calling program. NZ is the number 
of eigenvectors. Thus, <span class="roman">Z</span>(i,j) should contain the ith component 
of the jth eigenvector. This subroutine simply performs the matrix 
multiplication AZ to obtain the required eigenvectors. 

<div class="p"><!----></div>
 <br /><br /><a name="tql2"> </a>
 <b>183.&nbsp;TQL2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/tql2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/realsy.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to find eigenvalues and eigenvectors of 
ZTZ<sup>T</sup> using the QL&nbsp;algorithm, where T is a symmetric tridiagonal matrix  
and Z is an orthogonal matrix. 
This subroutine is based on the procedure <i>tql2</i>  in the <i>Handbook</i>. 
If the matrix Z is the transformation matrix, which reduces a real symmetric 
matrix to tridiagonal form, then this routine gives the eigenvectors of 
the original matrix. This subroutine can be used to find eigenvalues 
and eigenvectors of a real symmetric matrix, after it is reduced to a 
tridiagonal form using <a href="appendixb.htm#tred2"> TRED2</a>. In that case, Z will be the transformation 
matrix generated by TRED2. To find eigenvalues and eigenvectors of a 
symmetric tridiagonal matrix, set the matrix Z to an identity 
matrix. Z is a real array of length <span class="roman">IZ</span>&times;<span class="roman">N</span>, 
containing the transformation matrix. 
After execution, this array will be overwritten by the eigenvectors of 
the original matrix ZTZ<sup>T</sup>, with ith column containing the ith 
eigenvector. N is the order of the matrix. IZ is the first dimension of Z, 
as specified in the calling program. D is a real array of length  
N, containing the diagonal elements of the tridiagonal matrix with 
<span class="roman">D</span>(i)=t<sub>ii</sub>. After execution, the array D will be overwritten 
by the eigenvalues of the matrix. The eigenvalues are sorted in the 
ascending order. E is a real array of length N 
containing the off-diagonal elements of the tridiagonal matrix, with 
<span class="roman">E</span>(i+1)=t<sub>i,i+1</sub>=t<sub>i+1,i</sub>. E is used as a scratch space by the 
subroutine and hence its contents will be destroyed during the execution. 
REPS is the tolerance which should be equal to &#295;, the machine 
accuracy. IER is the error parameter. IER=108 implies that 
<span class="roman">N</span> &#8804; 1 or <span class="roman">N</span> &gt; <span class="roman">IZ</span>, in which case, no calculations are 
performed. IER=143 implies that 
the QL algorithm failed to converge for some eigenvalue, in which 
case, the calculations are abandoned. 

<div class="p"><!----></div>
 <br /><br /><a name="tridia"> </a>
 <b>184.&nbsp;TRIDIA&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/tridia.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/realsy.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to find some eigenvalues and eigenvectors 
of a symmetric tridiagonal matrix using the Sturm sequence property, 
coupled with the inverse iteration method. N is the order of the matrix. 
E and D are real arrays of length  N containing respectively, the 
off-diagonal and diagonal elements of the symmetric tridiagonal matrix, 
with <span class="roman">E</span>(i+1)=a<sub>i,i+1</sub>=a<sub>i+1,i</sub> and <span class="roman">D</span>(i)=a<sub>ii</sub>. 
It is assumed that all the off-diagonal elements are nonzero. Otherwise, 
the matrix should be split into two or more parts and each part should 
be considered independently. 
M1 and M2 are integers specifying which eigenvalues are to be calculated. 
If eigenvalues &#955;<sub>i</sub> are sorted in increasing order, then all eigenvalues 
from &#955;<sub><span class="roman">M</span><span class="roman">1</span></sub> to &#955;<sub><span class="roman">M</span><span class="roman">2</span></sub> will be determined. If 
<span class="roman">M</span><span class="roman">1</span> &gt; <span class="roman">M</span><span class="roman">2</span>, then no calculations are performed. EI is 
a real array of length  <span class="roman">M</span><span class="roman">2</span>&#8722;<span class="roman">M</span><span class="roman">1</span>+1, which will contain the 
eigenvalues after execution. EPS1 is a real parameter, which specifies 
the accuracy to which the eigenvalues should be located by bisection. 
This parameter is required in some cases, since the inverse iteration with variable 
shift, which is used to determine eigenvalues accurately may not always 
converge to the nearest eigenvalue. If that happens, then the parameter 
EPS1 can be decreased. A moderate value of the order of 0.1 or 0.01 times the 
typical eigenvalues should be normally sufficient. Increasing EPS1  
will improve the efficiency, provided the inverse iteration converges. 
REPS is the required tolerance in the eigenvalues and eigenvectors. 
EV is a real array of length <span class="roman">IV</span>&times;(<span class="roman">M</span><span class="roman">2</span>&#8722;<span class="roman">M</span><span class="roman">1</span><span class="roman">+</span><span class="roman">1</span>) 
which will contain the calculated eigenvectors. 
EV(i,j) will contain the ith component of the jth eigenvector. 
IV is the first dimension of the array EV as specified in the calling 
program, <span class="roman">IV</span> &#8805; <span class="roman">N</span>. 
WK is a real array of length  7N used as a scratch space. 
IER is the error parameter. IER=109 implies that <span class="roman">N</span> &#8804; 1 
or <span class="roman">N</span> &gt; <span class="roman">IV</span> or <span class="roman">M</span><span class="roman">1</span> &lt; 1 or <span class="roman">M</span><span class="roman">2</span> &gt; <span class="roman">N</span>, 
in which case, no calculations are performed. 
Other values of IER may be set by 
subroutine TINVIT, which is called to calculate the eigenvalues and 
eigenvectors. Only the last nonzero value of IER will be retained. 
This subroutine requires the subroutine <a href="appendixb.htm#sturm"> STURM</a> to locate the eigenvalues 
and subroutine <a href="appendixb.htm#tinvit"> TINVIT</a> to find the eigenvalues and eigenvectors of a 
symmetric tridiagonal matrix and function <a href="appendixb.htm#ran1"> RAN1</a> to calculate random numbers. 

<div class="p"><!----></div>
 <br /><br /><a name="sturm"> </a>
 <b>185.&nbsp;STURM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/sturm.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/realsy.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to locate required eigenvalues of a real symmetric 
tridiagonal matrix using the method of bisection on the Sturm sequence. 
It is assumed that all the off-diagonal elements are nonzero. Otherwise, 
the matrix should be split into two or more parts and each part should 
be considered independently. 
N is the order of the matrix. 
E and D are real arrays of length  N containing respectively, the 
off-diagonal and diagonal elements of the symmetric tridiagonal matrix, 
with <span class="roman">E</span>(i+1)=a<sub>i,i+1</sub>=a<sub>i+1,i</sub> and <span class="roman">D</span>(i)=a<sub>ii</sub>. 
M1 and M2 are integers specifying which eigenvalues are to be located. 
If eigenvalues &#955;<sub>i</sub> are sorted in increasing order, then all eigenvalues 
from &#955;<sub><span class="roman">M</span><span class="roman">1</span></sub> to &#955;<sub><span class="roman">M</span><span class="roman">2</span></sub> will be located. If 
<span class="roman">M</span><span class="roman">1</span> &gt; <span class="roman">M</span><span class="roman">2</span>, then no calculations are performed. EL and EU 
are real arrays of length  M2. After execution, the ith 
eigenvalue should be located in the interval (<span class="roman">EL</span>(i),<span class="roman">EU</span>(i)). 
NUM is an integer variable which will contain the number of times 
the Sturm sequence was evaluated for locating the eigenvalues to the 
specified accuracy. REPS is the specified accuracy to which the eigenvalues 
are to be located. Bisection is continued until  
&#124;<span class="roman">EU</span>(i)&#8722;<span class="roman">EL</span>(i)&#124; &lt; REPS and the eigenvalue has been isolated. 
At least three bisections are performed after the eigenvalues are isolated, 
that is <span class="roman">EU</span>(i&#8722;1) &lt; <span class="roman">EL</span>(i). If at any stage the interval is too 
small to be bisected further, then the iteration is naturally terminated. 
This situation can arise when the matrix has very close 
eigenvalues. WK is a real array of length  N used as a scratch 
space. IER is the error parameter. IER=110 implies that 
<span class="roman">M</span><span class="roman">1</span>  &lt; 1 or <span class="roman">M</span><span class="roman">2</span> &gt; <span class="roman">N</span>, in which case no calculations are 
done. 

<div class="p"><!----></div>
 <br /><br /><a name="tinvit"> </a>
 <b>186.&nbsp;TINVIT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/tinvit.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/realsy.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to find a specified eigenvalue and eigenvector of a 
symmetric tridiagonal matrix using inverse iteration. N is the order of the matrix.  
E and D are real arrays of length  N containing respectively, the 
off-diagonal and diagonal elements of the symmetric tridiagonal matrix, 
with <span class="roman">E</span>(i+1)=a<sub>i,i+1</sub>=a<sub>i+1,i</sub> and <span class="roman">D</span>(i)=a<sub>ii</sub>. EL 
and EU are real variables giving the lower and upper limit on the 
eigenvalue. The iteration will not go beyond these limits. 
EI is a real variable, which will return the calculated eigenvalue. 
EV is a real array of length  N, which will contain the 
calculated eigenvector. For IFLG &#8800; 0 it should contain the 
previous eigenvector determined by the program as input, 
so that the routine can choose initial vector orthogonal to it. 
REPS is the required accuracy. The iteration 
is continued until either of the following three conditions are 
satisfied, (1) the relative change in the eigenvalue as estimated using 
the Rayleigh quotient is less than REPS, (2) 
max(<b>v</b><sub><b>j</b><b>+</b><b>1</b></sub>)&#955; &gt; 1/REPS (where &#955; is an 
estimate for the eigenvalue), (3) &#124;&#124;<b>u</b><sub><b>j</b><b>+</b><b>1</b></sub>&#8722;<b>u</b><sub><b>j</b></sub>&#124;&#124;<sub>1</sub> &lt; REPS. 
IFLG is an integer variable used as a flag. 
If IFLG=0, then the initial vector is chosen randomly. Otherwise, 
the initial vector is chosen to be orthogonal to the vector EV<!--hbox-->. This device 
can be used to ensure that an independent vector is found when two 
or more eigenvalues are very close or equal. Since only one previous 
eigenvector is used, this device may not be very effective for eigenvalues 
of multiplicity greater than two. IER is the error parameter. 
IER=144 implies that the inverse iteration failed to converge 
to the specified accuracy. 
U and B are real arrays of length  N and 4N respectively, which 
are used as a scratch space to store intermediate quantities. NUM is an 
integer variable, which will contain the number of iterations required 
by the subroutine. This subroutine requires FUNCTION <a href="appendixb.htm#ran1"> RAN1</a>(SEED) to 
generate random numbers. If a different routine is used for this 
purpose, the seed should be changed appropriately. 

<div class="p"><!----></div>
 <br /><br /><a name="herevp"> </a>
 <b>187.&nbsp;HEREVP&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/herevp.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/herevp.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to find all eigenvalues and eigenvectors of 
a complex Hermitian matrix. 
This subroutine converts the eigenvalue problem for a Hermitian matrix 
into that for a real symmetric matrix of order 2N and solves this 
expanded problem. The expanded eigenvalue problem is solved by 
reducing the matrix to tridiagonal form using <a href="appendixb.htm#tred2"> TRED2</a> and then solving 
the eigenvalue problem for tridiagonal matrix using <a href="appendixb.htm#tql2"> TQL2</a>. 
ZA is a complex array of length <span class="roman">IA</span>&times;<span class="roman">N</span>, 
containing the matrix. The subroutine preserves the contents of this 
array. 
N is the order of the matrix. IA is the first dimension of ZA, 
as specified in the calling program. EI is a real array of length  
N, which will contain the eigenvalues of the matrix ZA<!--hbox-->. 
The eigenvalues are sorted in the ascending order. 
ZV is a complex array of length <span class="roman">IZ</span>&times;<span class="roman">N</span>, which will 
contain the eigenvectors of the complex matrix. ZV(I, J) will contain 
the Ith component of Jth eigenvector. 
IZ is the first dimension of array ZV as declared in the calling 
program. WK is a real array of length 2<span class="roman">N</span>&times;(2<span class="roman">N</span>+2) 
used as scratch space. 
REPS is the tolerance which should be of the order of &#295;, the machine 
accuracy. IER is the error parameter. IER=111 implies that 
<span class="roman">N</span> &#8804; 1 or <span class="roman">N</span> &gt; <span class="roman">IA</span> or <span class="roman">N</span> &gt; <span class="roman">IZ</span>, 
in which case, no calculations are 
performed. Other values may be set by TRED2 or TQL2. 
The subroutine requires <a href="appendixb.htm#tred2"> TRED2</a> and <a href="appendixb.htm#tql2"> TQL2</a> to solve the eigenvalue problem 
for equivalent real symmetric matrix. Since every eigenvalue of the 
equivalent real matrix is repeated, there may be problem in isolating 
the eigenvectors when the eigenvalue of complex matrix is multiple. 
If there is some problem all eigenvectors of the 2<span class="roman">N</span>&times;2<span class="roman">N</span> 
real matrix should be preserved so that the right combinations can be 
identified. This subroutine picks alternate eigenvectors. 

<div class="p"><!----></div>
 <br /><br /><a name="balanc"> </a>
 <b>188.&nbsp;BALANC&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/balanc.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/unsym.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine for reducing the norm of a matrix by exact 
diagonal similarity transformations. This subroutine is based on 
the procedure <i>balance</i>  in the <i>Handbook</i>. 
A is a real array of length <span class="roman">IA</span>&times;<span class="roman">N</span> containing the 
matrix. After execution, the balanced matrix will be overwritten on the 
same array. N is the order of the matrix and IA is the first dimension of 
array A, as declared in the calling program. B is the base of floating-point 
representation in the machine. For most machines <span class="roman">B</span>=2.  
LOW and IGH are integer variables, such 
that in the balanced matrix a<sub>ij</sub>=0 if i &gt; j and (j &lt; <span class="roman">LOW</span> or 
i &gt; <span class="roman">IGH</span>). This essentially means that after balancing 
we have to only consider 
the sub-matrix in rows and columns from LOW to IGH, since other 
eigenvalues are already isolated by subroutine BALANC<!--hbox-->. D is a real 
array of length  N containing the information about transformation. 
The elements D(LOW) to D(IGH) will contain the elements of diagonal matrix 
used for balancing, while other elements will contain the permutations 
used to isolate eigenvalues. IER is the error parameter. IER=112 
implies that <span class="roman">N</span> &#8804; 1 or <span class="roman">N</span> &gt; <span class="roman">IA</span>, in which case, no 
calculations are performed. 

<div class="p"><!----></div>
 <br /><br /><a name="balbak"> </a>
 <b>189.&nbsp;BALBAK&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/balbak.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/unsym.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform back-transformation of a set of 
right eigenvectors from those of the balanced matrix to that for the 
original matrix. This subroutine is based on the procedure <i>balbak</i>  
in the <i>Handbook</i>. N is the order of the matrix. LOW and IGH are integer 
variables obtained by the subroutine <a href="appendixb.htm#balanc"> BALANC</a><!--hbox-->. CZ is a complex array of 
length <span class="roman">IZ</span>&times;<span class="roman">M</span> containing 
the eigenvectors of the balanced matrix. After execution, the eigenvectors 
of the original matrix will be overwritten on the same array. M is the  
number of eigenvectors, and IZ is the first dimension of array CZ as 
declared in the calling program. D is a real array of length  N, 
containing the information about transformation as generated by the subroutine 
BALANC<!--hbox-->. This subroutine can be modified as explained in the 
Fortran file, to back-transform left eigenvectors and the corresponding 
version is implemented in BALBAK<tt>_</tt>L. 

<div class="p"><!----></div>
 <br /><br /><a name="elmhes"> </a>
 <b>190.&nbsp;ELMHES&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/elmhes.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/unsym.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine for reducing a general real matrix to an 
upper Hessenberg form using real stabilised elementary similarity 
transformation. This subroutine is based on the procedure <i>elmhes</i>  
in the <i>Handbook</i>. A is a real array of length <span class="roman">IA</span>&times;<span class="roman">N</span> 
containing the matrix. After execution, 
the reduced matrix will be overwritten on the same array. Information 
about the transformation (i.e., the elements m<sub>i,r+1</sub>) 
will also be written on the (i,r) element of the same array. N is 
the order of the matrix and IA is the first dimension of array A as 
declared in the calling program. LOW and IGH are integer variables as 
given by the subroutine <a href="appendixb.htm#balanc"> BALANC</a> while balancing the matrix. This subroutine 
only processes the sub-matrix in rows LOW to IGH<!--hbox-->. If the matrix 
is not balanced, then set <span class="roman">LOW</span>=1 and <span class="roman">IGH</span>=<span class="roman">N</span> before 
calling this subroutine. INC 
is an integer array of length  N, containing the information 
about the row and column interchanges used during the reduction. 
IER is the error parameter. IER=113 
implies that <span class="roman">N</span> &#8804; 1 or <span class="roman">N</span> &gt; <span class="roman">IA</span>, in which case, no 
calculations are performed. 

<div class="p"><!----></div>
 <br /><br /><a name="hqr"> </a>
 <b>191.&nbsp;HQR&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/hqr.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/unsym.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to find eigenvalues of an upper Hessenberg 
matrix using QR&nbsp;algorithm. This subroutine is based on the procedure 
<i>hqr</i>  in the <i>Handbook</i>. It 
does not keep track of the transformations and hence cannot be used 
to find eigenvectors. H is a real array of length <span class="roman">IH</span>&times;<span class="roman">NN</span> 
containing the matrix. 
During execution, the contents of H will be destroyed. NN is the 
order of the matrix and IH is the first dimension of H as specified in 
the calling program. ER and EI are real arrays of length  NN, 
which will contain the real and imaginary parts of the eigenvalues. 
REPS is the tolerance which should be of the order of &#295;, the machine 
accuracy. IER is the error parameter. IER=114 
implies that <span class="roman">N</span> &#8804; 1 or <span class="roman">N</span> &gt; <span class="roman">IH</span>, in which case, no 
calculations are performed. IER=145 implies that 
the QR&nbsp;iteration failed to converge at some stage and the calculations 
are abandoned. In this case, the eigenvalues which are already 
isolated should be available in arrays ER and EI. 

<div class="p"><!----></div>
 

<br /><br />
<a name="Ordinary Differential Equations"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.12&nbsp; ORDINARY DIFFERENTIAL EQUATIONS </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#rkm">RKM</a></td>
<td>&nbsp; <a href="#rk4">RK4</a></td>
<td>&nbsp; <a href="#rk2">RK2</a></td>
<td>&nbsp; <a href="#mstep">MSTEP</a></td>
<td>&nbsp; <a href="#adams">ADAMS</a></td>
<td>&nbsp; <a href="#strt4">STRT4</a></td>
<td>&nbsp; <a href="#gear">GEAR</a></td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#extp">EXTP</a></td>
<td>&nbsp; <a href="#fdm">FDM</a></td>
<td>&nbsp; <a href="#gevp">GEVP</a></td>
<td>&nbsp; <a href="#gaublk">GAUBLK</a></td>
<td>&nbsp; <a href="#setmat">SETMAT</a></td>
<td>&nbsp; <a href="#bspode">BSPODE</a></td>
</tr>
</table>


<div class="p"><!----></div>
<br /><br /><a name="rkm"> </a>
 <b>192.&nbsp;RKM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/rkm.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/rkm.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve initial value problems in ordinary 
differential equations, using a second or fourth-order Runge-Kutta 
method with adaptive step size control. This subroutine accepts 
a system of first-order differential equations. N is the number 
of first-order equations. Y is a real array of length  N, 
which should contain the initial values of the variables at input. 
After successful execution, it will contain the solution at the  
required point. If the execution is aborted in between, then it 
will contain the solution at some intermediate point T0, up to where 
the integration was successful. DY is a real array of length  
N, containing the first derivative of the solution. The derivative 
need not be supplied at the time of calling. DIF is the name 
of the external subroutine, which is invoked for calculating the right-hand 
side of the differential equation <b>y</b>&#8242;=<b>f</b>(t,<b>y</b>). 
H is the initial step size to be tried. The subroutine will adjust 
the step size if necessary, using the technique described in Section&nbsp;12.4. After execution, H will contain the current value of the step size. 
T0 is the initial value of the independent variable t, at which the 
initial conditions are specified. After execution, the value of T0 
will be updated, to the point up to which the integration is successful. 
TN is the value of t at which the solution is required. 
TN need not be greater than T0, i.e., the solution can be calculated 
in forward or backward direction.  If 
the integration is successful, then T0 will be set equal to TN<!--hbox-->. Thus, 
if the solution is required at several points, then the subroutine can 
be called repeatedly after changing TN between every call. Other 
variables need not be changed. REPS is the required relative accuracy 
in each component of the solution. This subroutine only tries to 
estimate the local truncation error and the computed solution 
may not be correct to the specified accuracy. NSTEP is the number of steps 
used by the Runge-Kutta method, each step may require 10 or 11 function 
evaluations with fourth-order Runge-Kutta method. 
Each step may not be successful. NMAX is the maximum  
number of steps that the subroutine is allowed to use. If NMAX &#8804; 0, 
then a default value of NMX (=10000) will be used. IER is the 
error parameter. IER=701 implies that <span class="roman">N</span> &#8804; 0, in which 
case, no calculations are performed. 
IER=721 implies that step size has become smaller 
than REPS&#124;TN&#8722;T0&#124;. If in a small region the step 
size is actually expected to be smaller than this limit, then the 
corresponding statement in the subroutine may be modified.  
IER=722 implies that the 
step size is too small for the arithmetic used 
(i.e., <span class="roman">H</span> &lt; &#295; &#124;<span class="roman">T</span><span class="roman">0</span>&#124;) and the calculations 
are aborted. IER=723 
implies that the integration could not be completed in the specified number 
(NMAX) of steps. The failure of this routine can arise either 
because of singularity, or stiffness, or because the specified accuracy 
is too high. WK is a real array of length 5N, which is used 
as a scratch space by the subroutine. This subroutine requires subroutine 
<a href="appendixb.htm#rk4"> RK4</a> or <a href="appendixb.htm#rk2"> RK2</a> to perform one step of Runge-Kutta integration. Subroutine 
RK4 uses a fourth-order Runge-Kutta method, while RK2 uses a second-order 
method. To use RK2 the call statements as well as the parameter statement 
in the beginning of the subroutine should be changed as indicated. 
RKM<tt>_</tt>2 is the version of RKM for second-order method. 
Further, the 
subroutine DIF(T, N, Y, DY) must be supplied by the user to calculate the 
right-hand sides of the equations, i.e., the derivatives <span class="roman">Y</span>&#8242;. 
Here T is the value of independent variable 
and  N is the number of equations. 
Y is the real array containing the dependent variables at time t=<span class="roman">T</span>, 
where the derivatives need to be evaluated. 
DY is the real array which will contain the calculated value of the derivatives. 
DY(i) should contain <span class="roman">Y</span>&#8242;(i)=f<sub>i</sub>(<span class="roman">T</span><span class="roman">,</span> <span class="roman">Y</span>). 

<div class="p"><!----></div>
 <br /><br /><a name="rk4"> </a>
 <b>193.&nbsp;RK4&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/rk4.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/rkm.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform one step of integration using a 
fourth-order Runge-Kutta method. N is the number of first-order differential 
equations in the system. T is the value of independent variable at the 
initial point. This value is not updated by the subroutine. H is the 
step size to be used. Y0, DY0 and Y1 are real arrays of length  
N<!--hbox-->. Y0 contains the initial value, while after execution, Y1 will contain 
the final value of the solution vector at t=<span class="roman">T</span><span class="roman">+</span><span class="roman">H</span>. DY0 contains 
the first derivative at Y0. Y0 and DY0 must be supplied at the time of 
calling the subroutine. DIF is the name of the external subroutine used to calculate 
the right-hand sides of the differential equations. 
WK is a real array of length  2N used as a scratch space. 
The subroutine DIF as described in the write up for subroutine <a href="appendixb.htm#rkm"> RKM</a> must 
 be 
supplied by the user. 
This subroutine is called by subroutine RKM, but 
it can be used independently to integrate an equation with constant step 
size. This can be achieved by repeatedly calling the subroutine 
after updating the value of T (=<span class="roman">T</span>+<span class="roman">H</span>), 
Y0 (=<span class="roman">Y</span><span class="roman">1</span>) and DY0 (using DIF). 

<div class="p"><!----></div>
 <br /><br /><a name="rk2"> </a>
 <b>194.&nbsp;RK2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/rk2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/rkm_2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform one step of integration using a 
second-order Runge-Kutta method. All arguments have the same meaning 
as that for the subroutine RK4. 

<div class="p"><!----></div>
 <br /><br /><a name="mstep"> </a>
 <b>195.&nbsp;MSTEP&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/mstep.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/mstep.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve initial value problems in ordinary 
differential equations, using a fourth-order multistep method  
with adaptive step size control. This subroutine accepts 
a system of first-order differential equations. It can be 
used with either subroutine <a href="appendixb.htm#adams"> ADAMS</a> for Adams-Bashforth-Moulton 
predictor-corrector method, or subroutine <a href="appendixb.htm#gear"> GEAR</a> for stiffly stable fourth-order 
method. The change can be affected by choice of a flag. 
By setting the flag appropriately, this 
subroutine can also be used to integrate the equation using a 
fixed step size. This subroutine is a crude implementation of multistep 
methods with simple techniques for adjusting the step-size which 
should work on simple problems. A more 
sophisticated implementation will be required to handle a larger 
fraction of equations efficiently. 
N is the number 
of first-order equations. Y is a real array of length  7N, 
the first N elements of 
which should contain the initial values of the solution at input. 
After execution, it will contain the solution at some 
intermediate points. The contents of this array must be preserved, if a 
second call to the subroutine is required for continuing the integration 
further. DY is a real array of length  
7N, containing the first derivatives of the solution. The first derivative 
need not be supplied at the time of calling. The arrays Y and DY are 
used to store the solution at seven most recent points. The second index 
of the array is increased in a circular manner, to avoid frequent copying 
of the array elements. DIF is the name 
of the external subroutine, which is invoked for calculating the right-hand 
sides of the differential equations <b>y</b>&#8242;=<b>f</b>(t,<b>y</b>). 
H is the initial step size to be tried. This subroutine generates 
the starting values using the fourth-order 
Runge-Kutta method, which will adjust the step 
size if necessary. After the starting values are generated, the step 
size can be doubled or halved as explained in Section&nbsp;12.3. After execution, H will contain the current value of the step size. 
T0 is the initial value of the independent variable t, at which the 
initial conditions are specified. After execution, the value of T0 
will be updated to the point up to which the integration is successful. 
If the execution is successful the final value of T0 may be beyond 
the requested value of TN<!--hbox-->. The solution at TN is computed using 
interpolation between values of solution at different values of t. 
TN is the value of t at which the solution is required. If 
the solution is required at several points, then the subroutine can 
be called repeatedly after changing TN between every call. Other 
variables (including the scratch arrays) should not be changed, 
because the subroutine 
uses the previous values of the solution as the starting values for 
the new problem. YF is a real array of length  N, which will 
contain the final value of the solution at the required point TN, provided 
the integration is successful. If the integration is aborted at some 
intermediate point after the starting values were calculated, then this array 
will contain the solution at the last successful point. 
REPS is the required relative accuracy 
in each component of the solution. This subroutine only tries to 
estimate the local truncation error. Hence, the computed solution 
may not be correct to the specified accuracy. NSTP is the number of  
evaluations of the right-hand side required by the subroutine. 
NSTP is initialised only during the first call (IFLG=0 or 1) and hence it 
will accumulate the number of calls to DIF from the first call, until 
IFLG is reset to 0 or 1. 
NMAX is the maximum number of function 
evaluations that the subroutine is allowed to use. If NMAX &#8804; 0, 
then a default value of NMX (=100000) will be used. IER is the 
error parameter. IER=702 implies that <span class="roman">N</span> &#8804; 0, in which 
case, no calculations are performed. IER=724 or 725 implies that 
subroutine <a href="appendixb.htm#strt4"> STRT4</a> failed to generate the required starting values. 
IER=726 implies that step size has become smaller 
than REPS&#124;TN&#8722;T0&#124;. If in a small region the step 
size is actually expected to be smaller than this limit, then the 
corresponding statement in the subroutine may be modified. 
IER=727 implies that the 
step size is too small for the arithmetic used 
(i.e., <span class="roman">H</span> &lt; &#295;&#124;<span class="roman">T</span><span class="roman">0</span>&#124;) and the calculations 
are aborted.  IER=728 
implies that the integration could not be completed in the specified number 
(NMAX) of function evaluations. The failure of this routine can arise either 
because of singularity, or stiffness (with <a href="appendixb.htm#adams"> ADAMS</a>), or because 
the specified accuracy 
is too high. For integration with fixed step size, IER may be set to 729 
if the corrector fails to converge. 
IFLG is an integer variable used as a flag by the subroutine. 
If IFLG=0 or 1, then the integration is started by generating fresh 
starting values using subroutine STRT4. For higher values of IFLG 
it is assumed that the starting values are already available in the 
arrays Y and DY<!--hbox-->. The subroutine itself resets the value of IFLG after 
generating the starting values. Hence, this parameter need not be reset 
between two calls, unless it is required to generate starting values again. 
If IFLG=0 or 2, then the step size is adjusted according to 
the required accuracy. For IFLG=1 and 3, the step size is kept 
fixed and no attempt is made to check the truncation error. However, 
the parameter REPS is used to check for convergence of the corrector 
iteration. In this case, if the iteration on corrector fails to converge, 
then IER will be set to 729. IST is an integer parameter to 
decide which multistep method is to be used. If IST=0 the 
fourth-order 
Adams-Bashforth-Moulton predictor-corrector method is used, while for 
other values of IST, the fourth-order stiffly stable method due to 
Gear is used. 
WK is a real array, which is used 
as a scratch space by the subroutine. The length of this array should be 
2N for Adams method and 3<span class="roman">N</span>+<span class="roman">N</span>&times;max(<span class="roman">N</span>+4,2<span class="roman">N</span>) 
for stiffly stable method. IWK is an integer array which is used as 
a scratch space. The length of this array should be  N, if subroutine  
GEAR is used. Subroutine ADAMS does not need this array and a dummy array 
of length one will be sufficient in that case. 
This subroutine requires subroutine 
<a href="appendixb.htm#adams"> ADAMS</a>, <a href="appendixb.htm#gear"> GEAR</a> and <a href="appendixb.htm#gauelm"> GAUELM</a> to perform the integration and subroutine <a href="appendixb.htm#strt4"> STRT4</a> and <a href="appendixb.htm#rk4"> RK4</a> 
to generate the starting values. In addition the 
subroutine DIF(T, N, Y, DY) must be supplied by the user to calculate the 
right-hand sides of the equations, i.e., the derivatives <span class="roman">Y</span>&#8242;. 
Here T is the value of independent variable 
and  N is the number of equations. 
Y is the real array containing the dependent variables at time t=<span class="roman">T</span>, 
where the derivatives need to be evaluated. 
DY is the real array which will contain the calculated value of the derivatives. 
DY(i) should contain <span class="roman">Y</span>&#8242;(i)=f<sub>i</sub>(<span class="roman">T</span><span class="roman">,</span> <span class="roman">Y</span>). 

<div class="p"><!----></div>
 <br /><br /><a name="adams"> </a>
 <b>196.&nbsp;ADAMS&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/adams.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/mstep.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform one step of solution of an initial 
value problem, using a fourth-order Adams-Bashforth-Moulton  
predictor-corrector method. This subroutine can be easily modified to use any 
other predictor-corrector formula. This subroutine is called by subroutine 
<a href="appendixb.htm#mstep"> MSTEP</a> to perform one step of integration. N is the number of first-order 
differential equations, Y and DY are real arrays of length  7N, 
as used by subroutine MSTEP<!--hbox-->. DIF is the name of the subroutine used to calculate 
the right-hand sides of the equations. H is the step size and T is 
the value of independent variable at which the solution is required. 
REPS is the specified 
accuracy. This subroutine does not check for the truncation error, but 
the parameter REPS is used to check for the convergence of corrector 
iteration. NSTP is the number of function evaluations used so far. 
This number is updated by the subroutine. 
IJ, IJM1, IJM2, IJM3 and IJM4 are respectively, the indices j+1, j, j&#8722;1, 
j&#8722;2 and j&#8722;3 in the predictor-corrector formula. IER is the error parameter. 
IER=729 implies that the iteration on corrector has failed to converge. 
WK is a real array of length  2N, which is used to transmit the 
predicted value to subroutine MSTEP<!--hbox-->. 
Subroutine DIF as described in the writeup for subroutine <a href="appendixb.htm#mstep"> MSTEP</a> 
must be supplied by the user. 

<div class="p"><!----></div>
 <br /><br /><a name="strt4"> </a>
 <b>197.&nbsp;STRT4&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/strt4.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/mstep.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to generate the starting values <b>y</b><sub><b>1</b></sub>, 
<b>y</b><sub><b>2</b></sub> and <b>y</b><sub><b>3</b></sub> using a fourth-order Runge-Kutta method. 
The truncation error is estimated by performing one integration with 
double step size. This subroutine is called by the subroutine <a href="appendixb.htm#mstep"> MSTEP</a><!--hbox-->. 
N is the number of first-order differential equations 
to be solved. Y and DY are real arrays of length  4N, containing 
the values of <b>y</b> and <b>y</b>&#8242; at the four starting points. While 
calling the subroutine, the initial values <b>y</b><sub><b>0</b></sub> must be stored 
in the first N elements of Y<!--hbox-->. Other elements of these arrays will 
be calculated by the subroutine. DIF is the name of the subroutine used to 
calculate the right-hand sides of the differential equations. H is the 
initial guess for the step size. If necessary the step size will 
be adjusted by the subroutine. T is the value of the independent variable at 
the initial point. If the execution is successful, then T is updated 
to <span class="roman">T</span>+3<span class="roman">H</span>. REPS is the specified relative accuracy. IFLG is 
an integer parameter used as a flag. If IFLG=0, then the step 
size may be adjusted while for other values of IFLG the step size 
will not be adjusted. For IFLG &#8800; 0, the value of REPS is redundant, 
since no attempt is made to check the truncation error. 
TSTEP is the size of interval over which the 
integration is requested. It is used only for convergence check. 
NSTP is an integer variable which contains 
the number of function evaluations used so far. This value is updated 
by the subroutine. IER is an error 
parameter. IER=724 implies that the routine failed to find 
the starting values, because the step size became too small. 
IER=725 implies that the routine failed to find the starting values 
in the specified number (NIT=10) of attempts. WK is a real array 
of length  2N used as a scratch space by the subroutine. 
This subroutine requires subroutines <a href="appendixb.htm#rk4"> RK4</a> and DIF<!--hbox-->. 
Subroutine DIF as described in the writeup for subroutine <a href="appendixb.htm#mstep"> MSTEP</a> 
must be supplied by the user. 

<div class="p"><!----></div>
 <br /><br /><a name="gear"> </a>
 <b>198.&nbsp;GEAR&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gear.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/mstep.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to perform one step of solution of initial 
value problem using a fourth-order stiffly stable method based on the 
backward differentiation formula. This subroutine uses the Broyden's 
method to solve the implicit corrector formula. 
This subroutine is called by the subroutine 
<a href="appendixb.htm#mstep"> MSTEP</a> to perform one step of integration. N is the number of first-order 
differential equations, Y and DY are real arrays of length  7N 
as used by subroutine MSTEP<!--hbox-->. DIF is the name of the subroutine used to calculate 
the right-hand sides of the equations. H is the step size and T is 
the value of the independent variable at which the solution is required. 
REPS is the specified 
accuracy. This subroutine does not check for the truncation error, but 
the parameter REPS is used to check for the convergence of corrector 
iteration. NSTP is the number of function evaluations used so far. 
This number is updated by the subroutine. 
IJ, IJM1, IJM2, IJM3 and IJM4 are respectively, the indices j+1, j, j&#8722;1, 
j&#8722;2 and j&#8722;3 in the corrector formula. IFLAG is an integer variable used 
as a flag. If IFLAG=0, initial approximation to the Jacobian 
is generated, otherwise the old approximation is used. In any case, 
Broyden's method will be used to update the initial approximation to 
the inverse of the Jacobian. If IFLAG=0, it is set to 1 after 
calculation of Jacobian so that the Jacobian is not calculated again 
next time. 
IER is the error parameter. 
IER=729 implies that the corrector iteration fails to converge. 
WK1 and WK are real arrays of length  3N and  
<span class="roman">N</span>&times;max(2<span class="roman">N</span>,<span class="roman">N</span>+4) respectively, 
used as a scratch space. IWK is 
an integer array of length  N used as a scratch space. 
Subroutine DIF as described in write-up for <a href="appendixb.htm#mstep"> MSTEP</a> must be supplied by 
the user. This subroutine also requires 
subroutine <a href="appendixb.htm#gauelm"> GAUELM</a> to solve systems of linear equations. 
The parameter CFAC in the subroutine may need to be reduced if the 
subroutine MSTEP needs to adjust the step size too often. 

<div class="p"><!----></div>
 <br /><br /><a name="extp"> </a>
 <b>199.&nbsp;EXTP&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/extp.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/extp.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve initial value problems in ordinary 
differential equations using extrapolation method. This subroutine accepts 
a system of first-order differential equations. N is the number 
of first-order equations. Y is a real array of length  N, 
which should contain the initial values of solution at input. 
After successful execution, it will contain the solution at the  
required point. If the execution is aborted in between, then it 
will contain the solution at some intermediate point T0, up to where 
the integration was successful. DY is a real array of length  
N containing the first derivative of the solution. The first derivative 
need not be supplied at the time of calling. DIF is the name 
of the external subroutine, which is invoked for calculating the right-hand 
sides of the differential equations <b>y</b>&#8242;=<b>f</b>(t,<b>y</b>). 
H is the initial step size to be tried. The subroutine will adjust 
the step size if necessary, using the crude technique described in Section&nbsp;12.5. After execution, H will contain the current value of the step size. 
T0 is the initial value of the independent variable t, at which the 
initial conditions are specified. After execution, the value of T0 
will be updated to the point, up to which the integration is successful. 
TN is the value of t at which the solution is required. If 
the integration is successful, then T0 will be set equal to TN<!--hbox-->. Thus, 
if the solution is required at several points, then the subroutine can 
be called repeatedly after changing TN between every call. Other 
variables need not be changed. REPS is the required relative accuracy 
in each component of the solution. This subroutine only tries to 
estimate the local truncation error. Hence, the computed solution 
may not be correct to the specified accuracy. NSTEP is the number of function 
evaluations used by the subroutine. This number is initialised to zero 
at every call to EXTP<!--hbox-->. Thus if EXTP is called repeatedly, then the 
total number of function evaluations used will need to be accumulated 
separately. 
NMAX is the maximum number of function 
evaluations that the subroutine is allowed to use. If NMAX &#8804; 0, 
then a default value of NMX (=100000) will be used. IER is the 
error parameter. IER=703 implies that <span class="roman">N</span> &#8804; 0, in which 
case, no calculations are performed. 
IER=730 implies that step size has become smaller 
than REPS&#124;TN&#8722;T0&#124;. If in a small region the step 
size is actually expected to be smaller than this limit, then the 
corresponding statement in the subroutine may be modified. 
IER=731 implies that the 
step size is too small for the arithmetic used (i.e., 
<span class="roman">H</span> &lt; &#295;&#124;<span class="roman">T</span><span class="roman">0</span>&#124;) and the calculations 
are aborted.  IER=732 
implies that the integration could not be completed in the specified number 
(NMAX) of steps. IER=733 implies that the denominator in the 
rational function extrapolation is zero. 
The failure of this routine can arise either 
because of singularity, or stiffness, or because the specified accuracy 
is too high. For rational function extrapolation, the failure can also 
be due to the fact that denominator has become zero. 
In this case, polynomial extrapolation can be tried. 
WK is a real array of length  39N, which is used 
as a scratch space by the subroutine. IFLG is an integer variable used 
to decide which type of extrapolation is to be used. If IFLG=0, 
then polynomial extrapolation is used, otherwise rational function 
extrapolation is used. 
The subroutine DIF(T, N, Y, DY) must be supplied by the user to calculate the 
right-hand sides of the equations, i.e., the derivatives <span class="roman">Y</span>&#8242;. 
Here T is the value of independent variable 
and  N is the number of equations. 
Y is the real array containing the dependent variables at time t=<span class="roman">T</span>, 
where the derivatives need to be evaluated. 
DY is the real array which will contain the calculated value of the derivatives. 
DY(i) should contain <span class="roman">Y</span>&#8242;(i)=f<sub>i</sub>(<span class="roman">T</span><span class="roman">,</span> <span class="roman">Y</span>). 

<div class="p"><!----></div>
 <br /><br /><a name="fdm"> </a>
 <b>200.&nbsp;FDM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/fdm.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fdm.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a two-point boundary value problem 
with separable boundary conditions, 
using finite difference method as explained in Section&nbsp;12.8. If a uniform mesh is used, then it is also possible to estimate the first-order 
correction, using the method of deferred correction. N is the number of 
mesh points to be used. M is the number of 
first-order differential equations in the system. ML is the number of 
boundary conditions at the first boundary (i.e., T(1)). PAR is a real 
array which is passed on to the subroutine EQN and BCS for calculating 
the required information about the equation and the boundary  
conditions. This array can be used to pass any parameters that may 
be required by these subroutines. This array is not used by subroutine 
FDM, or any other routine called by it except EQN and BCS, and its 
size can be arbitrary depending on the requirements. X is a real array 
of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which should contain the initial guess 
for the solution. After execution, it will contain the computed solution. 
If the problem is linear, then there is no need for initial approximation 
and this array could be initialised to zero or any other convenient 
value. The subroutine FDM treats it as a two-dimensional array of 
dimension (M, N) with X(I, J) containing the Ith component at Jth 
mesh point. Unfortunately, there is no provision to pass the first 
dimension of the array X, as specified in the calling program. Hence, 
to obtain meaningful results, the first dimension of the array X in the calling 
program must also be exactly equal to M<!--hbox-->. This problem arises because, while 
solving the finite difference equations, it is convenient to assume that 
the array elements are stored in consecutive positions without any gaps. 
XC is also a real array of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which will 
contain the solution after applying the deferred correction. This array is also 
stored in the same format as the array X and the same remarks apply here 
too. Even if deferred correction is not requested, this array should be provided, 
since it is also used as a scratch space during the computations. The 
difference <span class="roman">XC</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">J</span><span class="roman">)</span>&#8722;<span class="roman">X</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">J</span><span class="roman">)</span> gives an estimate of the truncation error 
in X(I, J) provided the deferred correction is calculated. 
T is a real array of length  N, containing the mesh points 
t<sub>j</sub>, (j=1,&#8230;,<span class="roman">N</span>), to be used in the finite difference approximation. 
This array must be supplied by the user. If deferred correction is required, 
then the mesh must be uniformly spaced, otherwise spacing can be arbitrary. 
In any case, the mesh points t<sub>j</sub> must be in either ascending or descending 
order. 
EQN is the name of the subroutine, which defines the differential equations. 
The differential equation is assumed to be in the 
form B<b>y</b>&#8242;=<b>f</b>(t,<b>y</b>), where B is a <span class="roman">M</span>&times;<span class="roman">M</span> 
matrix and <b>f</b> is a vector function of length M<!--hbox-->. The matrix B 
must be nonsingular. The elements of B and <b>f</b> at a given point T 
are calculated by the subroutine EQN<!--hbox-->. Apart from this, it 
must also calculate the Jacobian &#8706;f<sub>i</sub>/&#8706;y<sub>j</sub> (stored in the 
array A). BCS is 
the name of the subroutine, which specifies the boundary conditions. 
The boundary conditions are defined by functions g<sub>i</sub>(t<sub>1</sub>,<b>y</b><sub><b>1</b></sub><b>)</b><b>=</b><b>0</b> for 
i=1,&#8230;,<span class="roman">ML</span> at the first point t=<span class="roman">T</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span>, and 
g<sub>i</sub>(t<sub>N</sub>,<b>y</b><sub><b>N</b></sub><b>)</b><b>=</b><b>0</b> for i=<span class="roman">ML</span><span class="roman">+</span><span class="roman">1</span>,&#8230;,<span class="roman">M</span> at the last point 
t=<span class="roman">T</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span>. Apart from the functions g<sub>i</sub>, this subroutine should 
also calculate the Jacobian matrix &#8706;g<sub>i</sub>/&#8706;y<sub>j</sub> (stored in the 
array BC). The general form of these subroutines is as follows: 

<div class="p"><!----></div>
<br /> <tt><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SUBROUTINE EQN(J,M,ML,PAR,A,B,Y,F,T) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
    IMPLICIT REAL*8(A-H,O-Z) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
    DIMENSION A(M+ML,M),B(M+ML,M),Y(M),PAR(*),F(M) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
    DO I=1,M 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      F(I)=<span class="roman">f<sub>I</sub>(<span class="roman">T</span>,PAR,<span class="roman">Y</span>)</span> 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      DO K=1,M 
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
        A(K,I)=<span class="roman">&#8706;f<sub>K</sub>/&#8706;<span class="roman">Y</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span></span> 
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
 B(K,I)=<span class="roman">b<sub>KI</sub>(<span class="roman">T</span>,PAR)</span> 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      ENDDO 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      ENDDO 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
    END 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
    SUBROUTINE BCS(M,ML,PAR,BC,G,T1,TN,Y1,YN) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
    IMPLICIT REAL*8(A-H,O-Z) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
    DIMENSION PAR(*),BC(M+ML,M),G(M),Y1(M),YN(M) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
    DO I=1,M 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      IF(I.LE.ML) THEN 
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
        G(I)=<span class="roman">g<sub>I</sub>(<span class="roman">T</span><span class="roman">1</span>,PAR,<span class="roman">Y</span><span class="roman">1</span>)</span> 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      ELSE 
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
        G(I)=<span class="roman">g<sub>I</sub>(<span class="roman">TN</span>,PAR,<span class="roman">YN</span>)</span> 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      ENDIF 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      DO J=1,M 
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
 BC(I,J)=<span class="roman">&#8706;g<sub>I</sub>/&#8706;<span class="roman">Y</span><span class="roman">(</span><span class="roman">J</span><span class="roman">)</span></span> 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      ENDDO 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      ENDDO 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
    END
<div class="p"><!----></div>
</tt> It should be noted that the first dimension of A, B and BC is 
<span class="roman">M</span>+<span class="roman">ML</span> instead of <span class="roman">M</span>. Here T, T1 and TN are the values 
of t at relevant points, while the real arrays Y, Y1 and YN contain 
the values of <b>y</b> at these points. In subroutine EQN the parameter 
J identifies the interval at which the functions are evaluated (i.e., 
<span class="roman">T</span>=(t<sub>J</sub>+t<sub>J+1</sub>)/2). 
This index is useful in cases, where the coefficients 
are read in the form of a table. 

<div class="p"><!----></div>
IWK is an integer array of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which 
is used as a scratch space. WK is a real array of length  
(<span class="roman">M</span><span class="roman">+</span> <span class="roman">ML</span>)&times;2<span class="roman">M</span>&times;(<span class="roman">N</span>+1), which is used as 
a scratch space. IFLAG is an integer 
variable which is used as a flag. If IFLAG=0 or 1, then the 
equation is treated as nonlinear and solution will be calculated 
iteratively. If IFLAG=2 or 3, then the equations are treated 
as linear and calculation will be terminated after the first iteration. 
If IFLAG=0 or 2, then the first-order correction will be calculated 
using the method of deferred correction. For other values of IFLAG, the 
deferred correction will not be calculated. The deferred correction can be 
calculated only if the mesh spacing is uniform and the number of points 
N is at least five. REPS is the specified 
accuracy. This parameter is only used to check for the convergence 
of Newton's method, for solution of finite difference equations 
(only for nonlinear equations i.e., IFLAG=0,1). This parameter 
has no effect on truncation error, which is determined by the mesh spacing. 
The truncation error can be estimated by the difference between X and 
XC, if deferred correction is used. 
IER is the error parameter. IER=704 implies that <span class="roman">N</span> &lt; 3, 
or <span class="roman">M</span> &#8804; <span class="roman">ML</span>, or <span class="roman">ML</span> &#8804; 0, in which case, no calculations 
are performed. IER=734 implies that <span class="roman">N</span> &#8804; 4 and deferred 
correction is requested. In this case, the deferred correction is not 
calculated. IER=735 implies that the finite difference matrix 
is singular and the solution cannot be obtained. This problem may be due 
to some error in specifying the equation matrix or boundary conditions. 
IER=736 implies that the mesh spacing is not 
uniform, in which case, the deferred correction will not be calculated. 
IER=737 implies that the Newton's iteration 
for solving the finite difference equations fails to converge. 
This subroutine requires subroutine <a href="appendixb.htm#setmat"> SETMAT</a> for setting up the matrix of 
finite difference equations, and subroutine <a href="appendixb.htm#gaublk"> GAUBLK</a> to solve the system of 
linear equations defined by the block matrix as explained in Section&nbsp;12.8. Apart from these, the subroutines EQN and BCS specifying the problem must 
be supplied by the user. 

<div class="p"><!----></div>
 <br /><br /><a name="gevp"> </a>
 <b>201.&nbsp;GEVP&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gevp.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/gevp.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a generalised eigenvalue problem for 
a system of differential equations, with separable boundary conditions, 
using finite difference method as explained in Section&nbsp;12.9. If a uniform mesh is used, then it is also possible to estimate the first-order 
correction to the eigenvalue, using the method of deferred correction.  
N is the number of mesh points to be used. M is the number of 
first-order differential equations in the system. ML is the number of 
boundary conditions at the first boundary (i.e., T(1)). PAR is a real 
array which is passed on to the subroutines EQN, EQND, BCS and BCSD 
for calculating 
the required information about the equation and the boundary  
conditions. The first element of PAR is used to pass the eigenvalue 
and hence it should not be used for any other purpose. After execution, 
PAR(1) will contain the calculated eigenvalue. 
Other elements of this array can be used to pass any parameter that may 
be required by these subroutines. Other elements of the array are not 
used by subroutine 
GEVP or any other routine called by it except EQN, BCS, EQND and BCSD, 
and its 
size can be arbitrary depending on the requirements. X is a real array 
of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which  
will contain the computed eigenfunction. Even if the eigenfunction is 
not required, this array should be provided. 
The subroutine GEVP treats it as a two-dimensional array of 
dimension (M, N), with X(I, J) containing the Ith component at Jth 
mesh point. Unfortunately, there is no provision to pass the first 
dimension of the array X as specified in the calling program. Hence, 
to obtain meaningful results, the first dimension of the array X in the calling 
program must also be exactly equal to M<!--hbox-->. This problem arises, because while 
solving the finite difference equations it is convenient to assume that 
the array elements are stored in consecutive positions without any gaps. 
XC is also a real array of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which will 
contain the left eigenvector of the finite difference matrix, which is 
required for calculating the deferred correction. This array is also 
stored in the same format as the array X and the same remarks apply here 
too. Even if deferred correction is not requested, this array should be provided, 
since it is also used as a scratch space during the computations.  
T is a real array of length  N, containing the mesh points 
t<sub>j</sub> for j=1,&#8230;,<span class="roman">N</span> to be used in the finite difference approximation. 
This array must be supplied by the user. If deferred correction is required, 
then the mesh must be uniformly spaced, otherwise spacing can be arbitrary. 
In any case, the mesh points t<sub>j</sub> must be in either ascending or descending 
order. 
E0 is the initial guess for the eigenvalue. After execution, E0 will 
contain the corrected eigenvalue, provided deferred correction is calculated. 
EQN is the name of the subroutine which defines the differential equation. 
The differential equation is assumed to be in the 
form B<b>y</b>&#8242;=A<b>y</b>, where A and B are <span class="roman">M</span>&times;<span class="roman">M</span> 
matrices. The matrix B must be nonsingular. 
The elements of A and B which could be arbitrary functions 
of the eigenvalue &#955; and t, 
are calculated by the subroutine EQN<!--hbox-->. BCS is 
the name of the subroutine which specifies the boundary conditions. 
The boundary conditions are defined by C<sub>1</sub><b>y</b><sub><b>1</b></sub><b>=</b><b>0</b>, 
and C<sub>N</sub><b>y</b><sub><b>N</b></sub><b>=</b><b>0</b>, where C<sub>1</sub> and C<sub>N</sub> are <span class="roman">ML</span>&times;<span class="roman">M</span>  
and <span class="roman">(</span><span class="roman">M</span>&#8722;<span class="roman">ML</span><span class="roman">)</span>&times;<span class="roman">M</span> matrices, respectively. 
These matrices are combined 
in one <span class="roman">M</span>&times;<span class="roman">M</span> matrix BC, the first ML rows of which correspond 
to the boundary conditions at the first boundary (t=<span class="roman">T</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span>), while 
the remaining rows refer to boundary conditions at the last point 
(t=<span class="roman">T</span><span class="roman">(</span><span class="roman">N</span><span class="roman">)</span>). EQND is the name of the subroutine to calculate the 
derivatives of matrices A and B (as defined in EQN) with respect to the 
eigenvalue &#955;. Similarly, BCSD is the name of the subroutine to calculate 
the derivatives of matrix BC (as defined in BCS) with respect to the 
eigenvalue &#955;. If deferred correction is not required, then the 
subroutines EQND and BCSD are not called, but in order to satisfy the 
compiler and the linker, dummy subroutines containing only the dimension 
statement may be required. 
The general form of these subroutines is as follows: 

<div class="p"><!----></div>
<br /> <tt><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SUBROUTINE EQN(J,M,ML,PAR,A,B,Y,F,T) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      IMPLICIT REAL*8(A-H,O-Z) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      DIMENSION A(M+ML,M),B(M+ML,M),Y(M),PAR(*),F(M) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      DO I=1,M 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
        F(I)=0.0  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <span class="roman">set the right-hand side to zero for consistency</span> 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
        DO K=1,M 
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
          A(K,I)=<span class="roman">a<sub>KI</sub>(<span class="roman">T</span>,&#955; = PAR(1),PAR(2),&#8230;)</span> 
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
 B(K,I)=<span class="roman">b<sub>KI</sub>(<span class="roman">T</span>,&#955; = PAR(1),PAR(2),&#8230;)</span> 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      ENDDO 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      ENDDO 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      END 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      SUBROUTINE BCS(M,ML,PAR,BC,G,T1,TN,Y1,YN) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      IMPLICIT REAL*8(A-H,O-Z) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      DIMENSION PAR(*),BC(M+ML,M),G(M),Y1(M),YN(M) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      DO I=1,M 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
        G(I)=0  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   <span class="roman">set the right-hand side to zero for consistency</span> 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
        DO J=1,M 
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
          IF(I.LE.ML) THEN 
<br /><table align="left" border="0"><tr><td width="69" align="right">
</td></tr></table><!--hbox-->
            BC(I,J)=<span class="roman">c<sub>IJ</sub>(<span class="roman">T</span><span class="roman">1</span>,&#955;,&#8230;)</span> 
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
          ELSE 
<br /><table align="left" border="0"><tr><td width="69" align="right">
</td></tr></table><!--hbox-->
            BC(I,J)=c<sub>IJ</sub>(<span class="roman">TN</span>,&#955;,&#8230;) 
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
          ENDIF 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      ENDDO 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      ENDDO 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      END 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      SUBROUTINE EQND(J,M,ML,PAR,A,B,T) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      IMPLICIT REAL*8(A-H,O-Z) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      DIMENSION A(M+ML,M),B(M+ML,M),PAR(*) 
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      DO I=1,M 
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
        DO K=1,M 
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
          A(K,I)=<span class="roman">&#8706;a<sub>KI</sub>/&#8706;&#955;</span>
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
 B(K,I)=<span class="roman">&#8706;b<sub>KI</sub>/&#8706;&#955;</span>
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      ENDDO
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      ENDDO
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      END
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      SUBROUTINE BCSD(M,ML,PAR,BC,T1,TN)
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      IMPLICIT REAL*8(A-H,O-Z)
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      DIMENSION PAR(*),BC(M+ML,M+1)
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      DO I=1,M
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
        DO J=1,M
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
 BC(I,J)=<span class="roman">&#8706;c<sub>IJ</sub>/&#8706;&#955;</span>
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      ENDDO
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      ENDDO
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      END
<div class="p"><!----></div>
</tt> It should be noted that the first dimension of A, B and BC is 
<span class="roman">M</span>+<span class="roman">ML</span> instead of <span class="roman">M</span>.  Here T, T1 and TN are the values 
of t at relevant points. The real arrays Y, Y1, YN, F and G are not 
really required for eigenvalue problem, but are provided for consistency. 
Thus, in EQN and BCS, F(I) and G(I) 
should be set to zero in order to be consistent with subroutine <a href="appendixb.htm#fdm"> FDM</a>, since 
the same subroutine <a href="appendixb.htm#setmat"> SETMAT</a> is used in both cases. 
In subroutine EQN and EQND, the parameter 
J identifies the interval at which the functions are evaluated (i.e., 
<span class="roman">T</span>=(t<sub>J</sub>+t<sub>J+1</sub>)/2). This index is useful in cases, where the coefficients 
are read in the form of a table. 

<div class="p"><!----></div>
IWK is an integer array of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which 
is used as a scratch space. WK is a real array of length  
(<span class="roman">M</span><span class="roman">+</span> <span class="roman">ML</span>)&times;2<span class="roman">M</span>&times;(<span class="roman">N</span>+1) used as a scratch space. 
IFLAG is an integer 
variable which is used as a flag. If IFLAG=0, then only 
the eigenvalue is calculated. If IFLAG=1, then eigenvector 
is also calculated, using the method of inverse iteration. 
If IFLAG=2, then the first-order correction to the eigenvalue 
is also calculated, 
using the method of deferred correction. The deferred correction can be 
calculated only if the mesh spacing is uniform and the number of mesh 
points N is at least five. REPS is the specified 
accuracy. This parameter is only used to check for the convergence 
of Muller's method (or secant method) for finding zeros of the 
determinant, and the inverse 
iteration method for finding eigenvectors. This parameter 
has no effect on the truncation error, which is determined by the mesh spacing. 
If deferred correction is used, then the difference <span class="roman">E</span><span class="roman">0</span>&#8722;<span class="roman">PAR</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span> 
will give an estimate of the truncation error in PAR(1). RMX is a 
real variable, which is used to specify the region in which the eigenvalues 
are to be searched. This parameter is passed on to subroutine <a href="appendixb.htm#muler2"> MULER2</a>, 
(or SECANI) 
which terminates the iteration if at any stage &#124;&#955;&#124; &gt; RMX. 
IER is the error parameter. 
IER=704 implies that <span class="roman">N</span> &lt; 3, 
or <span class="roman">M</span> &#8804; <span class="roman">ML</span> or <span class="roman">ML</span> &#8804; 0. In this case, no calculations 
are performed. 
IER=734 implies that <span class="roman">N</span> &#8804; 4 and deferred 
correction is requested. In this case, the deferred correction is not 
calculated.  
IER=735 implies that 
one of the pivots has vanished during the calculation and hence the 
eigenvector cannot be calculated. In this case, the eigenvalue will be 
calculated. 
This problem can be avoided by perturbing the eigenvalue slightly and  
recalculating the determinant before calculating the eigenvector. 
IER=736 implies that the mesh spacing is not 
uniform, in which case the deferred correction will not be calculated. 
IER=738 implies that the eigenvector vanishes, 
in which case the calculations are terminated. In this case also the eigenvalue 
is already calculated and will be stored in PAR(1).  
IER=739 implies that the inverse iteration 
for calculating the eigenvector failed to converge. 
IER=740 implies that the inverse iteration 
for calculating the left eigenvector failed to converge. 
Apart from these, other values of IER may be set by subroutine MULER2 
(or SECANI), 
which is called to find zeros of the determinant. 
The subroutine GEVP requires subroutine <a href="appendixb.htm#setmat"> SETMAT</a> for setting up the matrix of 
finite difference equations, and subroutine <a href="appendixb.htm#gaublk"> GAUBLK</a> to solve the system of 
linear equations, or to calculate the determinant of the block matrix  
as explained in Section&nbsp;12.8. Subroutine <a href="appendixb.htm#muler2"> MULER2</a>, <a href="appendixb.htm#secani"> SECANI</a> or any other equivalent routine 
is required for finding zeros of the determinant. It may be noted that 
subroutine MULER2 requires the function to be complex, but if we want 
to avoid unnecessary use of complex arithmetic for calculating real 
eigenvalues, then we can take the real part of CX and calculate the real 
function DET and pass it back to MULER2 in the complex variable CF<!--hbox-->. 
In principle, such a procedure can lead to trouble, if the iterates 
become complex at some stage and the next iterate has the same real part. 
This problem can be avoided if SECANI is used. 
Both SECANI and MULER2 use reverse communication technique and hence 
the control is passed back to GEVP when a function evaluation is 
required. 
Apart from these, the subroutines EQN, EQND, BCS and BCSD specifying the  
problem must be supplied by the user. For calculating complex eigenvalues, 
all real variables other that those starting with H, R and T should be declared 
to be complex in subroutines GEVP, SETMAT, GAUBLK, EQN, EQND, BCS, and BCSD<!--hbox-->. In this case it will be preferable to use <a href="appendixb.htm#muler2"> MULER2</a>. This process is 
implemented in GEVP<tt>_</tt>C. 

<div class="p"><!----></div>
 <br /><br /><a name="gaublk"> </a>
 <b>202.&nbsp;GAUBLK&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/gaublk.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fdm.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a system of linear equations involving 
finite difference matrix of the form described in Section&nbsp;12.8. This subroutine uses 
Gaussian elimination with partial pivoting. N is the number of 
mesh points, M is the number of first-order differential equations in the 
system. ML is the number of boundary conditions at the first boundary. 
A is a real array of length  (<span class="roman">M</span><span class="roman">+</span><span class="roman">ML</span>)&times;2<span class="roman">M</span>&times;<span class="roman">N</span> containing the matrix (Section&nbsp;12.8). IFLG is an integer variable used as a flag. 
If IFLG=0, the subroutine performs elimination as well as the  
solution of linear 
equations. If IFLG=1, then only the elimination is performed. 
In both these cases, the determinant is calculated and IFLG is set to 2. 
If IFLG=2, 
then it is assumed that elimination is already performed and the 
triangular factors are stored in the same array A<!--hbox-->. In this case, only the 
linear equations are solved. DET is a real variable specifying the 
scaled value 
of the determinant, IDET is an integer variable which contains the 
exponent part of the determinant. The actual value of the 
determinant is <span class="roman">DET</span>&times;2<sup><span class="roman">IDET</span></sup>. INC is an integer array of 
length  <span class="roman">M</span>&times;<span class="roman">N</span>, which contains information about 
row interchanges used during Gaussian elimination. X is a real 
array of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which should contain 
the right-hand sides of the linear equations. After execution, the solution 
will be returned in the same array. IER is the error parameter. 
IER=735 implies that one of the pivots vanishes during 
elimination and hence the equations cannot be solved. In this 
case, the determinant will vanish, but that does not cause any 
problem for finding eigenvalues, which are obtained by finding zeros 
of the determinant. This subroutine is called by subroutines <a href="appendixb.htm#fdm"> FDM</a> and <a href="appendixb.htm#gevp"> GEVP</a><!--hbox-->. 
GAUBLK<tt>_</tt>C is the complex version of GAUBLK, when the matrix is complex. 

<div class="p"><!----></div>
 <br /><br /><a name="setmat"> </a>
 <b>203.&nbsp;SETMAT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/setmat.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fdm.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to setup the finite difference matrix for a 
system of first-order differential equations with separable boundary 
conditions, using a central difference approximation. This subroutine 
is called by subroutines <a href="appendixb.htm#fdm"> FDM</a> and <a href="appendixb.htm#gevp"> GEVP</a><!--hbox-->. N is the number 
of mesh points, M is the number of first-order differential equations 
in the system, ML is the number of boundary conditions at the first 
boundary. A is a real array of length  (<span class="roman">M</span><span class="roman">+</span><span class="roman">ML</span>)&times;2<span class="roman">M</span>&times;<span class="roman">N</span>, which will contain the finite difference matrix 
for the linearised equations. BC is a real array of length  
(<span class="roman">M</span><span class="roman">+</span><span class="roman">ML</span>)&times;(<span class="roman">M</span>+1), which is used to store information 
about the boundary conditions. X and XC are real arrays of length 
<span class="roman">M</span>&times;<span class="roman">N</span>. X should contain the approximation 
to solution of the boundary value problem, while after execution, 
XC will contain the right-hand sides of the finite difference equations. 
X(I, J) should contain the Ith component at Jth mesh point. 
T is a real array of length  N containing the mesh points. 
PAR is a real array containing parameters, which are passed on to the 
subroutines EQN and BCS<!--hbox-->. EQN and BCS are the names 
of subroutines for defining the differential equation and 
the boundary conditions, respectively. These subroutines must be supplied 
by the user, as explained in the write up for subroutines <a href="appendixb.htm#fdm"> FDM</a> or <a href="appendixb.htm#gevp"> GEVP</a><!--hbox-->. 
SETMAT<tt>_</tt>C is the complex version of SETMAT, when the matrix is complex. 

<div class="p"><!----></div>
 <br /><br /><a name="bspode"> </a>
 <b>204.&nbsp;BSPODE&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/bspode.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/bspode.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a two-point boundary value problem 
with separable boundary conditions, 
using expansion method with B-spline basis functions 
as explained in Section&nbsp;12.10. NK is the number of knots to be used. 
K is the order of B-splines to be used. <span class="roman">K</span>=4 corresponds to cubic 
B-splines, while <span class="roman">K</span>=2 gives linear B-splines, etc. The order may 
need to be increased to get higher accuracy. 
M is the number of 
first-order differential equations in the system. ML is the number of 
boundary conditions at the first boundary (i.e., T(1)). PAR is a real 
array which is passed on to the subroutine EQN and BCS for calculating 
the required information about the equation and the boundary  
conditions. This array can be used to pass any parameters that may 
be required by these subroutines. This array is not used by subroutine 
BSPODE, or any other routine called by it except EQN and BCS, and its 
size can be arbitrary depending on the requirements. X is a real array 
of length  <span class="roman">M</span>&times;<span class="roman">N</span>, which  
will contain the computed solution. X(I, J) will contain the Ith component 
of solution at TX(J). The first dimension of X must be equal to M in 
the calling program. 
A is a real array of length (<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)&times;<span class="roman">M</span> containing 
the coefficients of expansion in terms of B-splines. At the time of 
calling it should contain the initial guess to the coefficients, while 
after execution it will contain the calculated coefficients. 
If the problem is linear, then there is no need for initial approximation 
and this array could be initialised to zero or any other convenient 
value. The subroutine BSPODE treats it as a two-dimensional array of 
dimension (<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2,<span class="roman">M</span>) with A(I, J) containing the 
coefficient of Ith basis function in Jth component of the solution. 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">X</span><sub>j</sub>(t)=</td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2</small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">A</span>(i, j)&#981;<sub>i</sub>(t),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j=1,&#8230;,<span class="roman">M</span>. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.93)</td></tr></table>
</td></tr></table>

 
Unfortunately, there is no provision to pass the first 
dimension of the array X or A, as specified in the calling program. 
Hence, 
to obtain meaningful results, the first dimension of the array A in the calling 
program must also be exactly equal to <span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2. 
This problem arises because, while 
solving the system of equations, it is convenient to assume that 
the array elements are stored in consecutive positions without any gaps. 
T is a real array of length  NK, containing the knots 
t<sub>j</sub>, (j=1,&#8230;,<span class="roman">NK</span>), to be used for calculating the B-spline 
basis functions. 
This array must be supplied by the user. The knots must be in ascending 
order with T(1) and T(NK) as the two boundaries. 
N is the number of mesh points to be used for obtaining the equations 
connecting the coefficients of expansion, <span class="roman">N</span> &#8805; <span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2. 
TX is a real array of length N containing the mesh points 
to be used for calculating the coefficients. This array must be supplied 
by the user if IFLAG &gt; 1, otherwise the subroutine computes the 
elements of this array assuming uniform spacing and covering the 
interval T(1) to T(NK). The solution will be calculated at all these 
points. If the solution is required at any other point then function 
<a href="appendixb.htm#bspevl"> BSPEVL</a> can be used with the calculated coefficients. 
EQN is the name of the subroutine, which defines the differential equations. 
The differential equation is assumed to be in the 
form B<b>y</b>&#8242;=<b>f</b>(t,<b>y</b>), where B is a <span class="roman">M</span>&times;<span class="roman">M</span> 
matrix and <b>f</b> is a vector function of length M<!--hbox-->. The matrix B 
must be nonsingular. The elements of B and <b>f</b> at a given point T 
are calculated by the subroutine EQN<!--hbox-->. Apart from this, it 
must also calculate the Jacobian &#8706;f<sub>i</sub>/&#8706;y<sub>j</sub> (stored in the 
array A). BCS is 
the name of the subroutine, which specifies the boundary conditions. 
The boundary conditions are defined by functions g<sub>i</sub>(t<sub>1</sub>,<b>y</b><sub><b>1</b></sub><b>)</b><b>=</b><b>0</b> for 
i=1,&#8230;,<span class="roman">ML</span> at the first point t=<span class="roman">T</span><span class="roman">(</span><span class="roman">1</span><span class="roman">)</span>, and 
g<sub>i</sub>(t<sub>NK</sub>,<b>y</b><sub><b>NK</b></sub><b>)</b><b>=</b><b>0</b> for i=<span class="roman">ML</span><span class="roman">+</span><span class="roman">1</span>,&#8230;,<span class="roman">M</span> at the last point 
t=<span class="roman">T</span><span class="roman">(</span><span class="roman">NK</span><span class="roman">)</span>. Apart from the functions g<sub>i</sub>, this subroutine should 
also calculate the Jacobian matrix &#8706;g<sub>i</sub>/&#8706;y<sub>j</sub> (stored in the 
array BC). The general form of these subroutines is as follows: 

<div class="p"><!----></div>
<br /> <tt><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
<br clear="all" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SUBROUTINE EQN(J,M,ML,PAR,A,B,Y,F,T)
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      IMPLICIT REAL*8(A-H,O-Z)
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      DIMENSION A(M,M),B(M,M),Y(M),PAR(*),F(M)
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      DO I=1,M
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
        F(I)=<span class="roman">f<sub>I</sub>(<span class="roman">T</span>,PAR,<span class="roman">Y</span>)</span>
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
        DO K=1,M
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
          A(K,I)=<span class="roman">&#8706;f<sub>K</sub>/&#8706;<span class="roman">Y</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span></span>
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
 B(K,I)=<span class="roman">b<sub>KI</sub>(<span class="roman">T</span>,PAR)</span>
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      ENDDO
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      ENDDO
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      END
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      SUBROUTINE BCS(M,ML,PAR,BC,G,T1,TN,Y1,YN)
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      IMPLICIT REAL*8(A-H,O-Z)
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      DIMENSION PAR(*),BC(M,M),G(M),Y1(M),YN(M)
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      DO I=1,M
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
        IF(I.LE.ML) THEN
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
          G(I)=<span class="roman">g<sub>I</sub>(<span class="roman">T</span><span class="roman">1</span>,PAR,<span class="roman">Y</span><span class="roman">1</span>)</span>
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
        ELSE
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
          G(I)=<span class="roman">g<sub>I</sub>(<span class="roman">TN</span>,PAR,<span class="roman">YN</span>)</span>
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
        ENDIF
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
        DO J=1,M
<br /><table align="left" border="0"><tr><td width="55" align="right">
</td></tr></table><!--hbox-->
 BC(I,J)=<span class="roman">&#8706;g<sub>I</sub>/&#8706;<span class="roman">Y</span><span class="roman">(</span><span class="roman">J</span><span class="roman">)</span></span>
<br /><table align="left" border="0"><tr><td width="41" align="right">
</td></tr></table><!--hbox-->
      ENDDO
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      ENDDO
<br /><table align="left" border="0"><tr><td width="27" align="right">
</td></tr></table><!--hbox-->
      END
<div class="p"><!----></div>
</tt> It should be noted that these subroutines are same as those required by 
<a href="appendixb.htm#fdm"> FDM</a> except that 
the first dimension of arrays A, B and BC is 
<span class="roman">M</span> instead of <span class="roman">M</span><span class="roman">+</span><span class="roman">ML</span>. Here T, T1 and TN are the values 
of t at relevant points, while the real arrays Y, Y1 and YN contain 
the values of <b>y</b> at these points. In subroutine EQN the parameter 
J identifies the interval at which the functions are evaluated (i.e., 
TX(j)). This index is useful in cases, where the coefficients 
are read in the form of a table. 
WK is a real array of length  

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 <span class="roman">M</span>&times;(<span class="roman">N</span>+1)&times;(<span class="roman">M</span>&times;(<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2)+7) +(<span class="roman">M</span>&times;(<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2))<sup>2</sup>, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.94)</td></tr></table>
</td></tr></table>

 
which is used as 
a scratch space. IFLAG is an integer 
variable which is used as a flag. If IFLAG=0 or 2, then the 
equation is treated as nonlinear and solution will be calculated 
iteratively. If IFLAG=1 or 3, then the equations are treated 
as linear and calculation will be terminated after the first iteration. 
If IFLAG=0 or 1, then the array TX need not be initialised at 
the time of calling as the subroutine will compute the elements 
assuming uniform spacing.  
For other values of IFLAG, the array TX must be supplied by the user. 
REPS is the specified 
accuracy. This parameter is only used to check for the convergence 
of Newton's method, for solution of system of equations 
(only for nonlinear equations i.e., IFLAG=0,2). This parameter 
has no effect on truncation error, which is determined by the knots 
and the order of B-splines. 
IER is the error parameter. IER=705 implies that <span class="roman">N</span> &lt; 3, 
or <span class="roman">M</span> &#8804; <span class="roman">ML</span>, or <span class="roman">ML</span> &#8804; 0, or <span class="roman">N</span> &lt; <span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2, 
in which case, no calculations 
are performed.  
IER=741 implies that the Newton's iteration 
for solving the system of equations fails to converge. 
This subroutine requires subroutine <a href="appendixb.htm#bsplin"> BSPLIN</a>, <a href="appendixb.htm#bspevl"> BSPEVL</a>, <a href="appendixb.htm#svd"> SVD</a> and <a href="appendixb.htm#svdevl"> SVDEVL</a>. 
Apart from these, the subroutines EQN and BCS specifying the problem must 
be supplied by the user. 

<div class="p"><!----></div>
  

<br /><br />
<a name="Integral Equations"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.13&nbsp; INTEGRAL EQUATIONS </b></td></tr></table><!--hboxt-->

<br /> 

<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#fred">FRED</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#fredco">FREDCO</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#funk">FUNK</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#rls">RLS</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#forw">FORW</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#volt">VOLT</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#volt2">VOLT2</a></td>
</tr>
</table>

<div class="p"><!----></div>
<br /><br /><a name="fred"> </a>
 <b>205.&nbsp;FRED&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/fred.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fred.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a linear Fredholm equation 
as defined by Eq.&nbsp;(13.1) using quadrature methods.  M is the number of abscissas to be used in the 
quadrature formula. A and B are real variables specifying respectively, the 
lower and the upper limit of the integral. WT and X are real arrays of length 
M, which will return the weights and abscissas 
used by the quadrature formula. 
F and FC are real arrays of length  M, which will contain the  
calculated solution. F(I) will contain the computed solution at the abscissa 
X(I), while if the trapezoidal rule is used, then FC(I) will contain 
the value 
obtained after applying deferred correction, using the Gregory's formula 
including second-order differences. Array FC is not required for 
other quadrature formulae. Hence, in that case, a dummy array of length one 
may be provided. FG and FKER are the names of the function routines 
provided to calculate the functions g(x) and K(x,t). For Fredholm 
equation of the third kind g(x) is not required, but a dummy routine 
giving some nonzero value (e.g., g(x)=1) should be provided. In fact, 
this function supplies the starting vector for the inverse iteration 
and if necessary a reasonable guess for the eigenfunction may 
be provided via this function. However, in most cases, the inverse 
iteration method does converge to the eigenvalue, even when initial 
vector is far from the eigenvector and such a guess is not essential, 
but it can be used to improve the efficiency. EI is a real variable, 
which gives the initial guess for the eigenvalue of the Fredholm equation 
of the third kind. After execution, EI will contain the calculated eigenvalue. 
For equations of other kinds, EI will be ignored. WK is a real array used 
as a scratch space. The size of this array must be  <span class="roman">M</span><sup>2</sup> 
for Fredholm equations of the first and second kind, while it should be 
2<span class="roman">M</span><sup>2</sup>+<span class="roman">M</span> for equations of the third kind. IWK is 
an integer array of length  M used as a scratch space. IQ is 
an integer variable used to specify the quadrature formula to be used. 
If <span class="roman">IQ</span>=1, then trapezoidal rule is used, for <span class="roman">IQ</span>=2, 
Simpson's 1/3 rule is used, for <span class="roman">IQ</span>=4, 8, 16, 32 a composite 
rule using 4, 8, 16 or 32-point Gauss-Legendre formula is used. If 
IQ is negative, then it is assumed that weights and abscissas are supplied 
in the arrays WT and X<!--hbox-->. Other 
values of IQ will cause an error return. For <span class="roman">IQ</span> &gt; 1 if the number 
of points are not compatible with the composite quadrature formula, then 
the next lower value of M is used. For example, if <span class="roman">IQ</span>=4 and 
<span class="roman">M</span>=11, then computations will be performed using only 8 points, but the 
value of M remains unchanged. In this case, a warning is issued by setting 
IER=&#8722;11. IT is an integer variable, which specifies the kind of 
Fredholm equation to be solved. <span class="roman">IT</span>=1,2 and 3 corresponds to the 
Fredholm equations of the first, second and third kind, respectively. 
This subroutine can only find a real eigenvalue, but it can 
be easily modified to find complex eigenvalues also. 
REPS is a real parameter specifying the required (relative) accuracy in calculating 
the eigenvalues. This parameter is used only if <span class="roman">IT</span>=3. It is 
only passed on to the subroutine INVIT for calculating the eigenvalue. 
IER is the error parameter. IER=706 implies that 
<span class="roman">IT</span> &gt; 3, or <span class="roman">IT</span> &#8804; 0, or the number of points M are not 
sufficient for application of the specified quadrature formula. 
In this case, no calculations are performed. IER=707 implies that 
the value of IQ is not proper, in which case also no calculations are performed. 
IER=&#8722;11 implies that the number of points have been adjusted. 
In this case, the calculations are performed with a smaller value of M, 
which is applicable for the quadrature formula requested. Apart from these, 
other values may be set by subroutines <a href="appendixb.htm#gauelm"> GAUELM</a> and <a href="appendixb.htm#invit"> INVIT</a>, which are called 
by this subroutine. Subroutine FRED requires subroutine GAUELM 
to solve the system of linear equations, and subroutine 
INVIT (for <span class="roman">IT</span>=3) to calculate the eigenvalue and the eigenvector. 
It should be noted that subroutine <a href="appendixb.htm#invit"> INVIT</a> is called with IFLG=0, 
which keeps the shift P constant, to ensure convergence to the nearest 
eigenvalue. Consequently, the convergence could be rather slow in some 
cases. It may be more 
efficient to use other values of IFLG, but in that case, the inverse 
iteration will not necessarily converge to the nearest eigenvalue. 
FUNCTION FG(X) and FUNCTION FKER(X, T) must be supplied by the user. 

<div class="p"><!----></div>
 <br /><br /><a name="fredco"> </a>
 <b>206.&nbsp;FREDCO&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/fredco.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fredco.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a linear Fredholm equation of 
the first or second kind using the collocation 
method. The function is approximated by an expansion of the form 
f(x)=&#8721;<sub>i=1</sub><sup>N</sup> a<sub>i</sub>&nbsp;PHI(i,x). The basis functions PHI(I, X) must 
be supplied by the user. N is the number of points (which equals the 
number of basis functions) to be used in the 
collocation method. A and B are real variables specifying respectively, the 
lower and the upper limit of the integral. 
F is a real array of length  N, which will contain the  
calculated coefficients of the expansion. F(I) contains the coefficient (a<sub>i</sub>) 
of PHI(I, X) in the expansion for the solution. X is a real array of length 
N, which specifies the points to be used for collocation. 
This array must be supplied by the user. REPS and AEPS specify  
the accuracy with which the integrals are to be calculated. 
If <span class="roman">IQ</span>=0, then these parameters are passed on to the subroutine 
ADPINT, while in other cases, these parameters are ignored. 
WK is a real array of length  <span class="roman">N</span><sup>2</sup> used 
as a scratch space. IWK is 
an integer array of length  N used as a scratch space. IQ is 
an integer variable used to specify the treatment of integrals 
required to calculate 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">PSI</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">X</span><span class="roman">)</span>=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>B</small><!--sup
--><br /><br />
<small>A</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">FKER</span><span class="roman">(</span><span class="roman">X</span><span class="roman">,</span> <span class="roman">T</span><span class="roman">)</span>&nbsp;&nbsp;<span class="roman">PHI</span><span class="roman">(</span><span class="roman">I</span><span class="roman">,</span> <span class="roman">T</span><span class="roman">)</span>&nbsp;&nbsp;d<span class="roman">T</span>&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.95)</td></tr></table>
</td></tr></table>

 
If <span class="roman">IQ</span> &#8800; 0, then it is assumed that the function PSI(I, X) is supplied 
separately, while if <span class="roman">IQ</span>=0, then the integrals are calculated using 
the subroutine ADPINT<!--hbox-->. This subroutine uses external function routine <a href="appendixb.htm#funk"> FUNK</a> 
to calculate the integrand, which in turn requires the functions PHI(I, X) and 
FKER(X, T). IT is an integer variable which specifies the kind of 
Fredholm equation to be solved. <span class="roman">IT</span>=1 and 2 corresponds to the 
Fredholm equations of the first and second kind, respectively. 
IER is the error parameter. IER=708 implies that  
<span class="roman">IT</span> &gt; 2, or <span class="roman">IT</span> &#8804; 0, or <span class="roman">N</span> &lt; 1, 
in which case, no calculations are performed. Apart from these, 
other values may be set by the subroutines GAUELM or ADPINT, which are called 
by this subroutine. This subroutine requires subroutine <a href="appendixb.htm#gauelm"> GAUELM</a> 
to solve the system of linear equations, subroutines 
<a href="appendixb.htm#adpint"> ADPINT</a> and <a href="appendixb.htm#kronrd"> KRONRD</a> (for <span class="roman">IQ</span>=0) to evaluate 
the integrals and FUNCTION FUNK(X) 
to evaluate the required integrand. 
Further, the functions FG(X) (=g(x)), PHI(I, X) (=&#981;<sub>i</sub>(x)) 
and FUNCTION FKER(X, T) (=K(x,t), 
for <span class="roman">IQ</span>=0) or FUNCTION PSI(I, X) (for <span class="roman">IQ</span> &#8800; 0) must be supplied 
by the user. The names of these functions routines are fixed and cannot be passed 
on to the subroutine FREDCO, because the functions FKER and PHI 
are called by the function FUNK, and there is no simple way 
of passing on these 
names to FUNK<!--hbox-->. In order to maintain consistency, the names of other function 
routines are also not passed on to the subroutine. Common block 
ZZFRED is used to pass on variables to FUNK, XI and II in the 
common block are respectively the values of x and i for 
evaluating the integrand. 
This subroutine 
can also be used to solve linear Volterra equations, by defining the kernel 
to be zero for t &gt; x. 

<div class="p"><!----></div>
 <br /><br /><a name="funk"> </a>
 <b>207.&nbsp;FUNK&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/funk.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/fredco.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Function routine to calculate the integrand for calculating 
&#968;<sub>i</sub>(x) as required by subroutine <a href="appendixb.htm#fredco"> FREDCO</a><!--hbox-->. Function FKER(X, T) is the 
kernel K(x,t), while PHI(I, T) are the basis functions &#981;<sub>i</sub>(t) used 
for the expansion. Names of these routines have to be the same as 
there is no provision to pass on the names to FUNK<!--hbox-->. 
The common block ZZFRED is used to pass on the values of 
X and I. 

<div class="p"><!----></div>
 <br /><br /><a name="rls"> </a>
 <b>208.&nbsp;RLS&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/rls.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/rls.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a linear inverse problem in one 
dimension using Regularised Least Squares (RLS) technique with B-spline 
basis functions. The inverse problem is defined as 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 d<sub>i</sub>=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>b</small><!--sup
--><br /><br />
<small>a</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
K<sub>i</sub>(t)f(t)&nbsp;&nbsp;dt, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=1,2,&#8230;,<span class="roman">NM</span><span class="roman">,</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <span class="roman">(</span><span class="roman">B</span><span class="roman">.</span><span class="roman">96</span><span class="roman">)</span></td></tr></table>
</td></tr></table>

 
where the unknown function f(t) is to be obtained using given data 
d<sub>i</sub> and kernels K<sub>i</sub>(t) for all i. The corresponding forward problem 
where d<sub>i</sub> are calculated for a given f(t) is solved by the subroutine 
<a href="appendixb.htm#forw"> FORW</a><!--hbox-->.  
The kernel is given in the form 
of table of values at a grid of points in t covering the required 
interval. Alternately, it is possible to provide directly the coefficients 
of matrix which are 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 a<sub>ij</sub>=</td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>b</small><!--sup
--><br /><br />
<small>a</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
K<sub>i</sub>(t)&#981;<sub>j</sub>(t)&nbsp;&nbsp;dt&nbsp;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.97)</td></tr></table>
</td></tr></table>

 
where &#981;<sub>j</sub>(t) is the jth basis function. This form is more 
efficient to use and can be utilised when many options are to be 
tried with the same data points and set of knots. 
The subroutine itself 
calculates these integrals and hence during second and subsequent 
calls this option can be used, provided the data points and knots 
have not been modified. Using the coefficients a<sub>ij</sub> instead of 
kernels also saves storage space. 
It may be noted 
that for this to be useful, d<sub>i</sub> need not have the same values 
between different 
sets, only the set of NM kernels should be the same between different 
inversion problems. 
This option is useful as the solution will 
need to be calculated with different values of regularisation parameter 
before the optimum value is found. This routine can also 
estimate the errors in computed solution using Monte Carlo 
simulation. 

<div class="p"><!----></div>
NK is the number of knots defining the B-spline basis functions. 
The number of basis functions would be <span class="roman">NK</span>+<span class="roman">K</span>&#8722;2. 
XO is a real array of length at least  NK 
which should contain the knots for defining the B-splines. 
The knots must be in ascending order with XO(1) containing the first 
knot. 
K is the order of B-splines required, <span class="roman">K</span>=2 for linear B-splines 
while <span class="roman">K</span>=4 for cubic B-splines, etc. NR is the number of points used 
for defining the kernels. R is a real array of length NR, which should 
contain the points r<sub>i</sub> at which kernel values are available. This array 
should be in ascending order. The same set of points are used to 
calculate the solution after the coefficients of expansion are obtained. 
Hence, this array will be required even if matrix coefficients are 
directly available (unless <span class="roman">NR</span>=0). RKER is a real array of 
length <span class="roman">IK</span>&times;<span class="roman">NR</span> containing the kernels for the 
inverse problem. RKER(i, j) should contain K<sub>i</sub>(r<sub>j</sub>). This array 
must be supplied if IFLG &lt; 2, otherwise it is not required. 
The mesh r<sub>j</sub> need not be uniformly spaced as the integrals are 
evaluated using the trapezoidal rule. Since the accuracy of trapezoidal 
rule is low and also because in realistic problems the kernels are generally highly 
oscillatory, a large number of mesh points will be required to 
define the integrals to a good accuracy. IK is the first dimension 
of arrays RKER, AC and A, as specified in the calling program. IK 
must be at least <span class="roman">NM</span><span class="roman">+</span><span class="roman">NS</span>. AC is a real array of length 
<span class="roman">IK</span>&times;(<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) containing the coefficients of the 
matrix defining the inversion problem. AC(i, j) should contain 
the coefficient a<sub>ij</sub> defined by (<span class="roman">B</span>.97). If IFLG &lt; 2, 
these coefficients are calculated by evaluating the integrals in 
(<span class="roman">B</span>.97)&nbsp;using the trapezoidal rule. These calculations require 
substantial computing and hence on subsequent attempts the 
calculations can be suppressed by using IFLG=2, 3. The matrix 
coefficients depend on the kernels (and the number of data points) 
and the knots and order of 
B-splines. Thus if these are not modified between two calls, it 
is preferable to use IFLG=2 to find the solution using 
pre-calculated coefficients. If either the kernels or basis functions 
are modified then IFLG should be reset to 0 to force calculations 
of the coefficients once again. 
NM is the number of data points (and kernels) in the inversion problem. 
For each data point, the corresponding kernel must be supplied. 
NS is the number of points to be used for calculating the regularisation 
term. The subroutine chooses a uniform mesh covering the full interval 
for this purpose. ALP is the regularisation parameter, which must be 
positive. IDE is an integer parameter, which specifies the order 
of derivative to be used for regularisation. IDE should be 1 or 2 
for first or second derivative smoothing. DI is a real array of 
length NM, which should contain the data d<sub>i</sub>, for inversion. 
DE is a real array of length NM, containing the estimated errors in 
d<sub>i</sub>. These errors must be positive. DF is a real array of length 
NM, which will contain the normalised residuals obtained by fit. 
If DS(I) is the computed value of DI(I) using the solution, then 
the residual DF(I)=(DI(I)&#8722;DS(I))/DE(I). Ideally, these residuals 
should have a Gaussian distribution with zero mean and unit variance. 
A significant trend in the residual would generally imply that 
ALP should be reduced or number of knots is not sufficient to 
represent the solution. F is a real array of length NR which will 
contain the calculated solution at R(I). B is a real array of length 
<span class="roman">NM</span><span class="roman">+</span><span class="roman">NS</span>, which will contain the coefficients of expansion. The computed 
solution is 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 f(t)=</td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">B</span>(i)&#981;<sub>i</sub>(t). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.98)</td></tr></table>
</td></tr></table>

 
These coefficients can be used to compute the solution at any required 
point using FUNCTION <a href="appendixb.htm#bspevl"> BSPEVL</a><!--hbox-->. Although, the number of coefficients is 
only <span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span>, the rest of the array is used as scratch space. 

<div class="p"><!----></div>
IFLG is an integer parameter, which specifies the type of calculation 
required. If IFLG=0, the matrix coefficients are computed using the 
kernels. The system of equations is solved to find the solution and 
IFLG is set to 4 after calculations. The calculation of integrals to 
find matrix coefficients take significant time and hence this option 
should be used only when the coefficients are not available. After 
the first call to RLS, the coefficients are computed and returned in 
array AC<!--hbox-->. These coefficients should be used again if another solution 
is required with same set of kernels but with different regularisation 
(ALP or IDE) or with different data points DI for the same set of kernels. 
If IFLG=1, the matrix coefficients are computed using the 
kernels. The system of equations is setup and the SVD of the matrix is 
computed, but the solution for given DI is not computed. In this 
case also IFLG is set to 4 after calculations. Thus during subsequent 
calls solution for different DI's can be computed using
<a href="appendixb.htm#svdevl">SVDEVL</a>. 
If IFLG=2, the matrix coefficients are assumed to be known and 
available in array AC<!--hbox-->. These coefficients are used to setup the 
matrix and find the solution and IFLG is set to 4 after calculations. 
This option is more efficient than IFLG=0, and should be used when 
the coefficients have already been computed. 
If IFLG=3, the matrix coefficients are assumed to be known and 
available in array AC<!--hbox-->. These coefficients are used to setup the 
matrix and its SVD is computed, but the solution for given DI is 
not computed. In this 
case also IFLG is set to 4 after calculations. Thus during subsequent 
calls solution for different DI's can be computed using the subroutine SVDEVL<!--hbox-->. 
If IFLG=4, the SVD of equation matrix is assumed to be available in 
arrays, A, AV and SIGMA<!--hbox-->. These can be used to compute the solution for 
a given data set DI very efficiently. It may be noted that the 
matrix of equations depends only on the knots, kernels, regularisation and errors DE, 
but not 
on DI<!--hbox-->. So if only DI is changed there is no need to recompute the 
SVD<!--hbox-->. This is very useful, since on many applications several 
different data sets have to be inverted. Another application comes 
in estimating errors in computed inverse solution. For this purpose 
we need to solve the problem with different DI, which differ only 
in addition of different realisation of random errors to same 
basic data. Thus for estimating the errors in inversion although 
several different solutions are required, the net effort is not 
much since the SVD, which takes much more time, is computed only once. 
It should be noted that in all cases the subroutine sets IFLG to 4 
so if during subsequent call the matrix needs to be changed, IFLG 
must be set to 0 or 2 before calling. This would be needed if 
either the knots, kernels or errors DE are changed. If only  
errors are modified, then IFLG can be set to 2, to avoid 
computation of coefficients. While if kernels or knots are modified then 
IFLG should be set to 0, so that the coefficients are recomputed. 

<div class="p"><!----></div>
IER is the error parameter. IER=709 implies that <span class="roman">NM</span> &#8804; <span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2 or <span class="roman">IK</span> &lt; <span class="roman">NM</span><span class="roman">+</span><span class="roman">NS</span> or <span class="roman">IV</span> &lt; <span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2. 
IER=710 implies that ALP &lt;  0 or IDE &lt;  1 
or IDE &gt;  2. In all these cases no calculations are done. 
Other values may be set by subroutines <a href="appendixb.htm#bsplin"> BSPLIN</a> or <a href="appendixb.htm#svd"> SVD</a> which are called. 
It may be noted that the subroutine allows solution to be computed 
even when ALP=0, although the solution would be unacceptable 
in this case. 
REPS is the required accuracy for solution of equations using SVD<!--hbox-->. 
All singular values less than REPS times the largest singular 
value will be set to zero during solution. 
CHISQ is the computed value of &#967;<sup>2</sup> define by 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 &#967;<sup>2</sup>=</td><td nowrap="nowrap" align="center">
<small><span class="roman">NM</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<span class="roman">DF</span>(i)<sup>2</sup> = </td><td nowrap="nowrap" align="center">
<small><span class="roman">NM</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">DE</span>(i)<br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
<span class="roman">DI</span>(i)&#8722;</td><td nowrap="nowrap" align="center">
<small><span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;<span class="roman">2</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
a<sub>ij</sub><span class="roman">B</span>(j)</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.99)</td></tr></table>
</td></tr></table>

 
SUMD is the value of regularisation term computed at the solution, 
for IDE=2, it is given by 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 <span class="roman">SUMD</span>=</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
<span class="roman">R</span><span class="roman">(</span><span class="roman">NR</span><span class="roman">)</span>&#8722;<span class="roman">R</span>(1)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><span class="roman">NS</span>&#8722;1<br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small><span class="roman">NS</span></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
d<sup>2</sup>f
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>dt<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
(t<sub>i</sub>)</td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.100)</td></tr></table>
</td></tr></table>

 
where t<sub>i</sub> are the points at which smoothing is applied. For IDE=1 
the second derivative is replaced by first derivative. The values 
of CHISQ and SUMD for different values of ALP can be used to infer 
the optimal value of ALP using L-curve. A is a real array of length 
<span class="roman">IK</span>&times;(<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) containing the matrix U of SVD of the matrix of 
equations. AV is a real array of length <span class="roman">IV</span>&times;(<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) 
containing the matrix V of SVD of the matrix of equations. IV is the 
first dimension of array V as declared in the calling program. SIGMA 
is a real array of length (<span class="roman">NK</span><span class="roman">+</span><span class="roman">K</span>&#8722;2) containing the singular 
values of the matrix. If IFLG &lt;  4, the arrays A, AV and 
SIGMA will be calculated, otherwise they must be supplied. 
NSIM is the number of data sets to be used for Monte Carlo simulation 
for estimating the errors in solution. If NSIM &lt; 2, error 
estimates are not calculated. FE is a real array of length NR which 
will contain the estimated errors. FE(I) would contain the estimated 
error in F(I). This is calculated only if NSIM &gt; 1. 
WK is a real array of length 
<span class="roman">NR</span>&times;NSIM+<span class="roman">NM</span><span class="roman">+</span><span class="roman">NS</span>+4<span class="roman">NK</span>+5<span class="roman">K</span>+2, 
used as scratch space for simulations if NSIM &gt; 1. 
This subroutine requires subroutines <a href="appendixb.htm#bsplin"> BSPLIN</a>, <a href="appendixb.htm#bspevl"> BSPEVL</a>, <a href="appendixb.htm#svd"> SVD</a>, <a href="appendixb.htm#svdevl"> SVDEVL</a> and 
<a href="appendixb.htm#rangau"> RANGAU</a>. 

<div class="p"><!----></div>
  <br /><br /><a name="forw"> </a>
 <b>209.&nbsp;FORW&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/forw.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/rls.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 To solve the forward problem corresponding to the 
inverse problem solved by <a href="appendixb.htm#rls"> RLS</a><!--hbox-->. This routine evaluates the required 
integrals using the trapezoidal rule. 
NP is the number of points used in defining the kernels. NM is 
the number of data points, d<sub>i</sub> to be calculated. This should be 
the same as the number of kernels that are supplied in RKER<!--hbox-->. 
R is a real array of length <span class="roman">NP</span> containing the points 
at which values of kernels are available. 
RKER is a real array of length <span class="roman">IK</span>&times;<span class="roman">NP</span> containing 
the kernels for the inverse problem, RKER(i, j)=K<sub>i</sub>(<span class="roman">R</span>(j)). 
These kernels are the same as what are used by RLS for inversion. 
IK is the first dimension of RKER as declared in the calling program, 
<span class="roman">IK</span> &#8805; <span class="roman">NM</span>. DI is a real array of length NM, which will 
contain the calculated data points d<sub>i</sub>, using the kernels. 
F is a real array of length NP containing the function values, 
<span class="roman">F</span>(i)=f(<span class="roman">R</span>(i)). If IFLG=0, the function values are 
calculated using user supplied function routine FUN, otherwise, 
these values must be supplied while calling the subroutine. 
FUN is the name of the function routine to calculate the given function. 
This is used only if IFLG=0, otherwise the function values are to 
be supplied in the array F<!--hbox-->. In the latter case a dummy routine will 
still be required to satisfy the compiler or linker. IER is the 
error parameter, IER=711 implies that <span class="roman">IK</span> &lt; <span class="roman">NM</span> and no 
calculations are done. IFLG is an integer parameter that is used as 
a flag to decide the type of computation required. If IFLG=0, 
then the function values are calculated using a user supplied 
routine FUN<!--hbox-->. These values are returned in the array F and IFLG is 
set to 1, so that next time the values need not be calculated. 
If data points corresponding to different kernels are required 
then IFLG need not be reset. If a different FUN is used next time 
then IFLG must be reset to 0. For other values of IFLG the 
function values must be supplied in the array F<!--hbox-->. FUNCTION FUN(X) 
must be supplied by the user to calculate f(x). 
If the data points DI calculated by this routine are supplied to 
<a href="appendixb.htm#rls"> RLS</a> without adding any errors and using the same kernels with very 
small RLM, then the 
inverted function should match the function FUN used by FORW to a 
very good accuracy. 

<div class="p"><!----></div>
  <br /><br /><a name="volt"> </a>
 <b>210.&nbsp;VOLT&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/volt.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/volt.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve linear Volterra equations using quadrature 
method based on the trapezoidal rule. N is the number of points at which 
the function value needs to be estimated. A is a real variable specifying 
the lower limit of the integral. It is also the 
initial point, from which the solution is required. H is a real variable 
specifying the step size to be used in the quadrature method. The points 
are assumed to have a uniform spacing of H<!--hbox-->. F and X are real arrays of 
length  N, which will contain the calculated value of the solution 
at a set of uniformly spaced points. F(I) is the calculated solution at 
X(I). FG and FKER are the names of the function routines used to calculate 
the functions g(x) and the kernel K(x,t), respectively. IT is an 
integer variable specifying the kind of integral equation. If 
<span class="roman">IT</span>=2, Volterra equation of the second kind are solved, while for 
other values of IT a Volterra equation of the first kind is solved. 
If <span class="roman">IT</span>=&#8722;1, then the computed values are smoothed as explained in 
Section&nbsp;13.8. This option can be used only for equations of the first kind. 
It should be noted that smoothing cannot be applied to the first and 
the last point. 
IER is the error parameter. IER=712 implies that <span class="roman">N</span> &lt; 3, in which 
case no calculations are performed. IER=751 implies that the 
denominator is zero at some stage, in which case, no further calculations 
can be performed. This failure usually occurs for equations of the first kind 
when either <span class="roman">H</span>=0 or K(x,x)=0. FUNCTION FG(X) and FUNCTION FKER(X, T) 
must be supplied by the user. 

<div class="p"><!----></div>
 <br /><br /><a name="volt2"> </a>
 <b>211.&nbsp;VOLT2&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/volt2.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/volt2.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve nonlinear Volterra equation of the second 
kind 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 </td><td align="left" class="cl">&#8992;<br />&#8993;
</td><td nowrap="nowrap" align="center">
<small>x</small><!--sup
--><br /><br />
<small><span class="roman">A</span></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
K(x,t,f(t))&nbsp;&nbsp;dt=f(x)+g(x),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.101)</td></tr></table>
</td></tr></table>

 
using quadrature 
method based on the Simpson's rule. N is the number of points at which 
the function value needs to be estimated. A is a real variable specifying 
the lower limit of the integral. It is also 
the initial point from which the solution is required. H is a real variable 
specifying the step size to be used in the quadrature method. The points 
are assumed to have a uniform spacing of H<!--hbox-->. F and X are real arrays of 
length  N, which will contain the calculated value of the solution 
at a set of uniformly spaced points. F(I) is the calculated solution at 
X(I). FG and FKER are the names of the function routines used to calculate 
the functions g(x) and the kernel K(x,t,f), respectively. 
REPS is a real parameter, which specifies the (relative) accuracy to which the 
resulting nonlinear algebraic equations are solved. This parameter does not control the 
truncation error, which is determined by H<!--hbox-->. It is only used to 
decide the termination criterion for the fixed-point iteration, while 
solving the nonlinear equations for F(I). 
IER is the error parameter. IER=712 implies that <span class="roman">N</span> &lt; 3, in which 
case no calculations are performed. IER=752 implies that the 
fixed-point iteration fails to converge at some point, in which case, 
the calculations are aborted at that point. 
FUNCTION FG(X) and FUNCTION FKER(X, T, F) must be supplied by the user. 
It may be noted that FKER is not the kernel in the usual sense since 
it also includes the unknown function f(t) as it appears inside the 
integral in Eq.&nbsp;(<span class="roman">B</span>.101). 

<div class="p"><!----></div>
 

<br /><br />
<a name="Partial Differential Equations"> </a>

<table align="center" border="0"><tr><td>
<b> <span class="roman">B</span>.14&nbsp; PARTIAL DIFFERENTIAL EQUATIONS </b></td></tr></table><!--hboxt-->

<br />
<table BORDER=0 WIDTH="100%">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#crank">CRANK</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#lines">LINES</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#adm">ADM</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#lax">LAX</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#sor">SOR</a></td>
<td>&nbsp;&nbsp;&nbsp; <a href="#adi">ADI</a></td>
</tr>
</table>
<br />All subroutines in this chapter are simple implementations of 
finite difference 
methods. Although these subroutines may accept equations in somewhat 
general form with variable coefficients, the result may not be reliable in 
all cases. For example, if the coefficient A of the parabolic equation 
in <a href="appendixb.htm#crank"> CRANK</a> is negative in some range of (x,t) values, no reliable solution  
can be computed. The subroutine 
does not check for such inconsistencies and no error message will be 
issued. Similarly, some subroutines allow for rather general boundary 
conditions, but the accuracy may be only first order in &#8710;t, 
if the boundary conditions depend on time explicitly. 
Further, for special differential equations, it is possible 
to improve the efficiency significantly by writing the difference 
equations directly without calculating the coefficients. Similarly, 
the boundary conditions can be implemented directly to improve efficiency 
in some of the subroutines (e.g., <a href="appendixb.htm#adi"> ADI</a>). On the other hand, 
those subroutines which 
accept boundary condition in simple Dirichlet form only, can be modified 
to incorporate more general boundary conditions. Hence, these 
subroutines can only be treated as concrete (and straightforward) 
examples of implementing 
the algorithms covered in Chapter 14. They are not expected to be 
particularly efficient or robust. Users are expected to modify these 
routines to suit their problems. 

<div class="p"><!----></div>
 <br /><br /><a name="crank"> </a>
 <b>212.&nbsp;CRANK&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/crank.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/crank.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a linear parabolic equation of the form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;t<br /></td><td nowrap="nowrap" align="center">
=A(x,t)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+ B(x,t)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
+C(x,t)u+D(x,t),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.102)</td></tr></table>
</td></tr></table>

 
subject to 
boundary conditions 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 A<sub>0</sub>(t)u(<span class="roman">X</span><span class="roman">0</span>,t)+B<sub>0</sub>(t)</td><td nowrap="nowrap" align="center">
&#8706;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
u(<span class="roman">X</span><span class="roman">0</span>,t)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=F<sub>0</sub>(t),</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6> </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 A<sub>n</sub>(t)u(<span class="roman">XN</span>,t)+B<sub>n</sub>(t)</td><td nowrap="nowrap" align="center">
&#8706;
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
u(<span class="roman">XN</span>,t)</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">=F<sub>n</sub>(t),</td></tr></table></td></tr></table>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.103)</td></tr></table>

 
using the Crank-Nicolson difference scheme (14.29). Although the coefficients in the boundary conditions are functions 
of time, if B<sub>0</sub>=0 at some time step, then it must be so at every time 
step. The same is true for the coefficient B<sub>n</sub>. This essentially means that if 
boundary condition is of Dirichlet type, it should remain so at all times. 
T is the initial value of time. 
After execution, it is replaced by the value of t at the last point. 
DT is the time step to be used in the computations. (<span class="roman">X</span><span class="roman">0</span>,<span class="roman">XN</span>) 
is the range of x values over which the equation needs to be solved. 
NT is the number of time steps each of length DT, over which the equation 
is to be integrated. NX is the number of mesh points in the X direction. 
X is a real array of length  NX, which contains the mesh points in 
X direction. This array need not be initialised at input, since the subroutine 
assumes a uniform mesh spacing and calculates the required mesh points. 
U is a real array of length  NX, containing the solution at some 
time step. This array can be used to supply the 
initial values, while after execution, it will contain the solution at 
the required time. COF and BC are the names of the subroutines used 
to calculate the coefficients in the differential 
equation and the boundary conditions, 
respectively. SUBROUTINE COF(X, T, A, B, C, D) and  
SUBROUTINE BC(T, X0, XN, A0, B0, F0, AN, BN, FN) must be supplied by the user. 
Subroutine COF should 
calculate the coefficients A, B, C, D at a given value of X and T<!--hbox-->. 
Subroutine BC should calculate the coefficients A0, B0, F0, AN, BN and FN 
for a given value of T at the end points X0 and XN<!--hbox-->. FIC is the name 
of the 
function routine, which may be used to calculate the initial values for 
the solution, when IFLG=0. FUNCTION FIC(X, T) must be supplied by the 
user if IFLG=0. This routine calculates the solution u(x,t) at the 
initial time T<!--hbox-->. For other values of IFLG a dummy function routine FIC 
may be required to satisfy the Fortran compiler or the linker. 
IER is the error parameter. 
IER=713 implies that <span class="roman">DT</span>=0, or <span class="roman">XN</span>=<span class="roman">X</span><span class="roman">0</span>, or 
<span class="roman">NX</span> &#8804; 2, in which case, no calculations are performed. 
IER=761 implies that the difference equations are singular 
and the solution cannot be calculated. This problem may arise due to some 
error in specifying the equation or the boundary conditions. IFLG is 
an integer variable used as a flag. If IFLG=0, the initial values 
are calculated using the function routine FIC supplied by the user. 
For other values of IFLG the initial values must be supplied in the 
array U at the time of calling. In any case, the subroutine sets IFLG to 
1, so that during subsequent calls to the subroutine, the initial values 
are taken from the array U<!--hbox-->. This subroutine can be used to calculate the 
solution at several values of T by calling it repeatedly, after changing 
DT and NT appropriately. Other variables should not be changed. WK is 
a real array of length  8&times;<span class="roman">NX</span> used as a scratch space 
by the subroutine. 

<div class="p"><!----></div>
 <br /><br /><a name="lines"> </a>
 <b>213.&nbsp;LINES&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/lines.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/lines.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a system of nonlinear parabolic 
equations of the form 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&#8706;u<sub>i</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;t<br /></td><td nowrap="nowrap" align="center">
=f<sub>i</sub></td><td align="left" class="cl">&#x239B;<br />&#x239D;
</td><td nowrap="nowrap" align="center">
x,t,<b>u</b>,</td><td nowrap="nowrap" align="center">
&#8706;<b>u</b>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
, </td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup><b>u</b>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<sup>2</sup><br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;
</td><td nowrap="nowrap" align="center">
,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (i=1,2,&#8230;,<span class="roman">NE</span>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.104)</td></tr></table>
</td></tr></table>

 
subject to Dirichlet boundary conditions <b>u</b>(<span class="roman">X</span><span class="roman">0</span>,t)=<b>g</b><sub><b>1</b></sub>(t) 
and <b>u</b>(<span class="roman">XN</span>,t)=<b>g</b><sub><b>2</b></sub>(t), using the method of lines. 
This subroutine is 
actually used through the subroutines <a href="appendixb.htm#mstep"> MSTEP</a> or <a href="appendixb.htm#rkm"> RKM</a> of Chapter&nbsp;12. Since the 
system of resulting ordinary differential equations are expected to be stiff, 
it is preferable to use the 
subroutine MSTEP with <a href="appendixb.htm#gear"> GEAR</a><!--hbox-->. Subroutine LINES specifies the 
system of ordinary differential equations, as required by the subroutine 
MSTEP (subroutine DIF in the arguments for MSTEP). 
The parameters for the 
partial differential equations are passed via the common block ZZLINE<!--hbox-->. 
The relevant variables in this common block must be initialised before 
calling the subroutine MSTEP<!--hbox-->. NX is the number of mesh points in the x 
direction. NE is the number of parabolic equations in the system. 
DX is the step size in x direction. (<span class="roman">X</span><span class="roman">0</span>,<span class="roman">XN</span>) 
is the interval over which the solution is to be calculated. Since the 
boundary conditions are assumed to be in the Dirichlet form, the solution at the 
end points need not be calculated. Hence, the number of ordinary differential 
equations <span class="roman">N</span>=(<span class="roman">NX</span>&#8722;2)<span class="roman">NE</span>. X is a real array of length 
 <span class="roman">NX</span>&#8722;2, containing the mesh points x<sub>i</sub>, excluding the 
end points. This array must be initialised before calling the subroutine 
MSTEP<!--hbox-->. The dimension of this and other arrays in common block must match 
that declared in the calling program. U0 and UN are real arrays of length 
NE, containing the boundary values (at X0 and XN) 
of the solution at the current 
time. These arrays need not be initialised before calling MSTEP, since 
the boundary values are calculated by subroutine LINES using a user 
supplied subroutine BC<!--hbox-->. UX is a real array of length  
2&times;<span class="roman">NE</span>, used as a scratch space to store intermediate 
numbers by subroutine LINES<!--hbox-->. 
The arguments of LINES have the same definition as specified for subroutine 
DIF as required by <a href="appendixb.htm#mstep"> MSTEP</a> or <a href="appendixb.htm#rkm"> RKM</a><!--hbox-->. T is the value of t at which the 
derivatives of solution are required. N is the number of ordinary 
differential equations (which would be (<span class="roman">NX</span>&#8722;2)<span class="roman">NE</span>). 
U and DU are real arrays of length N<!--hbox-->. U will specify the values of 
solution at required point and DU will contain the time derivative of 
all these functions as calculated by LINES<!--hbox-->. 

<div class="p"><!----></div>
This subroutine requires subroutines FCN and BC to supply the information 
about the equations and the boundary conditions.  
SUBROUTINE FCN(NE, X, T, U, UX, UXX, DU) calculates the derivatives  

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<span class="roman">DU</span><span class="roman">(</span><span class="roman">I</span><span class="roman">)</span> = </td><td nowrap="nowrap" align="center">
&#8706;u<sub>i</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;t<br /></td><td nowrap="nowrap" align="center">
=f<sub>i</sub>(<span class="roman">X</span><span class="roman">,</span> <span class="roman">T</span><span class="roman">,</span><span class="roman">U</span><span class="roman">,</span><span class="roman">UX</span><span class="roman">,</span> <span class="roman">UXX</span>), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="roman">I</span>=1,&#8230;,<span class="roman">NE</span>), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.105)</td></tr></table>
</td></tr></table>

 
for a given value  
of X, T,  U(J), UX(J), UXX(J), (<span class="roman">J</span>=1,&#8230;,<span class="roman">NE</span>), as specified 
by the differential equation. Here U, UX, 
UXX and DU are real arrays of length  NE, containing <b>u</b>, &#8706;<b>u</b>/ &#8706;x, &#8706;<sup>2</sup> <b>u</b>/&#8706;x<sup>2</sup>, &#8706;<b>u</b>/&#8706;t 
respectively.  
SUBROUTINE BC(NE, T, X0, XN, U0, UN) calculates the boundary values 
U0(I), UN(I), (<span class="roman">I</span>=1,&#8230;,<span class="roman">NE</span>) for a given value of 
T, X0 and XN<!--hbox-->. The names of the subroutines FCN and BC are fixed and cannot 
be passed on as arguments. The initial values should be supplied to the 
subroutine <a href="appendixb.htm#mstep"> MSTEP</a> at the time of calling. The <span class="roman">NE</span>&times;(<span class="roman">NX</span>&#8722;2) 
components of the initial vector are arranged in the normal Fortran 
order, with NE components of <b>u</b> at each of the <span class="roman">NX</span>&#8722;2 mesh points 
stored consecutively. Thus, u<sub>j</sub>(x<sub>k</sub>) occupies the (k&#8722;1)<span class="roman">NE</span>+j 
position in the initial vector. The final result at the required value of 
time will also be returned in the same order. 

<div class="p"><!----></div>
 <br /><br /><a name="adm"> </a>
 <b>214.&nbsp;ADM&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/adm.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/adm.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a parabolic equation in two space variables 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;t<br /></td><td nowrap="nowrap" align="center">
=A<sub>xx</sub>(x,y,t)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+ A<sub>yy</sub>(x,y,t)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;<sup>2</sup> y<br /></td><td nowrap="nowrap" align="center">
+A<sub>x</sub>(x,y,t)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
+A<sub>y</sub>(x,y,t)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;y<br /></td><td nowrap="nowrap" align="center">
+A<sub>u</sub>(x,y,t)u+A<sub>0</sub>(x,y,t)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.106)</td></tr></table>
</td></tr></table>

 
with Dirichlet boundary conditions over a rectangular region, 
using alternating direction method. This subroutine uses the difference scheme 
<br />
<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td><td nowrap="nowrap" align="center">
u<sub>jl</sub><sup>n+1/2</sup>&#8722;u<sub>jl</sub><sup>n</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
&#8710;t</td></tr></table></td><td nowrap="nowrap" align="center">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(&#8710;x)<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
A<sub>xx</sub><sup>n+1/2</sup>&#948;<sub>x</sub><sup>2</sup>u<sub>jl</sub><sup>n+1/2</sup>+ </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#8710;x<br /></td><td nowrap="nowrap" align="center">
A<sub>x</sub><sup>n+1/2</sup>&#948;<sub>x</sub> u<sub>jl</sub><sup>n+1/2</sup></td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6> </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&nbsp;&nbsp;+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(&#8710;y)<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
A<sub>yy</sub><sup>n</sup>&#948;<sub>y</sub><sup>2</sup>u<sub>jl</sub><sup>n</sup> +</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#8710;y<br /></td><td nowrap="nowrap" align="center">
A<sub>y</sub><sup>n</sup>&#948;<sub>y</sub> u<sub>jl</sub><sup>n</sup></td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&nbsp;&nbsp;+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
(A<sub>u</sub><sup>n</sup>u<sub>jl</sub><sup>n</sup>+A<sub>u</sub><sup>n+1/2</sup>u<sub>jl</sub><sup>n+1/2</sup>) +</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
(A<sub>0</sub><sup>n+1/2</sup>+A<sub>0</sub><sup>n</sup>),</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td><td nowrap="nowrap" align="center">
u<sub>jl</sub><sup>n+1</sup>&#8722;u<sub>jl</sub><sup>n+1/2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
&#8710;t</td></tr></table></td><td nowrap="nowrap" align="center">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(&#8710;x)<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
A<sub>xx</sub><sup>n+1/2</sup>&#948;<sub>x</sub><sup>2</sup>u<sub>jl</sub><sup>n+1/2</sup>+ </td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#8710;x<br /></td><td nowrap="nowrap" align="center">
A<sub>x</sub><sup>n+1/2</sup>&#948;<sub>x</sub> u<sub>jl</sub><sup>n+1/2</sup></td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&nbsp;&nbsp;+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(&#8710;y)<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
A<sub>yy</sub><sup>n+1</sup>&#948;<sub>y</sub><sup>2</sup>u<sub>jl</sub><sup>n+1</sup> +</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#8710;y<br /></td><td nowrap="nowrap" align="center">
A<sub>y</sub><sup>n+1</sup>&#948;<sub>y</sub> u<sub>jl</sub><sup>n+1</sup></td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&nbsp;&nbsp;+</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
(A<sub>u</sub><sup>n+1</sup>u<sub>jl</sub><sup>n+1</sup>+A<sub>u</sub><sup>n+1/2</sup>u<sub>jl</sub><sup>n+1/2</sup>) +</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
(A<sub>0</sub><sup>n+1/2</sup>+A<sub>0</sub><sup>n+1</sup>),</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.107)</td></tr></table>

 
where all coefficients on the right-hand side are evaluated at x=x<sub>j</sub> 
and y=y<sub> <span class="roman">l</span></sub>. T is the initial value of time, DT is the time step to be used. 
After execution, T will be replaced by the current value of time. 
(<span class="roman">X</span><span class="roman">0</span>, <span class="roman">XN</span>) and (<span class="roman">Y</span><span class="roman">0</span>, <span class="roman">YN</span>) are the intervals along 
x and y axes, in which the solution is required. NT is the number of 
time steps, NX and NY are the number of mesh points in the x and y 
directions. X is a real array of length  NX, which will contain 
the mesh points x<sub>j</sub> in x direction. Y is a real array of length 
NY, which will contain the mesh points y<sub> <span class="roman">l</span></sub> in y direction. 
The arrays X and Y need not be initialised before calling the subroutine, 
since the subroutine assumes a uniform spacing and initialises the arrays 
before proceeding with the calculations. U is a real array of length 
<span class="roman">IU</span>&times;<span class="roman">NY</span>, which contains the solution u. 
This array can also be used to pass the initial values of the solution 
(if IFLG &#8800; 0). U(I, J) is the solution u(x<sub>I</sub>,y<sub>J</sub>). 
IU ( &#8805; <span class="roman">NX</span>) 
is the first dimension of U as declared in the 
calling program. COF is the name of the subroutine to calculate the 
coefficients of the equation. SUBROUTINE COF(X, Y, T, AXX, AYY, AX, AY, AU, A0) 
should calculate the coefficients AXX, AYY, AX, AY, AU and A0 at a given 
value of X, Y and T<!--hbox-->. BC is the name of the function routine to calculate 
the boundary values. FUNCTION BC(IB, X, Y, T) should calculate the 
boundary values for the solution. Here IB is an integer variable, which 
takes the value 1, 2, 3, 4 corresponding to the four boundary lines. 
The boundary values are given by 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 u(<span class="roman">X</span><span class="roman">0</span>,y,t)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=<span class="roman">BC</span><span class="roman">(</span><span class="roman">1</span><span class="roman">,</span><span class="roman">X</span><span class="roman">0</span>,y,t),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u(<span class="roman">XN</span>, y,t)=<span class="roman">BC</span><span class="roman">(</span><span class="roman">2</span><span class="roman">,</span><span class="roman">XN</span>,y,t),</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 u(x,<span class="roman">Y</span><span class="roman">0</span>,t)</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">=<span class="roman">BC</span>(3,x,<span class="roman">Y</span><span class="roman">0</span>,t),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u(x,<span class="roman">YN</span>,t)=<span class="roman">BC</span>(4,x,<span class="roman">YN</span>,t).</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.108)</td></tr></table>

 
If the boundary values depend on time, then the accuracy of difference 
approximation may be only O(&#8710;t). FIC is the name of the 
function routine, which may be used to calculate the initial values for 
the solution, when IFLG=0. FUNCTION FIC(X, Y, T) must be supplied by the 
user, if IFLG=0. This routine calculates the solution u(x,y,t) at the 
initial time T<!--hbox-->. For other values of IFLG a dummy function routine FIC 
may be required to satisfy the Fortran compiler, or the linker. 
IER is the error parameter.  
IER=714 implies that <span class="roman">DT</span>=0, or <span class="roman">XN</span>=<span class="roman">X</span><span class="roman">0</span>, or 
<span class="roman">YN</span>=<span class="roman">Y</span><span class="roman">0</span>, or <span class="roman">NX</span> &#8804; 2, or <span class="roman">NY</span> &#8804; 2, or  
<span class="roman">IU</span> &lt; <span class="roman">NX</span>, in which case, no calculations are performed. 
IER=762 implies that the difference equations are singular 
and the solution cannot be calculated. This problem may arise due to some 
error in specifying the equation. IFLG is 
an integer variable used as a flag. If IFLG=0, the initial values 
are calculated using the function routine FIC supplied by the user. 
For other values of IFLG, the initial values must be supplied in the 
array U at the time of calling. In any case, the subroutine sets IFLG to 
1, so that during subsequent calls to the subroutine, the initial values 
are taken from the array U<!--hbox-->. This subroutine can be used to calculate the 
solution at several values of T, by calling it repeatedly after changing 
DT and NT appropriately. Other variables should not be changed. WK is 
a real array of length  max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>)&times;(4+<span class="roman">NY</span>), 
used as a scratch space by the subroutine. 

<div class="p"><!----></div>
 <br /><br /><a name="lax"> </a>
 <b>215.&nbsp;LAX&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/lax.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/lax.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a system of hyperbolic equations in the 
conservation law form, using Lax-Wendroff difference scheme. The equations 
are assumed to be in the form &#8706;<b>u</b>/&#8706;t+&#8706;<b>f</b>/ &#8706;x=0, where <b>f</b>(x,t,<b>u</b>) can be a nonlinear function of <b>u</b>. 
N is the number of equations in the system, T is the initial value of time. 
After execution, T will be replaced by the current value of t. DT is the 
time step to be used. The time step is kept fixed. 
(<span class="roman">X</span><span class="roman">0</span>, <span class="roman">XN</span>) is the interval along x-axis, 
on which the solution is required. NT is the number of time steps over which 
integration is to be performed, NX is the number of mesh points to be used 
along the x-axis. X is a real array of length  NX, used to  
store the coordinates of the mesh points x<sub>j</sub>. This array need not be 
initialised before calling the subroutine, since the subroutine assumes 
a uniform spacing and calculates x<sub>j</sub> before performing the calculations. 
U is a real array of length 
<span class="roman">IU</span>&times;<span class="roman">NX</span>, which contains the solution u. 
This array can also be used to pass the initial values of the solution 
(if IFLG &#8800; 0). IU(I, J) contains the Ith component of the solution 
u<sub>i</sub> at Jth mesh point x<sub>j</sub>.  
IU ( &#8805; <span class="roman">N</span>) is the first dimension of U, as declared in the 
calling program. FLUX is the name of the subroutine, which is 
used to calculate the 
flux <b>f</b> occurring in the differential equations. 
SUBROUTINE FLUX(N, X, T, U, F) should calculate the flux F(I),  
(<span class="roman">I</span>=1,&#8230;,<span class="roman">N</span>) for a given 
value of X, T and U(J), (<span class="roman">J</span>=1,&#8230;,<span class="roman">N</span>). 
BC is the name of the function routine to calculate 
the boundary values. FUNCTION BC(IB, N, X, T, IW, A) should calculate the 
coefficients required for the boundary conditions. 
Here IB is an integer variable which 
takes the value 1 or 2 corresponding to <span class="roman">X</span>=<span class="roman">X</span><span class="roman">0</span> and XN, respectively. 
IW is an integer array of length  N, which contains information 
about the type of boundary condition on each component of <b>u</b> or <b>f</b>. 
If IW(I)=0, then the boundary condition is of the simple Dirichlet 
form a<sub>i1</sub>(t)u<sub>i</sub>=a<sub>i3</sub>(t), otherwise the boundary condition is applied to the 
corresponding component of the flux 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
a<sub>i1</sub>(t)f<sub>i</sub>+a<sub>i2</sub>(t)</td><td nowrap="nowrap" align="center">
&#8706;f<sub>i</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
=a<sub>i3</sub>(t).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.109)</td></tr></table>
</td></tr></table>

 
The coefficients a<sub>ij</sub> are returned in the array A, which should be 
dimensioned as A(N, 3) in the subroutine BC<!--hbox-->. 
FIC is the name of the subroutine, which 
may be used to calculate the initial values for 
the solution if IFLG=0. SUBROUTINE FIC(N, X, T, U) must be supplied by the 
user, when IFLG=0. This subroutine calculates the solution u<sub>i</sub>(<span class="roman">X</span>,<span class="roman">T</span>),  
(i=1,&#8230;,<span class="roman">N</span>) at the 
initial time T<!--hbox-->. For other values of IFLG a dummy subroutine FIC 
may be required to satisfy the Fortran compiler or the linker. 
(In subroutine FIC, U is a real array of length  N, which returns the value of 
the solution u<sub>i</sub> for i=1,&#8230;,<span class="roman">N</span>.) IER is the error parameter.  
IER=715 implies that <span class="roman">DT</span>=0, or <span class="roman">XN</span>=<span class="roman">X</span><span class="roman">0</span>, or 
<span class="roman">NX</span> &#8804; 2, or <span class="roman">IU</span> &lt; <span class="roman">N</span>, 
in which case, no calculations are performed. 
IER=763 implies that the denominator vanishes while calculating the 
boundary values 
and hence the solution cannot be continued. This problem may arise due to some 
error in specifying the boundary conditions. IFLG is 
an integer variable used as a flag. If IFLG=0, the initial values 
are calculated using the subroutine FIC supplied by the user. 
For other values of IFLG, the initial values must be supplied in the 
array U<!--hbox-->. In any case, the subroutine sets IFLG to 
1, so that during subsequent calls to the subroutine, the initial values 
are taken from the array U<!--hbox-->. This subroutine can be used to calculate the 
solution at several values of T by calling it repeatedly, after changing 
DT and NT appropriately. Other variables should not be changed. WK is 
a real array of length  <span class="roman">N</span>&times;(5+<span class="roman">NX</span>), 
used as a scratch space by the subroutine. IWK is an integer array 
of length  N, used as a scratch space by the subroutine. 

<div class="p"><!----></div>
 <br /><br /><a name="sor"> </a>
 <b>216.&nbsp;SOR&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/sor.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/sor.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a linear second-order elliptic equation 
<br />
<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
A<sub>xx</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+ A<sub>xy</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x&#8706;y<br /></td><td nowrap="nowrap" align="center">
+A<sub>yy</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;y<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+A<sub>x</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6> </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+A<sub>y</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;y<br /></td><td nowrap="nowrap" align="center">
+A<sub>0</sub>(x,y)u+F(x,y)=0,</td></tr></table></td></tr></table>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.110)</td></tr></table>

 
with Dirichlet boundary conditions on a rectangular region. Although 
arbitrary coefficients will be accepted by this subroutine, the result 
may be meaningful only when the resulting equation is elliptic, i.e. 
A<sub>xx</sub>A<sub>yy</sub>&#8722;4A<sub>xy</sub><sup>2</sup> &gt; 0. This 
subroutine uses the SOR method to solve the difference equations 
<br /><br />
<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
A<sub>xx</sub></td><td nowrap="nowrap" align="center">
2u<sub>jl</sub>&#8722;u<sub>j&#8722;1,l</sub>&#8722;u<sub>j+1,l</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(&#8710;x)<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+ A<sub>xy</sub></td><td nowrap="nowrap" align="center">
u<sub>j+1,l&#8722;1</sub>+u<sub>j&#8722;1,l+1</sub>&#8722;u<sub>j+1,l+1</sub>&#8722;u<sub>j&#8722;1,l&#8722;1</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4&#8710;x&#8710;y<br /></td><td nowrap="nowrap" align="center">
</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6> </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+A<sub>yy</sub></td><td nowrap="nowrap" align="center">
2u<sub>jl</sub>&#8722;u<sub>j,l&#8722;1</sub>&#8722;u<sub>j,l+1</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>(&#8710;y)<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+ A<sub>x</sub></td><td nowrap="nowrap" align="center">
u<sub>j&#8722;1,l</sub>&#8722;u<sub>j+1,l</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#8710;x<br /></td><td nowrap="nowrap" align="center">
+A<sub>y</sub></td><td nowrap="nowrap" align="center">
u<sub>j,l&#8722;1</sub>&#8722;u<sub>j,l+1</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2&#8710;y<br /></td><td nowrap="nowrap" align="center">
</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8722;A<sub>0</sub>u<sub>jl</sub>=F,</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.111)</td></tr></table>

 
where all coefficients are evaluated at (x<sub>j</sub>,y<sub> <span class="roman">l</span></sub>). The points 
(<span class="roman">X</span><span class="roman">0</span><span class="roman">,</span> <span class="roman">Y</span><span class="roman">0</span>) and (<span class="roman">XN</span><span class="roman">,</span> <span class="roman">YN</span>) define the rectangle over which the 
solution is required. NX and NY are the number of mesh points along the x 
and y directions. X and Y are real arrays of lengths  
NX and NY respectively, 
which contain the mesh points x<sub>j</sub> and y<sub> <span class="roman">l</span></sub>. These arrays need not 
be initialised before calling the subroutine, since the subroutine 
assumes a uniform spacing and initialises these arrays before proceeding 
with the calculations. 
U is a real array of length 
<span class="roman">IU</span>&times;<span class="roman">NY</span>, which contains the solution. U(I, J) 
will contain the computed approximation to u(x<sub>i</sub>,y<sub>j</sub>). Before calling the 
subroutine, an initial approximation to the solution should be supplied 
in this array. IU ( &#8805; <span class="roman">NX</span>) is the value of the first dimension of array 
U, as declared in the calling program. COF is the name of the subroutine used 
to calculate the coefficients in the equation.  
SUBROUTINE COF(X, Y, AXX, AXY, AYY, AX, AY, A0, F) should calculate the coefficients 
AXX, AXY, AYY, AX, AY, A0 and F at a given value of X and Y<!--hbox-->. BC is the 
name of the function routine to calculate the boundary values.  
FUNCTION BC(IB, X, Y) should calculate the 
boundary values for the solution. Here IB is an integer variable which 
takes the value 1, 2, 3, 4, corresponding to the four boundary lines. 
The boundary values are given by 
<br />
<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 u(<span class="roman">X</span><span class="roman">0</span>,y)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=<span class="roman">BC</span><span class="roman">(</span><span class="roman">1</span><span class="roman">,</span><span class="roman">X</span><span class="roman">0</span>, y), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u(<span class="roman">XN</span>,y)=<span class="roman">BC</span><span class="roman">(</span><span class="roman">2</span><span class="roman">,</span> <span class="roman">XN</span>,y),</td></tr></table></td><td width="50%"></td></tr><tr><td nowrap="nowrap" colspan=6>
<div class="p"><!----></div>
 </td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 u(x,<span class="roman">Y</span><span class="roman">0</span>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">=<span class="roman">BC</span>(3,x,<span class="roman">Y</span><span class="roman">0</span>),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u(x,<span class="roman">YN</span>)=<span class="roman">BC</span>(4,x,<span class="roman">YN</span>),</td></tr></table></td></tr></table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.112)</td></tr></table>

 
OMEGA is the value of the relaxation parameter &#969; to be used in 
the calculation. For meaningful results 1 &lt; &#969; &lt; 2, but this condition is not 
checked by the subroutine. If OMEGA &#8804; 0, then the subroutine 
uses the optimum value for the Poisson's equation, based on the number 
of mesh points in each direction (Section&nbsp;14.8). IER is the error parameter. 
IER=716 implies that <span class="roman">XN</span>=<span class="roman">X</span><span class="roman">0</span>, or 
<span class="roman">YN</span>=<span class="roman">Y</span><span class="roman">0</span>, or <span class="roman">NX</span> &#8804; 2, or <span class="roman">NY</span> &#8804; 2, 
or <span class="roman">IU</span> &lt; <span class="roman">NX</span>, in which case, no calculations are performed. 
IER=764 implies that the diagonal term in the difference 
equation vanishes and the calculations are abandoned. 
This failure may arise due to some error in specifying the equation, or the 
equation may be such that the diagonal term actually vanishes at some 
mesh point. In the latter case, changing mesh spacing along some axis may make 
the coefficient nonzero. IER=765 implies that the SOR iteration 
failed to converge in MAXIT (=1000) iterations. 
AEPS is the convergence parameter, which specifies 
the accuracy to which the difference equations are to be solved. The 
iteration is terminated when the maximum change in all elements is less 
than AEPS<!--hbox-->. It should be noted that, this parameter does not affect the truncation 
error, which depends only on the number of mesh points. For optimum results, 
AEPS should be somewhat smaller than the expected accuracy in the solution. 
Accuracy of the solution can be checked by repeating the calculations 
with different number of mesh points. NIT is an output parameter, 
which gives the number of SOR iterations required by the subroutine 
to achieve the specified accuracy. WK is 
a real array of length  9&times;<span class="roman">NX</span>&times;<span class="roman">NY</span>, 
used as a scratch space by the subroutine. 

<div class="p"><!----></div>
 <br /><br /><a name="adi"> </a>
 <b>217.&nbsp;ADI&nbsp;&nbsp;&nbsp;</b>(<a href="../f77/sub8/adi.f">subprogram</a>,&nbsp;&nbsp;&nbsp;
<a href="../f77/xmp8/adi.f">example</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="appendixb.htm#top">[top]</a>
<div class="p"><!----></div>
 Subroutine to solve a linear second-order elliptic equation 
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
A<sub>xx</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+ A<sub>yy</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;<sup>2</sup>u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;y<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
+A<sub>x</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;x<br /></td><td nowrap="nowrap" align="center">
 +A<sub>y</sub>(x,y)</td><td nowrap="nowrap" align="center">
&#8706;u
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#8706;y<br /></td><td nowrap="nowrap" align="center">
+A<sub>0</sub>(x,y)u+F(x,y)=0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (<span class="roman">B</span>.113)</td></tr></table>
</td></tr></table>

on a rectangular region using the Alternating Direction Implicit iterative 
(ADI) method. Although, 
arbitrary coefficients will be accepted by this subroutine, the result 
may be meaningful only when the resulting equation is elliptic, i.e. 
A<sub>xx</sub>A<sub>yy</sub> &gt; 0. This 
subroutine accepts more general boundary conditions of the form 
A<sub>0</sub>u+A<sub>n</sub> &#8706;<sub>n</sub>u=F, where &#8706;<sub>n</sub>u is the normal derivative. 
The points 
(<span class="roman">X</span><span class="roman">0</span><span class="roman">,</span> <span class="roman">Y</span><span class="roman">0</span>) and (<span class="roman">XN</span><span class="roman">,</span> <span class="roman">YN</span>) define the rectangle, over which the 
solution is required. KN is the parameter k in the ADI algorithm. This 
subroutine repeats a cycle of 2<sup>k</sup> iterations, until the result converges. 
The convergence criterion is tested after each iteration. Hence, the 
actual number of iterations may not be a multiple of 2<sup>k</sup>. Ideally 
k should be chosen such that convergence takes place in approximately 2<sup>k</sup> 
iterations, but the exact choice may not be very crucial. NX and NY are the number of mesh points along the x and y directions.  
X and Y are real arrays of lengths  NX and NY, respectively 
containing the mesh points x<sub>j</sub> and y<sub> <span class="roman">l</span></sub>. These arrays need not 
be initialised before calling the subroutine, since the subroutine 
assumes a uniform spacing and initialises these arrays before proceeding 
with the calculations. 
U is a real array of length 
<span class="roman">IU</span>&times;<span class="roman">NY</span>, which contains the solution. U(I, J) 
will contain the computed approximation to u(x<sub>i</sub>,y<sub>j</sub>). Before calling the 
subroutine an initial approximation to the solution should be supplied 
in this array. IU ( &#8805; <span class="roman">NX</span>) is the value of the first dimension of the array 
U, as declared in the calling program. 

<div class="p"><!----></div>
COF is the name of the subroutine used 
to calculate the coefficients in the equation.  
SUBROUTINE COF(X, Y, AXX, AYY, AX, AY, A0, F) should calculate the coefficients 
AXX, AYY, AX, AY, A0 and F at a given value of X and Y<!--hbox-->. BC is the name of 
the subroutine to calculate the coefficients for the boundary conditions.  
SUBROUTINE BC(IB, X, Y, A0, AN, F) should calculate the coefficients A0, AN and F 
for the boundary conditions. Here IB is an integer variable which 
takes the value 1, 2, 3, 4, corresponding to the four boundary lines 
x=<span class="roman">X</span><span class="roman">0</span>, x=<span class="roman">XN</span>, y=<span class="roman">Y</span><span class="roman">0</span> and y=<span class="roman">YN</span>, respectively. 
EL and EU are respectively, the lower and upper limit on the eigenvalues 
of the partitions X and Y of the finite difference matrix. 
If <span class="roman">EL</span> &#8804; 0, then the value for Poisson's equation will be used. 
Similarly, if <span class="roman">EU</span> &#8804; <span class="roman">EL</span>, then the value for Poisson's equation 
will be used. IER is the error parameter. 
IER=717 implies that <span class="roman">XN</span>=<span class="roman">X</span><span class="roman">0</span>, or 
<span class="roman">YN</span>=<span class="roman">Y</span><span class="roman">0</span>, or <span class="roman">NX</span> &#8804; 2, or <span class="roman">NY</span> &#8804; 2, 
or <span class="roman">IU</span> &lt; <span class="roman">NX</span>, in which case, no calculations are performed. 
IER=766 implies that the matrix for ADI iteration is singular 
and the calculations are abandoned. 
This problem may arise due to some error in specifying the equation or the boundary 
conditions. IER=767 implies that the ADI iteration 
failed to converge in MAXIT (=1000) iterations. 
AEPS is the convergence parameter, which specifies 
the accuracy to which the difference equations are to be solved. The 
iteration is terminated when the maximum change in all elements is less 
than AEPS<!--hbox-->. It should be noted that, this parameter does not affect the truncation 
error, which depends only on the number of mesh points. For optimum results, 
AEPS should be somewhat smaller than the expected accuracy in the solution. 
Accuracy of the solution can be checked by repeating the calculations 
with different number of mesh points. NIT is an output parameter, 
which gives the number of ADI iterations required by the subroutine 
to achieve the specified accuracy. WK is 
a real array of length  max(<span class="roman">NX</span><span class="roman">,</span> <span class="roman">NY</span>)&times;(2+<span class="roman">NY</span>), 
used as a scratch space by the subroutine. WKA is a real array of length 
 7&times;<span class="roman">NX</span>&times;<span class="roman">NY</span>, used as a scratch space by the 
subroutine. 

<div class="p"><!----></div>
 
<br /><br />



<table align="center" border="0"><tr><td>
<font size="+1"> BIBLIOGRAPHY </font></td></tr></table><!--hboxt-->
<br />
    

<div class="p"><!----></div>
 Brent, R. P. (1973): <i>Algorithms for Minimization Without Derivatives,</i> Prentice-Hall, Englewood Cliffs, New Jersey. 

<div class="p"><!----></div>
DiDonato R., Morris, A. H. Jr. (1986) <i>Computation of the Incomplete 
Gamma Function Ratios and their Inverse,</i> ACM Transactions on Mathematical 
Software (TOMS), <b>12</b>, p.&nbsp;377. 

<div class="p"><!----></div>
DiDonato R., Morris, A. H. Jr. (1992) <i>Algorithm 708: Significant 
Digit Computation of the Incomplete 
Beta Function Ratios,</i> ACM Transactions on Mathematical 
Software (TOMS), <b>18</b>, p.&nbsp;360. 

<div class="p"><!----></div>
Metcalf, M. and Reid, J. K. (1999): <i>Fortran 90/95 Explained,</i> 
(2nd ed.), Oxford University Press, Oxford 

<div class="p"><!----></div>
Perry Cole, J. W. (1987): <i>ANSI Fortran 77, A Structured Problem-Solving Approach,</i> S. Chand, New Delhi. 

<div class="p"><!----></div>
Press, W. H., Teukolsky, S. A., Vetterling, W. T. and Flannery, B. P. (2007): <i>Numerical Recipes : The Art of Scientific Computing,</i> (3rd ed.) Cambridge University Press, New York. 

<div class="p"><!----></div>
Wilkinson, J. H. and Reinsch, C. (1971): <i>Linear Algebra: Handbook for Automatic Computation,</i> Vol.&nbsp;2, Springer-Verlag, Berlin. 

<div class="p"><!----></div>
<p>
&nbsp;<a href="readme.htm">doc</a>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="../c/readme.htm">C programs</a>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="../f77/readme.htm">Fortran programs</a>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="../readme.htm">[Home]</a>

<p>
 
<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>Hgold</a>,
version 4.00.<br />On 13 DEC 2012, 14:31.</small>
</html>
