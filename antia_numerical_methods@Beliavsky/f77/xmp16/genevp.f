!     PROGRAM TO FIND EIGENVALUES AND EIGENVECTORS OF A GENERALISED 
!     EIGENVALUE PROBLEM FOR A  N x N  MATRIX
!     THE MATRIX IS GENERATED BY A USER SUPPLIED SUBROUTINE MATRIX

      PROGRAM GENEVP
      IMPLICIT COMPLEX*32(C)
      IMPLICIT REAL*16(A,B,D-H,O-Z)
      EXTERNAL CDET
      DIMENSION CX(20),CZERO(20),CM(20,20),CU(20),CWK(440),INT(20)

!     EXERCISE 11.34

51    FORMAT('   IER =',I4,5X,'NO. OF EIGENVALUES FOUND =',I3/
     1    '    EIGENVALUES =',1P2D14.6,2X,2D14.6/(5X,2D14.6,2X,2D14.6))
52    FORMAT('    EIGENVECTORS')
53    FORMAT(I5,2X,1P2D14.6,2X,2D14.6/(7X,2D14.6,2X,2D14.6))

      REPS=1.Q-33
      AEPS=1.Q-35
      RMX=1.Q3

!     NUM IS THE NUMBER OF EIGENVALUES TO BE LOCATED.
!     THE EIGENVALUES ARE NOT DETERMINED IN ANY PARTICULAR ORDER.
!     HENCE NUM MAY BE LARGER THAN THE NUMBER OF EIGENVALUES REQUIRED.
!     THE ORDER N MUST MATCH THAT OF THE MATRIX GENERATED BY
!     SUBROUTINE MATRIX.

      N=3
      PRINT *,'NUM=NO. OF EIGENVALUES'
      READ *,NUM
      NZ=0

!     SET STARTING VALUES TO REPS AND FIND ZEROS OF DETERMINANT
!     THIS CHOICE MAY PRODUCE EIGENVALUES IN INCREASING ORDER
!     OF MAGNITUDE.  IF NECESSARY DIFFERENT STARTING VALUES MAY
!     SUPPLIED.

      DO 1000 I=1,N
1000  CX(I)=1.Q-8
      CALL ZROOT2(NUM,CX,CZERO,NZ,REPS,AEPS,IER,RMX,CDET)
      WRITE(6,51) IER,NZ,(CZERO(I),I=1,NZ)

!     FIND EIGENVECTORS USING INVERSE ITERATION

      LC=20
      WRITE(6,52)
      DO 2000 J=1,NZ

!       INITIAL  APPROXIMATION TO EIGENVECTOR
        DO 1500 I=1,N
1500    CU(I)=1

!       SET UP THE MATRIX
!       PERTURB THE EIGENVALUE SLIGHTLY TO ENSURE THAT THE MATRIX IS NOT SINGULAR
        CALL MATRIX(CM,LC,CZERO(J)+1.Q-33)
        IFLG=0

!       SET SHIFT TO ZERO
        CP=0
        NIT=10
        CALL INVIT_CC(CM,N,LC,CP,CU,IFLG,CEI,CRC,REPS,CWK,INT,NIT,IER)
        WRITE(6,53) J,(CU(I),I=1,N)
2000  CONTINUE
      END

!     -------------------------------------------------------

!	Solution of a system of linear equations with complex coefficients
!	using Crout's algorithm with partial pivoting
!
!	N : (input) Number of equations to be solved
!	NUM : (input) Number of different sets (each with N equations) of
!	         equations to be solved
!	A : (input/output) The matrix of coefficient of size LJ*N
!	         A(I,J) is the coefficient of x_J in Ith equation
!	     at output it will contain the triangular decomposition
!	X : (input/output) The matrix containing right hand sides (size LJ*NUM)
!	         X(I,J) is the Ith element of Jth right hand side
!	     at output it will contain the solutions
!	DET, IDET : (output) The determinant of the matrix = DET*2**IDET
!	INC : (output) Integer array of length N containing information about
!		interchanges performed during elimination
!	LJ : (input) First dimension of arrays A and X in calling program
!	IER : (output) Error flag, IER=0 signifies successful execution
!		IER=102 implies (N.LE.0 or N.GT.LJ) 
!		IER=122 implies some pivot turned out to be zero and hence
!			matrix must be nearly singular
!	IFLG : (input) Integer parameter which determines the type of computation
!		required.
!		If IFLG.LE.0, both elimination and solution are calculated
!			and IFLG is set to 2
!		If IFLG=1, only elimination is done and IFLG is set to 2
!		If IFLG.GE.2 only solution is calculated, the triangular
!		    	decomposition should have been calculated earlier
!	WK : scratch array of length N
!
!	Required routines : None

      SUBROUTINE CROUT_C(N,NUM,A,X,DET,IDET,INT,LJ,IER,IFLG,WK)
      IMPLICIT COMPLEX*32(A-H,S-Z)
      IMPLICIT REAL*16(O-R)

      DIMENSION A(LJ,N),INT(N),X(LJ,NUM),WK(N)

      IF(N.LE.0.OR.N.GT.LJ) THEN
        IER=102
        RETURN
      ENDIF
      IER=122

      IF(IFLG.LE.1) THEN
!	Perform LU decomposition
        DO 1500 I=1,N
          R1=0.0
          DO 1200 J=1,N
            IF(ABS(A(I,J)).GT.R1) R1=ABS(A(I,J))
1200      CONTINUE
          WK(I)=R1
!	If any row is zero, then quit
          IF(R1.EQ.0.0) RETURN
1500    CONTINUE

        DET=1.0
        IDET=0
        DO 2600 K=1,N
          R1=0.0
          KM=K
!	Generate the Kth column of L
          DO 2200 L=K,N
            D1=A(L,K)
            DO 2100 L1=1,K-1
2100        D1=D1-A(L,L1)*A(L1,K)
            A(L,K)=D1

!	Finding the pivot
            R2=ABS(D1/WK(L))
            IF(R2.GT.R1) THEN
              R1=R2
              KM=L
            ENDIF
2200      CONTINUE

          INT(K)=KM
!	Interchange the rows if needed
          IF(KM.NE.K) THEN
            DET=-DET
            DO 2300 L=1,N
              T1=A(K,L)
              A(K,L)=A(KM,L)
2300        A(KM,L)=T1
            T1=WK(K)
            WK(K)=WK(KM)
            WK(KM)=T1
          ENDIF

          DET=DET*A(K,K)
!	If the pivot is zero, then quit
          IF(A(K,K).EQ.0.0) RETURN
!	To check for singular or nearly singular matrices replace this statement by
!         IF(ABS(A(K,K)).LT.REPS) RETURN

          IF(DET.NE.0.0) THEN
!	Scale the value of the determinant DET
2350        IF(ABS(DET).GT.32.) THEN
              DET=DET*0.03125Q0
              IDET=IDET+5
              GO TO 2350
            ENDIF

2370        IF(ABS(DET).LT.0.03125Q0) THEN
              DET=DET*32.
              IDET=IDET-5
              GO TO 2370
            ENDIF
          ENDIF

!	Generate the Kth row of U
          DO 2500 L=K+1,N
            D1=A(K,L)
            DO 2400 L1=1,K-1
2400        D1=D1-A(K,L1)*A(L1,L)
            A(K,L)=D1/A(K,K)
2500      CONTINUE
2600    CONTINUE
        IER=0

        IF(IFLG.EQ.1) THEN
          IFLG=2
          RETURN
        ENDIF
        IFLG=2
      ENDIF

      IER=0
!	Solution for NUM different right-hand sides
      DO 5000 J=1,NUM
!	Forward substitution
        DO 3000 K=1,N
          IF(K.NE.INT(K)) THEN
            T1=X(K,J)
            X(K,J)=X(INT(K),J)
            X(INT(K),J)=T1
          ENDIF

          D1=X(K,J)
          DO 2800 L=1,K-1
2800      D1=D1-A(K,L)*X(L,J)
          X(K,J)=D1/A(K,K)
3000    CONTINUE

!	Back-substitution
        DO 3300 K=N-1,1,-1
          D1=X(K,J)
          DO 3200 L=N,K+1,-1
3200      D1=D1-X(L,J)*A(K,L)
3300    X(K,J)=D1
5000  CONTINUE
      END

!     -----------------------------------------

!	Solution of a system of linear equations with complex coefficients
!	using Gaussian elimination with partial pivoting
!
!	N : (input) Number of equations to be solved
!	NUM : (input) Number of different sets (each with N equations) of
!	        equations to be solved
!	A : (input/output) The matrix of coefficient of size LJ*N
!	        A(I,J) is the coefficient of x_J in Ith equation
!	     	at output it will contain the triangular decomposition
!	X : (input/output) The matrix containing right hand sides (size LJ*NUM)
!	        X(I,J) is the Ith element of Jth right hand side
!	     	at output it will contain the solutions
!	DET : (output) The determinant of the matrix
!	INC : (output) Integer array of length N containing information about
!		interchanges performed during elimination
!	LJ : (input) First dimension of arrays A and X in calling program
!	IER : (output) Error flag, IER=0 signifies successful execution
!		IER=101 implies (N.LE.0 or N.GT.LJ) 
!		IER=121 implies some pivot turned out to be zero and hence
!			matrix must be nearly singular
!	IFLG : (input) Integer parameter to specify the type of computation required
!		If IFLG.LE.0, both elimination and solution are
!			done and IFLG is set to 2
!		If IFLG=1, only elimination is done and IFLG is set to 2
!		If IFLG.GE.2 only solution is calculated, the triangular
!		    	decomposition should have been calculated earlier
!
!	Required routines : None

      SUBROUTINE GAUELM_C(N,NUM,A,X,DET,INT,LJ,IER,IFLG)
!      IMPLICIT REAL*8(A-H,O-Z)
!	For complex matrices use the following statements instead
      IMPLICIT REAL*16(R)
      IMPLICIT COMPLEX*32(A-H,S-Z)

      DIMENSION A(LJ,N),INT(N),X(LJ,NUM)

      IF(N.LE.0.OR.N.GT.LJ) THEN
        IER=101
        RETURN
      ENDIF

      IER=121
      IF(IFLG.LE.1) THEN
!	Perform elimination

        DET=1.0
        DO 2600 K=1,N-1
!	Find the maximum element in the Kth column
          R1=0.0
          KM=K
          DO 2200 L=K,N
            IF(ABS(A(L,K)).GT.R1) THEN
              R1=ABS(A(L,K))
              KM=L
            ENDIF
2200      CONTINUE

          INT(K)=KM
          IF(KM.NE.K) THEN
!	Interchange the rows if needed
            DO 2300 L=K,N
              T1=A(K,L)
              A(K,L)=A(KM,L)
2300        A(KM,L)=T1
            DET=-DET
          ENDIF

          DET=DET*A(K,K)
          IF(A(K,K).EQ.0.0) RETURN
!	To check for singular or nearly singular matrices replace this
!	statement by, where REPS is approximately \hcross*Max(A(I,J))
!         IF(ABS(A(K,K)).LT.REPS) RETURN
          DO 2500 L=K+1,N
            A(L,K)=A(L,K)/A(K,K)
            DO 2500 L1=K+1,N
2500      A(L,L1)=A(L,L1)-A(L,K)*A(K,L1)
2600    CONTINUE
        DET=DET*A(N,N)
        INT(N)=N
!	If pivot is zero then return, IER has been set to 121
        IF(A(N,N).EQ.0.0) RETURN
!	To check for singular or nearly singular matrices replace this
!	statement by, where REPS is approximately \hcross*Max(A(I,J))
!         IF(ABS(A(N,N)).LT.REPS) RETURN

        IER=0
        IF(IFLG.EQ.1) THEN
          IFLG=2
          RETURN
        ENDIF
        IFLG=2
      ENDIF

      IER=0
!	Solution for the NUM different right-hand sides
      DO 5000 J=1,NUM
        DO 3000 K=1,N-1
!	Forward substitution
          IF(K.NE.INT(K)) THEN
            T1=X(K,J)
            X(K,J)=X(INT(K),J)
            X(INT(K),J)=T1
          ENDIF
          DO 3000 L=K+1,N
3000    X(L,J)=X(L,J)-A(L,K)*X(K,J)

!	back-substitution
        X(N,J)=X(N,J)/A(N,N)
        DO 3300 K=N-1,1,-1
          DO 3200 L=N,K+1,-1
3200      X(K,J)=X(K,J)-X(L,J)*A(K,L)
3300    X(K,J)=X(K,J)/A(K,K)
5000  CONTINUE
      END

!     --------------------------------------------------

!	Complex eigenvalues and eigenvector of a Complex matrix using inverse iteration
!
!	A : (input) Complex array of length IA*M containing the matrix elements
!	M : (input) Order of the matrix
!	IA : (input) The first dimension of A as declared in the calling program
!	P : (input/output) Initial value of the shift. This will be modified
!		by the program if IFLG>0
!	U : (input/output) Complex array of length M, which should specify the
!		initial approximation to eigenvector. After execution it
!		will contain the calculated eigenvector.
!	IFLG : (input) Integer variable to specify the type of iteration required
!		If IFLG=0 the shift P is kept fixed
!		If IFLG=1 the shift P is varied using Rayleigh quotient
!		If IFLG=2 the shift P is varied using max(V_s+1)
!	EI : (output) Estimated eigenvalue using simple inverse iteration
!	ERC : (output) Estimated eigenvalue using Rayleigh quotient
!	REPS : (input) Required absolute accuracy. Iteration is terminated
!		when all components of eigenvector and the eigenvalue have
!		converged to REPS.
!	WK : Complex array of length M*(M+1) used as scratch space
!	IWK : Integer array of length M used as scratch space
!	NIT : (input/output) Number of iterations required. If it is
!		zero or negative NIT is set to NIT0=100
!	IER : (output) Error parameter, IER=0 implies successful execution
!		IER=106 implies that M.LE.1 or M>IA, in which case no
!			calculations are done
!		IER=141 implies that vector is zero at some stage and
!			calculations are aborted
!		IER=142 implies that inverse iteration has failed to converge
!
!	Required routines : GAUELM_C
!
      SUBROUTINE INVIT_CC(A,M,IA,P,U,IFLG,EI,ERC,REPS,WK,IWK,NIT,IER)
      IMPLICIT REAL*16(O,R)
      IMPLICIT COMPLEX*32(A-H,P,S-Z)
      DIMENSION A(IA,M),U(M),WK(M,M+1),IWK(M)
      PARAMETER(NIT0=100)

      IF(M.LE.1.OR.M.GT.IA) THEN
        IER=106
        RETURN
      ENDIF

!	Copy the matrix to WK and apply the shift
      DO 1100 I=1,M
        WK(I,M+1)=U(I)
        DO 1000 J=1,M
1000    WK(J,I)=A(J,I)
1100  WK(I,I)=A(I,I)-P

      NUM=1
      LJ=M
      IFL=1
      IF(NIT.LE.0) NIT=NIT0
!	Perform Gaussian elimination on A-pI
      CALL GAUELM_C(M,NUM,WK,U,DET,IWK,LJ,IER,IFL)
      IF(IER.GT.0) RETURN

      EPI=0.0
!	Loop for inverse iteration
      DO 5000 J=1,NIT
        CALL GAUELM_C(M,NUM,WK,U,DET,IWK,LJ,IER,IFL)
        IF(IER.GT.0) RETURN

!	Normalising the vector U
        R1=0.0
        KM=0
        DO 3500 K=1,M
          IF(R1.LT.ABS(U(K))) THEN
            R1=ABS(U(K))
            KM=K
          ENDIF
3500    CONTINUE
        UKM=U(KM)
        IF(UKM.EQ.0.0) THEN
!	If the vector is zero, then quit
          IER=141
          RETURN
        ENDIF

!	The eigenvalue
        EI=WK(KM,M+1)/UKM+P
        S1=0.0
        S2=0.0
!	Calculating the Rayleigh quotient
        DO 4000 K=1,M
!          S1=S1+U(K)*WK(K,M+1)
!	For complex eigenvalues use the following statement instead of the
!	preceding one
          S1=S1+CONJG(U(K))*WK(K,M+1)
          S2=S2+ABS(U(K))**2
          U(K)=U(K)/UKM
4000    CONTINUE
        ERC=P+S1/S2

!	Convergence check
        R1=ABS(EI-EPI)
        DO 4500 I=1,M
          R1=MAX(R1,ABS(WK(I,M+1)-U(I)))
          WK(I,M+1)=U(I)
4500    CONTINUE
        IF(ABS(R1).LT.REPS) RETURN
        EPI=EI

        IF(IFLG.GE.1) THEN
!	Update the shift
          P=ERC
          IF(IFLG.EQ.2) P=EI
!	Setting up the new matrix A-pI
          DO 4700 I=1,M
            DO 4600 K=1,M
4600        WK(K,I)=A(K,I)
4700      WK(I,I)=A(I,I)-P
          IFL=1
          CALL GAUELM_C(M,NUM,WK,U,DET,IWK,LJ,IER,IFL)
          IF(IER.GT.0) RETURN
        ENDIF

5000  CONTINUE
!	Iteration fails to converge
      IER=142
      END

!     -----------------------------------------------------

!	Complex zero of a given function using Muller iteration with deflation
!	Function is assumed to be calculated as CF*2**IX
!	This subroutine uses reverse communication to calculate function
!	values. If IER<0 the function should be evaluated and MULER2
!	should be called back with new function value. Calculation of
!	function value should not change any other variables in the
!	call statement. First call should be with IER=0
!
!	CX1,CX2,CX3 : (input/output) Complex starting values for iteration
!		These will be updated during execution and CX3 should be
!		the best estimate for the zero.
!	REPS : (input) Required relative accuracy
!	AEPS : (input) Required absolute accuracy
!		The estimated error should be less than MAX(AEPS, REPS*ABS(CX3))
!	IER : (input/output) Error parameter, IER=0 implies successful execution
!		For the first call IER should be set to 0.
!		IER<0 implies that execution is not over and the subroutine
!			needs a new function evaluation at z=CX. After calculating
!			the function value MULER2 should be called back.
!		IER=42 implies that roundoff errors appear to be dominating
!			and calculations are terminated.
!		IER=43 implies that iteration failed to converge to specified accuracy
!			but a weaker convergence criterion is satisfied
!		IER=404 implies 2 of the 3 starting values are identical and
!			no calculations are done
!		IER=431 implies that iteration goes outside the specified limits
!		IER=432 implies that iteration failed to converge to specified accuracy
!		IER=433 implies that denominator for calculating the iteration
!			vanishes and it is not possible to continue further
!	CF : (input) Calculated value of the function at z=CX
!		If subroutine exits with IER<0, then the calling routine
!		should calculate the function value at CX and call MULER2
!		with this value stored in CF and IX. Other variables should
!		not be changed.
!	CX : (output) Value of z at which the function evaluation is needed
!	IX : (input) The exponent of function value, The function value 
!		should be CF*2**IX
!	NZ : (input) Number of zeros already known (for deflation)
!	CZERO : (input) Complex array of length NZ containing the known
!		zeros for deflation.
!	RMAX : (input) Maximum magnitude of zeros. Iteration will be terminated
!		when ABS(CX) > RMAX
!	
!	Required routines : None (Function has to be calculated by calling program)
!
      SUBROUTINE MULER2(CX1,CX2,CX3,REPS,AEPS,IER,CF,CX,IX,NZ,
     1                  CZERO,RMAX)
      IMPLICIT COMPLEX*32(C)
      IMPLICIT REAL*16(A,B,D-H,O-Z)
      PARAMETER(REPS0=1.Q-3,NIT=50)
      DIMENSION CZERO(NZ)
      SAVE

      IFL=-IER
      IF(IFL.GT.0.AND.IFL.LT.4) THEN
!	Jump to proper location and continue execution
        GO TO (1000,2000,3000), IFL
      ENDIF
!	Initial call to subroutine, start from beginning
      IF(CX2.EQ.CX1.OR.CX2.EQ.CX3.OR.CX3.EQ.CX1) THEN
!	If 2 of the starting values are equal, then quit
        IER=404
        RETURN
      ENDIF

      IER=-1
      CX=CX1
!	To evaluate the function at CX1
      RETURN
1000  CF1=CF
      IF1=IX
!	perform deflation
      DO 1500 J=1,NZ
1500  CF1=CF1/(CX1-CZERO(J))

      IER=-2
      CX=CX2
!	To calculate the function value at CX2
      RETURN
2000  CF2=CF
      IF2=IX
!	perform deflation
      DO 2500 J=1,NZ
2500  CF2=CF2/(CX2-CZERO(J))

      CF1I=CF1*2.Q0**(IF1-IF2)
      CH1=(CF2-CF1I)/(CX2-CX1)
      I=0
      DX1=ABS(CX3-CX2)
      CX=CX3
      IER=-3
!	To calculate the function value at CX3
      RETURN

!	Loop for the Muller iteration
3000  I=I+1
      CF3=CF
      IF3=IX
      IF(NZ.GT.0) THEN
!	perform deflation
        DO 3500 J=1,NZ
3500    CF3=CF3/(CX3-CZERO(J))
      ENDIF

      IER=0
      IF(CX3.EQ.CX1.OR.CX3.EQ.CX2) RETURN
      IF(CF3.EQ.0.0) RETURN
      CF2A=CF2*2.Q0**(IF2-IF3)
      CH2=(CF3-CF2A)/(CX3-CX2)
      CH1A=CH1*2.Q0**(IF2-IF3)
      C2=(CH2-CH1A)/(CX3-CX1)
      CG=CH2+(CX3-CX2)*C2
      CI=SQRT(CG*CG-4.*CF3*C2)
      CD=CG+CI
      CD1=CG-CI
      IF(ABS(CD1).GT.ABS(CD)) CD=CD1

      IF(CD.EQ.0.0) THEN
!	If the denominator is zero, then quit
        IER=433
        RETURN
      ENDIF

      CDX=-2.*CF3/CD
      CX1=CX2
      CX2=CX3
!	The new approximation to zero
      CX3=CX3+CDX
      CF1=CF2
      CF2=CF3
      IF1=IF2
      IF2=IF3
      CH1=CH2
      DX=ABS(CDX)
      IF(I.GT.2.AND.DX.LT.MAX(REPS*ABS(CX3),AEPS)) RETURN
      IF(I.GT.5.AND.DX.LT.MAX(REPS0*ABS(CX3),AEPS)
     1   .AND.DX.GT.DX1) THEN
!	Roundoff errors appear to be dominating, hence quit
        IER=42
        RETURN
      ENDIF

      DX1=DX
      IF(ABS(CX3).GT.RMAX) THEN
!	Iteration goes outside the specified range
        IER=431
        RETURN
      ENDIF

      IF(I.LT.NIT) THEN
        IER=-3
        CX=CX3
!	To calculate the function value at CX3 and continue the loop
        RETURN
      ENDIF

!	Iteration fails to converge
      IER=43
      IF(DX.LT.MAX(REPS0*ABS(CX3),AEPS)) RETURN
      IER=432
      END

!     --------------------------------------------

!	Complex zeros of a given function using Muller iteration with deflation
!	For use with MULER2 which requires function in form CF*2**IDET
!
!	N : (input) Number of zeros to be determined
!	CX : (input) Complex array of length N containing the initial guesses
!		for the zeros
!	CZERO : (input/output) Complex array of length N+NZ containing the
!		computed values of the zeros. The first NZ zeros which are
!		already known must be supplied as input while other zeros will be added
!	NZ : (input/output) Number of known zeros. At input it should
!		contain the number already known which are included in
!		array CZERO. This number will be incremented as more zeros
!		are determined successfully.
!	REPS : (input) Required relative accuracy
!	AEPS : (input) Required absolute accuracy
!		The estimated error should be less than MAX(AEPS, REPS*ABS(X))
!	IER : (output) Error parameter, IER=0 implies successful execution
!		IER=41 implies that iteration did not converge to satisfactory accuracy for
!			at least one zero, but value is acceptable at lower accuracy.
!		IER=429 implies that iteration failed to find at least one zero.
!			The number of zeros found can be checked from the value of NZ.
!	RMAX : (input) Maximum magnitude of zeros. Iteration will be terminated
!		when ABS(CZ) > RMAX
!	CF : (input) Name of the function routine to calculate the function
!		FUNCTION CF(CZ,JF) must be supplied by the user, where CF and CZ
!		are complex. To avoid overflow and underflow the function is
!		calculated in the form CF*2**JF.
!
!	Required routines : MULER2, CF

      SUBROUTINE ZROOT2(N,CX,CZERO,NZ,REPS,AEPS,IER,RMAX,CF)
      IMPLICIT COMPLEX*32(C)
      IMPLICIT REAL*16(A,B,D-H,O-Z)
      EXTERNAL CF
      DIMENSION CZERO(NZ+N),CX(N)

      IF(N.LE.0) RETURN
      IF(NZ.LT.0) NZ=0
      IER=0

      DO 1000 I=1,N
!	The starting values for Muller's iteration
        CX3=CX(I)
        CDX=0.01Q0*CX3
        IF(I.LT.N.AND.CDX.EQ.0.0) CDX=0.1Q0*(CX(I+1)-CX(I))
        IF(I.GT.1.AND.CDX.EQ.0.0) CDX=0.1Q0*(CX(I-1)-CX(I))
        IF(CDX.EQ.0.0) CDX=1.Q-3
!	These values may need to be changed in some cases
        CX2=CX3+CDX
        CX1=CX3-CDX

!	Find the next zero
!        CALL MULLER(CX1,CX2,CX3,REPS,AEPS,IER1,CF,NZ,CZERO,RMAX)
!	For MULER use the preceding statements instead
        IER1=0
500     CALL MULER2(CX1,CX2,CX3,REPS,AEPS,IER1,CF0,CX0,IX,NZ,CZERO,RMAX)
        IF(IER1.LT.0) THEN
          CF0=CF(CX0,IX)
          GO TO 500
        ENDIF

        IF(IER1.LT.100) THEN
!	The zero is accepted
          NZ=NZ+1
          CZERO(NZ)=CX3
          IF(IER.EQ.0.AND.IER1.NE.0) IER=41
        ELSE
          IER=429
        ENDIF
1000  CONTINUE
      END

!     --------------------------------------------

!	TO SET UP THE MATRIX C,  CX IS THE EIGENVALUE
!	THE EIGENVALUE PROBLEM IS C X = 0

      SUBROUTINE MATRIX(C,IC,CX)
      IMPLICIT COMPLEX*32(C)
      IMPLICIT REAL*16(A,B,D-H,O-Z)
      DIMENSION C(IC,10)
      DATA BETA,Q/-0.1Q0,0.01Q0/

!     SET UP THE MATRIX

!     TO SOLVE AN EIGENVALUE PROBLEM   A X = CX B X
!     SET THE MATRIX C = A - CX*B

      C(1,1)=CX
      C(1,2)=(0.5,1)
      C(1,3)=-1
      C(2,1)=CX*(-0.5,1)
      C(2,2)=CX**2+1
      C(2,3)=-CX**2
      C(3,1)=BETA
      C(3,2)=-BETA*CX
      C(3,3)=Q+(1+BETA)*CX
      END

!      ------------------------------------------

      FUNCTION CDET(CX,IF)
      IMPLICIT COMPLEX*32(C)
      IMPLICIT REAL*16(A,B,D-H,O-Z)
      DIMENSION C(10,10),INT(10),CWK(100),CU(10)

!     ROUTINE FOR CALCULATING THE DETERMINANT OF THE MATRIX USING
!     CROUT'S ALGORITHM FOR TRIANGULAR DECOMPOSITION

      LC=10
      CALL MATRIX(C,LC,CX)
      N=3
      NUM=1
      IFLG=1
      CALL CROUT_C(N,NUM,C,CU,CDET,IF,INT,LC,IER,IFLG,CWK)
      END
